
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model AgentInvite
 * 
 */
export type AgentInvite = $Result.DefaultSelection<Prisma.$AgentInvitePayload>
/**
 * Model Property
 * 
 */
export type Property = $Result.DefaultSelection<Prisma.$PropertyPayload>
/**
 * Model PropertyImage
 * 
 */
export type PropertyImage = $Result.DefaultSelection<Prisma.$PropertyImagePayload>
/**
 * Model PropertyView
 * 
 */
export type PropertyView = $Result.DefaultSelection<Prisma.$PropertyViewPayload>
/**
 * Model ViewingRequest
 * 
 */
export type ViewingRequest = $Result.DefaultSelection<Prisma.$ViewingRequestPayload>
/**
 * Model InvestorLead
 * 
 */
export type InvestorLead = $Result.DefaultSelection<Prisma.$InvestorLeadPayload>
/**
 * Model RentalLead
 * 
 */
export type RentalLead = $Result.DefaultSelection<Prisma.$RentalLeadPayload>
/**
 * Model Blog
 * 
 */
export type Blog = $Result.DefaultSelection<Prisma.$BlogPayload>
/**
 * Model BlogCategory
 * 
 */
export type BlogCategory = $Result.DefaultSelection<Prisma.$BlogCategoryPayload>
/**
 * Model PropertySubmission
 * 
 */
export type PropertySubmission = $Result.DefaultSelection<Prisma.$PropertySubmissionPayload>
/**
 * Model SiteSettings
 * 
 */
export type SiteSettings = $Result.DefaultSelection<Prisma.$SiteSettingsPayload>
/**
 * Model InternalLink
 * 
 */
export type InternalLink = $Result.DefaultSelection<Prisma.$InternalLinkPayload>
/**
 * Model LinkUsage
 * 
 */
export type LinkUsage = $Result.DefaultSelection<Prisma.$LinkUsagePayload>
/**
 * Model LandingPageSuggestion
 * 
 */
export type LandingPageSuggestion = $Result.DefaultSelection<Prisma.$LandingPageSuggestionPayload>
/**
 * Model LandingPage
 * 
 */
export type LandingPage = $Result.DefaultSelection<Prisma.$LandingPagePayload>
/**
 * Model CompanyProfile
 * 
 */
export type CompanyProfile = $Result.DefaultSelection<Prisma.$CompanyProfilePayload>
/**
 * Model BlogScheduleSettings
 * 
 */
export type BlogScheduleSettings = $Result.DefaultSelection<Prisma.$BlogScheduleSettingsPayload>
/**
 * Model TopicSuggestion
 * 
 */
export type TopicSuggestion = $Result.DefaultSelection<Prisma.$TopicSuggestionPayload>
/**
 * Model ScheduledBlog
 * 
 */
export type ScheduledBlog = $Result.DefaultSelection<Prisma.$ScheduledBlogPayload>
/**
 * Model HeroImage
 * 
 */
export type HeroImage = $Result.DefaultSelection<Prisma.$HeroImagePayload>
/**
 * Model PropertyAlert
 * 
 */
export type PropertyAlert = $Result.DefaultSelection<Prisma.$PropertyAlertPayload>
/**
 * Model PropertyAlertNotification
 * 
 */
export type PropertyAlertNotification = $Result.DefaultSelection<Prisma.$PropertyAlertNotificationPayload>
/**
 * Model Poi
 * 
 */
export type Poi = $Result.DefaultSelection<Prisma.$PoiPayload>
/**
 * Model PropertyPoiDistance
 * 
 */
export type PropertyPoiDistance = $Result.DefaultSelection<Prisma.$PropertyPoiDistancePayload>
/**
 * Model PoiSyncJob
 * 
 */
export type PoiSyncJob = $Result.DefaultSelection<Prisma.$PoiSyncJobPayload>
/**
 * Model RentalPricingConfig
 * 
 */
export type RentalPricingConfig = $Result.DefaultSelection<Prisma.$RentalPricingConfigPayload>
/**
 * Model RentalBooking
 * 
 */
export type RentalBooking = $Result.DefaultSelection<Prisma.$RentalBookingPayload>
/**
 * Model BookingMessage
 * 
 */
export type BookingMessage = $Result.DefaultSelection<Prisma.$BookingMessagePayload>
/**
 * Model BookingGuest
 * 
 */
export type BookingGuest = $Result.DefaultSelection<Prisma.$BookingGuestPayload>
/**
 * Model PropertyBlockedDate
 * 
 */
export type PropertyBlockedDate = $Result.DefaultSelection<Prisma.$PropertyBlockedDatePayload>
/**
 * Model Tm30Accommodation
 * 
 */
export type Tm30Accommodation = $Result.DefaultSelection<Prisma.$Tm30AccommodationPayload>
/**
 * Model Tm30AccommodationRequest
 * 
 */
export type Tm30AccommodationRequest = $Result.DefaultSelection<Prisma.$Tm30AccommodationRequestPayload>
/**
 * Model PropertyOwner
 * 
 */
export type PropertyOwner = $Result.DefaultSelection<Prisma.$PropertyOwnerPayload>
/**
 * Model OwnerDocument
 * 
 */
export type OwnerDocument = $Result.DefaultSelection<Prisma.$OwnerDocumentPayload>
/**
 * Model WhatsappListingSession
 * 
 */
export type WhatsappListingSession = $Result.DefaultSelection<Prisma.$WhatsappListingSessionPayload>
/**
 * Model AIAgentConfig
 * 
 */
export type AIAgentConfig = $Result.DefaultSelection<Prisma.$AIAgentConfigPayload>
/**
 * Model AIDecision
 * 
 */
export type AIDecision = $Result.DefaultSelection<Prisma.$AIDecisionPayload>
/**
 * Model AICodeChange
 * 
 */
export type AICodeChange = $Result.DefaultSelection<Prisma.$AICodeChangePayload>
/**
 * Model AIAgentLog
 * 
 */
export type AIAgentLog = $Result.DefaultSelection<Prisma.$AIAgentLogPayload>
/**
 * Model AIDataSnapshot
 * 
 */
export type AIDataSnapshot = $Result.DefaultSelection<Prisma.$AIDataSnapshotPayload>
/**
 * Model AIOpportunity
 * 
 */
export type AIOpportunity = $Result.DefaultSelection<Prisma.$AIOpportunityPayload>
/**
 * Model AILearning
 * 
 */
export type AILearning = $Result.DefaultSelection<Prisma.$AILearningPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PropertyType: {
  FOR_SALE: 'FOR_SALE',
  FOR_RENT: 'FOR_RENT'
};

export type PropertyType = (typeof PropertyType)[keyof typeof PropertyType]


export const OwnershipType: {
  FREEHOLD: 'FREEHOLD',
  LEASEHOLD: 'LEASEHOLD'
};

export type OwnershipType = (typeof OwnershipType)[keyof typeof OwnershipType]


export const PropertyCategory: {
  LUXURY_VILLA: 'LUXURY_VILLA',
  APARTMENT: 'APARTMENT',
  RESIDENTIAL_HOME: 'RESIDENTIAL_HOME',
  OFFICE_SPACES: 'OFFICE_SPACES'
};

export type PropertyCategory = (typeof PropertyCategory)[keyof typeof PropertyCategory]


export const Status: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SOLD: 'SOLD',
  RENTED: 'RENTED'
};

export type Status = (typeof Status)[keyof typeof Status]


export const RequestType: {
  SCHEDULE_VIEWING: 'SCHEDULE_VIEWING',
  MAKE_OFFER: 'MAKE_OFFER'
};

export type RequestType = (typeof RequestType)[keyof typeof RequestType]


export const RequestStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED'
};

export type RequestStatus = (typeof RequestStatus)[keyof typeof RequestStatus]


export const LeadStatus: {
  NEW: 'NEW',
  CONTACTED: 'CONTACTED',
  QUALIFIED: 'QUALIFIED',
  PROPOSAL_SENT: 'PROPOSAL_SENT',
  CONVERTED: 'CONVERTED',
  NOT_INTERESTED: 'NOT_INTERESTED',
  LOST: 'LOST'
};

export type LeadStatus = (typeof LeadStatus)[keyof typeof LeadStatus]


export const RentalLeadStatus: {
  NEW: 'NEW',
  CONTACTED: 'CONTACTED',
  VIEWING_SCHEDULED: 'VIEWING_SCHEDULED',
  OFFER_MADE: 'OFFER_MADE',
  RENTED: 'RENTED',
  NOT_INTERESTED: 'NOT_INTERESTED',
  LOST: 'LOST'
};

export type RentalLeadStatus = (typeof RentalLeadStatus)[keyof typeof RentalLeadStatus]


export const SubmissionStatus: {
  PENDING_REVIEW: 'PENDING_REVIEW',
  UNDER_REVIEW: 'UNDER_REVIEW',
  INFO_REQUESTED: 'INFO_REQUESTED',
  APPROVED: 'APPROVED',
  IMAGES_UPLOADED: 'IMAGES_UPLOADED',
  READY_TO_PUBLISH: 'READY_TO_PUBLISH',
  PUBLISHED: 'PUBLISHED',
  REJECTED: 'REJECTED'
};

export type SubmissionStatus = (typeof SubmissionStatus)[keyof typeof SubmissionStatus]


export const LandingPageStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  CREATED: 'CREATED',
  DISMISSED: 'DISMISSED'
};

export type LandingPageStatus = (typeof LandingPageStatus)[keyof typeof LandingPageStatus]


export const TopicStatus: {
  AVAILABLE: 'AVAILABLE',
  SCHEDULED: 'SCHEDULED',
  USED: 'USED',
  SKIPPED: 'SKIPPED'
};

export type TopicStatus = (typeof TopicStatus)[keyof typeof TopicStatus]


export const ScheduledBlogStatus: {
  SCHEDULED: 'SCHEDULED',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type ScheduledBlogStatus = (typeof ScheduledBlogStatus)[keyof typeof ScheduledBlogStatus]


export const HeroDeviceType: {
  DESKTOP: 'DESKTOP',
  MOBILE: 'MOBILE',
  TABLET: 'TABLET'
};

export type HeroDeviceType = (typeof HeroDeviceType)[keyof typeof HeroDeviceType]


export const PoiSource: {
  OSM: 'OSM',
  GOOGLE: 'GOOGLE',
  MANUAL: 'MANUAL',
  GOVERNMENT: 'GOVERNMENT'
};

export type PoiSource = (typeof PoiSource)[keyof typeof PoiSource]


export const PoiCategory: {
  BEACH: 'BEACH',
  PARK: 'PARK',
  VIEWPOINT: 'VIEWPOINT',
  GOLF_COURSE: 'GOLF_COURSE',
  MARINA: 'MARINA',
  TEMPLE: 'TEMPLE',
  INTERNATIONAL_SCHOOL: 'INTERNATIONAL_SCHOOL',
  LOCAL_SCHOOL: 'LOCAL_SCHOOL',
  KINDERGARTEN: 'KINDERGARTEN',
  UNIVERSITY: 'UNIVERSITY',
  HOSPITAL: 'HOSPITAL',
  CLINIC: 'CLINIC',
  PHARMACY: 'PHARMACY',
  DENTIST: 'DENTIST',
  SHOPPING_MALL: 'SHOPPING_MALL',
  SUPERMARKET: 'SUPERMARKET',
  CONVENIENCE_STORE: 'CONVENIENCE_STORE',
  MARKET: 'MARKET',
  GYM: 'GYM',
  COWORKING: 'COWORKING',
  BANK: 'BANK',
  ATM: 'ATM',
  POST_OFFICE: 'POST_OFFICE',
  RESTAURANT: 'RESTAURANT',
  CAFE: 'CAFE',
  BAR: 'BAR',
  NIGHTCLUB: 'NIGHTCLUB',
  MAIN_ROAD: 'MAIN_ROAD',
  HIGHWAY_ACCESS: 'HIGHWAY_ACCESS',
  AIRPORT: 'AIRPORT',
  BUS_STATION: 'BUS_STATION',
  FERRY_TERMINAL: 'FERRY_TERMINAL',
  TAXI_STAND: 'TAXI_STAND',
  SEA_VIEW_POINT: 'SEA_VIEW_POINT',
  MOUNTAIN_VIEW: 'MOUNTAIN_VIEW',
  RIVER: 'RIVER',
  LAKE: 'LAKE',
  NIGHTLIFE_CLUSTER: 'NIGHTLIFE_CLUSTER',
  BUSY_INTERSECTION: 'BUSY_INTERSECTION',
  CONSTRUCTION_ZONE: 'CONSTRUCTION_ZONE',
  NEIGHBORHOOD: 'NEIGHBORHOOD',
  TOURIST_AREA: 'TOURIST_AREA',
  RESIDENTIAL_AREA: 'RESIDENTIAL_AREA',
  HOTEL: 'HOTEL',
  RESORT: 'RESORT'
};

export type PoiCategory = (typeof PoiCategory)[keyof typeof PoiCategory]


export const NoiseLevel: {
  QUIET: 'QUIET',
  MODERATE: 'MODERATE',
  BUSY: 'BUSY',
  LOUD: 'LOUD'
};

export type NoiseLevel = (typeof NoiseLevel)[keyof typeof NoiseLevel]


export const TrafficLevel: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  VERY_HIGH: 'VERY_HIGH'
};

export type TrafficLevel = (typeof TrafficLevel)[keyof typeof TrafficLevel]


export const PoiSyncJobType: {
  FULL_SYNC: 'FULL_SYNC',
  CATEGORY_SYNC: 'CATEGORY_SYNC',
  DISTRICT_SYNC: 'DISTRICT_SYNC',
  INCREMENTAL: 'INCREMENTAL'
};

export type PoiSyncJobType = (typeof PoiSyncJobType)[keyof typeof PoiSyncJobType]


export const PoiSyncJobStatus: {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type PoiSyncJobStatus = (typeof PoiSyncJobStatus)[keyof typeof PoiSyncJobStatus]


export const RentalBookingStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED'
};

export type RentalBookingStatus = (typeof RentalBookingStatus)[keyof typeof RentalBookingStatus]


export const TM30BookingStatus: {
  PENDING: 'PENDING',
  PASSPORT_RECEIVED: 'PASSPORT_RECEIVED',
  PROCESSING: 'PROCESSING',
  SUBMITTED: 'SUBMITTED',
  FAILED: 'FAILED'
};

export type TM30BookingStatus = (typeof TM30BookingStatus)[keyof typeof TM30BookingStatus]


export const TM30GuestStatus: {
  PENDING: 'PENDING',
  SCANNED: 'SCANNED',
  VERIFIED: 'VERIFIED',
  SUBMITTED: 'SUBMITTED',
  FAILED: 'FAILED'
};

export type TM30GuestStatus = (typeof TM30GuestStatus)[keyof typeof TM30GuestStatus]


export const Tm30AccomRequestStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  SUBMITTED: 'SUBMITTED',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  FAILED: 'FAILED'
};

export type Tm30AccomRequestStatus = (typeof Tm30AccomRequestStatus)[keyof typeof Tm30AccomRequestStatus]


export const OwnerDocumentType: {
  ID_CARD: 'ID_CARD',
  BLUEBOOK: 'BLUEBOOK',
  PASSPORT: 'PASSPORT',
  BUSINESS_REG: 'BUSINESS_REG',
  OTHER: 'OTHER'
};

export type OwnerDocumentType = (typeof OwnerDocumentType)[keyof typeof OwnerDocumentType]


export const AIDecisionStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  EXECUTING: 'EXECUTING',
  EXECUTED: 'EXECUTED',
  FAILED: 'FAILED',
  REJECTED: 'REJECTED',
  ROLLED_BACK: 'ROLLED_BACK',
  CANCELLED: 'CANCELLED'
};

export type AIDecisionStatus = (typeof AIDecisionStatus)[keyof typeof AIDecisionStatus]


export const AICodeAction: {
  CREATE: 'CREATE',
  MODIFY: 'MODIFY',
  DELETE: 'DELETE'
};

export type AICodeAction = (typeof AICodeAction)[keyof typeof AICodeAction]


export const AILogLevel: {
  DEBUG: 'DEBUG',
  INFO: 'INFO',
  WARN: 'WARN',
  ERROR: 'ERROR',
  CRITICAL: 'CRITICAL'
};

export type AILogLevel = (typeof AILogLevel)[keyof typeof AILogLevel]


export const AIOpportunityStatus: {
  IDENTIFIED: 'IDENTIFIED',
  ANALYZING: 'ANALYZING',
  DECISION_MADE: 'DECISION_MADE',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  DISMISSED: 'DISMISSED'
};

export type AIOpportunityStatus = (typeof AIOpportunityStatus)[keyof typeof AIOpportunityStatus]

}

export type PropertyType = $Enums.PropertyType

export const PropertyType: typeof $Enums.PropertyType

export type OwnershipType = $Enums.OwnershipType

export const OwnershipType: typeof $Enums.OwnershipType

export type PropertyCategory = $Enums.PropertyCategory

export const PropertyCategory: typeof $Enums.PropertyCategory

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type RequestType = $Enums.RequestType

export const RequestType: typeof $Enums.RequestType

export type RequestStatus = $Enums.RequestStatus

export const RequestStatus: typeof $Enums.RequestStatus

export type LeadStatus = $Enums.LeadStatus

export const LeadStatus: typeof $Enums.LeadStatus

export type RentalLeadStatus = $Enums.RentalLeadStatus

export const RentalLeadStatus: typeof $Enums.RentalLeadStatus

export type SubmissionStatus = $Enums.SubmissionStatus

export const SubmissionStatus: typeof $Enums.SubmissionStatus

export type LandingPageStatus = $Enums.LandingPageStatus

export const LandingPageStatus: typeof $Enums.LandingPageStatus

export type TopicStatus = $Enums.TopicStatus

export const TopicStatus: typeof $Enums.TopicStatus

export type ScheduledBlogStatus = $Enums.ScheduledBlogStatus

export const ScheduledBlogStatus: typeof $Enums.ScheduledBlogStatus

export type HeroDeviceType = $Enums.HeroDeviceType

export const HeroDeviceType: typeof $Enums.HeroDeviceType

export type PoiSource = $Enums.PoiSource

export const PoiSource: typeof $Enums.PoiSource

export type PoiCategory = $Enums.PoiCategory

export const PoiCategory: typeof $Enums.PoiCategory

export type NoiseLevel = $Enums.NoiseLevel

export const NoiseLevel: typeof $Enums.NoiseLevel

export type TrafficLevel = $Enums.TrafficLevel

export const TrafficLevel: typeof $Enums.TrafficLevel

export type PoiSyncJobType = $Enums.PoiSyncJobType

export const PoiSyncJobType: typeof $Enums.PoiSyncJobType

export type PoiSyncJobStatus = $Enums.PoiSyncJobStatus

export const PoiSyncJobStatus: typeof $Enums.PoiSyncJobStatus

export type RentalBookingStatus = $Enums.RentalBookingStatus

export const RentalBookingStatus: typeof $Enums.RentalBookingStatus

export type TM30BookingStatus = $Enums.TM30BookingStatus

export const TM30BookingStatus: typeof $Enums.TM30BookingStatus

export type TM30GuestStatus = $Enums.TM30GuestStatus

export const TM30GuestStatus: typeof $Enums.TM30GuestStatus

export type Tm30AccomRequestStatus = $Enums.Tm30AccomRequestStatus

export const Tm30AccomRequestStatus: typeof $Enums.Tm30AccomRequestStatus

export type OwnerDocumentType = $Enums.OwnerDocumentType

export const OwnerDocumentType: typeof $Enums.OwnerDocumentType

export type AIDecisionStatus = $Enums.AIDecisionStatus

export const AIDecisionStatus: typeof $Enums.AIDecisionStatus

export type AICodeAction = $Enums.AICodeAction

export const AICodeAction: typeof $Enums.AICodeAction

export type AILogLevel = $Enums.AILogLevel

export const AILogLevel: typeof $Enums.AILogLevel

export type AIOpportunityStatus = $Enums.AIOpportunityStatus

export const AIOpportunityStatus: typeof $Enums.AIOpportunityStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentInvite`: Exposes CRUD operations for the **AgentInvite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentInvites
    * const agentInvites = await prisma.agentInvite.findMany()
    * ```
    */
  get agentInvite(): Prisma.AgentInviteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.property`: Exposes CRUD operations for the **Property** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Properties
    * const properties = await prisma.property.findMany()
    * ```
    */
  get property(): Prisma.PropertyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyImage`: Exposes CRUD operations for the **PropertyImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyImages
    * const propertyImages = await prisma.propertyImage.findMany()
    * ```
    */
  get propertyImage(): Prisma.PropertyImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyView`: Exposes CRUD operations for the **PropertyView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyViews
    * const propertyViews = await prisma.propertyView.findMany()
    * ```
    */
  get propertyView(): Prisma.PropertyViewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.viewingRequest`: Exposes CRUD operations for the **ViewingRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ViewingRequests
    * const viewingRequests = await prisma.viewingRequest.findMany()
    * ```
    */
  get viewingRequest(): Prisma.ViewingRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.investorLead`: Exposes CRUD operations for the **InvestorLead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvestorLeads
    * const investorLeads = await prisma.investorLead.findMany()
    * ```
    */
  get investorLead(): Prisma.InvestorLeadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rentalLead`: Exposes CRUD operations for the **RentalLead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RentalLeads
    * const rentalLeads = await prisma.rentalLead.findMany()
    * ```
    */
  get rentalLead(): Prisma.RentalLeadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blog`: Exposes CRUD operations for the **Blog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blogs
    * const blogs = await prisma.blog.findMany()
    * ```
    */
  get blog(): Prisma.BlogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogCategory`: Exposes CRUD operations for the **BlogCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogCategories
    * const blogCategories = await prisma.blogCategory.findMany()
    * ```
    */
  get blogCategory(): Prisma.BlogCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertySubmission`: Exposes CRUD operations for the **PropertySubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertySubmissions
    * const propertySubmissions = await prisma.propertySubmission.findMany()
    * ```
    */
  get propertySubmission(): Prisma.PropertySubmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.siteSettings`: Exposes CRUD operations for the **SiteSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteSettings
    * const siteSettings = await prisma.siteSettings.findMany()
    * ```
    */
  get siteSettings(): Prisma.SiteSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.internalLink`: Exposes CRUD operations for the **InternalLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InternalLinks
    * const internalLinks = await prisma.internalLink.findMany()
    * ```
    */
  get internalLink(): Prisma.InternalLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.linkUsage`: Exposes CRUD operations for the **LinkUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LinkUsages
    * const linkUsages = await prisma.linkUsage.findMany()
    * ```
    */
  get linkUsage(): Prisma.LinkUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.landingPageSuggestion`: Exposes CRUD operations for the **LandingPageSuggestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LandingPageSuggestions
    * const landingPageSuggestions = await prisma.landingPageSuggestion.findMany()
    * ```
    */
  get landingPageSuggestion(): Prisma.LandingPageSuggestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.landingPage`: Exposes CRUD operations for the **LandingPage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LandingPages
    * const landingPages = await prisma.landingPage.findMany()
    * ```
    */
  get landingPage(): Prisma.LandingPageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyProfile`: Exposes CRUD operations for the **CompanyProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyProfiles
    * const companyProfiles = await prisma.companyProfile.findMany()
    * ```
    */
  get companyProfile(): Prisma.CompanyProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogScheduleSettings`: Exposes CRUD operations for the **BlogScheduleSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogScheduleSettings
    * const blogScheduleSettings = await prisma.blogScheduleSettings.findMany()
    * ```
    */
  get blogScheduleSettings(): Prisma.BlogScheduleSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.topicSuggestion`: Exposes CRUD operations for the **TopicSuggestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TopicSuggestions
    * const topicSuggestions = await prisma.topicSuggestion.findMany()
    * ```
    */
  get topicSuggestion(): Prisma.TopicSuggestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scheduledBlog`: Exposes CRUD operations for the **ScheduledBlog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduledBlogs
    * const scheduledBlogs = await prisma.scheduledBlog.findMany()
    * ```
    */
  get scheduledBlog(): Prisma.ScheduledBlogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.heroImage`: Exposes CRUD operations for the **HeroImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HeroImages
    * const heroImages = await prisma.heroImage.findMany()
    * ```
    */
  get heroImage(): Prisma.HeroImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyAlert`: Exposes CRUD operations for the **PropertyAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyAlerts
    * const propertyAlerts = await prisma.propertyAlert.findMany()
    * ```
    */
  get propertyAlert(): Prisma.PropertyAlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyAlertNotification`: Exposes CRUD operations for the **PropertyAlertNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyAlertNotifications
    * const propertyAlertNotifications = await prisma.propertyAlertNotification.findMany()
    * ```
    */
  get propertyAlertNotification(): Prisma.PropertyAlertNotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.poi`: Exposes CRUD operations for the **Poi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pois
    * const pois = await prisma.poi.findMany()
    * ```
    */
  get poi(): Prisma.PoiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyPoiDistance`: Exposes CRUD operations for the **PropertyPoiDistance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyPoiDistances
    * const propertyPoiDistances = await prisma.propertyPoiDistance.findMany()
    * ```
    */
  get propertyPoiDistance(): Prisma.PropertyPoiDistanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.poiSyncJob`: Exposes CRUD operations for the **PoiSyncJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PoiSyncJobs
    * const poiSyncJobs = await prisma.poiSyncJob.findMany()
    * ```
    */
  get poiSyncJob(): Prisma.PoiSyncJobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rentalPricingConfig`: Exposes CRUD operations for the **RentalPricingConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RentalPricingConfigs
    * const rentalPricingConfigs = await prisma.rentalPricingConfig.findMany()
    * ```
    */
  get rentalPricingConfig(): Prisma.RentalPricingConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rentalBooking`: Exposes CRUD operations for the **RentalBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RentalBookings
    * const rentalBookings = await prisma.rentalBooking.findMany()
    * ```
    */
  get rentalBooking(): Prisma.RentalBookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingMessage`: Exposes CRUD operations for the **BookingMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingMessages
    * const bookingMessages = await prisma.bookingMessage.findMany()
    * ```
    */
  get bookingMessage(): Prisma.BookingMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingGuest`: Exposes CRUD operations for the **BookingGuest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingGuests
    * const bookingGuests = await prisma.bookingGuest.findMany()
    * ```
    */
  get bookingGuest(): Prisma.BookingGuestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyBlockedDate`: Exposes CRUD operations for the **PropertyBlockedDate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyBlockedDates
    * const propertyBlockedDates = await prisma.propertyBlockedDate.findMany()
    * ```
    */
  get propertyBlockedDate(): Prisma.PropertyBlockedDateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tm30Accommodation`: Exposes CRUD operations for the **Tm30Accommodation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tm30Accommodations
    * const tm30Accommodations = await prisma.tm30Accommodation.findMany()
    * ```
    */
  get tm30Accommodation(): Prisma.Tm30AccommodationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tm30AccommodationRequest`: Exposes CRUD operations for the **Tm30AccommodationRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tm30AccommodationRequests
    * const tm30AccommodationRequests = await prisma.tm30AccommodationRequest.findMany()
    * ```
    */
  get tm30AccommodationRequest(): Prisma.Tm30AccommodationRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyOwner`: Exposes CRUD operations for the **PropertyOwner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyOwners
    * const propertyOwners = await prisma.propertyOwner.findMany()
    * ```
    */
  get propertyOwner(): Prisma.PropertyOwnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ownerDocument`: Exposes CRUD operations for the **OwnerDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OwnerDocuments
    * const ownerDocuments = await prisma.ownerDocument.findMany()
    * ```
    */
  get ownerDocument(): Prisma.OwnerDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsappListingSession`: Exposes CRUD operations for the **WhatsappListingSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsappListingSessions
    * const whatsappListingSessions = await prisma.whatsappListingSession.findMany()
    * ```
    */
  get whatsappListingSession(): Prisma.WhatsappListingSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIAgentConfig`: Exposes CRUD operations for the **AIAgentConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIAgentConfigs
    * const aIAgentConfigs = await prisma.aIAgentConfig.findMany()
    * ```
    */
  get aIAgentConfig(): Prisma.AIAgentConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIDecision`: Exposes CRUD operations for the **AIDecision** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIDecisions
    * const aIDecisions = await prisma.aIDecision.findMany()
    * ```
    */
  get aIDecision(): Prisma.AIDecisionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aICodeChange`: Exposes CRUD operations for the **AICodeChange** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AICodeChanges
    * const aICodeChanges = await prisma.aICodeChange.findMany()
    * ```
    */
  get aICodeChange(): Prisma.AICodeChangeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIAgentLog`: Exposes CRUD operations for the **AIAgentLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIAgentLogs
    * const aIAgentLogs = await prisma.aIAgentLog.findMany()
    * ```
    */
  get aIAgentLog(): Prisma.AIAgentLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIDataSnapshot`: Exposes CRUD operations for the **AIDataSnapshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIDataSnapshots
    * const aIDataSnapshots = await prisma.aIDataSnapshot.findMany()
    * ```
    */
  get aIDataSnapshot(): Prisma.AIDataSnapshotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIOpportunity`: Exposes CRUD operations for the **AIOpportunity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIOpportunities
    * const aIOpportunities = await prisma.aIOpportunity.findMany()
    * ```
    */
  get aIOpportunity(): Prisma.AIOpportunityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aILearning`: Exposes CRUD operations for the **AILearning** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AILearnings
    * const aILearnings = await prisma.aILearning.findMany()
    * ```
    */
  get aILearning(): Prisma.AILearningDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.0.0
   * Query Engine version: 0c19ccc313cf9911a90d99d2ac2eb0280c76c513
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    Session: 'Session',
    User: 'User',
    Verification: 'Verification',
    AgentInvite: 'AgentInvite',
    Property: 'Property',
    PropertyImage: 'PropertyImage',
    PropertyView: 'PropertyView',
    ViewingRequest: 'ViewingRequest',
    InvestorLead: 'InvestorLead',
    RentalLead: 'RentalLead',
    Blog: 'Blog',
    BlogCategory: 'BlogCategory',
    PropertySubmission: 'PropertySubmission',
    SiteSettings: 'SiteSettings',
    InternalLink: 'InternalLink',
    LinkUsage: 'LinkUsage',
    LandingPageSuggestion: 'LandingPageSuggestion',
    LandingPage: 'LandingPage',
    CompanyProfile: 'CompanyProfile',
    BlogScheduleSettings: 'BlogScheduleSettings',
    TopicSuggestion: 'TopicSuggestion',
    ScheduledBlog: 'ScheduledBlog',
    HeroImage: 'HeroImage',
    PropertyAlert: 'PropertyAlert',
    PropertyAlertNotification: 'PropertyAlertNotification',
    Poi: 'Poi',
    PropertyPoiDistance: 'PropertyPoiDistance',
    PoiSyncJob: 'PoiSyncJob',
    RentalPricingConfig: 'RentalPricingConfig',
    RentalBooking: 'RentalBooking',
    BookingMessage: 'BookingMessage',
    BookingGuest: 'BookingGuest',
    PropertyBlockedDate: 'PropertyBlockedDate',
    Tm30Accommodation: 'Tm30Accommodation',
    Tm30AccommodationRequest: 'Tm30AccommodationRequest',
    PropertyOwner: 'PropertyOwner',
    OwnerDocument: 'OwnerDocument',
    WhatsappListingSession: 'WhatsappListingSession',
    AIAgentConfig: 'AIAgentConfig',
    AIDecision: 'AIDecision',
    AICodeChange: 'AICodeChange',
    AIAgentLog: 'AIAgentLog',
    AIDataSnapshot: 'AIDataSnapshot',
    AIOpportunity: 'AIOpportunity',
    AILearning: 'AILearning'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "account" | "session" | "user" | "verification" | "agentInvite" | "property" | "propertyImage" | "propertyView" | "viewingRequest" | "investorLead" | "rentalLead" | "blog" | "blogCategory" | "propertySubmission" | "siteSettings" | "internalLink" | "linkUsage" | "landingPageSuggestion" | "landingPage" | "companyProfile" | "blogScheduleSettings" | "topicSuggestion" | "scheduledBlog" | "heroImage" | "propertyAlert" | "propertyAlertNotification" | "poi" | "propertyPoiDistance" | "poiSyncJob" | "rentalPricingConfig" | "rentalBooking" | "bookingMessage" | "bookingGuest" | "propertyBlockedDate" | "tm30Accommodation" | "tm30AccommodationRequest" | "propertyOwner" | "ownerDocument" | "whatsappListingSession" | "aIAgentConfig" | "aIDecision" | "aICodeChange" | "aIAgentLog" | "aIDataSnapshot" | "aIOpportunity" | "aILearning"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      AgentInvite: {
        payload: Prisma.$AgentInvitePayload<ExtArgs>
        fields: Prisma.AgentInviteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentInviteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentInvitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentInviteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentInvitePayload>
          }
          findFirst: {
            args: Prisma.AgentInviteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentInvitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentInviteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentInvitePayload>
          }
          findMany: {
            args: Prisma.AgentInviteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentInvitePayload>[]
          }
          create: {
            args: Prisma.AgentInviteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentInvitePayload>
          }
          createMany: {
            args: Prisma.AgentInviteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentInviteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentInvitePayload>[]
          }
          delete: {
            args: Prisma.AgentInviteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentInvitePayload>
          }
          update: {
            args: Prisma.AgentInviteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentInvitePayload>
          }
          deleteMany: {
            args: Prisma.AgentInviteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentInviteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentInviteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentInvitePayload>[]
          }
          upsert: {
            args: Prisma.AgentInviteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentInvitePayload>
          }
          aggregate: {
            args: Prisma.AgentInviteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentInvite>
          }
          groupBy: {
            args: Prisma.AgentInviteGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentInviteGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentInviteCountArgs<ExtArgs>
            result: $Utils.Optional<AgentInviteCountAggregateOutputType> | number
          }
        }
      }
      Property: {
        payload: Prisma.$PropertyPayload<ExtArgs>
        fields: Prisma.PropertyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findFirst: {
            args: Prisma.PropertyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findMany: {
            args: Prisma.PropertyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          create: {
            args: Prisma.PropertyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          createMany: {
            args: Prisma.PropertyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          delete: {
            args: Prisma.PropertyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          update: {
            args: Prisma.PropertyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          deleteMany: {
            args: Prisma.PropertyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          upsert: {
            args: Prisma.PropertyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          aggregate: {
            args: Prisma.PropertyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProperty>
          }
          groupBy: {
            args: Prisma.PropertyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyCountAggregateOutputType> | number
          }
        }
      }
      PropertyImage: {
        payload: Prisma.$PropertyImagePayload<ExtArgs>
        fields: Prisma.PropertyImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyImagePayload>
          }
          findFirst: {
            args: Prisma.PropertyImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyImagePayload>
          }
          findMany: {
            args: Prisma.PropertyImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyImagePayload>[]
          }
          create: {
            args: Prisma.PropertyImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyImagePayload>
          }
          createMany: {
            args: Prisma.PropertyImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyImagePayload>[]
          }
          delete: {
            args: Prisma.PropertyImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyImagePayload>
          }
          update: {
            args: Prisma.PropertyImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyImagePayload>
          }
          deleteMany: {
            args: Prisma.PropertyImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyImagePayload>[]
          }
          upsert: {
            args: Prisma.PropertyImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyImagePayload>
          }
          aggregate: {
            args: Prisma.PropertyImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyImage>
          }
          groupBy: {
            args: Prisma.PropertyImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyImageCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyImageCountAggregateOutputType> | number
          }
        }
      }
      PropertyView: {
        payload: Prisma.$PropertyViewPayload<ExtArgs>
        fields: Prisma.PropertyViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          findFirst: {
            args: Prisma.PropertyViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          findMany: {
            args: Prisma.PropertyViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>[]
          }
          create: {
            args: Prisma.PropertyViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          createMany: {
            args: Prisma.PropertyViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>[]
          }
          delete: {
            args: Prisma.PropertyViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          update: {
            args: Prisma.PropertyViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          deleteMany: {
            args: Prisma.PropertyViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyViewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>[]
          }
          upsert: {
            args: Prisma.PropertyViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          aggregate: {
            args: Prisma.PropertyViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyView>
          }
          groupBy: {
            args: Prisma.PropertyViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyViewCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyViewCountAggregateOutputType> | number
          }
        }
      }
      ViewingRequest: {
        payload: Prisma.$ViewingRequestPayload<ExtArgs>
        fields: Prisma.ViewingRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViewingRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViewingRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingRequestPayload>
          }
          findFirst: {
            args: Prisma.ViewingRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViewingRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingRequestPayload>
          }
          findMany: {
            args: Prisma.ViewingRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingRequestPayload>[]
          }
          create: {
            args: Prisma.ViewingRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingRequestPayload>
          }
          createMany: {
            args: Prisma.ViewingRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViewingRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingRequestPayload>[]
          }
          delete: {
            args: Prisma.ViewingRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingRequestPayload>
          }
          update: {
            args: Prisma.ViewingRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingRequestPayload>
          }
          deleteMany: {
            args: Prisma.ViewingRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViewingRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ViewingRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingRequestPayload>[]
          }
          upsert: {
            args: Prisma.ViewingRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingRequestPayload>
          }
          aggregate: {
            args: Prisma.ViewingRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViewingRequest>
          }
          groupBy: {
            args: Prisma.ViewingRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViewingRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViewingRequestCountArgs<ExtArgs>
            result: $Utils.Optional<ViewingRequestCountAggregateOutputType> | number
          }
        }
      }
      InvestorLead: {
        payload: Prisma.$InvestorLeadPayload<ExtArgs>
        fields: Prisma.InvestorLeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvestorLeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorLeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvestorLeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorLeadPayload>
          }
          findFirst: {
            args: Prisma.InvestorLeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorLeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvestorLeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorLeadPayload>
          }
          findMany: {
            args: Prisma.InvestorLeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorLeadPayload>[]
          }
          create: {
            args: Prisma.InvestorLeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorLeadPayload>
          }
          createMany: {
            args: Prisma.InvestorLeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvestorLeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorLeadPayload>[]
          }
          delete: {
            args: Prisma.InvestorLeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorLeadPayload>
          }
          update: {
            args: Prisma.InvestorLeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorLeadPayload>
          }
          deleteMany: {
            args: Prisma.InvestorLeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvestorLeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvestorLeadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorLeadPayload>[]
          }
          upsert: {
            args: Prisma.InvestorLeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorLeadPayload>
          }
          aggregate: {
            args: Prisma.InvestorLeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvestorLead>
          }
          groupBy: {
            args: Prisma.InvestorLeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvestorLeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvestorLeadCountArgs<ExtArgs>
            result: $Utils.Optional<InvestorLeadCountAggregateOutputType> | number
          }
        }
      }
      RentalLead: {
        payload: Prisma.$RentalLeadPayload<ExtArgs>
        fields: Prisma.RentalLeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RentalLeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalLeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RentalLeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalLeadPayload>
          }
          findFirst: {
            args: Prisma.RentalLeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalLeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RentalLeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalLeadPayload>
          }
          findMany: {
            args: Prisma.RentalLeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalLeadPayload>[]
          }
          create: {
            args: Prisma.RentalLeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalLeadPayload>
          }
          createMany: {
            args: Prisma.RentalLeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RentalLeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalLeadPayload>[]
          }
          delete: {
            args: Prisma.RentalLeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalLeadPayload>
          }
          update: {
            args: Prisma.RentalLeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalLeadPayload>
          }
          deleteMany: {
            args: Prisma.RentalLeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RentalLeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RentalLeadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalLeadPayload>[]
          }
          upsert: {
            args: Prisma.RentalLeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalLeadPayload>
          }
          aggregate: {
            args: Prisma.RentalLeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRentalLead>
          }
          groupBy: {
            args: Prisma.RentalLeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<RentalLeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.RentalLeadCountArgs<ExtArgs>
            result: $Utils.Optional<RentalLeadCountAggregateOutputType> | number
          }
        }
      }
      Blog: {
        payload: Prisma.$BlogPayload<ExtArgs>
        fields: Prisma.BlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          findFirst: {
            args: Prisma.BlogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          findMany: {
            args: Prisma.BlogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>[]
          }
          create: {
            args: Prisma.BlogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          createMany: {
            args: Prisma.BlogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>[]
          }
          delete: {
            args: Prisma.BlogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          update: {
            args: Prisma.BlogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          deleteMany: {
            args: Prisma.BlogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>[]
          }
          upsert: {
            args: Prisma.BlogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          aggregate: {
            args: Prisma.BlogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlog>
          }
          groupBy: {
            args: Prisma.BlogGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogCountArgs<ExtArgs>
            result: $Utils.Optional<BlogCountAggregateOutputType> | number
          }
        }
      }
      BlogCategory: {
        payload: Prisma.$BlogCategoryPayload<ExtArgs>
        fields: Prisma.BlogCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCategoryPayload>
          }
          findFirst: {
            args: Prisma.BlogCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCategoryPayload>
          }
          findMany: {
            args: Prisma.BlogCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCategoryPayload>[]
          }
          create: {
            args: Prisma.BlogCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCategoryPayload>
          }
          createMany: {
            args: Prisma.BlogCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCategoryPayload>[]
          }
          delete: {
            args: Prisma.BlogCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCategoryPayload>
          }
          update: {
            args: Prisma.BlogCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCategoryPayload>
          }
          deleteMany: {
            args: Prisma.BlogCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCategoryPayload>[]
          }
          upsert: {
            args: Prisma.BlogCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogCategoryPayload>
          }
          aggregate: {
            args: Prisma.BlogCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogCategory>
          }
          groupBy: {
            args: Prisma.BlogCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<BlogCategoryCountAggregateOutputType> | number
          }
        }
      }
      PropertySubmission: {
        payload: Prisma.$PropertySubmissionPayload<ExtArgs>
        fields: Prisma.PropertySubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertySubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertySubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubmissionPayload>
          }
          findFirst: {
            args: Prisma.PropertySubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertySubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubmissionPayload>
          }
          findMany: {
            args: Prisma.PropertySubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubmissionPayload>[]
          }
          create: {
            args: Prisma.PropertySubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubmissionPayload>
          }
          createMany: {
            args: Prisma.PropertySubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertySubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubmissionPayload>[]
          }
          delete: {
            args: Prisma.PropertySubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubmissionPayload>
          }
          update: {
            args: Prisma.PropertySubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubmissionPayload>
          }
          deleteMany: {
            args: Prisma.PropertySubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertySubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertySubmissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubmissionPayload>[]
          }
          upsert: {
            args: Prisma.PropertySubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertySubmissionPayload>
          }
          aggregate: {
            args: Prisma.PropertySubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertySubmission>
          }
          groupBy: {
            args: Prisma.PropertySubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertySubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertySubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<PropertySubmissionCountAggregateOutputType> | number
          }
        }
      }
      SiteSettings: {
        payload: Prisma.$SiteSettingsPayload<ExtArgs>
        fields: Prisma.SiteSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          findFirst: {
            args: Prisma.SiteSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          findMany: {
            args: Prisma.SiteSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>[]
          }
          create: {
            args: Prisma.SiteSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          createMany: {
            args: Prisma.SiteSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SiteSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>[]
          }
          delete: {
            args: Prisma.SiteSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          update: {
            args: Prisma.SiteSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          deleteMany: {
            args: Prisma.SiteSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SiteSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>[]
          }
          upsert: {
            args: Prisma.SiteSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          aggregate: {
            args: Prisma.SiteSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSiteSettings>
          }
          groupBy: {
            args: Prisma.SiteSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SiteSettingsCountAggregateOutputType> | number
          }
        }
      }
      InternalLink: {
        payload: Prisma.$InternalLinkPayload<ExtArgs>
        fields: Prisma.InternalLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InternalLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InternalLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalLinkPayload>
          }
          findFirst: {
            args: Prisma.InternalLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InternalLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalLinkPayload>
          }
          findMany: {
            args: Prisma.InternalLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalLinkPayload>[]
          }
          create: {
            args: Prisma.InternalLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalLinkPayload>
          }
          createMany: {
            args: Prisma.InternalLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InternalLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalLinkPayload>[]
          }
          delete: {
            args: Prisma.InternalLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalLinkPayload>
          }
          update: {
            args: Prisma.InternalLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalLinkPayload>
          }
          deleteMany: {
            args: Prisma.InternalLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InternalLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InternalLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalLinkPayload>[]
          }
          upsert: {
            args: Prisma.InternalLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternalLinkPayload>
          }
          aggregate: {
            args: Prisma.InternalLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInternalLink>
          }
          groupBy: {
            args: Prisma.InternalLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<InternalLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.InternalLinkCountArgs<ExtArgs>
            result: $Utils.Optional<InternalLinkCountAggregateOutputType> | number
          }
        }
      }
      LinkUsage: {
        payload: Prisma.$LinkUsagePayload<ExtArgs>
        fields: Prisma.LinkUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LinkUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LinkUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkUsagePayload>
          }
          findFirst: {
            args: Prisma.LinkUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LinkUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkUsagePayload>
          }
          findMany: {
            args: Prisma.LinkUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkUsagePayload>[]
          }
          create: {
            args: Prisma.LinkUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkUsagePayload>
          }
          createMany: {
            args: Prisma.LinkUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LinkUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkUsagePayload>[]
          }
          delete: {
            args: Prisma.LinkUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkUsagePayload>
          }
          update: {
            args: Prisma.LinkUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkUsagePayload>
          }
          deleteMany: {
            args: Prisma.LinkUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LinkUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LinkUsageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkUsagePayload>[]
          }
          upsert: {
            args: Prisma.LinkUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkUsagePayload>
          }
          aggregate: {
            args: Prisma.LinkUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLinkUsage>
          }
          groupBy: {
            args: Prisma.LinkUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LinkUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LinkUsageCountArgs<ExtArgs>
            result: $Utils.Optional<LinkUsageCountAggregateOutputType> | number
          }
        }
      }
      LandingPageSuggestion: {
        payload: Prisma.$LandingPageSuggestionPayload<ExtArgs>
        fields: Prisma.LandingPageSuggestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LandingPageSuggestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPageSuggestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LandingPageSuggestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPageSuggestionPayload>
          }
          findFirst: {
            args: Prisma.LandingPageSuggestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPageSuggestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LandingPageSuggestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPageSuggestionPayload>
          }
          findMany: {
            args: Prisma.LandingPageSuggestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPageSuggestionPayload>[]
          }
          create: {
            args: Prisma.LandingPageSuggestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPageSuggestionPayload>
          }
          createMany: {
            args: Prisma.LandingPageSuggestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LandingPageSuggestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPageSuggestionPayload>[]
          }
          delete: {
            args: Prisma.LandingPageSuggestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPageSuggestionPayload>
          }
          update: {
            args: Prisma.LandingPageSuggestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPageSuggestionPayload>
          }
          deleteMany: {
            args: Prisma.LandingPageSuggestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LandingPageSuggestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LandingPageSuggestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPageSuggestionPayload>[]
          }
          upsert: {
            args: Prisma.LandingPageSuggestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPageSuggestionPayload>
          }
          aggregate: {
            args: Prisma.LandingPageSuggestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLandingPageSuggestion>
          }
          groupBy: {
            args: Prisma.LandingPageSuggestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<LandingPageSuggestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.LandingPageSuggestionCountArgs<ExtArgs>
            result: $Utils.Optional<LandingPageSuggestionCountAggregateOutputType> | number
          }
        }
      }
      LandingPage: {
        payload: Prisma.$LandingPagePayload<ExtArgs>
        fields: Prisma.LandingPageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LandingPageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LandingPageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPagePayload>
          }
          findFirst: {
            args: Prisma.LandingPageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LandingPageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPagePayload>
          }
          findMany: {
            args: Prisma.LandingPageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPagePayload>[]
          }
          create: {
            args: Prisma.LandingPageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPagePayload>
          }
          createMany: {
            args: Prisma.LandingPageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LandingPageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPagePayload>[]
          }
          delete: {
            args: Prisma.LandingPageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPagePayload>
          }
          update: {
            args: Prisma.LandingPageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPagePayload>
          }
          deleteMany: {
            args: Prisma.LandingPageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LandingPageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LandingPageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPagePayload>[]
          }
          upsert: {
            args: Prisma.LandingPageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LandingPagePayload>
          }
          aggregate: {
            args: Prisma.LandingPageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLandingPage>
          }
          groupBy: {
            args: Prisma.LandingPageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LandingPageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LandingPageCountArgs<ExtArgs>
            result: $Utils.Optional<LandingPageCountAggregateOutputType> | number
          }
        }
      }
      CompanyProfile: {
        payload: Prisma.$CompanyProfilePayload<ExtArgs>
        fields: Prisma.CompanyProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>
          }
          findFirst: {
            args: Prisma.CompanyProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>
          }
          findMany: {
            args: Prisma.CompanyProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>[]
          }
          create: {
            args: Prisma.CompanyProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>
          }
          createMany: {
            args: Prisma.CompanyProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>[]
          }
          delete: {
            args: Prisma.CompanyProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>
          }
          update: {
            args: Prisma.CompanyProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>
          }
          deleteMany: {
            args: Prisma.CompanyProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>[]
          }
          upsert: {
            args: Prisma.CompanyProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProfilePayload>
          }
          aggregate: {
            args: Prisma.CompanyProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyProfile>
          }
          groupBy: {
            args: Prisma.CompanyProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyProfileCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyProfileCountAggregateOutputType> | number
          }
        }
      }
      BlogScheduleSettings: {
        payload: Prisma.$BlogScheduleSettingsPayload<ExtArgs>
        fields: Prisma.BlogScheduleSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogScheduleSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogScheduleSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogScheduleSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogScheduleSettingsPayload>
          }
          findFirst: {
            args: Prisma.BlogScheduleSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogScheduleSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogScheduleSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogScheduleSettingsPayload>
          }
          findMany: {
            args: Prisma.BlogScheduleSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogScheduleSettingsPayload>[]
          }
          create: {
            args: Prisma.BlogScheduleSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogScheduleSettingsPayload>
          }
          createMany: {
            args: Prisma.BlogScheduleSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogScheduleSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogScheduleSettingsPayload>[]
          }
          delete: {
            args: Prisma.BlogScheduleSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogScheduleSettingsPayload>
          }
          update: {
            args: Prisma.BlogScheduleSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogScheduleSettingsPayload>
          }
          deleteMany: {
            args: Prisma.BlogScheduleSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogScheduleSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogScheduleSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogScheduleSettingsPayload>[]
          }
          upsert: {
            args: Prisma.BlogScheduleSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogScheduleSettingsPayload>
          }
          aggregate: {
            args: Prisma.BlogScheduleSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogScheduleSettings>
          }
          groupBy: {
            args: Prisma.BlogScheduleSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogScheduleSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogScheduleSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<BlogScheduleSettingsCountAggregateOutputType> | number
          }
        }
      }
      TopicSuggestion: {
        payload: Prisma.$TopicSuggestionPayload<ExtArgs>
        fields: Prisma.TopicSuggestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopicSuggestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicSuggestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopicSuggestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicSuggestionPayload>
          }
          findFirst: {
            args: Prisma.TopicSuggestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicSuggestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopicSuggestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicSuggestionPayload>
          }
          findMany: {
            args: Prisma.TopicSuggestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicSuggestionPayload>[]
          }
          create: {
            args: Prisma.TopicSuggestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicSuggestionPayload>
          }
          createMany: {
            args: Prisma.TopicSuggestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TopicSuggestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicSuggestionPayload>[]
          }
          delete: {
            args: Prisma.TopicSuggestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicSuggestionPayload>
          }
          update: {
            args: Prisma.TopicSuggestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicSuggestionPayload>
          }
          deleteMany: {
            args: Prisma.TopicSuggestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TopicSuggestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TopicSuggestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicSuggestionPayload>[]
          }
          upsert: {
            args: Prisma.TopicSuggestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicSuggestionPayload>
          }
          aggregate: {
            args: Prisma.TopicSuggestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopicSuggestion>
          }
          groupBy: {
            args: Prisma.TopicSuggestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopicSuggestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopicSuggestionCountArgs<ExtArgs>
            result: $Utils.Optional<TopicSuggestionCountAggregateOutputType> | number
          }
        }
      }
      ScheduledBlog: {
        payload: Prisma.$ScheduledBlogPayload<ExtArgs>
        fields: Prisma.ScheduledBlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduledBlogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledBlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduledBlogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledBlogPayload>
          }
          findFirst: {
            args: Prisma.ScheduledBlogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledBlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduledBlogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledBlogPayload>
          }
          findMany: {
            args: Prisma.ScheduledBlogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledBlogPayload>[]
          }
          create: {
            args: Prisma.ScheduledBlogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledBlogPayload>
          }
          createMany: {
            args: Prisma.ScheduledBlogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduledBlogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledBlogPayload>[]
          }
          delete: {
            args: Prisma.ScheduledBlogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledBlogPayload>
          }
          update: {
            args: Prisma.ScheduledBlogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledBlogPayload>
          }
          deleteMany: {
            args: Prisma.ScheduledBlogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduledBlogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduledBlogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledBlogPayload>[]
          }
          upsert: {
            args: Prisma.ScheduledBlogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledBlogPayload>
          }
          aggregate: {
            args: Prisma.ScheduledBlogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduledBlog>
          }
          groupBy: {
            args: Prisma.ScheduledBlogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduledBlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduledBlogCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduledBlogCountAggregateOutputType> | number
          }
        }
      }
      HeroImage: {
        payload: Prisma.$HeroImagePayload<ExtArgs>
        fields: Prisma.HeroImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HeroImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HeroImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroImagePayload>
          }
          findFirst: {
            args: Prisma.HeroImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HeroImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroImagePayload>
          }
          findMany: {
            args: Prisma.HeroImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroImagePayload>[]
          }
          create: {
            args: Prisma.HeroImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroImagePayload>
          }
          createMany: {
            args: Prisma.HeroImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HeroImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroImagePayload>[]
          }
          delete: {
            args: Prisma.HeroImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroImagePayload>
          }
          update: {
            args: Prisma.HeroImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroImagePayload>
          }
          deleteMany: {
            args: Prisma.HeroImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HeroImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HeroImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroImagePayload>[]
          }
          upsert: {
            args: Prisma.HeroImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroImagePayload>
          }
          aggregate: {
            args: Prisma.HeroImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHeroImage>
          }
          groupBy: {
            args: Prisma.HeroImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<HeroImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.HeroImageCountArgs<ExtArgs>
            result: $Utils.Optional<HeroImageCountAggregateOutputType> | number
          }
        }
      }
      PropertyAlert: {
        payload: Prisma.$PropertyAlertPayload<ExtArgs>
        fields: Prisma.PropertyAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAlertPayload>
          }
          findFirst: {
            args: Prisma.PropertyAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAlertPayload>
          }
          findMany: {
            args: Prisma.PropertyAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAlertPayload>[]
          }
          create: {
            args: Prisma.PropertyAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAlertPayload>
          }
          createMany: {
            args: Prisma.PropertyAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAlertPayload>[]
          }
          delete: {
            args: Prisma.PropertyAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAlertPayload>
          }
          update: {
            args: Prisma.PropertyAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAlertPayload>
          }
          deleteMany: {
            args: Prisma.PropertyAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyAlertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAlertPayload>[]
          }
          upsert: {
            args: Prisma.PropertyAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAlertPayload>
          }
          aggregate: {
            args: Prisma.PropertyAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyAlert>
          }
          groupBy: {
            args: Prisma.PropertyAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyAlertCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyAlertCountAggregateOutputType> | number
          }
        }
      }
      PropertyAlertNotification: {
        payload: Prisma.$PropertyAlertNotificationPayload<ExtArgs>
        fields: Prisma.PropertyAlertNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyAlertNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAlertNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyAlertNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAlertNotificationPayload>
          }
          findFirst: {
            args: Prisma.PropertyAlertNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAlertNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyAlertNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAlertNotificationPayload>
          }
          findMany: {
            args: Prisma.PropertyAlertNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAlertNotificationPayload>[]
          }
          create: {
            args: Prisma.PropertyAlertNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAlertNotificationPayload>
          }
          createMany: {
            args: Prisma.PropertyAlertNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyAlertNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAlertNotificationPayload>[]
          }
          delete: {
            args: Prisma.PropertyAlertNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAlertNotificationPayload>
          }
          update: {
            args: Prisma.PropertyAlertNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAlertNotificationPayload>
          }
          deleteMany: {
            args: Prisma.PropertyAlertNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyAlertNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyAlertNotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAlertNotificationPayload>[]
          }
          upsert: {
            args: Prisma.PropertyAlertNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAlertNotificationPayload>
          }
          aggregate: {
            args: Prisma.PropertyAlertNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyAlertNotification>
          }
          groupBy: {
            args: Prisma.PropertyAlertNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyAlertNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyAlertNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyAlertNotificationCountAggregateOutputType> | number
          }
        }
      }
      Poi: {
        payload: Prisma.$PoiPayload<ExtArgs>
        fields: Prisma.PoiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PoiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PoiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoiPayload>
          }
          findFirst: {
            args: Prisma.PoiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PoiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoiPayload>
          }
          findMany: {
            args: Prisma.PoiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoiPayload>[]
          }
          create: {
            args: Prisma.PoiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoiPayload>
          }
          createMany: {
            args: Prisma.PoiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PoiCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoiPayload>[]
          }
          delete: {
            args: Prisma.PoiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoiPayload>
          }
          update: {
            args: Prisma.PoiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoiPayload>
          }
          deleteMany: {
            args: Prisma.PoiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PoiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PoiUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoiPayload>[]
          }
          upsert: {
            args: Prisma.PoiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoiPayload>
          }
          aggregate: {
            args: Prisma.PoiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePoi>
          }
          groupBy: {
            args: Prisma.PoiGroupByArgs<ExtArgs>
            result: $Utils.Optional<PoiGroupByOutputType>[]
          }
          count: {
            args: Prisma.PoiCountArgs<ExtArgs>
            result: $Utils.Optional<PoiCountAggregateOutputType> | number
          }
        }
      }
      PropertyPoiDistance: {
        payload: Prisma.$PropertyPoiDistancePayload<ExtArgs>
        fields: Prisma.PropertyPoiDistanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyPoiDistanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPoiDistancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyPoiDistanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPoiDistancePayload>
          }
          findFirst: {
            args: Prisma.PropertyPoiDistanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPoiDistancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyPoiDistanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPoiDistancePayload>
          }
          findMany: {
            args: Prisma.PropertyPoiDistanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPoiDistancePayload>[]
          }
          create: {
            args: Prisma.PropertyPoiDistanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPoiDistancePayload>
          }
          createMany: {
            args: Prisma.PropertyPoiDistanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyPoiDistanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPoiDistancePayload>[]
          }
          delete: {
            args: Prisma.PropertyPoiDistanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPoiDistancePayload>
          }
          update: {
            args: Prisma.PropertyPoiDistanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPoiDistancePayload>
          }
          deleteMany: {
            args: Prisma.PropertyPoiDistanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyPoiDistanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyPoiDistanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPoiDistancePayload>[]
          }
          upsert: {
            args: Prisma.PropertyPoiDistanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPoiDistancePayload>
          }
          aggregate: {
            args: Prisma.PropertyPoiDistanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyPoiDistance>
          }
          groupBy: {
            args: Prisma.PropertyPoiDistanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyPoiDistanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyPoiDistanceCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyPoiDistanceCountAggregateOutputType> | number
          }
        }
      }
      PoiSyncJob: {
        payload: Prisma.$PoiSyncJobPayload<ExtArgs>
        fields: Prisma.PoiSyncJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PoiSyncJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoiSyncJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PoiSyncJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoiSyncJobPayload>
          }
          findFirst: {
            args: Prisma.PoiSyncJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoiSyncJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PoiSyncJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoiSyncJobPayload>
          }
          findMany: {
            args: Prisma.PoiSyncJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoiSyncJobPayload>[]
          }
          create: {
            args: Prisma.PoiSyncJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoiSyncJobPayload>
          }
          createMany: {
            args: Prisma.PoiSyncJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PoiSyncJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoiSyncJobPayload>[]
          }
          delete: {
            args: Prisma.PoiSyncJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoiSyncJobPayload>
          }
          update: {
            args: Prisma.PoiSyncJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoiSyncJobPayload>
          }
          deleteMany: {
            args: Prisma.PoiSyncJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PoiSyncJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PoiSyncJobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoiSyncJobPayload>[]
          }
          upsert: {
            args: Prisma.PoiSyncJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PoiSyncJobPayload>
          }
          aggregate: {
            args: Prisma.PoiSyncJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePoiSyncJob>
          }
          groupBy: {
            args: Prisma.PoiSyncJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<PoiSyncJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.PoiSyncJobCountArgs<ExtArgs>
            result: $Utils.Optional<PoiSyncJobCountAggregateOutputType> | number
          }
        }
      }
      RentalPricingConfig: {
        payload: Prisma.$RentalPricingConfigPayload<ExtArgs>
        fields: Prisma.RentalPricingConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RentalPricingConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPricingConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RentalPricingConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPricingConfigPayload>
          }
          findFirst: {
            args: Prisma.RentalPricingConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPricingConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RentalPricingConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPricingConfigPayload>
          }
          findMany: {
            args: Prisma.RentalPricingConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPricingConfigPayload>[]
          }
          create: {
            args: Prisma.RentalPricingConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPricingConfigPayload>
          }
          createMany: {
            args: Prisma.RentalPricingConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RentalPricingConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPricingConfigPayload>[]
          }
          delete: {
            args: Prisma.RentalPricingConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPricingConfigPayload>
          }
          update: {
            args: Prisma.RentalPricingConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPricingConfigPayload>
          }
          deleteMany: {
            args: Prisma.RentalPricingConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RentalPricingConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RentalPricingConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPricingConfigPayload>[]
          }
          upsert: {
            args: Prisma.RentalPricingConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalPricingConfigPayload>
          }
          aggregate: {
            args: Prisma.RentalPricingConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRentalPricingConfig>
          }
          groupBy: {
            args: Prisma.RentalPricingConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<RentalPricingConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.RentalPricingConfigCountArgs<ExtArgs>
            result: $Utils.Optional<RentalPricingConfigCountAggregateOutputType> | number
          }
        }
      }
      RentalBooking: {
        payload: Prisma.$RentalBookingPayload<ExtArgs>
        fields: Prisma.RentalBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RentalBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RentalBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalBookingPayload>
          }
          findFirst: {
            args: Prisma.RentalBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RentalBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalBookingPayload>
          }
          findMany: {
            args: Prisma.RentalBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalBookingPayload>[]
          }
          create: {
            args: Prisma.RentalBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalBookingPayload>
          }
          createMany: {
            args: Prisma.RentalBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RentalBookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalBookingPayload>[]
          }
          delete: {
            args: Prisma.RentalBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalBookingPayload>
          }
          update: {
            args: Prisma.RentalBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalBookingPayload>
          }
          deleteMany: {
            args: Prisma.RentalBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RentalBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RentalBookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalBookingPayload>[]
          }
          upsert: {
            args: Prisma.RentalBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalBookingPayload>
          }
          aggregate: {
            args: Prisma.RentalBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRentalBooking>
          }
          groupBy: {
            args: Prisma.RentalBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<RentalBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.RentalBookingCountArgs<ExtArgs>
            result: $Utils.Optional<RentalBookingCountAggregateOutputType> | number
          }
        }
      }
      BookingMessage: {
        payload: Prisma.$BookingMessagePayload<ExtArgs>
        fields: Prisma.BookingMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingMessagePayload>
          }
          findFirst: {
            args: Prisma.BookingMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingMessagePayload>
          }
          findMany: {
            args: Prisma.BookingMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingMessagePayload>[]
          }
          create: {
            args: Prisma.BookingMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingMessagePayload>
          }
          createMany: {
            args: Prisma.BookingMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingMessagePayload>[]
          }
          delete: {
            args: Prisma.BookingMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingMessagePayload>
          }
          update: {
            args: Prisma.BookingMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingMessagePayload>
          }
          deleteMany: {
            args: Prisma.BookingMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingMessagePayload>[]
          }
          upsert: {
            args: Prisma.BookingMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingMessagePayload>
          }
          aggregate: {
            args: Prisma.BookingMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingMessage>
          }
          groupBy: {
            args: Prisma.BookingMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingMessageCountArgs<ExtArgs>
            result: $Utils.Optional<BookingMessageCountAggregateOutputType> | number
          }
        }
      }
      BookingGuest: {
        payload: Prisma.$BookingGuestPayload<ExtArgs>
        fields: Prisma.BookingGuestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingGuestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingGuestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingGuestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingGuestPayload>
          }
          findFirst: {
            args: Prisma.BookingGuestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingGuestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingGuestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingGuestPayload>
          }
          findMany: {
            args: Prisma.BookingGuestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingGuestPayload>[]
          }
          create: {
            args: Prisma.BookingGuestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingGuestPayload>
          }
          createMany: {
            args: Prisma.BookingGuestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingGuestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingGuestPayload>[]
          }
          delete: {
            args: Prisma.BookingGuestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingGuestPayload>
          }
          update: {
            args: Prisma.BookingGuestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingGuestPayload>
          }
          deleteMany: {
            args: Prisma.BookingGuestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingGuestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingGuestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingGuestPayload>[]
          }
          upsert: {
            args: Prisma.BookingGuestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingGuestPayload>
          }
          aggregate: {
            args: Prisma.BookingGuestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingGuest>
          }
          groupBy: {
            args: Prisma.BookingGuestGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGuestGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingGuestCountArgs<ExtArgs>
            result: $Utils.Optional<BookingGuestCountAggregateOutputType> | number
          }
        }
      }
      PropertyBlockedDate: {
        payload: Prisma.$PropertyBlockedDatePayload<ExtArgs>
        fields: Prisma.PropertyBlockedDateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyBlockedDateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyBlockedDatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyBlockedDateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyBlockedDatePayload>
          }
          findFirst: {
            args: Prisma.PropertyBlockedDateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyBlockedDatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyBlockedDateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyBlockedDatePayload>
          }
          findMany: {
            args: Prisma.PropertyBlockedDateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyBlockedDatePayload>[]
          }
          create: {
            args: Prisma.PropertyBlockedDateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyBlockedDatePayload>
          }
          createMany: {
            args: Prisma.PropertyBlockedDateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyBlockedDateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyBlockedDatePayload>[]
          }
          delete: {
            args: Prisma.PropertyBlockedDateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyBlockedDatePayload>
          }
          update: {
            args: Prisma.PropertyBlockedDateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyBlockedDatePayload>
          }
          deleteMany: {
            args: Prisma.PropertyBlockedDateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyBlockedDateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyBlockedDateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyBlockedDatePayload>[]
          }
          upsert: {
            args: Prisma.PropertyBlockedDateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyBlockedDatePayload>
          }
          aggregate: {
            args: Prisma.PropertyBlockedDateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyBlockedDate>
          }
          groupBy: {
            args: Prisma.PropertyBlockedDateGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyBlockedDateGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyBlockedDateCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyBlockedDateCountAggregateOutputType> | number
          }
        }
      }
      Tm30Accommodation: {
        payload: Prisma.$Tm30AccommodationPayload<ExtArgs>
        fields: Prisma.Tm30AccommodationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Tm30AccommodationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tm30AccommodationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Tm30AccommodationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tm30AccommodationPayload>
          }
          findFirst: {
            args: Prisma.Tm30AccommodationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tm30AccommodationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Tm30AccommodationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tm30AccommodationPayload>
          }
          findMany: {
            args: Prisma.Tm30AccommodationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tm30AccommodationPayload>[]
          }
          create: {
            args: Prisma.Tm30AccommodationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tm30AccommodationPayload>
          }
          createMany: {
            args: Prisma.Tm30AccommodationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Tm30AccommodationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tm30AccommodationPayload>[]
          }
          delete: {
            args: Prisma.Tm30AccommodationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tm30AccommodationPayload>
          }
          update: {
            args: Prisma.Tm30AccommodationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tm30AccommodationPayload>
          }
          deleteMany: {
            args: Prisma.Tm30AccommodationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Tm30AccommodationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Tm30AccommodationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tm30AccommodationPayload>[]
          }
          upsert: {
            args: Prisma.Tm30AccommodationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tm30AccommodationPayload>
          }
          aggregate: {
            args: Prisma.Tm30AccommodationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTm30Accommodation>
          }
          groupBy: {
            args: Prisma.Tm30AccommodationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tm30AccommodationGroupByOutputType>[]
          }
          count: {
            args: Prisma.Tm30AccommodationCountArgs<ExtArgs>
            result: $Utils.Optional<Tm30AccommodationCountAggregateOutputType> | number
          }
        }
      }
      Tm30AccommodationRequest: {
        payload: Prisma.$Tm30AccommodationRequestPayload<ExtArgs>
        fields: Prisma.Tm30AccommodationRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Tm30AccommodationRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tm30AccommodationRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Tm30AccommodationRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tm30AccommodationRequestPayload>
          }
          findFirst: {
            args: Prisma.Tm30AccommodationRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tm30AccommodationRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Tm30AccommodationRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tm30AccommodationRequestPayload>
          }
          findMany: {
            args: Prisma.Tm30AccommodationRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tm30AccommodationRequestPayload>[]
          }
          create: {
            args: Prisma.Tm30AccommodationRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tm30AccommodationRequestPayload>
          }
          createMany: {
            args: Prisma.Tm30AccommodationRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Tm30AccommodationRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tm30AccommodationRequestPayload>[]
          }
          delete: {
            args: Prisma.Tm30AccommodationRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tm30AccommodationRequestPayload>
          }
          update: {
            args: Prisma.Tm30AccommodationRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tm30AccommodationRequestPayload>
          }
          deleteMany: {
            args: Prisma.Tm30AccommodationRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Tm30AccommodationRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Tm30AccommodationRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tm30AccommodationRequestPayload>[]
          }
          upsert: {
            args: Prisma.Tm30AccommodationRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Tm30AccommodationRequestPayload>
          }
          aggregate: {
            args: Prisma.Tm30AccommodationRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTm30AccommodationRequest>
          }
          groupBy: {
            args: Prisma.Tm30AccommodationRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tm30AccommodationRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.Tm30AccommodationRequestCountArgs<ExtArgs>
            result: $Utils.Optional<Tm30AccommodationRequestCountAggregateOutputType> | number
          }
        }
      }
      PropertyOwner: {
        payload: Prisma.$PropertyOwnerPayload<ExtArgs>
        fields: Prisma.PropertyOwnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyOwnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyOwnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyOwnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyOwnerPayload>
          }
          findFirst: {
            args: Prisma.PropertyOwnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyOwnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyOwnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyOwnerPayload>
          }
          findMany: {
            args: Prisma.PropertyOwnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyOwnerPayload>[]
          }
          create: {
            args: Prisma.PropertyOwnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyOwnerPayload>
          }
          createMany: {
            args: Prisma.PropertyOwnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyOwnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyOwnerPayload>[]
          }
          delete: {
            args: Prisma.PropertyOwnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyOwnerPayload>
          }
          update: {
            args: Prisma.PropertyOwnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyOwnerPayload>
          }
          deleteMany: {
            args: Prisma.PropertyOwnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyOwnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyOwnerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyOwnerPayload>[]
          }
          upsert: {
            args: Prisma.PropertyOwnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyOwnerPayload>
          }
          aggregate: {
            args: Prisma.PropertyOwnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyOwner>
          }
          groupBy: {
            args: Prisma.PropertyOwnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyOwnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyOwnerCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyOwnerCountAggregateOutputType> | number
          }
        }
      }
      OwnerDocument: {
        payload: Prisma.$OwnerDocumentPayload<ExtArgs>
        fields: Prisma.OwnerDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OwnerDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OwnerDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDocumentPayload>
          }
          findFirst: {
            args: Prisma.OwnerDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OwnerDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDocumentPayload>
          }
          findMany: {
            args: Prisma.OwnerDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDocumentPayload>[]
          }
          create: {
            args: Prisma.OwnerDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDocumentPayload>
          }
          createMany: {
            args: Prisma.OwnerDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OwnerDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDocumentPayload>[]
          }
          delete: {
            args: Prisma.OwnerDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDocumentPayload>
          }
          update: {
            args: Prisma.OwnerDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDocumentPayload>
          }
          deleteMany: {
            args: Prisma.OwnerDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OwnerDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OwnerDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDocumentPayload>[]
          }
          upsert: {
            args: Prisma.OwnerDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerDocumentPayload>
          }
          aggregate: {
            args: Prisma.OwnerDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOwnerDocument>
          }
          groupBy: {
            args: Prisma.OwnerDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<OwnerDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.OwnerDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<OwnerDocumentCountAggregateOutputType> | number
          }
        }
      }
      WhatsappListingSession: {
        payload: Prisma.$WhatsappListingSessionPayload<ExtArgs>
        fields: Prisma.WhatsappListingSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsappListingSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappListingSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsappListingSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappListingSessionPayload>
          }
          findFirst: {
            args: Prisma.WhatsappListingSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappListingSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsappListingSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappListingSessionPayload>
          }
          findMany: {
            args: Prisma.WhatsappListingSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappListingSessionPayload>[]
          }
          create: {
            args: Prisma.WhatsappListingSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappListingSessionPayload>
          }
          createMany: {
            args: Prisma.WhatsappListingSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsappListingSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappListingSessionPayload>[]
          }
          delete: {
            args: Prisma.WhatsappListingSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappListingSessionPayload>
          }
          update: {
            args: Prisma.WhatsappListingSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappListingSessionPayload>
          }
          deleteMany: {
            args: Prisma.WhatsappListingSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsappListingSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsappListingSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappListingSessionPayload>[]
          }
          upsert: {
            args: Prisma.WhatsappListingSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappListingSessionPayload>
          }
          aggregate: {
            args: Prisma.WhatsappListingSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsappListingSession>
          }
          groupBy: {
            args: Prisma.WhatsappListingSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsappListingSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsappListingSessionCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsappListingSessionCountAggregateOutputType> | number
          }
        }
      }
      AIAgentConfig: {
        payload: Prisma.$AIAgentConfigPayload<ExtArgs>
        fields: Prisma.AIAgentConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIAgentConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIAgentConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentConfigPayload>
          }
          findFirst: {
            args: Prisma.AIAgentConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIAgentConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentConfigPayload>
          }
          findMany: {
            args: Prisma.AIAgentConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentConfigPayload>[]
          }
          create: {
            args: Prisma.AIAgentConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentConfigPayload>
          }
          createMany: {
            args: Prisma.AIAgentConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIAgentConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentConfigPayload>[]
          }
          delete: {
            args: Prisma.AIAgentConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentConfigPayload>
          }
          update: {
            args: Prisma.AIAgentConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentConfigPayload>
          }
          deleteMany: {
            args: Prisma.AIAgentConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIAgentConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIAgentConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentConfigPayload>[]
          }
          upsert: {
            args: Prisma.AIAgentConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentConfigPayload>
          }
          aggregate: {
            args: Prisma.AIAgentConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIAgentConfig>
          }
          groupBy: {
            args: Prisma.AIAgentConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIAgentConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIAgentConfigCountArgs<ExtArgs>
            result: $Utils.Optional<AIAgentConfigCountAggregateOutputType> | number
          }
        }
      }
      AIDecision: {
        payload: Prisma.$AIDecisionPayload<ExtArgs>
        fields: Prisma.AIDecisionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIDecisionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDecisionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIDecisionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDecisionPayload>
          }
          findFirst: {
            args: Prisma.AIDecisionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDecisionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIDecisionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDecisionPayload>
          }
          findMany: {
            args: Prisma.AIDecisionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDecisionPayload>[]
          }
          create: {
            args: Prisma.AIDecisionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDecisionPayload>
          }
          createMany: {
            args: Prisma.AIDecisionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIDecisionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDecisionPayload>[]
          }
          delete: {
            args: Prisma.AIDecisionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDecisionPayload>
          }
          update: {
            args: Prisma.AIDecisionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDecisionPayload>
          }
          deleteMany: {
            args: Prisma.AIDecisionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIDecisionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIDecisionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDecisionPayload>[]
          }
          upsert: {
            args: Prisma.AIDecisionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDecisionPayload>
          }
          aggregate: {
            args: Prisma.AIDecisionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIDecision>
          }
          groupBy: {
            args: Prisma.AIDecisionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIDecisionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIDecisionCountArgs<ExtArgs>
            result: $Utils.Optional<AIDecisionCountAggregateOutputType> | number
          }
        }
      }
      AICodeChange: {
        payload: Prisma.$AICodeChangePayload<ExtArgs>
        fields: Prisma.AICodeChangeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AICodeChangeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICodeChangePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AICodeChangeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICodeChangePayload>
          }
          findFirst: {
            args: Prisma.AICodeChangeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICodeChangePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AICodeChangeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICodeChangePayload>
          }
          findMany: {
            args: Prisma.AICodeChangeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICodeChangePayload>[]
          }
          create: {
            args: Prisma.AICodeChangeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICodeChangePayload>
          }
          createMany: {
            args: Prisma.AICodeChangeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AICodeChangeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICodeChangePayload>[]
          }
          delete: {
            args: Prisma.AICodeChangeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICodeChangePayload>
          }
          update: {
            args: Prisma.AICodeChangeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICodeChangePayload>
          }
          deleteMany: {
            args: Prisma.AICodeChangeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AICodeChangeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AICodeChangeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICodeChangePayload>[]
          }
          upsert: {
            args: Prisma.AICodeChangeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AICodeChangePayload>
          }
          aggregate: {
            args: Prisma.AICodeChangeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAICodeChange>
          }
          groupBy: {
            args: Prisma.AICodeChangeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AICodeChangeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AICodeChangeCountArgs<ExtArgs>
            result: $Utils.Optional<AICodeChangeCountAggregateOutputType> | number
          }
        }
      }
      AIAgentLog: {
        payload: Prisma.$AIAgentLogPayload<ExtArgs>
        fields: Prisma.AIAgentLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIAgentLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIAgentLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentLogPayload>
          }
          findFirst: {
            args: Prisma.AIAgentLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIAgentLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentLogPayload>
          }
          findMany: {
            args: Prisma.AIAgentLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentLogPayload>[]
          }
          create: {
            args: Prisma.AIAgentLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentLogPayload>
          }
          createMany: {
            args: Prisma.AIAgentLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIAgentLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentLogPayload>[]
          }
          delete: {
            args: Prisma.AIAgentLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentLogPayload>
          }
          update: {
            args: Prisma.AIAgentLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentLogPayload>
          }
          deleteMany: {
            args: Prisma.AIAgentLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIAgentLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIAgentLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentLogPayload>[]
          }
          upsert: {
            args: Prisma.AIAgentLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIAgentLogPayload>
          }
          aggregate: {
            args: Prisma.AIAgentLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIAgentLog>
          }
          groupBy: {
            args: Prisma.AIAgentLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIAgentLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIAgentLogCountArgs<ExtArgs>
            result: $Utils.Optional<AIAgentLogCountAggregateOutputType> | number
          }
        }
      }
      AIDataSnapshot: {
        payload: Prisma.$AIDataSnapshotPayload<ExtArgs>
        fields: Prisma.AIDataSnapshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIDataSnapshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDataSnapshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIDataSnapshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDataSnapshotPayload>
          }
          findFirst: {
            args: Prisma.AIDataSnapshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDataSnapshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIDataSnapshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDataSnapshotPayload>
          }
          findMany: {
            args: Prisma.AIDataSnapshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDataSnapshotPayload>[]
          }
          create: {
            args: Prisma.AIDataSnapshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDataSnapshotPayload>
          }
          createMany: {
            args: Prisma.AIDataSnapshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIDataSnapshotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDataSnapshotPayload>[]
          }
          delete: {
            args: Prisma.AIDataSnapshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDataSnapshotPayload>
          }
          update: {
            args: Prisma.AIDataSnapshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDataSnapshotPayload>
          }
          deleteMany: {
            args: Prisma.AIDataSnapshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIDataSnapshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIDataSnapshotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDataSnapshotPayload>[]
          }
          upsert: {
            args: Prisma.AIDataSnapshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIDataSnapshotPayload>
          }
          aggregate: {
            args: Prisma.AIDataSnapshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIDataSnapshot>
          }
          groupBy: {
            args: Prisma.AIDataSnapshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIDataSnapshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIDataSnapshotCountArgs<ExtArgs>
            result: $Utils.Optional<AIDataSnapshotCountAggregateOutputType> | number
          }
        }
      }
      AIOpportunity: {
        payload: Prisma.$AIOpportunityPayload<ExtArgs>
        fields: Prisma.AIOpportunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIOpportunityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOpportunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIOpportunityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOpportunityPayload>
          }
          findFirst: {
            args: Prisma.AIOpportunityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOpportunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIOpportunityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOpportunityPayload>
          }
          findMany: {
            args: Prisma.AIOpportunityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOpportunityPayload>[]
          }
          create: {
            args: Prisma.AIOpportunityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOpportunityPayload>
          }
          createMany: {
            args: Prisma.AIOpportunityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIOpportunityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOpportunityPayload>[]
          }
          delete: {
            args: Prisma.AIOpportunityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOpportunityPayload>
          }
          update: {
            args: Prisma.AIOpportunityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOpportunityPayload>
          }
          deleteMany: {
            args: Prisma.AIOpportunityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIOpportunityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIOpportunityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOpportunityPayload>[]
          }
          upsert: {
            args: Prisma.AIOpportunityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIOpportunityPayload>
          }
          aggregate: {
            args: Prisma.AIOpportunityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIOpportunity>
          }
          groupBy: {
            args: Prisma.AIOpportunityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIOpportunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIOpportunityCountArgs<ExtArgs>
            result: $Utils.Optional<AIOpportunityCountAggregateOutputType> | number
          }
        }
      }
      AILearning: {
        payload: Prisma.$AILearningPayload<ExtArgs>
        fields: Prisma.AILearningFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AILearningFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILearningPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AILearningFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILearningPayload>
          }
          findFirst: {
            args: Prisma.AILearningFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILearningPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AILearningFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILearningPayload>
          }
          findMany: {
            args: Prisma.AILearningFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILearningPayload>[]
          }
          create: {
            args: Prisma.AILearningCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILearningPayload>
          }
          createMany: {
            args: Prisma.AILearningCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AILearningCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILearningPayload>[]
          }
          delete: {
            args: Prisma.AILearningDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILearningPayload>
          }
          update: {
            args: Prisma.AILearningUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILearningPayload>
          }
          deleteMany: {
            args: Prisma.AILearningDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AILearningUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AILearningUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILearningPayload>[]
          }
          upsert: {
            args: Prisma.AILearningUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AILearningPayload>
          }
          aggregate: {
            args: Prisma.AILearningAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAILearning>
          }
          groupBy: {
            args: Prisma.AILearningGroupByArgs<ExtArgs>
            result: $Utils.Optional<AILearningGroupByOutputType>[]
          }
          count: {
            args: Prisma.AILearningCountArgs<ExtArgs>
            result: $Utils.Optional<AILearningCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    account?: AccountOmit
    session?: SessionOmit
    user?: UserOmit
    verification?: VerificationOmit
    agentInvite?: AgentInviteOmit
    property?: PropertyOmit
    propertyImage?: PropertyImageOmit
    propertyView?: PropertyViewOmit
    viewingRequest?: ViewingRequestOmit
    investorLead?: InvestorLeadOmit
    rentalLead?: RentalLeadOmit
    blog?: BlogOmit
    blogCategory?: BlogCategoryOmit
    propertySubmission?: PropertySubmissionOmit
    siteSettings?: SiteSettingsOmit
    internalLink?: InternalLinkOmit
    linkUsage?: LinkUsageOmit
    landingPageSuggestion?: LandingPageSuggestionOmit
    landingPage?: LandingPageOmit
    companyProfile?: CompanyProfileOmit
    blogScheduleSettings?: BlogScheduleSettingsOmit
    topicSuggestion?: TopicSuggestionOmit
    scheduledBlog?: ScheduledBlogOmit
    heroImage?: HeroImageOmit
    propertyAlert?: PropertyAlertOmit
    propertyAlertNotification?: PropertyAlertNotificationOmit
    poi?: PoiOmit
    propertyPoiDistance?: PropertyPoiDistanceOmit
    poiSyncJob?: PoiSyncJobOmit
    rentalPricingConfig?: RentalPricingConfigOmit
    rentalBooking?: RentalBookingOmit
    bookingMessage?: BookingMessageOmit
    bookingGuest?: BookingGuestOmit
    propertyBlockedDate?: PropertyBlockedDateOmit
    tm30Accommodation?: Tm30AccommodationOmit
    tm30AccommodationRequest?: Tm30AccommodationRequestOmit
    propertyOwner?: PropertyOwnerOmit
    ownerDocument?: OwnerDocumentOmit
    whatsappListingSession?: WhatsappListingSessionOmit
    aIAgentConfig?: AIAgentConfigOmit
    aIDecision?: AIDecisionOmit
    aICodeChange?: AICodeChangeOmit
    aIAgentLog?: AIAgentLogOmit
    aIDataSnapshot?: AIDataSnapshotOmit
    aIOpportunity?: AIOpportunityOmit
    aILearning?: AILearningOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    accounts: number
    properties: number
    investorLeads: number
    rentalLeads: number
    blogs: number
    rentalBookings: number
    bookingsAsAgent: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    properties?: boolean | UserCountOutputTypeCountPropertiesArgs
    investorLeads?: boolean | UserCountOutputTypeCountInvestorLeadsArgs
    rentalLeads?: boolean | UserCountOutputTypeCountRentalLeadsArgs
    blogs?: boolean | UserCountOutputTypeCountBlogsArgs
    rentalBookings?: boolean | UserCountOutputTypeCountRentalBookingsArgs
    bookingsAsAgent?: boolean | UserCountOutputTypeCountBookingsAsAgentArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvestorLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorLeadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRentalLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RentalLeadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRentalBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RentalBookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsAsAgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RentalBookingWhereInput
  }


  /**
   * Count Type PropertyCountOutputType
   */

  export type PropertyCountOutputType = {
    images: number
    views: number
    poiDistances: number
    viewingRequests: number
    rentalBookings: number
    blockedDates: number
  }

  export type PropertyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | PropertyCountOutputTypeCountImagesArgs
    views?: boolean | PropertyCountOutputTypeCountViewsArgs
    poiDistances?: boolean | PropertyCountOutputTypeCountPoiDistancesArgs
    viewingRequests?: boolean | PropertyCountOutputTypeCountViewingRequestsArgs
    rentalBookings?: boolean | PropertyCountOutputTypeCountRentalBookingsArgs
    blockedDates?: boolean | PropertyCountOutputTypeCountBlockedDatesArgs
  }

  // Custom InputTypes
  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCountOutputType
     */
    select?: PropertyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyImageWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyViewWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountPoiDistancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyPoiDistanceWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountViewingRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewingRequestWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountRentalBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RentalBookingWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountBlockedDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyBlockedDateWhereInput
  }


  /**
   * Count Type BlogCountOutputType
   */

  export type BlogCountOutputType = {
    linkUsages: number
  }

  export type BlogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    linkUsages?: boolean | BlogCountOutputTypeCountLinkUsagesArgs
  }

  // Custom InputTypes
  /**
   * BlogCountOutputType without action
   */
  export type BlogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCountOutputType
     */
    select?: BlogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogCountOutputType without action
   */
  export type BlogCountOutputTypeCountLinkUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkUsageWhereInput
  }


  /**
   * Count Type BlogCategoryCountOutputType
   */

  export type BlogCategoryCountOutputType = {
    children: number
    blogs: number
  }

  export type BlogCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | BlogCategoryCountOutputTypeCountChildrenArgs
    blogs?: boolean | BlogCategoryCountOutputTypeCountBlogsArgs
  }

  // Custom InputTypes
  /**
   * BlogCategoryCountOutputType without action
   */
  export type BlogCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategoryCountOutputType
     */
    select?: BlogCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogCategoryCountOutputType without action
   */
  export type BlogCategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogCategoryWhereInput
  }

  /**
   * BlogCategoryCountOutputType without action
   */
  export type BlogCategoryCountOutputTypeCountBlogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogWhereInput
  }


  /**
   * Count Type InternalLinkCountOutputType
   */

  export type InternalLinkCountOutputType = {
    usages: number
  }

  export type InternalLinkCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usages?: boolean | InternalLinkCountOutputTypeCountUsagesArgs
  }

  // Custom InputTypes
  /**
   * InternalLinkCountOutputType without action
   */
  export type InternalLinkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalLinkCountOutputType
     */
    select?: InternalLinkCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InternalLinkCountOutputType without action
   */
  export type InternalLinkCountOutputTypeCountUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkUsageWhereInput
  }


  /**
   * Count Type PoiCountOutputType
   */

  export type PoiCountOutputType = {
    propertyDistances: number
  }

  export type PoiCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyDistances?: boolean | PoiCountOutputTypeCountPropertyDistancesArgs
  }

  // Custom InputTypes
  /**
   * PoiCountOutputType without action
   */
  export type PoiCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoiCountOutputType
     */
    select?: PoiCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PoiCountOutputType without action
   */
  export type PoiCountOutputTypeCountPropertyDistancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyPoiDistanceWhereInput
  }


  /**
   * Count Type RentalBookingCountOutputType
   */

  export type RentalBookingCountOutputType = {
    messages: number
    guests: number
  }

  export type RentalBookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | RentalBookingCountOutputTypeCountMessagesArgs
    guests?: boolean | RentalBookingCountOutputTypeCountGuestsArgs
  }

  // Custom InputTypes
  /**
   * RentalBookingCountOutputType without action
   */
  export type RentalBookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalBookingCountOutputType
     */
    select?: RentalBookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RentalBookingCountOutputType without action
   */
  export type RentalBookingCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingMessageWhereInput
  }

  /**
   * RentalBookingCountOutputType without action
   */
  export type RentalBookingCountOutputTypeCountGuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingGuestWhereInput
  }


  /**
   * Count Type PropertyOwnerCountOutputType
   */

  export type PropertyOwnerCountOutputType = {
    documents: number
    properties: number
    tm30Requests: number
  }

  export type PropertyOwnerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | PropertyOwnerCountOutputTypeCountDocumentsArgs
    properties?: boolean | PropertyOwnerCountOutputTypeCountPropertiesArgs
    tm30Requests?: boolean | PropertyOwnerCountOutputTypeCountTm30RequestsArgs
  }

  // Custom InputTypes
  /**
   * PropertyOwnerCountOutputType without action
   */
  export type PropertyOwnerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwnerCountOutputType
     */
    select?: PropertyOwnerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyOwnerCountOutputType without action
   */
  export type PropertyOwnerCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerDocumentWhereInput
  }

  /**
   * PropertyOwnerCountOutputType without action
   */
  export type PropertyOwnerCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }

  /**
   * PropertyOwnerCountOutputType without action
   */
  export type PropertyOwnerCountOutputTypeCountTm30RequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tm30AccommodationRequestWhereInput
  }


  /**
   * Count Type AIDecisionCountOutputType
   */

  export type AIDecisionCountOutputType = {
    codeChanges: number
    logs: number
  }

  export type AIDecisionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    codeChanges?: boolean | AIDecisionCountOutputTypeCountCodeChangesArgs
    logs?: boolean | AIDecisionCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * AIDecisionCountOutputType without action
   */
  export type AIDecisionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecisionCountOutputType
     */
    select?: AIDecisionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AIDecisionCountOutputType without action
   */
  export type AIDecisionCountOutputTypeCountCodeChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AICodeChangeWhereInput
  }

  /**
   * AIDecisionCountOutputType without action
   */
  export type AIDecisionCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIAgentLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountId: number
    providerId: number
    userId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "providerId" | "userId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      providerId: string
      userId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
    impersonatedBy: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
    impersonatedBy: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    expiresAt: number
    token: number
    createdAt: number
    updatedAt: number
    ipAddress: number
    userAgent: number
    userId: number
    impersonatedBy: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    impersonatedBy?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    impersonatedBy?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    impersonatedBy?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    expiresAt: Date
    token: string
    createdAt: Date
    updatedAt: Date
    ipAddress: string | null
    userAgent: string | null
    userId: string
    impersonatedBy: string | null
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    impersonatedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    impersonatedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    impersonatedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    impersonatedBy?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expiresAt" | "token" | "createdAt" | "updatedAt" | "ipAddress" | "userAgent" | "userId" | "impersonatedBy", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expiresAt: Date
      token: string
      createdAt: Date
      updatedAt: Date
      ipAddress: string | null
      userAgent: string | null
      userId: string
      impersonatedBy: string | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly token: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly impersonatedBy: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    role: string | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    role: string | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    createdAt: number
    updatedAt: number
    role: number
    banned: number
    banReason: number
    banExpires: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    role?: true
    banned?: true
    banReason?: true
    banExpires?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    role?: true
    banned?: true
    banReason?: true
    banExpires?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    role?: true
    banned?: true
    banReason?: true
    banExpires?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image: string | null
    createdAt: Date
    updatedAt: Date
    role: string | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    properties?: boolean | User$propertiesArgs<ExtArgs>
    investorLeads?: boolean | User$investorLeadsArgs<ExtArgs>
    rentalLeads?: boolean | User$rentalLeadsArgs<ExtArgs>
    blogs?: boolean | User$blogsArgs<ExtArgs>
    rentalBookings?: boolean | User$rentalBookingsArgs<ExtArgs>
    bookingsAsAgent?: boolean | User$bookingsAsAgentArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "createdAt" | "updatedAt" | "role" | "banned" | "banReason" | "banExpires", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    properties?: boolean | User$propertiesArgs<ExtArgs>
    investorLeads?: boolean | User$investorLeadsArgs<ExtArgs>
    rentalLeads?: boolean | User$rentalLeadsArgs<ExtArgs>
    blogs?: boolean | User$blogsArgs<ExtArgs>
    rentalBookings?: boolean | User$rentalBookingsArgs<ExtArgs>
    bookingsAsAgent?: boolean | User$bookingsAsAgentArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      properties: Prisma.$PropertyPayload<ExtArgs>[]
      investorLeads: Prisma.$InvestorLeadPayload<ExtArgs>[]
      rentalLeads: Prisma.$RentalLeadPayload<ExtArgs>[]
      blogs: Prisma.$BlogPayload<ExtArgs>[]
      rentalBookings: Prisma.$RentalBookingPayload<ExtArgs>[]
      bookingsAsAgent: Prisma.$RentalBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      emailVerified: boolean
      image: string | null
      createdAt: Date
      updatedAt: Date
      role: string | null
      banned: boolean | null
      banReason: string | null
      banExpires: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    properties<T extends User$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, User$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    investorLeads<T extends User$investorLeadsArgs<ExtArgs> = {}>(args?: Subset<T, User$investorLeadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorLeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rentalLeads<T extends User$rentalLeadsArgs<ExtArgs> = {}>(args?: Subset<T, User$rentalLeadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalLeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blogs<T extends User$blogsArgs<ExtArgs> = {}>(args?: Subset<T, User$blogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rentalBookings<T extends User$rentalBookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$rentalBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookingsAsAgent<T extends User$bookingsAsAgentArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsAsAgentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'String'>
    readonly banned: FieldRef<"User", 'Boolean'>
    readonly banReason: FieldRef<"User", 'String'>
    readonly banExpires: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.properties
   */
  export type User$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * User.investorLeads
   */
  export type User$investorLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorLead
     */
    select?: InvestorLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorLead
     */
    omit?: InvestorLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorLeadInclude<ExtArgs> | null
    where?: InvestorLeadWhereInput
    orderBy?: InvestorLeadOrderByWithRelationInput | InvestorLeadOrderByWithRelationInput[]
    cursor?: InvestorLeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvestorLeadScalarFieldEnum | InvestorLeadScalarFieldEnum[]
  }

  /**
   * User.rentalLeads
   */
  export type User$rentalLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalLead
     */
    select?: RentalLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalLead
     */
    omit?: RentalLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalLeadInclude<ExtArgs> | null
    where?: RentalLeadWhereInput
    orderBy?: RentalLeadOrderByWithRelationInput | RentalLeadOrderByWithRelationInput[]
    cursor?: RentalLeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RentalLeadScalarFieldEnum | RentalLeadScalarFieldEnum[]
  }

  /**
   * User.blogs
   */
  export type User$blogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    where?: BlogWhereInput
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    cursor?: BlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * User.rentalBookings
   */
  export type User$rentalBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalBooking
     */
    select?: RentalBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalBooking
     */
    omit?: RentalBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalBookingInclude<ExtArgs> | null
    where?: RentalBookingWhereInput
    orderBy?: RentalBookingOrderByWithRelationInput | RentalBookingOrderByWithRelationInput[]
    cursor?: RentalBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RentalBookingScalarFieldEnum | RentalBookingScalarFieldEnum[]
  }

  /**
   * User.bookingsAsAgent
   */
  export type User$bookingsAsAgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalBooking
     */
    select?: RentalBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalBooking
     */
    omit?: RentalBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalBookingInclude<ExtArgs> | null
    where?: RentalBookingWhereInput
    orderBy?: RentalBookingOrderByWithRelationInput | RentalBookingOrderByWithRelationInput[]
    cursor?: RentalBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RentalBookingScalarFieldEnum | RentalBookingScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date | null
    updatedAt: Date | null
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model AgentInvite
   */

  export type AggregateAgentInvite = {
    _count: AgentInviteCountAggregateOutputType | null
    _avg: AgentInviteAvgAggregateOutputType | null
    _sum: AgentInviteSumAggregateOutputType | null
    _min: AgentInviteMinAggregateOutputType | null
    _max: AgentInviteMaxAggregateOutputType | null
  }

  export type AgentInviteAvgAggregateOutputType = {
    maxUses: number | null
    usedCount: number | null
  }

  export type AgentInviteSumAggregateOutputType = {
    maxUses: number | null
    usedCount: number | null
  }

  export type AgentInviteMinAggregateOutputType = {
    id: string | null
    code: string | null
    email: string | null
    role: string | null
    maxUses: number | null
    usedCount: number | null
    usedBy: string | null
    usedAt: Date | null
    expiresAt: Date | null
    isActive: boolean | null
    createdBy: string | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentInviteMaxAggregateOutputType = {
    id: string | null
    code: string | null
    email: string | null
    role: string | null
    maxUses: number | null
    usedCount: number | null
    usedBy: string | null
    usedAt: Date | null
    expiresAt: Date | null
    isActive: boolean | null
    createdBy: string | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentInviteCountAggregateOutputType = {
    id: number
    code: number
    email: number
    role: number
    maxUses: number
    usedCount: number
    usedBy: number
    usedAt: number
    expiresAt: number
    isActive: number
    createdBy: number
    note: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentInviteAvgAggregateInputType = {
    maxUses?: true
    usedCount?: true
  }

  export type AgentInviteSumAggregateInputType = {
    maxUses?: true
    usedCount?: true
  }

  export type AgentInviteMinAggregateInputType = {
    id?: true
    code?: true
    email?: true
    role?: true
    maxUses?: true
    usedCount?: true
    usedBy?: true
    usedAt?: true
    expiresAt?: true
    isActive?: true
    createdBy?: true
    note?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentInviteMaxAggregateInputType = {
    id?: true
    code?: true
    email?: true
    role?: true
    maxUses?: true
    usedCount?: true
    usedBy?: true
    usedAt?: true
    expiresAt?: true
    isActive?: true
    createdBy?: true
    note?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentInviteCountAggregateInputType = {
    id?: true
    code?: true
    email?: true
    role?: true
    maxUses?: true
    usedCount?: true
    usedBy?: true
    usedAt?: true
    expiresAt?: true
    isActive?: true
    createdBy?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentInviteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentInvite to aggregate.
     */
    where?: AgentInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentInvites to fetch.
     */
    orderBy?: AgentInviteOrderByWithRelationInput | AgentInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentInvites
    **/
    _count?: true | AgentInviteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentInviteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentInviteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentInviteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentInviteMaxAggregateInputType
  }

  export type GetAgentInviteAggregateType<T extends AgentInviteAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentInvite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentInvite[P]>
      : GetScalarType<T[P], AggregateAgentInvite[P]>
  }




  export type AgentInviteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentInviteWhereInput
    orderBy?: AgentInviteOrderByWithAggregationInput | AgentInviteOrderByWithAggregationInput[]
    by: AgentInviteScalarFieldEnum[] | AgentInviteScalarFieldEnum
    having?: AgentInviteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentInviteCountAggregateInputType | true
    _avg?: AgentInviteAvgAggregateInputType
    _sum?: AgentInviteSumAggregateInputType
    _min?: AgentInviteMinAggregateInputType
    _max?: AgentInviteMaxAggregateInputType
  }

  export type AgentInviteGroupByOutputType = {
    id: string
    code: string
    email: string | null
    role: string
    maxUses: number
    usedCount: number
    usedBy: string | null
    usedAt: Date | null
    expiresAt: Date | null
    isActive: boolean
    createdBy: string
    note: string | null
    createdAt: Date
    updatedAt: Date
    _count: AgentInviteCountAggregateOutputType | null
    _avg: AgentInviteAvgAggregateOutputType | null
    _sum: AgentInviteSumAggregateOutputType | null
    _min: AgentInviteMinAggregateOutputType | null
    _max: AgentInviteMaxAggregateOutputType | null
  }

  type GetAgentInviteGroupByPayload<T extends AgentInviteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentInviteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentInviteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentInviteGroupByOutputType[P]>
            : GetScalarType<T[P], AgentInviteGroupByOutputType[P]>
        }
      >
    >


  export type AgentInviteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    email?: boolean
    role?: boolean
    maxUses?: boolean
    usedCount?: boolean
    usedBy?: boolean
    usedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdBy?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agentInvite"]>

  export type AgentInviteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    email?: boolean
    role?: boolean
    maxUses?: boolean
    usedCount?: boolean
    usedBy?: boolean
    usedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdBy?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agentInvite"]>

  export type AgentInviteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    email?: boolean
    role?: boolean
    maxUses?: boolean
    usedCount?: boolean
    usedBy?: boolean
    usedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdBy?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agentInvite"]>

  export type AgentInviteSelectScalar = {
    id?: boolean
    code?: boolean
    email?: boolean
    role?: boolean
    maxUses?: boolean
    usedCount?: boolean
    usedBy?: boolean
    usedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdBy?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentInviteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "email" | "role" | "maxUses" | "usedCount" | "usedBy" | "usedAt" | "expiresAt" | "isActive" | "createdBy" | "note" | "createdAt" | "updatedAt", ExtArgs["result"]["agentInvite"]>

  export type $AgentInvitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentInvite"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      email: string | null
      role: string
      maxUses: number
      usedCount: number
      usedBy: string | null
      usedAt: Date | null
      expiresAt: Date | null
      isActive: boolean
      createdBy: string
      note: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agentInvite"]>
    composites: {}
  }

  type AgentInviteGetPayload<S extends boolean | null | undefined | AgentInviteDefaultArgs> = $Result.GetResult<Prisma.$AgentInvitePayload, S>

  type AgentInviteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentInviteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentInviteCountAggregateInputType | true
    }

  export interface AgentInviteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentInvite'], meta: { name: 'AgentInvite' } }
    /**
     * Find zero or one AgentInvite that matches the filter.
     * @param {AgentInviteFindUniqueArgs} args - Arguments to find a AgentInvite
     * @example
     * // Get one AgentInvite
     * const agentInvite = await prisma.agentInvite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentInviteFindUniqueArgs>(args: SelectSubset<T, AgentInviteFindUniqueArgs<ExtArgs>>): Prisma__AgentInviteClient<$Result.GetResult<Prisma.$AgentInvitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentInvite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentInviteFindUniqueOrThrowArgs} args - Arguments to find a AgentInvite
     * @example
     * // Get one AgentInvite
     * const agentInvite = await prisma.agentInvite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentInviteFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentInviteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentInviteClient<$Result.GetResult<Prisma.$AgentInvitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentInvite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentInviteFindFirstArgs} args - Arguments to find a AgentInvite
     * @example
     * // Get one AgentInvite
     * const agentInvite = await prisma.agentInvite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentInviteFindFirstArgs>(args?: SelectSubset<T, AgentInviteFindFirstArgs<ExtArgs>>): Prisma__AgentInviteClient<$Result.GetResult<Prisma.$AgentInvitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentInvite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentInviteFindFirstOrThrowArgs} args - Arguments to find a AgentInvite
     * @example
     * // Get one AgentInvite
     * const agentInvite = await prisma.agentInvite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentInviteFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentInviteFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentInviteClient<$Result.GetResult<Prisma.$AgentInvitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentInvites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentInviteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentInvites
     * const agentInvites = await prisma.agentInvite.findMany()
     * 
     * // Get first 10 AgentInvites
     * const agentInvites = await prisma.agentInvite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentInviteWithIdOnly = await prisma.agentInvite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentInviteFindManyArgs>(args?: SelectSubset<T, AgentInviteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentInvitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentInvite.
     * @param {AgentInviteCreateArgs} args - Arguments to create a AgentInvite.
     * @example
     * // Create one AgentInvite
     * const AgentInvite = await prisma.agentInvite.create({
     *   data: {
     *     // ... data to create a AgentInvite
     *   }
     * })
     * 
     */
    create<T extends AgentInviteCreateArgs>(args: SelectSubset<T, AgentInviteCreateArgs<ExtArgs>>): Prisma__AgentInviteClient<$Result.GetResult<Prisma.$AgentInvitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentInvites.
     * @param {AgentInviteCreateManyArgs} args - Arguments to create many AgentInvites.
     * @example
     * // Create many AgentInvites
     * const agentInvite = await prisma.agentInvite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentInviteCreateManyArgs>(args?: SelectSubset<T, AgentInviteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentInvites and returns the data saved in the database.
     * @param {AgentInviteCreateManyAndReturnArgs} args - Arguments to create many AgentInvites.
     * @example
     * // Create many AgentInvites
     * const agentInvite = await prisma.agentInvite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentInvites and only return the `id`
     * const agentInviteWithIdOnly = await prisma.agentInvite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentInviteCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentInviteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentInvitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentInvite.
     * @param {AgentInviteDeleteArgs} args - Arguments to delete one AgentInvite.
     * @example
     * // Delete one AgentInvite
     * const AgentInvite = await prisma.agentInvite.delete({
     *   where: {
     *     // ... filter to delete one AgentInvite
     *   }
     * })
     * 
     */
    delete<T extends AgentInviteDeleteArgs>(args: SelectSubset<T, AgentInviteDeleteArgs<ExtArgs>>): Prisma__AgentInviteClient<$Result.GetResult<Prisma.$AgentInvitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentInvite.
     * @param {AgentInviteUpdateArgs} args - Arguments to update one AgentInvite.
     * @example
     * // Update one AgentInvite
     * const agentInvite = await prisma.agentInvite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentInviteUpdateArgs>(args: SelectSubset<T, AgentInviteUpdateArgs<ExtArgs>>): Prisma__AgentInviteClient<$Result.GetResult<Prisma.$AgentInvitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentInvites.
     * @param {AgentInviteDeleteManyArgs} args - Arguments to filter AgentInvites to delete.
     * @example
     * // Delete a few AgentInvites
     * const { count } = await prisma.agentInvite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentInviteDeleteManyArgs>(args?: SelectSubset<T, AgentInviteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentInviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentInvites
     * const agentInvite = await prisma.agentInvite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentInviteUpdateManyArgs>(args: SelectSubset<T, AgentInviteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentInvites and returns the data updated in the database.
     * @param {AgentInviteUpdateManyAndReturnArgs} args - Arguments to update many AgentInvites.
     * @example
     * // Update many AgentInvites
     * const agentInvite = await prisma.agentInvite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentInvites and only return the `id`
     * const agentInviteWithIdOnly = await prisma.agentInvite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentInviteUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentInviteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentInvitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentInvite.
     * @param {AgentInviteUpsertArgs} args - Arguments to update or create a AgentInvite.
     * @example
     * // Update or create a AgentInvite
     * const agentInvite = await prisma.agentInvite.upsert({
     *   create: {
     *     // ... data to create a AgentInvite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentInvite we want to update
     *   }
     * })
     */
    upsert<T extends AgentInviteUpsertArgs>(args: SelectSubset<T, AgentInviteUpsertArgs<ExtArgs>>): Prisma__AgentInviteClient<$Result.GetResult<Prisma.$AgentInvitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentInviteCountArgs} args - Arguments to filter AgentInvites to count.
     * @example
     * // Count the number of AgentInvites
     * const count = await prisma.agentInvite.count({
     *   where: {
     *     // ... the filter for the AgentInvites we want to count
     *   }
     * })
    **/
    count<T extends AgentInviteCountArgs>(
      args?: Subset<T, AgentInviteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentInviteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentInviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentInviteAggregateArgs>(args: Subset<T, AgentInviteAggregateArgs>): Prisma.PrismaPromise<GetAgentInviteAggregateType<T>>

    /**
     * Group by AgentInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentInviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentInviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentInviteGroupByArgs['orderBy'] }
        : { orderBy?: AgentInviteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentInviteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentInviteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentInvite model
   */
  readonly fields: AgentInviteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentInvite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentInviteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentInvite model
   */
  interface AgentInviteFieldRefs {
    readonly id: FieldRef<"AgentInvite", 'String'>
    readonly code: FieldRef<"AgentInvite", 'String'>
    readonly email: FieldRef<"AgentInvite", 'String'>
    readonly role: FieldRef<"AgentInvite", 'String'>
    readonly maxUses: FieldRef<"AgentInvite", 'Int'>
    readonly usedCount: FieldRef<"AgentInvite", 'Int'>
    readonly usedBy: FieldRef<"AgentInvite", 'String'>
    readonly usedAt: FieldRef<"AgentInvite", 'DateTime'>
    readonly expiresAt: FieldRef<"AgentInvite", 'DateTime'>
    readonly isActive: FieldRef<"AgentInvite", 'Boolean'>
    readonly createdBy: FieldRef<"AgentInvite", 'String'>
    readonly note: FieldRef<"AgentInvite", 'String'>
    readonly createdAt: FieldRef<"AgentInvite", 'DateTime'>
    readonly updatedAt: FieldRef<"AgentInvite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentInvite findUnique
   */
  export type AgentInviteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInvite
     */
    select?: AgentInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInvite
     */
    omit?: AgentInviteOmit<ExtArgs> | null
    /**
     * Filter, which AgentInvite to fetch.
     */
    where: AgentInviteWhereUniqueInput
  }

  /**
   * AgentInvite findUniqueOrThrow
   */
  export type AgentInviteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInvite
     */
    select?: AgentInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInvite
     */
    omit?: AgentInviteOmit<ExtArgs> | null
    /**
     * Filter, which AgentInvite to fetch.
     */
    where: AgentInviteWhereUniqueInput
  }

  /**
   * AgentInvite findFirst
   */
  export type AgentInviteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInvite
     */
    select?: AgentInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInvite
     */
    omit?: AgentInviteOmit<ExtArgs> | null
    /**
     * Filter, which AgentInvite to fetch.
     */
    where?: AgentInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentInvites to fetch.
     */
    orderBy?: AgentInviteOrderByWithRelationInput | AgentInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentInvites.
     */
    cursor?: AgentInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentInvites.
     */
    distinct?: AgentInviteScalarFieldEnum | AgentInviteScalarFieldEnum[]
  }

  /**
   * AgentInvite findFirstOrThrow
   */
  export type AgentInviteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInvite
     */
    select?: AgentInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInvite
     */
    omit?: AgentInviteOmit<ExtArgs> | null
    /**
     * Filter, which AgentInvite to fetch.
     */
    where?: AgentInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentInvites to fetch.
     */
    orderBy?: AgentInviteOrderByWithRelationInput | AgentInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentInvites.
     */
    cursor?: AgentInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentInvites.
     */
    distinct?: AgentInviteScalarFieldEnum | AgentInviteScalarFieldEnum[]
  }

  /**
   * AgentInvite findMany
   */
  export type AgentInviteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInvite
     */
    select?: AgentInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInvite
     */
    omit?: AgentInviteOmit<ExtArgs> | null
    /**
     * Filter, which AgentInvites to fetch.
     */
    where?: AgentInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentInvites to fetch.
     */
    orderBy?: AgentInviteOrderByWithRelationInput | AgentInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentInvites.
     */
    cursor?: AgentInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentInvites.
     */
    skip?: number
    distinct?: AgentInviteScalarFieldEnum | AgentInviteScalarFieldEnum[]
  }

  /**
   * AgentInvite create
   */
  export type AgentInviteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInvite
     */
    select?: AgentInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInvite
     */
    omit?: AgentInviteOmit<ExtArgs> | null
    /**
     * The data needed to create a AgentInvite.
     */
    data: XOR<AgentInviteCreateInput, AgentInviteUncheckedCreateInput>
  }

  /**
   * AgentInvite createMany
   */
  export type AgentInviteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentInvites.
     */
    data: AgentInviteCreateManyInput | AgentInviteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentInvite createManyAndReturn
   */
  export type AgentInviteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInvite
     */
    select?: AgentInviteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInvite
     */
    omit?: AgentInviteOmit<ExtArgs> | null
    /**
     * The data used to create many AgentInvites.
     */
    data: AgentInviteCreateManyInput | AgentInviteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentInvite update
   */
  export type AgentInviteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInvite
     */
    select?: AgentInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInvite
     */
    omit?: AgentInviteOmit<ExtArgs> | null
    /**
     * The data needed to update a AgentInvite.
     */
    data: XOR<AgentInviteUpdateInput, AgentInviteUncheckedUpdateInput>
    /**
     * Choose, which AgentInvite to update.
     */
    where: AgentInviteWhereUniqueInput
  }

  /**
   * AgentInvite updateMany
   */
  export type AgentInviteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentInvites.
     */
    data: XOR<AgentInviteUpdateManyMutationInput, AgentInviteUncheckedUpdateManyInput>
    /**
     * Filter which AgentInvites to update
     */
    where?: AgentInviteWhereInput
    /**
     * Limit how many AgentInvites to update.
     */
    limit?: number
  }

  /**
   * AgentInvite updateManyAndReturn
   */
  export type AgentInviteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInvite
     */
    select?: AgentInviteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInvite
     */
    omit?: AgentInviteOmit<ExtArgs> | null
    /**
     * The data used to update AgentInvites.
     */
    data: XOR<AgentInviteUpdateManyMutationInput, AgentInviteUncheckedUpdateManyInput>
    /**
     * Filter which AgentInvites to update
     */
    where?: AgentInviteWhereInput
    /**
     * Limit how many AgentInvites to update.
     */
    limit?: number
  }

  /**
   * AgentInvite upsert
   */
  export type AgentInviteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInvite
     */
    select?: AgentInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInvite
     */
    omit?: AgentInviteOmit<ExtArgs> | null
    /**
     * The filter to search for the AgentInvite to update in case it exists.
     */
    where: AgentInviteWhereUniqueInput
    /**
     * In case the AgentInvite found by the `where` argument doesn't exist, create a new AgentInvite with this data.
     */
    create: XOR<AgentInviteCreateInput, AgentInviteUncheckedCreateInput>
    /**
     * In case the AgentInvite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentInviteUpdateInput, AgentInviteUncheckedUpdateInput>
  }

  /**
   * AgentInvite delete
   */
  export type AgentInviteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInvite
     */
    select?: AgentInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInvite
     */
    omit?: AgentInviteOmit<ExtArgs> | null
    /**
     * Filter which AgentInvite to delete.
     */
    where: AgentInviteWhereUniqueInput
  }

  /**
   * AgentInvite deleteMany
   */
  export type AgentInviteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentInvites to delete
     */
    where?: AgentInviteWhereInput
    /**
     * Limit how many AgentInvites to delete.
     */
    limit?: number
  }

  /**
   * AgentInvite without action
   */
  export type AgentInviteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentInvite
     */
    select?: AgentInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentInvite
     */
    omit?: AgentInviteOmit<ExtArgs> | null
  }


  /**
   * Model Property
   */

  export type AggregateProperty = {
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  export type PropertyAvgAggregateOutputType = {
    beds: number | null
    baths: number | null
    sqft: number | null
    plotSize: number | null
    yearBuilt: number | null
    monthlyRentalPrice: number | null
    maxGuests: number | null
    commissionRate: number | null
    latitude: number | null
    longitude: number | null
    beachScore: number | null
    familyScore: number | null
    convenienceScore: number | null
    quietnessScore: number | null
    seaDistance: number | null
  }

  export type PropertySumAggregateOutputType = {
    beds: number | null
    baths: number | null
    sqft: number | null
    plotSize: number | null
    yearBuilt: number | null
    monthlyRentalPrice: number | null
    maxGuests: number | null
    commissionRate: number | null
    latitude: number | null
    longitude: number | null
    beachScore: number | null
    familyScore: number | null
    convenienceScore: number | null
    quietnessScore: number | null
    seaDistance: number | null
  }

  export type PropertyMinAggregateOutputType = {
    id: string | null
    listingNumber: string | null
    title: string | null
    slug: string | null
    location: string | null
    price: string | null
    beds: number | null
    baths: number | null
    sqft: number | null
    plotSize: number | null
    type: $Enums.PropertyType | null
    category: $Enums.PropertyCategory | null
    tag: string | null
    status: $Enums.Status | null
    isHighlighted: boolean | null
    ownershipType: $Enums.OwnershipType | null
    isResale: boolean | null
    image: string | null
    shortDescription: string | null
    content: string | null
    yearBuilt: number | null
    mapUrl: string | null
    monthlyRentalPrice: number | null
    allowPets: boolean | null
    enableDailyRental: boolean | null
    maxGuests: number | null
    provinceSlug: string | null
    areaSlug: string | null
    ownerName: string | null
    ownerEmail: string | null
    ownerPhone: string | null
    ownerCountryCode: string | null
    ownerCompany: string | null
    ownerNotes: string | null
    propertyOwnerId: string | null
    bluebookUrl: string | null
    bluebookHouseId: string | null
    commissionRate: number | null
    tm30AccommodationId: string | null
    tm30AccommodationName: string | null
    defaultCheckInTime: string | null
    defaultCheckOutTime: string | null
    defaultPropertyAddress: string | null
    defaultWifiName: string | null
    defaultWifiPassword: string | null
    defaultAccessCode: string | null
    defaultEmergencyContact: string | null
    defaultPropertyInstructions: string | null
    defaultHouseRules: string | null
    latitude: number | null
    longitude: number | null
    beachScore: number | null
    familyScore: number | null
    convenienceScore: number | null
    quietnessScore: number | null
    hasSeaView: boolean | null
    seaViewDirection: string | null
    seaDistance: number | null
    district: string | null
    poisLastCalculatedAt: Date | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyMaxAggregateOutputType = {
    id: string | null
    listingNumber: string | null
    title: string | null
    slug: string | null
    location: string | null
    price: string | null
    beds: number | null
    baths: number | null
    sqft: number | null
    plotSize: number | null
    type: $Enums.PropertyType | null
    category: $Enums.PropertyCategory | null
    tag: string | null
    status: $Enums.Status | null
    isHighlighted: boolean | null
    ownershipType: $Enums.OwnershipType | null
    isResale: boolean | null
    image: string | null
    shortDescription: string | null
    content: string | null
    yearBuilt: number | null
    mapUrl: string | null
    monthlyRentalPrice: number | null
    allowPets: boolean | null
    enableDailyRental: boolean | null
    maxGuests: number | null
    provinceSlug: string | null
    areaSlug: string | null
    ownerName: string | null
    ownerEmail: string | null
    ownerPhone: string | null
    ownerCountryCode: string | null
    ownerCompany: string | null
    ownerNotes: string | null
    propertyOwnerId: string | null
    bluebookUrl: string | null
    bluebookHouseId: string | null
    commissionRate: number | null
    tm30AccommodationId: string | null
    tm30AccommodationName: string | null
    defaultCheckInTime: string | null
    defaultCheckOutTime: string | null
    defaultPropertyAddress: string | null
    defaultWifiName: string | null
    defaultWifiPassword: string | null
    defaultAccessCode: string | null
    defaultEmergencyContact: string | null
    defaultPropertyInstructions: string | null
    defaultHouseRules: string | null
    latitude: number | null
    longitude: number | null
    beachScore: number | null
    familyScore: number | null
    convenienceScore: number | null
    quietnessScore: number | null
    hasSeaView: boolean | null
    seaViewDirection: string | null
    seaDistance: number | null
    district: string | null
    poisLastCalculatedAt: Date | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyCountAggregateOutputType = {
    id: number
    listingNumber: number
    title: number
    slug: number
    location: number
    price: number
    beds: number
    baths: number
    sqft: number
    plotSize: number
    type: number
    category: number
    tag: number
    status: number
    isHighlighted: number
    ownershipType: number
    isResale: number
    image: number
    shortDescription: number
    descriptionParagraphs: number
    propertyFeatures: number
    amenities: number
    amenitiesWithIcons: number
    content: number
    yearBuilt: number
    mapUrl: number
    monthlyRentalPrice: number
    allowPets: number
    enableDailyRental: number
    maxGuests: number
    provinceSlug: number
    areaSlug: number
    ownerName: number
    ownerEmail: number
    ownerPhone: number
    ownerCountryCode: number
    ownerCompany: number
    ownerNotes: number
    propertyOwnerId: number
    bluebookUrl: number
    bluebookHouseId: number
    commissionRate: number
    tm30AccommodationId: number
    tm30AccommodationName: number
    defaultCheckInTime: number
    defaultCheckOutTime: number
    defaultPropertyAddress: number
    defaultWifiName: number
    defaultWifiPassword: number
    defaultAccessCode: number
    defaultEmergencyContact: number
    defaultPropertyInstructions: number
    defaultHouseRules: number
    latitude: number
    longitude: number
    beachScore: number
    familyScore: number
    convenienceScore: number
    quietnessScore: number
    hasSeaView: number
    seaViewDirection: number
    seaDistance: number
    district: number
    poisLastCalculatedAt: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyAvgAggregateInputType = {
    beds?: true
    baths?: true
    sqft?: true
    plotSize?: true
    yearBuilt?: true
    monthlyRentalPrice?: true
    maxGuests?: true
    commissionRate?: true
    latitude?: true
    longitude?: true
    beachScore?: true
    familyScore?: true
    convenienceScore?: true
    quietnessScore?: true
    seaDistance?: true
  }

  export type PropertySumAggregateInputType = {
    beds?: true
    baths?: true
    sqft?: true
    plotSize?: true
    yearBuilt?: true
    monthlyRentalPrice?: true
    maxGuests?: true
    commissionRate?: true
    latitude?: true
    longitude?: true
    beachScore?: true
    familyScore?: true
    convenienceScore?: true
    quietnessScore?: true
    seaDistance?: true
  }

  export type PropertyMinAggregateInputType = {
    id?: true
    listingNumber?: true
    title?: true
    slug?: true
    location?: true
    price?: true
    beds?: true
    baths?: true
    sqft?: true
    plotSize?: true
    type?: true
    category?: true
    tag?: true
    status?: true
    isHighlighted?: true
    ownershipType?: true
    isResale?: true
    image?: true
    shortDescription?: true
    content?: true
    yearBuilt?: true
    mapUrl?: true
    monthlyRentalPrice?: true
    allowPets?: true
    enableDailyRental?: true
    maxGuests?: true
    provinceSlug?: true
    areaSlug?: true
    ownerName?: true
    ownerEmail?: true
    ownerPhone?: true
    ownerCountryCode?: true
    ownerCompany?: true
    ownerNotes?: true
    propertyOwnerId?: true
    bluebookUrl?: true
    bluebookHouseId?: true
    commissionRate?: true
    tm30AccommodationId?: true
    tm30AccommodationName?: true
    defaultCheckInTime?: true
    defaultCheckOutTime?: true
    defaultPropertyAddress?: true
    defaultWifiName?: true
    defaultWifiPassword?: true
    defaultAccessCode?: true
    defaultEmergencyContact?: true
    defaultPropertyInstructions?: true
    defaultHouseRules?: true
    latitude?: true
    longitude?: true
    beachScore?: true
    familyScore?: true
    convenienceScore?: true
    quietnessScore?: true
    hasSeaView?: true
    seaViewDirection?: true
    seaDistance?: true
    district?: true
    poisLastCalculatedAt?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyMaxAggregateInputType = {
    id?: true
    listingNumber?: true
    title?: true
    slug?: true
    location?: true
    price?: true
    beds?: true
    baths?: true
    sqft?: true
    plotSize?: true
    type?: true
    category?: true
    tag?: true
    status?: true
    isHighlighted?: true
    ownershipType?: true
    isResale?: true
    image?: true
    shortDescription?: true
    content?: true
    yearBuilt?: true
    mapUrl?: true
    monthlyRentalPrice?: true
    allowPets?: true
    enableDailyRental?: true
    maxGuests?: true
    provinceSlug?: true
    areaSlug?: true
    ownerName?: true
    ownerEmail?: true
    ownerPhone?: true
    ownerCountryCode?: true
    ownerCompany?: true
    ownerNotes?: true
    propertyOwnerId?: true
    bluebookUrl?: true
    bluebookHouseId?: true
    commissionRate?: true
    tm30AccommodationId?: true
    tm30AccommodationName?: true
    defaultCheckInTime?: true
    defaultCheckOutTime?: true
    defaultPropertyAddress?: true
    defaultWifiName?: true
    defaultWifiPassword?: true
    defaultAccessCode?: true
    defaultEmergencyContact?: true
    defaultPropertyInstructions?: true
    defaultHouseRules?: true
    latitude?: true
    longitude?: true
    beachScore?: true
    familyScore?: true
    convenienceScore?: true
    quietnessScore?: true
    hasSeaView?: true
    seaViewDirection?: true
    seaDistance?: true
    district?: true
    poisLastCalculatedAt?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyCountAggregateInputType = {
    id?: true
    listingNumber?: true
    title?: true
    slug?: true
    location?: true
    price?: true
    beds?: true
    baths?: true
    sqft?: true
    plotSize?: true
    type?: true
    category?: true
    tag?: true
    status?: true
    isHighlighted?: true
    ownershipType?: true
    isResale?: true
    image?: true
    shortDescription?: true
    descriptionParagraphs?: true
    propertyFeatures?: true
    amenities?: true
    amenitiesWithIcons?: true
    content?: true
    yearBuilt?: true
    mapUrl?: true
    monthlyRentalPrice?: true
    allowPets?: true
    enableDailyRental?: true
    maxGuests?: true
    provinceSlug?: true
    areaSlug?: true
    ownerName?: true
    ownerEmail?: true
    ownerPhone?: true
    ownerCountryCode?: true
    ownerCompany?: true
    ownerNotes?: true
    propertyOwnerId?: true
    bluebookUrl?: true
    bluebookHouseId?: true
    commissionRate?: true
    tm30AccommodationId?: true
    tm30AccommodationName?: true
    defaultCheckInTime?: true
    defaultCheckOutTime?: true
    defaultPropertyAddress?: true
    defaultWifiName?: true
    defaultWifiPassword?: true
    defaultAccessCode?: true
    defaultEmergencyContact?: true
    defaultPropertyInstructions?: true
    defaultHouseRules?: true
    latitude?: true
    longitude?: true
    beachScore?: true
    familyScore?: true
    convenienceScore?: true
    quietnessScore?: true
    hasSeaView?: true
    seaViewDirection?: true
    seaDistance?: true
    district?: true
    poisLastCalculatedAt?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Property to aggregate.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Properties
    **/
    _count?: true | PropertyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyMaxAggregateInputType
  }

  export type GetPropertyAggregateType<T extends PropertyAggregateArgs> = {
        [P in keyof T & keyof AggregateProperty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperty[P]>
      : GetScalarType<T[P], AggregateProperty[P]>
  }




  export type PropertyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithAggregationInput | PropertyOrderByWithAggregationInput[]
    by: PropertyScalarFieldEnum[] | PropertyScalarFieldEnum
    having?: PropertyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyCountAggregateInputType | true
    _avg?: PropertyAvgAggregateInputType
    _sum?: PropertySumAggregateInputType
    _min?: PropertyMinAggregateInputType
    _max?: PropertyMaxAggregateInputType
  }

  export type PropertyGroupByOutputType = {
    id: string
    listingNumber: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize: number | null
    type: $Enums.PropertyType
    category: $Enums.PropertyCategory
    tag: string | null
    status: $Enums.Status
    isHighlighted: boolean
    ownershipType: $Enums.OwnershipType | null
    isResale: boolean | null
    image: string
    shortDescription: string | null
    descriptionParagraphs: JsonValue | null
    propertyFeatures: JsonValue | null
    amenities: string[]
    amenitiesWithIcons: JsonValue | null
    content: string
    yearBuilt: number | null
    mapUrl: string | null
    monthlyRentalPrice: number | null
    allowPets: boolean
    enableDailyRental: boolean
    maxGuests: number | null
    provinceSlug: string | null
    areaSlug: string | null
    ownerName: string | null
    ownerEmail: string | null
    ownerPhone: string | null
    ownerCountryCode: string | null
    ownerCompany: string | null
    ownerNotes: string | null
    propertyOwnerId: string | null
    bluebookUrl: string | null
    bluebookHouseId: string | null
    commissionRate: number | null
    tm30AccommodationId: string | null
    tm30AccommodationName: string | null
    defaultCheckInTime: string | null
    defaultCheckOutTime: string | null
    defaultPropertyAddress: string | null
    defaultWifiName: string | null
    defaultWifiPassword: string | null
    defaultAccessCode: string | null
    defaultEmergencyContact: string | null
    defaultPropertyInstructions: string | null
    defaultHouseRules: string | null
    latitude: number | null
    longitude: number | null
    beachScore: number | null
    familyScore: number | null
    convenienceScore: number | null
    quietnessScore: number | null
    hasSeaView: boolean
    seaViewDirection: string | null
    seaDistance: number | null
    district: string | null
    poisLastCalculatedAt: Date | null
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  type GetPropertyGroupByPayload<T extends PropertyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyGroupByOutputType[P]>
        }
      >
    >


  export type PropertySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingNumber?: boolean
    title?: boolean
    slug?: boolean
    location?: boolean
    price?: boolean
    beds?: boolean
    baths?: boolean
    sqft?: boolean
    plotSize?: boolean
    type?: boolean
    category?: boolean
    tag?: boolean
    status?: boolean
    isHighlighted?: boolean
    ownershipType?: boolean
    isResale?: boolean
    image?: boolean
    shortDescription?: boolean
    descriptionParagraphs?: boolean
    propertyFeatures?: boolean
    amenities?: boolean
    amenitiesWithIcons?: boolean
    content?: boolean
    yearBuilt?: boolean
    mapUrl?: boolean
    monthlyRentalPrice?: boolean
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: boolean
    provinceSlug?: boolean
    areaSlug?: boolean
    ownerName?: boolean
    ownerEmail?: boolean
    ownerPhone?: boolean
    ownerCountryCode?: boolean
    ownerCompany?: boolean
    ownerNotes?: boolean
    propertyOwnerId?: boolean
    bluebookUrl?: boolean
    bluebookHouseId?: boolean
    commissionRate?: boolean
    tm30AccommodationId?: boolean
    tm30AccommodationName?: boolean
    defaultCheckInTime?: boolean
    defaultCheckOutTime?: boolean
    defaultPropertyAddress?: boolean
    defaultWifiName?: boolean
    defaultWifiPassword?: boolean
    defaultAccessCode?: boolean
    defaultEmergencyContact?: boolean
    defaultPropertyInstructions?: boolean
    defaultHouseRules?: boolean
    latitude?: boolean
    longitude?: boolean
    beachScore?: boolean
    familyScore?: boolean
    convenienceScore?: boolean
    quietnessScore?: boolean
    hasSeaView?: boolean
    seaViewDirection?: boolean
    seaDistance?: boolean
    district?: boolean
    poisLastCalculatedAt?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    images?: boolean | Property$imagesArgs<ExtArgs>
    views?: boolean | Property$viewsArgs<ExtArgs>
    propertyOwner?: boolean | Property$propertyOwnerArgs<ExtArgs>
    poiDistances?: boolean | Property$poiDistancesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    viewingRequests?: boolean | Property$viewingRequestsArgs<ExtArgs>
    rentalBookings?: boolean | Property$rentalBookingsArgs<ExtArgs>
    blockedDates?: boolean | Property$blockedDatesArgs<ExtArgs>
    tm30Accommodation?: boolean | Property$tm30AccommodationArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingNumber?: boolean
    title?: boolean
    slug?: boolean
    location?: boolean
    price?: boolean
    beds?: boolean
    baths?: boolean
    sqft?: boolean
    plotSize?: boolean
    type?: boolean
    category?: boolean
    tag?: boolean
    status?: boolean
    isHighlighted?: boolean
    ownershipType?: boolean
    isResale?: boolean
    image?: boolean
    shortDescription?: boolean
    descriptionParagraphs?: boolean
    propertyFeatures?: boolean
    amenities?: boolean
    amenitiesWithIcons?: boolean
    content?: boolean
    yearBuilt?: boolean
    mapUrl?: boolean
    monthlyRentalPrice?: boolean
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: boolean
    provinceSlug?: boolean
    areaSlug?: boolean
    ownerName?: boolean
    ownerEmail?: boolean
    ownerPhone?: boolean
    ownerCountryCode?: boolean
    ownerCompany?: boolean
    ownerNotes?: boolean
    propertyOwnerId?: boolean
    bluebookUrl?: boolean
    bluebookHouseId?: boolean
    commissionRate?: boolean
    tm30AccommodationId?: boolean
    tm30AccommodationName?: boolean
    defaultCheckInTime?: boolean
    defaultCheckOutTime?: boolean
    defaultPropertyAddress?: boolean
    defaultWifiName?: boolean
    defaultWifiPassword?: boolean
    defaultAccessCode?: boolean
    defaultEmergencyContact?: boolean
    defaultPropertyInstructions?: boolean
    defaultHouseRules?: boolean
    latitude?: boolean
    longitude?: boolean
    beachScore?: boolean
    familyScore?: boolean
    convenienceScore?: boolean
    quietnessScore?: boolean
    hasSeaView?: boolean
    seaViewDirection?: boolean
    seaDistance?: boolean
    district?: boolean
    poisLastCalculatedAt?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    propertyOwner?: boolean | Property$propertyOwnerArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingNumber?: boolean
    title?: boolean
    slug?: boolean
    location?: boolean
    price?: boolean
    beds?: boolean
    baths?: boolean
    sqft?: boolean
    plotSize?: boolean
    type?: boolean
    category?: boolean
    tag?: boolean
    status?: boolean
    isHighlighted?: boolean
    ownershipType?: boolean
    isResale?: boolean
    image?: boolean
    shortDescription?: boolean
    descriptionParagraphs?: boolean
    propertyFeatures?: boolean
    amenities?: boolean
    amenitiesWithIcons?: boolean
    content?: boolean
    yearBuilt?: boolean
    mapUrl?: boolean
    monthlyRentalPrice?: boolean
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: boolean
    provinceSlug?: boolean
    areaSlug?: boolean
    ownerName?: boolean
    ownerEmail?: boolean
    ownerPhone?: boolean
    ownerCountryCode?: boolean
    ownerCompany?: boolean
    ownerNotes?: boolean
    propertyOwnerId?: boolean
    bluebookUrl?: boolean
    bluebookHouseId?: boolean
    commissionRate?: boolean
    tm30AccommodationId?: boolean
    tm30AccommodationName?: boolean
    defaultCheckInTime?: boolean
    defaultCheckOutTime?: boolean
    defaultPropertyAddress?: boolean
    defaultWifiName?: boolean
    defaultWifiPassword?: boolean
    defaultAccessCode?: boolean
    defaultEmergencyContact?: boolean
    defaultPropertyInstructions?: boolean
    defaultHouseRules?: boolean
    latitude?: boolean
    longitude?: boolean
    beachScore?: boolean
    familyScore?: boolean
    convenienceScore?: boolean
    quietnessScore?: boolean
    hasSeaView?: boolean
    seaViewDirection?: boolean
    seaDistance?: boolean
    district?: boolean
    poisLastCalculatedAt?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    propertyOwner?: boolean | Property$propertyOwnerArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectScalar = {
    id?: boolean
    listingNumber?: boolean
    title?: boolean
    slug?: boolean
    location?: boolean
    price?: boolean
    beds?: boolean
    baths?: boolean
    sqft?: boolean
    plotSize?: boolean
    type?: boolean
    category?: boolean
    tag?: boolean
    status?: boolean
    isHighlighted?: boolean
    ownershipType?: boolean
    isResale?: boolean
    image?: boolean
    shortDescription?: boolean
    descriptionParagraphs?: boolean
    propertyFeatures?: boolean
    amenities?: boolean
    amenitiesWithIcons?: boolean
    content?: boolean
    yearBuilt?: boolean
    mapUrl?: boolean
    monthlyRentalPrice?: boolean
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: boolean
    provinceSlug?: boolean
    areaSlug?: boolean
    ownerName?: boolean
    ownerEmail?: boolean
    ownerPhone?: boolean
    ownerCountryCode?: boolean
    ownerCompany?: boolean
    ownerNotes?: boolean
    propertyOwnerId?: boolean
    bluebookUrl?: boolean
    bluebookHouseId?: boolean
    commissionRate?: boolean
    tm30AccommodationId?: boolean
    tm30AccommodationName?: boolean
    defaultCheckInTime?: boolean
    defaultCheckOutTime?: boolean
    defaultPropertyAddress?: boolean
    defaultWifiName?: boolean
    defaultWifiPassword?: boolean
    defaultAccessCode?: boolean
    defaultEmergencyContact?: boolean
    defaultPropertyInstructions?: boolean
    defaultHouseRules?: boolean
    latitude?: boolean
    longitude?: boolean
    beachScore?: boolean
    familyScore?: boolean
    convenienceScore?: boolean
    quietnessScore?: boolean
    hasSeaView?: boolean
    seaViewDirection?: boolean
    seaDistance?: boolean
    district?: boolean
    poisLastCalculatedAt?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "listingNumber" | "title" | "slug" | "location" | "price" | "beds" | "baths" | "sqft" | "plotSize" | "type" | "category" | "tag" | "status" | "isHighlighted" | "ownershipType" | "isResale" | "image" | "shortDescription" | "descriptionParagraphs" | "propertyFeatures" | "amenities" | "amenitiesWithIcons" | "content" | "yearBuilt" | "mapUrl" | "monthlyRentalPrice" | "allowPets" | "enableDailyRental" | "maxGuests" | "provinceSlug" | "areaSlug" | "ownerName" | "ownerEmail" | "ownerPhone" | "ownerCountryCode" | "ownerCompany" | "ownerNotes" | "propertyOwnerId" | "bluebookUrl" | "bluebookHouseId" | "commissionRate" | "tm30AccommodationId" | "tm30AccommodationName" | "defaultCheckInTime" | "defaultCheckOutTime" | "defaultPropertyAddress" | "defaultWifiName" | "defaultWifiPassword" | "defaultAccessCode" | "defaultEmergencyContact" | "defaultPropertyInstructions" | "defaultHouseRules" | "latitude" | "longitude" | "beachScore" | "familyScore" | "convenienceScore" | "quietnessScore" | "hasSeaView" | "seaViewDirection" | "seaDistance" | "district" | "poisLastCalculatedAt" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["property"]>
  export type PropertyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | Property$imagesArgs<ExtArgs>
    views?: boolean | Property$viewsArgs<ExtArgs>
    propertyOwner?: boolean | Property$propertyOwnerArgs<ExtArgs>
    poiDistances?: boolean | Property$poiDistancesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    viewingRequests?: boolean | Property$viewingRequestsArgs<ExtArgs>
    rentalBookings?: boolean | Property$rentalBookingsArgs<ExtArgs>
    blockedDates?: boolean | Property$blockedDatesArgs<ExtArgs>
    tm30Accommodation?: boolean | Property$tm30AccommodationArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyOwner?: boolean | Property$propertyOwnerArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyOwner?: boolean | Property$propertyOwnerArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PropertyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Property"
    objects: {
      images: Prisma.$PropertyImagePayload<ExtArgs>[]
      views: Prisma.$PropertyViewPayload<ExtArgs>[]
      propertyOwner: Prisma.$PropertyOwnerPayload<ExtArgs> | null
      poiDistances: Prisma.$PropertyPoiDistancePayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      viewingRequests: Prisma.$ViewingRequestPayload<ExtArgs>[]
      rentalBookings: Prisma.$RentalBookingPayload<ExtArgs>[]
      blockedDates: Prisma.$PropertyBlockedDatePayload<ExtArgs>[]
      tm30Accommodation: Prisma.$Tm30AccommodationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      listingNumber: string | null
      title: string
      slug: string
      location: string
      price: string
      beds: number
      baths: number
      sqft: number
      plotSize: number | null
      type: $Enums.PropertyType
      category: $Enums.PropertyCategory
      tag: string | null
      status: $Enums.Status
      isHighlighted: boolean
      ownershipType: $Enums.OwnershipType | null
      isResale: boolean | null
      image: string
      shortDescription: string | null
      descriptionParagraphs: Prisma.JsonValue | null
      propertyFeatures: Prisma.JsonValue | null
      amenities: string[]
      amenitiesWithIcons: Prisma.JsonValue | null
      content: string
      yearBuilt: number | null
      mapUrl: string | null
      monthlyRentalPrice: number | null
      allowPets: boolean
      enableDailyRental: boolean
      maxGuests: number | null
      provinceSlug: string | null
      areaSlug: string | null
      ownerName: string | null
      ownerEmail: string | null
      ownerPhone: string | null
      ownerCountryCode: string | null
      ownerCompany: string | null
      ownerNotes: string | null
      propertyOwnerId: string | null
      bluebookUrl: string | null
      bluebookHouseId: string | null
      commissionRate: number | null
      tm30AccommodationId: string | null
      tm30AccommodationName: string | null
      defaultCheckInTime: string | null
      defaultCheckOutTime: string | null
      defaultPropertyAddress: string | null
      defaultWifiName: string | null
      defaultWifiPassword: string | null
      defaultAccessCode: string | null
      defaultEmergencyContact: string | null
      defaultPropertyInstructions: string | null
      defaultHouseRules: string | null
      latitude: number | null
      longitude: number | null
      beachScore: number | null
      familyScore: number | null
      convenienceScore: number | null
      quietnessScore: number | null
      hasSeaView: boolean
      seaViewDirection: string | null
      seaDistance: number | null
      district: string | null
      poisLastCalculatedAt: Date | null
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["property"]>
    composites: {}
  }

  type PropertyGetPayload<S extends boolean | null | undefined | PropertyDefaultArgs> = $Result.GetResult<Prisma.$PropertyPayload, S>

  type PropertyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyCountAggregateInputType | true
    }

  export interface PropertyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Property'], meta: { name: 'Property' } }
    /**
     * Find zero or one Property that matches the filter.
     * @param {PropertyFindUniqueArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyFindUniqueArgs>(args: SelectSubset<T, PropertyFindUniqueArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Property that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyFindUniqueOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyFindFirstArgs>(args?: SelectSubset<T, PropertyFindFirstArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Properties
     * const properties = await prisma.property.findMany()
     * 
     * // Get first 10 Properties
     * const properties = await prisma.property.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyWithIdOnly = await prisma.property.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyFindManyArgs>(args?: SelectSubset<T, PropertyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Property.
     * @param {PropertyCreateArgs} args - Arguments to create a Property.
     * @example
     * // Create one Property
     * const Property = await prisma.property.create({
     *   data: {
     *     // ... data to create a Property
     *   }
     * })
     * 
     */
    create<T extends PropertyCreateArgs>(args: SelectSubset<T, PropertyCreateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Properties.
     * @param {PropertyCreateManyArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyCreateManyArgs>(args?: SelectSubset<T, PropertyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Properties and returns the data saved in the database.
     * @param {PropertyCreateManyAndReturnArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Property.
     * @param {PropertyDeleteArgs} args - Arguments to delete one Property.
     * @example
     * // Delete one Property
     * const Property = await prisma.property.delete({
     *   where: {
     *     // ... filter to delete one Property
     *   }
     * })
     * 
     */
    delete<T extends PropertyDeleteArgs>(args: SelectSubset<T, PropertyDeleteArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Property.
     * @param {PropertyUpdateArgs} args - Arguments to update one Property.
     * @example
     * // Update one Property
     * const property = await prisma.property.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyUpdateArgs>(args: SelectSubset<T, PropertyUpdateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Properties.
     * @param {PropertyDeleteManyArgs} args - Arguments to filter Properties to delete.
     * @example
     * // Delete a few Properties
     * const { count } = await prisma.property.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyDeleteManyArgs>(args?: SelectSubset<T, PropertyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyUpdateManyArgs>(args: SelectSubset<T, PropertyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties and returns the data updated in the database.
     * @param {PropertyUpdateManyAndReturnArgs} args - Arguments to update many Properties.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Property.
     * @param {PropertyUpsertArgs} args - Arguments to update or create a Property.
     * @example
     * // Update or create a Property
     * const property = await prisma.property.upsert({
     *   create: {
     *     // ... data to create a Property
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Property we want to update
     *   }
     * })
     */
    upsert<T extends PropertyUpsertArgs>(args: SelectSubset<T, PropertyUpsertArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCountArgs} args - Arguments to filter Properties to count.
     * @example
     * // Count the number of Properties
     * const count = await prisma.property.count({
     *   where: {
     *     // ... the filter for the Properties we want to count
     *   }
     * })
    **/
    count<T extends PropertyCountArgs>(
      args?: Subset<T, PropertyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAggregateArgs>(args: Subset<T, PropertyAggregateArgs>): Prisma.PrismaPromise<GetPropertyAggregateType<T>>

    /**
     * Group by Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Property model
   */
  readonly fields: PropertyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Property.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    images<T extends Property$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Property$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    views<T extends Property$viewsArgs<ExtArgs> = {}>(args?: Subset<T, Property$viewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    propertyOwner<T extends Property$propertyOwnerArgs<ExtArgs> = {}>(args?: Subset<T, Property$propertyOwnerArgs<ExtArgs>>): Prisma__PropertyOwnerClient<$Result.GetResult<Prisma.$PropertyOwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    poiDistances<T extends Property$poiDistancesArgs<ExtArgs> = {}>(args?: Subset<T, Property$poiDistancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPoiDistancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    viewingRequests<T extends Property$viewingRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Property$viewingRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewingRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rentalBookings<T extends Property$rentalBookingsArgs<ExtArgs> = {}>(args?: Subset<T, Property$rentalBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blockedDates<T extends Property$blockedDatesArgs<ExtArgs> = {}>(args?: Subset<T, Property$blockedDatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyBlockedDatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tm30Accommodation<T extends Property$tm30AccommodationArgs<ExtArgs> = {}>(args?: Subset<T, Property$tm30AccommodationArgs<ExtArgs>>): Prisma__Tm30AccommodationClient<$Result.GetResult<Prisma.$Tm30AccommodationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Property model
   */
  interface PropertyFieldRefs {
    readonly id: FieldRef<"Property", 'String'>
    readonly listingNumber: FieldRef<"Property", 'String'>
    readonly title: FieldRef<"Property", 'String'>
    readonly slug: FieldRef<"Property", 'String'>
    readonly location: FieldRef<"Property", 'String'>
    readonly price: FieldRef<"Property", 'String'>
    readonly beds: FieldRef<"Property", 'Int'>
    readonly baths: FieldRef<"Property", 'Float'>
    readonly sqft: FieldRef<"Property", 'Int'>
    readonly plotSize: FieldRef<"Property", 'Int'>
    readonly type: FieldRef<"Property", 'PropertyType'>
    readonly category: FieldRef<"Property", 'PropertyCategory'>
    readonly tag: FieldRef<"Property", 'String'>
    readonly status: FieldRef<"Property", 'Status'>
    readonly isHighlighted: FieldRef<"Property", 'Boolean'>
    readonly ownershipType: FieldRef<"Property", 'OwnershipType'>
    readonly isResale: FieldRef<"Property", 'Boolean'>
    readonly image: FieldRef<"Property", 'String'>
    readonly shortDescription: FieldRef<"Property", 'String'>
    readonly descriptionParagraphs: FieldRef<"Property", 'Json'>
    readonly propertyFeatures: FieldRef<"Property", 'Json'>
    readonly amenities: FieldRef<"Property", 'String[]'>
    readonly amenitiesWithIcons: FieldRef<"Property", 'Json'>
    readonly content: FieldRef<"Property", 'String'>
    readonly yearBuilt: FieldRef<"Property", 'Int'>
    readonly mapUrl: FieldRef<"Property", 'String'>
    readonly monthlyRentalPrice: FieldRef<"Property", 'Float'>
    readonly allowPets: FieldRef<"Property", 'Boolean'>
    readonly enableDailyRental: FieldRef<"Property", 'Boolean'>
    readonly maxGuests: FieldRef<"Property", 'Int'>
    readonly provinceSlug: FieldRef<"Property", 'String'>
    readonly areaSlug: FieldRef<"Property", 'String'>
    readonly ownerName: FieldRef<"Property", 'String'>
    readonly ownerEmail: FieldRef<"Property", 'String'>
    readonly ownerPhone: FieldRef<"Property", 'String'>
    readonly ownerCountryCode: FieldRef<"Property", 'String'>
    readonly ownerCompany: FieldRef<"Property", 'String'>
    readonly ownerNotes: FieldRef<"Property", 'String'>
    readonly propertyOwnerId: FieldRef<"Property", 'String'>
    readonly bluebookUrl: FieldRef<"Property", 'String'>
    readonly bluebookHouseId: FieldRef<"Property", 'String'>
    readonly commissionRate: FieldRef<"Property", 'Float'>
    readonly tm30AccommodationId: FieldRef<"Property", 'String'>
    readonly tm30AccommodationName: FieldRef<"Property", 'String'>
    readonly defaultCheckInTime: FieldRef<"Property", 'String'>
    readonly defaultCheckOutTime: FieldRef<"Property", 'String'>
    readonly defaultPropertyAddress: FieldRef<"Property", 'String'>
    readonly defaultWifiName: FieldRef<"Property", 'String'>
    readonly defaultWifiPassword: FieldRef<"Property", 'String'>
    readonly defaultAccessCode: FieldRef<"Property", 'String'>
    readonly defaultEmergencyContact: FieldRef<"Property", 'String'>
    readonly defaultPropertyInstructions: FieldRef<"Property", 'String'>
    readonly defaultHouseRules: FieldRef<"Property", 'String'>
    readonly latitude: FieldRef<"Property", 'Float'>
    readonly longitude: FieldRef<"Property", 'Float'>
    readonly beachScore: FieldRef<"Property", 'Int'>
    readonly familyScore: FieldRef<"Property", 'Int'>
    readonly convenienceScore: FieldRef<"Property", 'Int'>
    readonly quietnessScore: FieldRef<"Property", 'Int'>
    readonly hasSeaView: FieldRef<"Property", 'Boolean'>
    readonly seaViewDirection: FieldRef<"Property", 'String'>
    readonly seaDistance: FieldRef<"Property", 'Int'>
    readonly district: FieldRef<"Property", 'String'>
    readonly poisLastCalculatedAt: FieldRef<"Property", 'DateTime'>
    readonly userId: FieldRef<"Property", 'String'>
    readonly createdAt: FieldRef<"Property", 'DateTime'>
    readonly updatedAt: FieldRef<"Property", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Property findUnique
   */
  export type PropertyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findUniqueOrThrow
   */
  export type PropertyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findFirst
   */
  export type PropertyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findFirstOrThrow
   */
  export type PropertyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findMany
   */
  export type PropertyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Properties to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property create
   */
  export type PropertyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to create a Property.
     */
    data: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
  }

  /**
   * Property createMany
   */
  export type PropertyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Property createManyAndReturn
   */
  export type PropertyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property update
   */
  export type PropertyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to update a Property.
     */
    data: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
    /**
     * Choose, which Property to update.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property updateMany
   */
  export type PropertyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
  }

  /**
   * Property updateManyAndReturn
   */
  export type PropertyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property upsert
   */
  export type PropertyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The filter to search for the Property to update in case it exists.
     */
    where: PropertyWhereUniqueInput
    /**
     * In case the Property found by the `where` argument doesn't exist, create a new Property with this data.
     */
    create: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
    /**
     * In case the Property was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
  }

  /**
   * Property delete
   */
  export type PropertyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter which Property to delete.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property deleteMany
   */
  export type PropertyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Properties to delete
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to delete.
     */
    limit?: number
  }

  /**
   * Property.images
   */
  export type Property$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
    where?: PropertyImageWhereInput
    orderBy?: PropertyImageOrderByWithRelationInput | PropertyImageOrderByWithRelationInput[]
    cursor?: PropertyImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyImageScalarFieldEnum | PropertyImageScalarFieldEnum[]
  }

  /**
   * Property.views
   */
  export type Property$viewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    where?: PropertyViewWhereInput
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    cursor?: PropertyViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyViewScalarFieldEnum | PropertyViewScalarFieldEnum[]
  }

  /**
   * Property.propertyOwner
   */
  export type Property$propertyOwnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwner
     */
    select?: PropertyOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwner
     */
    omit?: PropertyOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerInclude<ExtArgs> | null
    where?: PropertyOwnerWhereInput
  }

  /**
   * Property.poiDistances
   */
  export type Property$poiDistancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPoiDistance
     */
    select?: PropertyPoiDistanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPoiDistance
     */
    omit?: PropertyPoiDistanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPoiDistanceInclude<ExtArgs> | null
    where?: PropertyPoiDistanceWhereInput
    orderBy?: PropertyPoiDistanceOrderByWithRelationInput | PropertyPoiDistanceOrderByWithRelationInput[]
    cursor?: PropertyPoiDistanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyPoiDistanceScalarFieldEnum | PropertyPoiDistanceScalarFieldEnum[]
  }

  /**
   * Property.viewingRequests
   */
  export type Property$viewingRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRequest
     */
    select?: ViewingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRequest
     */
    omit?: ViewingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRequestInclude<ExtArgs> | null
    where?: ViewingRequestWhereInput
    orderBy?: ViewingRequestOrderByWithRelationInput | ViewingRequestOrderByWithRelationInput[]
    cursor?: ViewingRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViewingRequestScalarFieldEnum | ViewingRequestScalarFieldEnum[]
  }

  /**
   * Property.rentalBookings
   */
  export type Property$rentalBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalBooking
     */
    select?: RentalBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalBooking
     */
    omit?: RentalBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalBookingInclude<ExtArgs> | null
    where?: RentalBookingWhereInput
    orderBy?: RentalBookingOrderByWithRelationInput | RentalBookingOrderByWithRelationInput[]
    cursor?: RentalBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RentalBookingScalarFieldEnum | RentalBookingScalarFieldEnum[]
  }

  /**
   * Property.blockedDates
   */
  export type Property$blockedDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyBlockedDate
     */
    select?: PropertyBlockedDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyBlockedDate
     */
    omit?: PropertyBlockedDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyBlockedDateInclude<ExtArgs> | null
    where?: PropertyBlockedDateWhereInput
    orderBy?: PropertyBlockedDateOrderByWithRelationInput | PropertyBlockedDateOrderByWithRelationInput[]
    cursor?: PropertyBlockedDateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyBlockedDateScalarFieldEnum | PropertyBlockedDateScalarFieldEnum[]
  }

  /**
   * Property.tm30Accommodation
   */
  export type Property$tm30AccommodationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30Accommodation
     */
    select?: Tm30AccommodationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30Accommodation
     */
    omit?: Tm30AccommodationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationInclude<ExtArgs> | null
    where?: Tm30AccommodationWhereInput
  }

  /**
   * Property without action
   */
  export type PropertyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
  }


  /**
   * Model PropertyImage
   */

  export type AggregatePropertyImage = {
    _count: PropertyImageCountAggregateOutputType | null
    _avg: PropertyImageAvgAggregateOutputType | null
    _sum: PropertyImageSumAggregateOutputType | null
    _min: PropertyImageMinAggregateOutputType | null
    _max: PropertyImageMaxAggregateOutputType | null
  }

  export type PropertyImageAvgAggregateOutputType = {
    position: number | null
  }

  export type PropertyImageSumAggregateOutputType = {
    position: number | null
  }

  export type PropertyImageMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    url: string | null
    position: number | null
    alt: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyImageMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    url: string | null
    position: number | null
    alt: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyImageCountAggregateOutputType = {
    id: number
    propertyId: number
    url: number
    position: number
    alt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyImageAvgAggregateInputType = {
    position?: true
  }

  export type PropertyImageSumAggregateInputType = {
    position?: true
  }

  export type PropertyImageMinAggregateInputType = {
    id?: true
    propertyId?: true
    url?: true
    position?: true
    alt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyImageMaxAggregateInputType = {
    id?: true
    propertyId?: true
    url?: true
    position?: true
    alt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyImageCountAggregateInputType = {
    id?: true
    propertyId?: true
    url?: true
    position?: true
    alt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyImage to aggregate.
     */
    where?: PropertyImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyImages to fetch.
     */
    orderBy?: PropertyImageOrderByWithRelationInput | PropertyImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyImages
    **/
    _count?: true | PropertyImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyImageMaxAggregateInputType
  }

  export type GetPropertyImageAggregateType<T extends PropertyImageAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyImage[P]>
      : GetScalarType<T[P], AggregatePropertyImage[P]>
  }




  export type PropertyImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyImageWhereInput
    orderBy?: PropertyImageOrderByWithAggregationInput | PropertyImageOrderByWithAggregationInput[]
    by: PropertyImageScalarFieldEnum[] | PropertyImageScalarFieldEnum
    having?: PropertyImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyImageCountAggregateInputType | true
    _avg?: PropertyImageAvgAggregateInputType
    _sum?: PropertyImageSumAggregateInputType
    _min?: PropertyImageMinAggregateInputType
    _max?: PropertyImageMaxAggregateInputType
  }

  export type PropertyImageGroupByOutputType = {
    id: string
    propertyId: string
    url: string | null
    position: number
    alt: string | null
    createdAt: Date
    updatedAt: Date
    _count: PropertyImageCountAggregateOutputType | null
    _avg: PropertyImageAvgAggregateOutputType | null
    _sum: PropertyImageSumAggregateOutputType | null
    _min: PropertyImageMinAggregateOutputType | null
    _max: PropertyImageMaxAggregateOutputType | null
  }

  type GetPropertyImageGroupByPayload<T extends PropertyImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyImageGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyImageGroupByOutputType[P]>
        }
      >
    >


  export type PropertyImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    url?: boolean
    position?: boolean
    alt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyImage"]>

  export type PropertyImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    url?: boolean
    position?: boolean
    alt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyImage"]>

  export type PropertyImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    url?: boolean
    position?: boolean
    alt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyImage"]>

  export type PropertyImageSelectScalar = {
    id?: boolean
    propertyId?: boolean
    url?: boolean
    position?: boolean
    alt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "url" | "position" | "alt" | "createdAt" | "updatedAt", ExtArgs["result"]["propertyImage"]>
  export type PropertyImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PropertyImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyImage"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      url: string | null
      position: number
      alt: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["propertyImage"]>
    composites: {}
  }

  type PropertyImageGetPayload<S extends boolean | null | undefined | PropertyImageDefaultArgs> = $Result.GetResult<Prisma.$PropertyImagePayload, S>

  type PropertyImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyImageCountAggregateInputType | true
    }

  export interface PropertyImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyImage'], meta: { name: 'PropertyImage' } }
    /**
     * Find zero or one PropertyImage that matches the filter.
     * @param {PropertyImageFindUniqueArgs} args - Arguments to find a PropertyImage
     * @example
     * // Get one PropertyImage
     * const propertyImage = await prisma.propertyImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyImageFindUniqueArgs>(args: SelectSubset<T, PropertyImageFindUniqueArgs<ExtArgs>>): Prisma__PropertyImageClient<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyImageFindUniqueOrThrowArgs} args - Arguments to find a PropertyImage
     * @example
     * // Get one PropertyImage
     * const propertyImage = await prisma.propertyImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyImageFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyImageClient<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyImageFindFirstArgs} args - Arguments to find a PropertyImage
     * @example
     * // Get one PropertyImage
     * const propertyImage = await prisma.propertyImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyImageFindFirstArgs>(args?: SelectSubset<T, PropertyImageFindFirstArgs<ExtArgs>>): Prisma__PropertyImageClient<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyImageFindFirstOrThrowArgs} args - Arguments to find a PropertyImage
     * @example
     * // Get one PropertyImage
     * const propertyImage = await prisma.propertyImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyImageFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyImageClient<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyImages
     * const propertyImages = await prisma.propertyImage.findMany()
     * 
     * // Get first 10 PropertyImages
     * const propertyImages = await prisma.propertyImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyImageWithIdOnly = await prisma.propertyImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyImageFindManyArgs>(args?: SelectSubset<T, PropertyImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyImage.
     * @param {PropertyImageCreateArgs} args - Arguments to create a PropertyImage.
     * @example
     * // Create one PropertyImage
     * const PropertyImage = await prisma.propertyImage.create({
     *   data: {
     *     // ... data to create a PropertyImage
     *   }
     * })
     * 
     */
    create<T extends PropertyImageCreateArgs>(args: SelectSubset<T, PropertyImageCreateArgs<ExtArgs>>): Prisma__PropertyImageClient<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyImages.
     * @param {PropertyImageCreateManyArgs} args - Arguments to create many PropertyImages.
     * @example
     * // Create many PropertyImages
     * const propertyImage = await prisma.propertyImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyImageCreateManyArgs>(args?: SelectSubset<T, PropertyImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyImages and returns the data saved in the database.
     * @param {PropertyImageCreateManyAndReturnArgs} args - Arguments to create many PropertyImages.
     * @example
     * // Create many PropertyImages
     * const propertyImage = await prisma.propertyImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyImages and only return the `id`
     * const propertyImageWithIdOnly = await prisma.propertyImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyImageCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyImage.
     * @param {PropertyImageDeleteArgs} args - Arguments to delete one PropertyImage.
     * @example
     * // Delete one PropertyImage
     * const PropertyImage = await prisma.propertyImage.delete({
     *   where: {
     *     // ... filter to delete one PropertyImage
     *   }
     * })
     * 
     */
    delete<T extends PropertyImageDeleteArgs>(args: SelectSubset<T, PropertyImageDeleteArgs<ExtArgs>>): Prisma__PropertyImageClient<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyImage.
     * @param {PropertyImageUpdateArgs} args - Arguments to update one PropertyImage.
     * @example
     * // Update one PropertyImage
     * const propertyImage = await prisma.propertyImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyImageUpdateArgs>(args: SelectSubset<T, PropertyImageUpdateArgs<ExtArgs>>): Prisma__PropertyImageClient<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyImages.
     * @param {PropertyImageDeleteManyArgs} args - Arguments to filter PropertyImages to delete.
     * @example
     * // Delete a few PropertyImages
     * const { count } = await prisma.propertyImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyImageDeleteManyArgs>(args?: SelectSubset<T, PropertyImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyImages
     * const propertyImage = await prisma.propertyImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyImageUpdateManyArgs>(args: SelectSubset<T, PropertyImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyImages and returns the data updated in the database.
     * @param {PropertyImageUpdateManyAndReturnArgs} args - Arguments to update many PropertyImages.
     * @example
     * // Update many PropertyImages
     * const propertyImage = await prisma.propertyImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyImages and only return the `id`
     * const propertyImageWithIdOnly = await prisma.propertyImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyImageUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyImage.
     * @param {PropertyImageUpsertArgs} args - Arguments to update or create a PropertyImage.
     * @example
     * // Update or create a PropertyImage
     * const propertyImage = await prisma.propertyImage.upsert({
     *   create: {
     *     // ... data to create a PropertyImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyImage we want to update
     *   }
     * })
     */
    upsert<T extends PropertyImageUpsertArgs>(args: SelectSubset<T, PropertyImageUpsertArgs<ExtArgs>>): Prisma__PropertyImageClient<$Result.GetResult<Prisma.$PropertyImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyImageCountArgs} args - Arguments to filter PropertyImages to count.
     * @example
     * // Count the number of PropertyImages
     * const count = await prisma.propertyImage.count({
     *   where: {
     *     // ... the filter for the PropertyImages we want to count
     *   }
     * })
    **/
    count<T extends PropertyImageCountArgs>(
      args?: Subset<T, PropertyImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyImageAggregateArgs>(args: Subset<T, PropertyImageAggregateArgs>): Prisma.PrismaPromise<GetPropertyImageAggregateType<T>>

    /**
     * Group by PropertyImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyImageGroupByArgs['orderBy'] }
        : { orderBy?: PropertyImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyImage model
   */
  readonly fields: PropertyImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyImage model
   */
  interface PropertyImageFieldRefs {
    readonly id: FieldRef<"PropertyImage", 'String'>
    readonly propertyId: FieldRef<"PropertyImage", 'String'>
    readonly url: FieldRef<"PropertyImage", 'String'>
    readonly position: FieldRef<"PropertyImage", 'Int'>
    readonly alt: FieldRef<"PropertyImage", 'String'>
    readonly createdAt: FieldRef<"PropertyImage", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertyImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyImage findUnique
   */
  export type PropertyImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
    /**
     * Filter, which PropertyImage to fetch.
     */
    where: PropertyImageWhereUniqueInput
  }

  /**
   * PropertyImage findUniqueOrThrow
   */
  export type PropertyImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
    /**
     * Filter, which PropertyImage to fetch.
     */
    where: PropertyImageWhereUniqueInput
  }

  /**
   * PropertyImage findFirst
   */
  export type PropertyImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
    /**
     * Filter, which PropertyImage to fetch.
     */
    where?: PropertyImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyImages to fetch.
     */
    orderBy?: PropertyImageOrderByWithRelationInput | PropertyImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyImages.
     */
    cursor?: PropertyImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyImages.
     */
    distinct?: PropertyImageScalarFieldEnum | PropertyImageScalarFieldEnum[]
  }

  /**
   * PropertyImage findFirstOrThrow
   */
  export type PropertyImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
    /**
     * Filter, which PropertyImage to fetch.
     */
    where?: PropertyImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyImages to fetch.
     */
    orderBy?: PropertyImageOrderByWithRelationInput | PropertyImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyImages.
     */
    cursor?: PropertyImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyImages.
     */
    distinct?: PropertyImageScalarFieldEnum | PropertyImageScalarFieldEnum[]
  }

  /**
   * PropertyImage findMany
   */
  export type PropertyImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
    /**
     * Filter, which PropertyImages to fetch.
     */
    where?: PropertyImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyImages to fetch.
     */
    orderBy?: PropertyImageOrderByWithRelationInput | PropertyImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyImages.
     */
    cursor?: PropertyImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyImages.
     */
    skip?: number
    distinct?: PropertyImageScalarFieldEnum | PropertyImageScalarFieldEnum[]
  }

  /**
   * PropertyImage create
   */
  export type PropertyImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyImage.
     */
    data: XOR<PropertyImageCreateInput, PropertyImageUncheckedCreateInput>
  }

  /**
   * PropertyImage createMany
   */
  export type PropertyImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyImages.
     */
    data: PropertyImageCreateManyInput | PropertyImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyImage createManyAndReturn
   */
  export type PropertyImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyImages.
     */
    data: PropertyImageCreateManyInput | PropertyImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyImage update
   */
  export type PropertyImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyImage.
     */
    data: XOR<PropertyImageUpdateInput, PropertyImageUncheckedUpdateInput>
    /**
     * Choose, which PropertyImage to update.
     */
    where: PropertyImageWhereUniqueInput
  }

  /**
   * PropertyImage updateMany
   */
  export type PropertyImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyImages.
     */
    data: XOR<PropertyImageUpdateManyMutationInput, PropertyImageUncheckedUpdateManyInput>
    /**
     * Filter which PropertyImages to update
     */
    where?: PropertyImageWhereInput
    /**
     * Limit how many PropertyImages to update.
     */
    limit?: number
  }

  /**
   * PropertyImage updateManyAndReturn
   */
  export type PropertyImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * The data used to update PropertyImages.
     */
    data: XOR<PropertyImageUpdateManyMutationInput, PropertyImageUncheckedUpdateManyInput>
    /**
     * Filter which PropertyImages to update
     */
    where?: PropertyImageWhereInput
    /**
     * Limit how many PropertyImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyImage upsert
   */
  export type PropertyImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyImage to update in case it exists.
     */
    where: PropertyImageWhereUniqueInput
    /**
     * In case the PropertyImage found by the `where` argument doesn't exist, create a new PropertyImage with this data.
     */
    create: XOR<PropertyImageCreateInput, PropertyImageUncheckedCreateInput>
    /**
     * In case the PropertyImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyImageUpdateInput, PropertyImageUncheckedUpdateInput>
  }

  /**
   * PropertyImage delete
   */
  export type PropertyImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
    /**
     * Filter which PropertyImage to delete.
     */
    where: PropertyImageWhereUniqueInput
  }

  /**
   * PropertyImage deleteMany
   */
  export type PropertyImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyImages to delete
     */
    where?: PropertyImageWhereInput
    /**
     * Limit how many PropertyImages to delete.
     */
    limit?: number
  }

  /**
   * PropertyImage without action
   */
  export type PropertyImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyImage
     */
    select?: PropertyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyImage
     */
    omit?: PropertyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyImageInclude<ExtArgs> | null
  }


  /**
   * Model PropertyView
   */

  export type AggregatePropertyView = {
    _count: PropertyViewCountAggregateOutputType | null
    _min: PropertyViewMinAggregateOutputType | null
    _max: PropertyViewMaxAggregateOutputType | null
  }

  export type PropertyViewMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    viewedAt: Date | null
    country: string | null
    city: string | null
    ipHash: string | null
    userAgent: string | null
    referrer: string | null
    sessionId: string | null
  }

  export type PropertyViewMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    viewedAt: Date | null
    country: string | null
    city: string | null
    ipHash: string | null
    userAgent: string | null
    referrer: string | null
    sessionId: string | null
  }

  export type PropertyViewCountAggregateOutputType = {
    id: number
    propertyId: number
    viewedAt: number
    country: number
    city: number
    ipHash: number
    userAgent: number
    referrer: number
    sessionId: number
    _all: number
  }


  export type PropertyViewMinAggregateInputType = {
    id?: true
    propertyId?: true
    viewedAt?: true
    country?: true
    city?: true
    ipHash?: true
    userAgent?: true
    referrer?: true
    sessionId?: true
  }

  export type PropertyViewMaxAggregateInputType = {
    id?: true
    propertyId?: true
    viewedAt?: true
    country?: true
    city?: true
    ipHash?: true
    userAgent?: true
    referrer?: true
    sessionId?: true
  }

  export type PropertyViewCountAggregateInputType = {
    id?: true
    propertyId?: true
    viewedAt?: true
    country?: true
    city?: true
    ipHash?: true
    userAgent?: true
    referrer?: true
    sessionId?: true
    _all?: true
  }

  export type PropertyViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyView to aggregate.
     */
    where?: PropertyViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyViews to fetch.
     */
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyViews
    **/
    _count?: true | PropertyViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyViewMaxAggregateInputType
  }

  export type GetPropertyViewAggregateType<T extends PropertyViewAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyView[P]>
      : GetScalarType<T[P], AggregatePropertyView[P]>
  }




  export type PropertyViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyViewWhereInput
    orderBy?: PropertyViewOrderByWithAggregationInput | PropertyViewOrderByWithAggregationInput[]
    by: PropertyViewScalarFieldEnum[] | PropertyViewScalarFieldEnum
    having?: PropertyViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyViewCountAggregateInputType | true
    _min?: PropertyViewMinAggregateInputType
    _max?: PropertyViewMaxAggregateInputType
  }

  export type PropertyViewGroupByOutputType = {
    id: string
    propertyId: string
    viewedAt: Date
    country: string | null
    city: string | null
    ipHash: string | null
    userAgent: string | null
    referrer: string | null
    sessionId: string | null
    _count: PropertyViewCountAggregateOutputType | null
    _min: PropertyViewMinAggregateOutputType | null
    _max: PropertyViewMaxAggregateOutputType | null
  }

  type GetPropertyViewGroupByPayload<T extends PropertyViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyViewGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyViewGroupByOutputType[P]>
        }
      >
    >


  export type PropertyViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    viewedAt?: boolean
    country?: boolean
    city?: boolean
    ipHash?: boolean
    userAgent?: boolean
    referrer?: boolean
    sessionId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyView"]>

  export type PropertyViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    viewedAt?: boolean
    country?: boolean
    city?: boolean
    ipHash?: boolean
    userAgent?: boolean
    referrer?: boolean
    sessionId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyView"]>

  export type PropertyViewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    viewedAt?: boolean
    country?: boolean
    city?: boolean
    ipHash?: boolean
    userAgent?: boolean
    referrer?: boolean
    sessionId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyView"]>

  export type PropertyViewSelectScalar = {
    id?: boolean
    propertyId?: boolean
    viewedAt?: boolean
    country?: boolean
    city?: boolean
    ipHash?: boolean
    userAgent?: boolean
    referrer?: boolean
    sessionId?: boolean
  }

  export type PropertyViewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "viewedAt" | "country" | "city" | "ipHash" | "userAgent" | "referrer" | "sessionId", ExtArgs["result"]["propertyView"]>
  export type PropertyViewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyViewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyViewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PropertyViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyView"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      viewedAt: Date
      country: string | null
      city: string | null
      ipHash: string | null
      userAgent: string | null
      referrer: string | null
      sessionId: string | null
    }, ExtArgs["result"]["propertyView"]>
    composites: {}
  }

  type PropertyViewGetPayload<S extends boolean | null | undefined | PropertyViewDefaultArgs> = $Result.GetResult<Prisma.$PropertyViewPayload, S>

  type PropertyViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyViewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyViewCountAggregateInputType | true
    }

  export interface PropertyViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyView'], meta: { name: 'PropertyView' } }
    /**
     * Find zero or one PropertyView that matches the filter.
     * @param {PropertyViewFindUniqueArgs} args - Arguments to find a PropertyView
     * @example
     * // Get one PropertyView
     * const propertyView = await prisma.propertyView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyViewFindUniqueArgs>(args: SelectSubset<T, PropertyViewFindUniqueArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyView that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyViewFindUniqueOrThrowArgs} args - Arguments to find a PropertyView
     * @example
     * // Get one PropertyView
     * const propertyView = await prisma.propertyView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyViewFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewFindFirstArgs} args - Arguments to find a PropertyView
     * @example
     * // Get one PropertyView
     * const propertyView = await prisma.propertyView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyViewFindFirstArgs>(args?: SelectSubset<T, PropertyViewFindFirstArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewFindFirstOrThrowArgs} args - Arguments to find a PropertyView
     * @example
     * // Get one PropertyView
     * const propertyView = await prisma.propertyView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyViewFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyViews
     * const propertyViews = await prisma.propertyView.findMany()
     * 
     * // Get first 10 PropertyViews
     * const propertyViews = await prisma.propertyView.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyViewWithIdOnly = await prisma.propertyView.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyViewFindManyArgs>(args?: SelectSubset<T, PropertyViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyView.
     * @param {PropertyViewCreateArgs} args - Arguments to create a PropertyView.
     * @example
     * // Create one PropertyView
     * const PropertyView = await prisma.propertyView.create({
     *   data: {
     *     // ... data to create a PropertyView
     *   }
     * })
     * 
     */
    create<T extends PropertyViewCreateArgs>(args: SelectSubset<T, PropertyViewCreateArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyViews.
     * @param {PropertyViewCreateManyArgs} args - Arguments to create many PropertyViews.
     * @example
     * // Create many PropertyViews
     * const propertyView = await prisma.propertyView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyViewCreateManyArgs>(args?: SelectSubset<T, PropertyViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyViews and returns the data saved in the database.
     * @param {PropertyViewCreateManyAndReturnArgs} args - Arguments to create many PropertyViews.
     * @example
     * // Create many PropertyViews
     * const propertyView = await prisma.propertyView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyViews and only return the `id`
     * const propertyViewWithIdOnly = await prisma.propertyView.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyViewCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyView.
     * @param {PropertyViewDeleteArgs} args - Arguments to delete one PropertyView.
     * @example
     * // Delete one PropertyView
     * const PropertyView = await prisma.propertyView.delete({
     *   where: {
     *     // ... filter to delete one PropertyView
     *   }
     * })
     * 
     */
    delete<T extends PropertyViewDeleteArgs>(args: SelectSubset<T, PropertyViewDeleteArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyView.
     * @param {PropertyViewUpdateArgs} args - Arguments to update one PropertyView.
     * @example
     * // Update one PropertyView
     * const propertyView = await prisma.propertyView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyViewUpdateArgs>(args: SelectSubset<T, PropertyViewUpdateArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyViews.
     * @param {PropertyViewDeleteManyArgs} args - Arguments to filter PropertyViews to delete.
     * @example
     * // Delete a few PropertyViews
     * const { count } = await prisma.propertyView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyViewDeleteManyArgs>(args?: SelectSubset<T, PropertyViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyViews
     * const propertyView = await prisma.propertyView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyViewUpdateManyArgs>(args: SelectSubset<T, PropertyViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyViews and returns the data updated in the database.
     * @param {PropertyViewUpdateManyAndReturnArgs} args - Arguments to update many PropertyViews.
     * @example
     * // Update many PropertyViews
     * const propertyView = await prisma.propertyView.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyViews and only return the `id`
     * const propertyViewWithIdOnly = await prisma.propertyView.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyViewUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyViewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyView.
     * @param {PropertyViewUpsertArgs} args - Arguments to update or create a PropertyView.
     * @example
     * // Update or create a PropertyView
     * const propertyView = await prisma.propertyView.upsert({
     *   create: {
     *     // ... data to create a PropertyView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyView we want to update
     *   }
     * })
     */
    upsert<T extends PropertyViewUpsertArgs>(args: SelectSubset<T, PropertyViewUpsertArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewCountArgs} args - Arguments to filter PropertyViews to count.
     * @example
     * // Count the number of PropertyViews
     * const count = await prisma.propertyView.count({
     *   where: {
     *     // ... the filter for the PropertyViews we want to count
     *   }
     * })
    **/
    count<T extends PropertyViewCountArgs>(
      args?: Subset<T, PropertyViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyViewAggregateArgs>(args: Subset<T, PropertyViewAggregateArgs>): Prisma.PrismaPromise<GetPropertyViewAggregateType<T>>

    /**
     * Group by PropertyView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyViewGroupByArgs['orderBy'] }
        : { orderBy?: PropertyViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyView model
   */
  readonly fields: PropertyViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyView model
   */
  interface PropertyViewFieldRefs {
    readonly id: FieldRef<"PropertyView", 'String'>
    readonly propertyId: FieldRef<"PropertyView", 'String'>
    readonly viewedAt: FieldRef<"PropertyView", 'DateTime'>
    readonly country: FieldRef<"PropertyView", 'String'>
    readonly city: FieldRef<"PropertyView", 'String'>
    readonly ipHash: FieldRef<"PropertyView", 'String'>
    readonly userAgent: FieldRef<"PropertyView", 'String'>
    readonly referrer: FieldRef<"PropertyView", 'String'>
    readonly sessionId: FieldRef<"PropertyView", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PropertyView findUnique
   */
  export type PropertyViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyView to fetch.
     */
    where: PropertyViewWhereUniqueInput
  }

  /**
   * PropertyView findUniqueOrThrow
   */
  export type PropertyViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyView to fetch.
     */
    where: PropertyViewWhereUniqueInput
  }

  /**
   * PropertyView findFirst
   */
  export type PropertyViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyView to fetch.
     */
    where?: PropertyViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyViews to fetch.
     */
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyViews.
     */
    cursor?: PropertyViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyViews.
     */
    distinct?: PropertyViewScalarFieldEnum | PropertyViewScalarFieldEnum[]
  }

  /**
   * PropertyView findFirstOrThrow
   */
  export type PropertyViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyView to fetch.
     */
    where?: PropertyViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyViews to fetch.
     */
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyViews.
     */
    cursor?: PropertyViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyViews.
     */
    distinct?: PropertyViewScalarFieldEnum | PropertyViewScalarFieldEnum[]
  }

  /**
   * PropertyView findMany
   */
  export type PropertyViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyViews to fetch.
     */
    where?: PropertyViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyViews to fetch.
     */
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyViews.
     */
    cursor?: PropertyViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyViews.
     */
    skip?: number
    distinct?: PropertyViewScalarFieldEnum | PropertyViewScalarFieldEnum[]
  }

  /**
   * PropertyView create
   */
  export type PropertyViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyView.
     */
    data: XOR<PropertyViewCreateInput, PropertyViewUncheckedCreateInput>
  }

  /**
   * PropertyView createMany
   */
  export type PropertyViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyViews.
     */
    data: PropertyViewCreateManyInput | PropertyViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyView createManyAndReturn
   */
  export type PropertyViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyViews.
     */
    data: PropertyViewCreateManyInput | PropertyViewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyView update
   */
  export type PropertyViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyView.
     */
    data: XOR<PropertyViewUpdateInput, PropertyViewUncheckedUpdateInput>
    /**
     * Choose, which PropertyView to update.
     */
    where: PropertyViewWhereUniqueInput
  }

  /**
   * PropertyView updateMany
   */
  export type PropertyViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyViews.
     */
    data: XOR<PropertyViewUpdateManyMutationInput, PropertyViewUncheckedUpdateManyInput>
    /**
     * Filter which PropertyViews to update
     */
    where?: PropertyViewWhereInput
    /**
     * Limit how many PropertyViews to update.
     */
    limit?: number
  }

  /**
   * PropertyView updateManyAndReturn
   */
  export type PropertyViewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * The data used to update PropertyViews.
     */
    data: XOR<PropertyViewUpdateManyMutationInput, PropertyViewUncheckedUpdateManyInput>
    /**
     * Filter which PropertyViews to update
     */
    where?: PropertyViewWhereInput
    /**
     * Limit how many PropertyViews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyView upsert
   */
  export type PropertyViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyView to update in case it exists.
     */
    where: PropertyViewWhereUniqueInput
    /**
     * In case the PropertyView found by the `where` argument doesn't exist, create a new PropertyView with this data.
     */
    create: XOR<PropertyViewCreateInput, PropertyViewUncheckedCreateInput>
    /**
     * In case the PropertyView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyViewUpdateInput, PropertyViewUncheckedUpdateInput>
  }

  /**
   * PropertyView delete
   */
  export type PropertyViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter which PropertyView to delete.
     */
    where: PropertyViewWhereUniqueInput
  }

  /**
   * PropertyView deleteMany
   */
  export type PropertyViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyViews to delete
     */
    where?: PropertyViewWhereInput
    /**
     * Limit how many PropertyViews to delete.
     */
    limit?: number
  }

  /**
   * PropertyView without action
   */
  export type PropertyViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
  }


  /**
   * Model ViewingRequest
   */

  export type AggregateViewingRequest = {
    _count: ViewingRequestCountAggregateOutputType | null
    _min: ViewingRequestMinAggregateOutputType | null
    _max: ViewingRequestMaxAggregateOutputType | null
  }

  export type ViewingRequestMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    requestType: $Enums.RequestType | null
    viewingDate: Date | null
    name: string | null
    email: string | null
    phone: string | null
    countryCode: string | null
    language: string | null
    message: string | null
    offerAmount: string | null
    offerCurrency: string | null
    status: $Enums.RequestStatus | null
    confirmedBy: string | null
    confirmedByName: string | null
    confirmedAt: Date | null
    completedBy: string | null
    completedByName: string | null
    completedAt: Date | null
    cancelledBy: string | null
    cancelledByName: string | null
    cancelledAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ViewingRequestMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    requestType: $Enums.RequestType | null
    viewingDate: Date | null
    name: string | null
    email: string | null
    phone: string | null
    countryCode: string | null
    language: string | null
    message: string | null
    offerAmount: string | null
    offerCurrency: string | null
    status: $Enums.RequestStatus | null
    confirmedBy: string | null
    confirmedByName: string | null
    confirmedAt: Date | null
    completedBy: string | null
    completedByName: string | null
    completedAt: Date | null
    cancelledBy: string | null
    cancelledByName: string | null
    cancelledAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ViewingRequestCountAggregateOutputType = {
    id: number
    propertyId: number
    requestType: number
    viewingDate: number
    name: number
    email: number
    phone: number
    countryCode: number
    language: number
    message: number
    offerAmount: number
    offerCurrency: number
    status: number
    confirmedBy: number
    confirmedByName: number
    confirmedAt: number
    completedBy: number
    completedByName: number
    completedAt: number
    cancelledBy: number
    cancelledByName: number
    cancelledAt: number
    ipAddress: number
    userAgent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ViewingRequestMinAggregateInputType = {
    id?: true
    propertyId?: true
    requestType?: true
    viewingDate?: true
    name?: true
    email?: true
    phone?: true
    countryCode?: true
    language?: true
    message?: true
    offerAmount?: true
    offerCurrency?: true
    status?: true
    confirmedBy?: true
    confirmedByName?: true
    confirmedAt?: true
    completedBy?: true
    completedByName?: true
    completedAt?: true
    cancelledBy?: true
    cancelledByName?: true
    cancelledAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ViewingRequestMaxAggregateInputType = {
    id?: true
    propertyId?: true
    requestType?: true
    viewingDate?: true
    name?: true
    email?: true
    phone?: true
    countryCode?: true
    language?: true
    message?: true
    offerAmount?: true
    offerCurrency?: true
    status?: true
    confirmedBy?: true
    confirmedByName?: true
    confirmedAt?: true
    completedBy?: true
    completedByName?: true
    completedAt?: true
    cancelledBy?: true
    cancelledByName?: true
    cancelledAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ViewingRequestCountAggregateInputType = {
    id?: true
    propertyId?: true
    requestType?: true
    viewingDate?: true
    name?: true
    email?: true
    phone?: true
    countryCode?: true
    language?: true
    message?: true
    offerAmount?: true
    offerCurrency?: true
    status?: true
    confirmedBy?: true
    confirmedByName?: true
    confirmedAt?: true
    completedBy?: true
    completedByName?: true
    completedAt?: true
    cancelledBy?: true
    cancelledByName?: true
    cancelledAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ViewingRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewingRequest to aggregate.
     */
    where?: ViewingRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewingRequests to fetch.
     */
    orderBy?: ViewingRequestOrderByWithRelationInput | ViewingRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViewingRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewingRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewingRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ViewingRequests
    **/
    _count?: true | ViewingRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViewingRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViewingRequestMaxAggregateInputType
  }

  export type GetViewingRequestAggregateType<T extends ViewingRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateViewingRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViewingRequest[P]>
      : GetScalarType<T[P], AggregateViewingRequest[P]>
  }




  export type ViewingRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewingRequestWhereInput
    orderBy?: ViewingRequestOrderByWithAggregationInput | ViewingRequestOrderByWithAggregationInput[]
    by: ViewingRequestScalarFieldEnum[] | ViewingRequestScalarFieldEnum
    having?: ViewingRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViewingRequestCountAggregateInputType | true
    _min?: ViewingRequestMinAggregateInputType
    _max?: ViewingRequestMaxAggregateInputType
  }

  export type ViewingRequestGroupByOutputType = {
    id: string
    propertyId: string | null
    requestType: $Enums.RequestType
    viewingDate: Date | null
    name: string
    email: string
    phone: string
    countryCode: string
    language: string | null
    message: string | null
    offerAmount: string | null
    offerCurrency: string | null
    status: $Enums.RequestStatus
    confirmedBy: string | null
    confirmedByName: string | null
    confirmedAt: Date | null
    completedBy: string | null
    completedByName: string | null
    completedAt: Date | null
    cancelledBy: string | null
    cancelledByName: string | null
    cancelledAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    updatedAt: Date
    _count: ViewingRequestCountAggregateOutputType | null
    _min: ViewingRequestMinAggregateOutputType | null
    _max: ViewingRequestMaxAggregateOutputType | null
  }

  type GetViewingRequestGroupByPayload<T extends ViewingRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViewingRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViewingRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViewingRequestGroupByOutputType[P]>
            : GetScalarType<T[P], ViewingRequestGroupByOutputType[P]>
        }
      >
    >


  export type ViewingRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    requestType?: boolean
    viewingDate?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    countryCode?: boolean
    language?: boolean
    message?: boolean
    offerAmount?: boolean
    offerCurrency?: boolean
    status?: boolean
    confirmedBy?: boolean
    confirmedByName?: boolean
    confirmedAt?: boolean
    completedBy?: boolean
    completedByName?: boolean
    completedAt?: boolean
    cancelledBy?: boolean
    cancelledByName?: boolean
    cancelledAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | ViewingRequest$propertyArgs<ExtArgs>
  }, ExtArgs["result"]["viewingRequest"]>

  export type ViewingRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    requestType?: boolean
    viewingDate?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    countryCode?: boolean
    language?: boolean
    message?: boolean
    offerAmount?: boolean
    offerCurrency?: boolean
    status?: boolean
    confirmedBy?: boolean
    confirmedByName?: boolean
    confirmedAt?: boolean
    completedBy?: boolean
    completedByName?: boolean
    completedAt?: boolean
    cancelledBy?: boolean
    cancelledByName?: boolean
    cancelledAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | ViewingRequest$propertyArgs<ExtArgs>
  }, ExtArgs["result"]["viewingRequest"]>

  export type ViewingRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    requestType?: boolean
    viewingDate?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    countryCode?: boolean
    language?: boolean
    message?: boolean
    offerAmount?: boolean
    offerCurrency?: boolean
    status?: boolean
    confirmedBy?: boolean
    confirmedByName?: boolean
    confirmedAt?: boolean
    completedBy?: boolean
    completedByName?: boolean
    completedAt?: boolean
    cancelledBy?: boolean
    cancelledByName?: boolean
    cancelledAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | ViewingRequest$propertyArgs<ExtArgs>
  }, ExtArgs["result"]["viewingRequest"]>

  export type ViewingRequestSelectScalar = {
    id?: boolean
    propertyId?: boolean
    requestType?: boolean
    viewingDate?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    countryCode?: boolean
    language?: boolean
    message?: boolean
    offerAmount?: boolean
    offerCurrency?: boolean
    status?: boolean
    confirmedBy?: boolean
    confirmedByName?: boolean
    confirmedAt?: boolean
    completedBy?: boolean
    completedByName?: boolean
    completedAt?: boolean
    cancelledBy?: boolean
    cancelledByName?: boolean
    cancelledAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ViewingRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "requestType" | "viewingDate" | "name" | "email" | "phone" | "countryCode" | "language" | "message" | "offerAmount" | "offerCurrency" | "status" | "confirmedBy" | "confirmedByName" | "confirmedAt" | "completedBy" | "completedByName" | "completedAt" | "cancelledBy" | "cancelledByName" | "cancelledAt" | "ipAddress" | "userAgent" | "createdAt" | "updatedAt", ExtArgs["result"]["viewingRequest"]>
  export type ViewingRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | ViewingRequest$propertyArgs<ExtArgs>
  }
  export type ViewingRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | ViewingRequest$propertyArgs<ExtArgs>
  }
  export type ViewingRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | ViewingRequest$propertyArgs<ExtArgs>
  }

  export type $ViewingRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ViewingRequest"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string | null
      requestType: $Enums.RequestType
      viewingDate: Date | null
      name: string
      email: string
      phone: string
      countryCode: string
      language: string | null
      message: string | null
      offerAmount: string | null
      offerCurrency: string | null
      status: $Enums.RequestStatus
      confirmedBy: string | null
      confirmedByName: string | null
      confirmedAt: Date | null
      completedBy: string | null
      completedByName: string | null
      completedAt: Date | null
      cancelledBy: string | null
      cancelledByName: string | null
      cancelledAt: Date | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["viewingRequest"]>
    composites: {}
  }

  type ViewingRequestGetPayload<S extends boolean | null | undefined | ViewingRequestDefaultArgs> = $Result.GetResult<Prisma.$ViewingRequestPayload, S>

  type ViewingRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ViewingRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ViewingRequestCountAggregateInputType | true
    }

  export interface ViewingRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ViewingRequest'], meta: { name: 'ViewingRequest' } }
    /**
     * Find zero or one ViewingRequest that matches the filter.
     * @param {ViewingRequestFindUniqueArgs} args - Arguments to find a ViewingRequest
     * @example
     * // Get one ViewingRequest
     * const viewingRequest = await prisma.viewingRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViewingRequestFindUniqueArgs>(args: SelectSubset<T, ViewingRequestFindUniqueArgs<ExtArgs>>): Prisma__ViewingRequestClient<$Result.GetResult<Prisma.$ViewingRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ViewingRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ViewingRequestFindUniqueOrThrowArgs} args - Arguments to find a ViewingRequest
     * @example
     * // Get one ViewingRequest
     * const viewingRequest = await prisma.viewingRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViewingRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, ViewingRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViewingRequestClient<$Result.GetResult<Prisma.$ViewingRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViewingRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewingRequestFindFirstArgs} args - Arguments to find a ViewingRequest
     * @example
     * // Get one ViewingRequest
     * const viewingRequest = await prisma.viewingRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViewingRequestFindFirstArgs>(args?: SelectSubset<T, ViewingRequestFindFirstArgs<ExtArgs>>): Prisma__ViewingRequestClient<$Result.GetResult<Prisma.$ViewingRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViewingRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewingRequestFindFirstOrThrowArgs} args - Arguments to find a ViewingRequest
     * @example
     * // Get one ViewingRequest
     * const viewingRequest = await prisma.viewingRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViewingRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, ViewingRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViewingRequestClient<$Result.GetResult<Prisma.$ViewingRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ViewingRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewingRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ViewingRequests
     * const viewingRequests = await prisma.viewingRequest.findMany()
     * 
     * // Get first 10 ViewingRequests
     * const viewingRequests = await prisma.viewingRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viewingRequestWithIdOnly = await prisma.viewingRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ViewingRequestFindManyArgs>(args?: SelectSubset<T, ViewingRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewingRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ViewingRequest.
     * @param {ViewingRequestCreateArgs} args - Arguments to create a ViewingRequest.
     * @example
     * // Create one ViewingRequest
     * const ViewingRequest = await prisma.viewingRequest.create({
     *   data: {
     *     // ... data to create a ViewingRequest
     *   }
     * })
     * 
     */
    create<T extends ViewingRequestCreateArgs>(args: SelectSubset<T, ViewingRequestCreateArgs<ExtArgs>>): Prisma__ViewingRequestClient<$Result.GetResult<Prisma.$ViewingRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ViewingRequests.
     * @param {ViewingRequestCreateManyArgs} args - Arguments to create many ViewingRequests.
     * @example
     * // Create many ViewingRequests
     * const viewingRequest = await prisma.viewingRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViewingRequestCreateManyArgs>(args?: SelectSubset<T, ViewingRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ViewingRequests and returns the data saved in the database.
     * @param {ViewingRequestCreateManyAndReturnArgs} args - Arguments to create many ViewingRequests.
     * @example
     * // Create many ViewingRequests
     * const viewingRequest = await prisma.viewingRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ViewingRequests and only return the `id`
     * const viewingRequestWithIdOnly = await prisma.viewingRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViewingRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, ViewingRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewingRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ViewingRequest.
     * @param {ViewingRequestDeleteArgs} args - Arguments to delete one ViewingRequest.
     * @example
     * // Delete one ViewingRequest
     * const ViewingRequest = await prisma.viewingRequest.delete({
     *   where: {
     *     // ... filter to delete one ViewingRequest
     *   }
     * })
     * 
     */
    delete<T extends ViewingRequestDeleteArgs>(args: SelectSubset<T, ViewingRequestDeleteArgs<ExtArgs>>): Prisma__ViewingRequestClient<$Result.GetResult<Prisma.$ViewingRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ViewingRequest.
     * @param {ViewingRequestUpdateArgs} args - Arguments to update one ViewingRequest.
     * @example
     * // Update one ViewingRequest
     * const viewingRequest = await prisma.viewingRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViewingRequestUpdateArgs>(args: SelectSubset<T, ViewingRequestUpdateArgs<ExtArgs>>): Prisma__ViewingRequestClient<$Result.GetResult<Prisma.$ViewingRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ViewingRequests.
     * @param {ViewingRequestDeleteManyArgs} args - Arguments to filter ViewingRequests to delete.
     * @example
     * // Delete a few ViewingRequests
     * const { count } = await prisma.viewingRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViewingRequestDeleteManyArgs>(args?: SelectSubset<T, ViewingRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViewingRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewingRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ViewingRequests
     * const viewingRequest = await prisma.viewingRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViewingRequestUpdateManyArgs>(args: SelectSubset<T, ViewingRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViewingRequests and returns the data updated in the database.
     * @param {ViewingRequestUpdateManyAndReturnArgs} args - Arguments to update many ViewingRequests.
     * @example
     * // Update many ViewingRequests
     * const viewingRequest = await prisma.viewingRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ViewingRequests and only return the `id`
     * const viewingRequestWithIdOnly = await prisma.viewingRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ViewingRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, ViewingRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewingRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ViewingRequest.
     * @param {ViewingRequestUpsertArgs} args - Arguments to update or create a ViewingRequest.
     * @example
     * // Update or create a ViewingRequest
     * const viewingRequest = await prisma.viewingRequest.upsert({
     *   create: {
     *     // ... data to create a ViewingRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ViewingRequest we want to update
     *   }
     * })
     */
    upsert<T extends ViewingRequestUpsertArgs>(args: SelectSubset<T, ViewingRequestUpsertArgs<ExtArgs>>): Prisma__ViewingRequestClient<$Result.GetResult<Prisma.$ViewingRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ViewingRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewingRequestCountArgs} args - Arguments to filter ViewingRequests to count.
     * @example
     * // Count the number of ViewingRequests
     * const count = await prisma.viewingRequest.count({
     *   where: {
     *     // ... the filter for the ViewingRequests we want to count
     *   }
     * })
    **/
    count<T extends ViewingRequestCountArgs>(
      args?: Subset<T, ViewingRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViewingRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ViewingRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewingRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViewingRequestAggregateArgs>(args: Subset<T, ViewingRequestAggregateArgs>): Prisma.PrismaPromise<GetViewingRequestAggregateType<T>>

    /**
     * Group by ViewingRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewingRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViewingRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViewingRequestGroupByArgs['orderBy'] }
        : { orderBy?: ViewingRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViewingRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViewingRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ViewingRequest model
   */
  readonly fields: ViewingRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ViewingRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViewingRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends ViewingRequest$propertyArgs<ExtArgs> = {}>(args?: Subset<T, ViewingRequest$propertyArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ViewingRequest model
   */
  interface ViewingRequestFieldRefs {
    readonly id: FieldRef<"ViewingRequest", 'String'>
    readonly propertyId: FieldRef<"ViewingRequest", 'String'>
    readonly requestType: FieldRef<"ViewingRequest", 'RequestType'>
    readonly viewingDate: FieldRef<"ViewingRequest", 'DateTime'>
    readonly name: FieldRef<"ViewingRequest", 'String'>
    readonly email: FieldRef<"ViewingRequest", 'String'>
    readonly phone: FieldRef<"ViewingRequest", 'String'>
    readonly countryCode: FieldRef<"ViewingRequest", 'String'>
    readonly language: FieldRef<"ViewingRequest", 'String'>
    readonly message: FieldRef<"ViewingRequest", 'String'>
    readonly offerAmount: FieldRef<"ViewingRequest", 'String'>
    readonly offerCurrency: FieldRef<"ViewingRequest", 'String'>
    readonly status: FieldRef<"ViewingRequest", 'RequestStatus'>
    readonly confirmedBy: FieldRef<"ViewingRequest", 'String'>
    readonly confirmedByName: FieldRef<"ViewingRequest", 'String'>
    readonly confirmedAt: FieldRef<"ViewingRequest", 'DateTime'>
    readonly completedBy: FieldRef<"ViewingRequest", 'String'>
    readonly completedByName: FieldRef<"ViewingRequest", 'String'>
    readonly completedAt: FieldRef<"ViewingRequest", 'DateTime'>
    readonly cancelledBy: FieldRef<"ViewingRequest", 'String'>
    readonly cancelledByName: FieldRef<"ViewingRequest", 'String'>
    readonly cancelledAt: FieldRef<"ViewingRequest", 'DateTime'>
    readonly ipAddress: FieldRef<"ViewingRequest", 'String'>
    readonly userAgent: FieldRef<"ViewingRequest", 'String'>
    readonly createdAt: FieldRef<"ViewingRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"ViewingRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ViewingRequest findUnique
   */
  export type ViewingRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRequest
     */
    select?: ViewingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRequest
     */
    omit?: ViewingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRequestInclude<ExtArgs> | null
    /**
     * Filter, which ViewingRequest to fetch.
     */
    where: ViewingRequestWhereUniqueInput
  }

  /**
   * ViewingRequest findUniqueOrThrow
   */
  export type ViewingRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRequest
     */
    select?: ViewingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRequest
     */
    omit?: ViewingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRequestInclude<ExtArgs> | null
    /**
     * Filter, which ViewingRequest to fetch.
     */
    where: ViewingRequestWhereUniqueInput
  }

  /**
   * ViewingRequest findFirst
   */
  export type ViewingRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRequest
     */
    select?: ViewingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRequest
     */
    omit?: ViewingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRequestInclude<ExtArgs> | null
    /**
     * Filter, which ViewingRequest to fetch.
     */
    where?: ViewingRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewingRequests to fetch.
     */
    orderBy?: ViewingRequestOrderByWithRelationInput | ViewingRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewingRequests.
     */
    cursor?: ViewingRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewingRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewingRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewingRequests.
     */
    distinct?: ViewingRequestScalarFieldEnum | ViewingRequestScalarFieldEnum[]
  }

  /**
   * ViewingRequest findFirstOrThrow
   */
  export type ViewingRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRequest
     */
    select?: ViewingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRequest
     */
    omit?: ViewingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRequestInclude<ExtArgs> | null
    /**
     * Filter, which ViewingRequest to fetch.
     */
    where?: ViewingRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewingRequests to fetch.
     */
    orderBy?: ViewingRequestOrderByWithRelationInput | ViewingRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewingRequests.
     */
    cursor?: ViewingRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewingRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewingRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewingRequests.
     */
    distinct?: ViewingRequestScalarFieldEnum | ViewingRequestScalarFieldEnum[]
  }

  /**
   * ViewingRequest findMany
   */
  export type ViewingRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRequest
     */
    select?: ViewingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRequest
     */
    omit?: ViewingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRequestInclude<ExtArgs> | null
    /**
     * Filter, which ViewingRequests to fetch.
     */
    where?: ViewingRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewingRequests to fetch.
     */
    orderBy?: ViewingRequestOrderByWithRelationInput | ViewingRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ViewingRequests.
     */
    cursor?: ViewingRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewingRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewingRequests.
     */
    skip?: number
    distinct?: ViewingRequestScalarFieldEnum | ViewingRequestScalarFieldEnum[]
  }

  /**
   * ViewingRequest create
   */
  export type ViewingRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRequest
     */
    select?: ViewingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRequest
     */
    omit?: ViewingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a ViewingRequest.
     */
    data: XOR<ViewingRequestCreateInput, ViewingRequestUncheckedCreateInput>
  }

  /**
   * ViewingRequest createMany
   */
  export type ViewingRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ViewingRequests.
     */
    data: ViewingRequestCreateManyInput | ViewingRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViewingRequest createManyAndReturn
   */
  export type ViewingRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRequest
     */
    select?: ViewingRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRequest
     */
    omit?: ViewingRequestOmit<ExtArgs> | null
    /**
     * The data used to create many ViewingRequests.
     */
    data: ViewingRequestCreateManyInput | ViewingRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViewingRequest update
   */
  export type ViewingRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRequest
     */
    select?: ViewingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRequest
     */
    omit?: ViewingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a ViewingRequest.
     */
    data: XOR<ViewingRequestUpdateInput, ViewingRequestUncheckedUpdateInput>
    /**
     * Choose, which ViewingRequest to update.
     */
    where: ViewingRequestWhereUniqueInput
  }

  /**
   * ViewingRequest updateMany
   */
  export type ViewingRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ViewingRequests.
     */
    data: XOR<ViewingRequestUpdateManyMutationInput, ViewingRequestUncheckedUpdateManyInput>
    /**
     * Filter which ViewingRequests to update
     */
    where?: ViewingRequestWhereInput
    /**
     * Limit how many ViewingRequests to update.
     */
    limit?: number
  }

  /**
   * ViewingRequest updateManyAndReturn
   */
  export type ViewingRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRequest
     */
    select?: ViewingRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRequest
     */
    omit?: ViewingRequestOmit<ExtArgs> | null
    /**
     * The data used to update ViewingRequests.
     */
    data: XOR<ViewingRequestUpdateManyMutationInput, ViewingRequestUncheckedUpdateManyInput>
    /**
     * Filter which ViewingRequests to update
     */
    where?: ViewingRequestWhereInput
    /**
     * Limit how many ViewingRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViewingRequest upsert
   */
  export type ViewingRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRequest
     */
    select?: ViewingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRequest
     */
    omit?: ViewingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the ViewingRequest to update in case it exists.
     */
    where: ViewingRequestWhereUniqueInput
    /**
     * In case the ViewingRequest found by the `where` argument doesn't exist, create a new ViewingRequest with this data.
     */
    create: XOR<ViewingRequestCreateInput, ViewingRequestUncheckedCreateInput>
    /**
     * In case the ViewingRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViewingRequestUpdateInput, ViewingRequestUncheckedUpdateInput>
  }

  /**
   * ViewingRequest delete
   */
  export type ViewingRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRequest
     */
    select?: ViewingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRequest
     */
    omit?: ViewingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRequestInclude<ExtArgs> | null
    /**
     * Filter which ViewingRequest to delete.
     */
    where: ViewingRequestWhereUniqueInput
  }

  /**
   * ViewingRequest deleteMany
   */
  export type ViewingRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewingRequests to delete
     */
    where?: ViewingRequestWhereInput
    /**
     * Limit how many ViewingRequests to delete.
     */
    limit?: number
  }

  /**
   * ViewingRequest.property
   */
  export type ViewingRequest$propertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
  }

  /**
   * ViewingRequest without action
   */
  export type ViewingRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingRequest
     */
    select?: ViewingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingRequest
     */
    omit?: ViewingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingRequestInclude<ExtArgs> | null
  }


  /**
   * Model InvestorLead
   */

  export type AggregateInvestorLead = {
    _count: InvestorLeadCountAggregateOutputType | null
    _min: InvestorLeadMinAggregateOutputType | null
    _max: InvestorLeadMaxAggregateOutputType | null
  }

  export type InvestorLeadMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    countryCode: string | null
    currency: string | null
    investmentBudget: string | null
    investmentGoal: string | null
    timeline: string | null
    preferredAreas: string | null
    propertyType: string | null
    experience: string | null
    financing: string | null
    message: string | null
    newsletter: boolean | null
    status: $Enums.LeadStatus | null
    assignedToId: string | null
    ipAddress: string | null
    userAgent: string | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestorLeadMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    countryCode: string | null
    currency: string | null
    investmentBudget: string | null
    investmentGoal: string | null
    timeline: string | null
    preferredAreas: string | null
    propertyType: string | null
    experience: string | null
    financing: string | null
    message: string | null
    newsletter: boolean | null
    status: $Enums.LeadStatus | null
    assignedToId: string | null
    ipAddress: string | null
    userAgent: string | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestorLeadCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    countryCode: number
    currency: number
    investmentBudget: number
    investmentGoal: number
    timeline: number
    preferredAreas: number
    propertyType: number
    experience: number
    financing: number
    message: number
    newsletter: number
    status: number
    assignedToId: number
    ipAddress: number
    userAgent: number
    source: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvestorLeadMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    countryCode?: true
    currency?: true
    investmentBudget?: true
    investmentGoal?: true
    timeline?: true
    preferredAreas?: true
    propertyType?: true
    experience?: true
    financing?: true
    message?: true
    newsletter?: true
    status?: true
    assignedToId?: true
    ipAddress?: true
    userAgent?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestorLeadMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    countryCode?: true
    currency?: true
    investmentBudget?: true
    investmentGoal?: true
    timeline?: true
    preferredAreas?: true
    propertyType?: true
    experience?: true
    financing?: true
    message?: true
    newsletter?: true
    status?: true
    assignedToId?: true
    ipAddress?: true
    userAgent?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestorLeadCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    countryCode?: true
    currency?: true
    investmentBudget?: true
    investmentGoal?: true
    timeline?: true
    preferredAreas?: true
    propertyType?: true
    experience?: true
    financing?: true
    message?: true
    newsletter?: true
    status?: true
    assignedToId?: true
    ipAddress?: true
    userAgent?: true
    source?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvestorLeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvestorLead to aggregate.
     */
    where?: InvestorLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorLeads to fetch.
     */
    orderBy?: InvestorLeadOrderByWithRelationInput | InvestorLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvestorLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorLeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvestorLeads
    **/
    _count?: true | InvestorLeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvestorLeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvestorLeadMaxAggregateInputType
  }

  export type GetInvestorLeadAggregateType<T extends InvestorLeadAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestorLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestorLead[P]>
      : GetScalarType<T[P], AggregateInvestorLead[P]>
  }




  export type InvestorLeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorLeadWhereInput
    orderBy?: InvestorLeadOrderByWithAggregationInput | InvestorLeadOrderByWithAggregationInput[]
    by: InvestorLeadScalarFieldEnum[] | InvestorLeadScalarFieldEnum
    having?: InvestorLeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvestorLeadCountAggregateInputType | true
    _min?: InvestorLeadMinAggregateInputType
    _max?: InvestorLeadMaxAggregateInputType
  }

  export type InvestorLeadGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string
    countryCode: string
    currency: string
    investmentBudget: string
    investmentGoal: string
    timeline: string
    preferredAreas: string | null
    propertyType: string | null
    experience: string | null
    financing: string | null
    message: string | null
    newsletter: boolean
    status: $Enums.LeadStatus
    assignedToId: string | null
    ipAddress: string | null
    userAgent: string | null
    source: string | null
    createdAt: Date
    updatedAt: Date
    _count: InvestorLeadCountAggregateOutputType | null
    _min: InvestorLeadMinAggregateOutputType | null
    _max: InvestorLeadMaxAggregateOutputType | null
  }

  type GetInvestorLeadGroupByPayload<T extends InvestorLeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvestorLeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvestorLeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvestorLeadGroupByOutputType[P]>
            : GetScalarType<T[P], InvestorLeadGroupByOutputType[P]>
        }
      >
    >


  export type InvestorLeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    countryCode?: boolean
    currency?: boolean
    investmentBudget?: boolean
    investmentGoal?: boolean
    timeline?: boolean
    preferredAreas?: boolean
    propertyType?: boolean
    experience?: boolean
    financing?: boolean
    message?: boolean
    newsletter?: boolean
    status?: boolean
    assignedToId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedTo?: boolean | InvestorLead$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["investorLead"]>

  export type InvestorLeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    countryCode?: boolean
    currency?: boolean
    investmentBudget?: boolean
    investmentGoal?: boolean
    timeline?: boolean
    preferredAreas?: boolean
    propertyType?: boolean
    experience?: boolean
    financing?: boolean
    message?: boolean
    newsletter?: boolean
    status?: boolean
    assignedToId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedTo?: boolean | InvestorLead$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["investorLead"]>

  export type InvestorLeadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    countryCode?: boolean
    currency?: boolean
    investmentBudget?: boolean
    investmentGoal?: boolean
    timeline?: boolean
    preferredAreas?: boolean
    propertyType?: boolean
    experience?: boolean
    financing?: boolean
    message?: boolean
    newsletter?: boolean
    status?: boolean
    assignedToId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedTo?: boolean | InvestorLead$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["investorLead"]>

  export type InvestorLeadSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    countryCode?: boolean
    currency?: boolean
    investmentBudget?: boolean
    investmentGoal?: boolean
    timeline?: boolean
    preferredAreas?: boolean
    propertyType?: boolean
    experience?: boolean
    financing?: boolean
    message?: boolean
    newsletter?: boolean
    status?: boolean
    assignedToId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvestorLeadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "countryCode" | "currency" | "investmentBudget" | "investmentGoal" | "timeline" | "preferredAreas" | "propertyType" | "experience" | "financing" | "message" | "newsletter" | "status" | "assignedToId" | "ipAddress" | "userAgent" | "source" | "createdAt" | "updatedAt", ExtArgs["result"]["investorLead"]>
  export type InvestorLeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | InvestorLead$assignedToArgs<ExtArgs>
  }
  export type InvestorLeadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | InvestorLead$assignedToArgs<ExtArgs>
  }
  export type InvestorLeadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | InvestorLead$assignedToArgs<ExtArgs>
  }

  export type $InvestorLeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvestorLead"
    objects: {
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string
      countryCode: string
      currency: string
      investmentBudget: string
      investmentGoal: string
      timeline: string
      preferredAreas: string | null
      propertyType: string | null
      experience: string | null
      financing: string | null
      message: string | null
      newsletter: boolean
      status: $Enums.LeadStatus
      assignedToId: string | null
      ipAddress: string | null
      userAgent: string | null
      source: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["investorLead"]>
    composites: {}
  }

  type InvestorLeadGetPayload<S extends boolean | null | undefined | InvestorLeadDefaultArgs> = $Result.GetResult<Prisma.$InvestorLeadPayload, S>

  type InvestorLeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvestorLeadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvestorLeadCountAggregateInputType | true
    }

  export interface InvestorLeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvestorLead'], meta: { name: 'InvestorLead' } }
    /**
     * Find zero or one InvestorLead that matches the filter.
     * @param {InvestorLeadFindUniqueArgs} args - Arguments to find a InvestorLead
     * @example
     * // Get one InvestorLead
     * const investorLead = await prisma.investorLead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvestorLeadFindUniqueArgs>(args: SelectSubset<T, InvestorLeadFindUniqueArgs<ExtArgs>>): Prisma__InvestorLeadClient<$Result.GetResult<Prisma.$InvestorLeadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvestorLead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvestorLeadFindUniqueOrThrowArgs} args - Arguments to find a InvestorLead
     * @example
     * // Get one InvestorLead
     * const investorLead = await prisma.investorLead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvestorLeadFindUniqueOrThrowArgs>(args: SelectSubset<T, InvestorLeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvestorLeadClient<$Result.GetResult<Prisma.$InvestorLeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvestorLead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorLeadFindFirstArgs} args - Arguments to find a InvestorLead
     * @example
     * // Get one InvestorLead
     * const investorLead = await prisma.investorLead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvestorLeadFindFirstArgs>(args?: SelectSubset<T, InvestorLeadFindFirstArgs<ExtArgs>>): Prisma__InvestorLeadClient<$Result.GetResult<Prisma.$InvestorLeadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvestorLead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorLeadFindFirstOrThrowArgs} args - Arguments to find a InvestorLead
     * @example
     * // Get one InvestorLead
     * const investorLead = await prisma.investorLead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvestorLeadFindFirstOrThrowArgs>(args?: SelectSubset<T, InvestorLeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvestorLeadClient<$Result.GetResult<Prisma.$InvestorLeadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvestorLeads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorLeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvestorLeads
     * const investorLeads = await prisma.investorLead.findMany()
     * 
     * // Get first 10 InvestorLeads
     * const investorLeads = await prisma.investorLead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investorLeadWithIdOnly = await prisma.investorLead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvestorLeadFindManyArgs>(args?: SelectSubset<T, InvestorLeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorLeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvestorLead.
     * @param {InvestorLeadCreateArgs} args - Arguments to create a InvestorLead.
     * @example
     * // Create one InvestorLead
     * const InvestorLead = await prisma.investorLead.create({
     *   data: {
     *     // ... data to create a InvestorLead
     *   }
     * })
     * 
     */
    create<T extends InvestorLeadCreateArgs>(args: SelectSubset<T, InvestorLeadCreateArgs<ExtArgs>>): Prisma__InvestorLeadClient<$Result.GetResult<Prisma.$InvestorLeadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvestorLeads.
     * @param {InvestorLeadCreateManyArgs} args - Arguments to create many InvestorLeads.
     * @example
     * // Create many InvestorLeads
     * const investorLead = await prisma.investorLead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvestorLeadCreateManyArgs>(args?: SelectSubset<T, InvestorLeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvestorLeads and returns the data saved in the database.
     * @param {InvestorLeadCreateManyAndReturnArgs} args - Arguments to create many InvestorLeads.
     * @example
     * // Create many InvestorLeads
     * const investorLead = await prisma.investorLead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvestorLeads and only return the `id`
     * const investorLeadWithIdOnly = await prisma.investorLead.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvestorLeadCreateManyAndReturnArgs>(args?: SelectSubset<T, InvestorLeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorLeadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvestorLead.
     * @param {InvestorLeadDeleteArgs} args - Arguments to delete one InvestorLead.
     * @example
     * // Delete one InvestorLead
     * const InvestorLead = await prisma.investorLead.delete({
     *   where: {
     *     // ... filter to delete one InvestorLead
     *   }
     * })
     * 
     */
    delete<T extends InvestorLeadDeleteArgs>(args: SelectSubset<T, InvestorLeadDeleteArgs<ExtArgs>>): Prisma__InvestorLeadClient<$Result.GetResult<Prisma.$InvestorLeadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvestorLead.
     * @param {InvestorLeadUpdateArgs} args - Arguments to update one InvestorLead.
     * @example
     * // Update one InvestorLead
     * const investorLead = await prisma.investorLead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvestorLeadUpdateArgs>(args: SelectSubset<T, InvestorLeadUpdateArgs<ExtArgs>>): Prisma__InvestorLeadClient<$Result.GetResult<Prisma.$InvestorLeadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvestorLeads.
     * @param {InvestorLeadDeleteManyArgs} args - Arguments to filter InvestorLeads to delete.
     * @example
     * // Delete a few InvestorLeads
     * const { count } = await prisma.investorLead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvestorLeadDeleteManyArgs>(args?: SelectSubset<T, InvestorLeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvestorLeads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorLeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvestorLeads
     * const investorLead = await prisma.investorLead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvestorLeadUpdateManyArgs>(args: SelectSubset<T, InvestorLeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvestorLeads and returns the data updated in the database.
     * @param {InvestorLeadUpdateManyAndReturnArgs} args - Arguments to update many InvestorLeads.
     * @example
     * // Update many InvestorLeads
     * const investorLead = await prisma.investorLead.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvestorLeads and only return the `id`
     * const investorLeadWithIdOnly = await prisma.investorLead.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvestorLeadUpdateManyAndReturnArgs>(args: SelectSubset<T, InvestorLeadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorLeadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvestorLead.
     * @param {InvestorLeadUpsertArgs} args - Arguments to update or create a InvestorLead.
     * @example
     * // Update or create a InvestorLead
     * const investorLead = await prisma.investorLead.upsert({
     *   create: {
     *     // ... data to create a InvestorLead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvestorLead we want to update
     *   }
     * })
     */
    upsert<T extends InvestorLeadUpsertArgs>(args: SelectSubset<T, InvestorLeadUpsertArgs<ExtArgs>>): Prisma__InvestorLeadClient<$Result.GetResult<Prisma.$InvestorLeadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvestorLeads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorLeadCountArgs} args - Arguments to filter InvestorLeads to count.
     * @example
     * // Count the number of InvestorLeads
     * const count = await prisma.investorLead.count({
     *   where: {
     *     // ... the filter for the InvestorLeads we want to count
     *   }
     * })
    **/
    count<T extends InvestorLeadCountArgs>(
      args?: Subset<T, InvestorLeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvestorLeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvestorLead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorLeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvestorLeadAggregateArgs>(args: Subset<T, InvestorLeadAggregateArgs>): Prisma.PrismaPromise<GetInvestorLeadAggregateType<T>>

    /**
     * Group by InvestorLead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorLeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvestorLeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvestorLeadGroupByArgs['orderBy'] }
        : { orderBy?: InvestorLeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvestorLeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestorLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvestorLead model
   */
  readonly fields: InvestorLeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvestorLead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvestorLeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedTo<T extends InvestorLead$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, InvestorLead$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvestorLead model
   */
  interface InvestorLeadFieldRefs {
    readonly id: FieldRef<"InvestorLead", 'String'>
    readonly name: FieldRef<"InvestorLead", 'String'>
    readonly email: FieldRef<"InvestorLead", 'String'>
    readonly phone: FieldRef<"InvestorLead", 'String'>
    readonly countryCode: FieldRef<"InvestorLead", 'String'>
    readonly currency: FieldRef<"InvestorLead", 'String'>
    readonly investmentBudget: FieldRef<"InvestorLead", 'String'>
    readonly investmentGoal: FieldRef<"InvestorLead", 'String'>
    readonly timeline: FieldRef<"InvestorLead", 'String'>
    readonly preferredAreas: FieldRef<"InvestorLead", 'String'>
    readonly propertyType: FieldRef<"InvestorLead", 'String'>
    readonly experience: FieldRef<"InvestorLead", 'String'>
    readonly financing: FieldRef<"InvestorLead", 'String'>
    readonly message: FieldRef<"InvestorLead", 'String'>
    readonly newsletter: FieldRef<"InvestorLead", 'Boolean'>
    readonly status: FieldRef<"InvestorLead", 'LeadStatus'>
    readonly assignedToId: FieldRef<"InvestorLead", 'String'>
    readonly ipAddress: FieldRef<"InvestorLead", 'String'>
    readonly userAgent: FieldRef<"InvestorLead", 'String'>
    readonly source: FieldRef<"InvestorLead", 'String'>
    readonly createdAt: FieldRef<"InvestorLead", 'DateTime'>
    readonly updatedAt: FieldRef<"InvestorLead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvestorLead findUnique
   */
  export type InvestorLeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorLead
     */
    select?: InvestorLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorLead
     */
    omit?: InvestorLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorLeadInclude<ExtArgs> | null
    /**
     * Filter, which InvestorLead to fetch.
     */
    where: InvestorLeadWhereUniqueInput
  }

  /**
   * InvestorLead findUniqueOrThrow
   */
  export type InvestorLeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorLead
     */
    select?: InvestorLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorLead
     */
    omit?: InvestorLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorLeadInclude<ExtArgs> | null
    /**
     * Filter, which InvestorLead to fetch.
     */
    where: InvestorLeadWhereUniqueInput
  }

  /**
   * InvestorLead findFirst
   */
  export type InvestorLeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorLead
     */
    select?: InvestorLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorLead
     */
    omit?: InvestorLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorLeadInclude<ExtArgs> | null
    /**
     * Filter, which InvestorLead to fetch.
     */
    where?: InvestorLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorLeads to fetch.
     */
    orderBy?: InvestorLeadOrderByWithRelationInput | InvestorLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvestorLeads.
     */
    cursor?: InvestorLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorLeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvestorLeads.
     */
    distinct?: InvestorLeadScalarFieldEnum | InvestorLeadScalarFieldEnum[]
  }

  /**
   * InvestorLead findFirstOrThrow
   */
  export type InvestorLeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorLead
     */
    select?: InvestorLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorLead
     */
    omit?: InvestorLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorLeadInclude<ExtArgs> | null
    /**
     * Filter, which InvestorLead to fetch.
     */
    where?: InvestorLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorLeads to fetch.
     */
    orderBy?: InvestorLeadOrderByWithRelationInput | InvestorLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvestorLeads.
     */
    cursor?: InvestorLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorLeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvestorLeads.
     */
    distinct?: InvestorLeadScalarFieldEnum | InvestorLeadScalarFieldEnum[]
  }

  /**
   * InvestorLead findMany
   */
  export type InvestorLeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorLead
     */
    select?: InvestorLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorLead
     */
    omit?: InvestorLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorLeadInclude<ExtArgs> | null
    /**
     * Filter, which InvestorLeads to fetch.
     */
    where?: InvestorLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorLeads to fetch.
     */
    orderBy?: InvestorLeadOrderByWithRelationInput | InvestorLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvestorLeads.
     */
    cursor?: InvestorLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorLeads.
     */
    skip?: number
    distinct?: InvestorLeadScalarFieldEnum | InvestorLeadScalarFieldEnum[]
  }

  /**
   * InvestorLead create
   */
  export type InvestorLeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorLead
     */
    select?: InvestorLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorLead
     */
    omit?: InvestorLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorLeadInclude<ExtArgs> | null
    /**
     * The data needed to create a InvestorLead.
     */
    data: XOR<InvestorLeadCreateInput, InvestorLeadUncheckedCreateInput>
  }

  /**
   * InvestorLead createMany
   */
  export type InvestorLeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvestorLeads.
     */
    data: InvestorLeadCreateManyInput | InvestorLeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvestorLead createManyAndReturn
   */
  export type InvestorLeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorLead
     */
    select?: InvestorLeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorLead
     */
    omit?: InvestorLeadOmit<ExtArgs> | null
    /**
     * The data used to create many InvestorLeads.
     */
    data: InvestorLeadCreateManyInput | InvestorLeadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorLeadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvestorLead update
   */
  export type InvestorLeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorLead
     */
    select?: InvestorLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorLead
     */
    omit?: InvestorLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorLeadInclude<ExtArgs> | null
    /**
     * The data needed to update a InvestorLead.
     */
    data: XOR<InvestorLeadUpdateInput, InvestorLeadUncheckedUpdateInput>
    /**
     * Choose, which InvestorLead to update.
     */
    where: InvestorLeadWhereUniqueInput
  }

  /**
   * InvestorLead updateMany
   */
  export type InvestorLeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvestorLeads.
     */
    data: XOR<InvestorLeadUpdateManyMutationInput, InvestorLeadUncheckedUpdateManyInput>
    /**
     * Filter which InvestorLeads to update
     */
    where?: InvestorLeadWhereInput
    /**
     * Limit how many InvestorLeads to update.
     */
    limit?: number
  }

  /**
   * InvestorLead updateManyAndReturn
   */
  export type InvestorLeadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorLead
     */
    select?: InvestorLeadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorLead
     */
    omit?: InvestorLeadOmit<ExtArgs> | null
    /**
     * The data used to update InvestorLeads.
     */
    data: XOR<InvestorLeadUpdateManyMutationInput, InvestorLeadUncheckedUpdateManyInput>
    /**
     * Filter which InvestorLeads to update
     */
    where?: InvestorLeadWhereInput
    /**
     * Limit how many InvestorLeads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorLeadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvestorLead upsert
   */
  export type InvestorLeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorLead
     */
    select?: InvestorLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorLead
     */
    omit?: InvestorLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorLeadInclude<ExtArgs> | null
    /**
     * The filter to search for the InvestorLead to update in case it exists.
     */
    where: InvestorLeadWhereUniqueInput
    /**
     * In case the InvestorLead found by the `where` argument doesn't exist, create a new InvestorLead with this data.
     */
    create: XOR<InvestorLeadCreateInput, InvestorLeadUncheckedCreateInput>
    /**
     * In case the InvestorLead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvestorLeadUpdateInput, InvestorLeadUncheckedUpdateInput>
  }

  /**
   * InvestorLead delete
   */
  export type InvestorLeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorLead
     */
    select?: InvestorLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorLead
     */
    omit?: InvestorLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorLeadInclude<ExtArgs> | null
    /**
     * Filter which InvestorLead to delete.
     */
    where: InvestorLeadWhereUniqueInput
  }

  /**
   * InvestorLead deleteMany
   */
  export type InvestorLeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvestorLeads to delete
     */
    where?: InvestorLeadWhereInput
    /**
     * Limit how many InvestorLeads to delete.
     */
    limit?: number
  }

  /**
   * InvestorLead.assignedTo
   */
  export type InvestorLead$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * InvestorLead without action
   */
  export type InvestorLeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorLead
     */
    select?: InvestorLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorLead
     */
    omit?: InvestorLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorLeadInclude<ExtArgs> | null
  }


  /**
   * Model RentalLead
   */

  export type AggregateRentalLead = {
    _count: RentalLeadCountAggregateOutputType | null
    _min: RentalLeadMinAggregateOutputType | null
    _max: RentalLeadMaxAggregateOutputType | null
  }

  export type RentalLeadMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    countryCode: string | null
    propertyType: string | null
    bedrooms: string | null
    budget: string | null
    rentalDuration: string | null
    preferredAreas: string | null
    moveInDate: string | null
    furnished: string | null
    pets: string | null
    message: string | null
    newsletter: boolean | null
    status: $Enums.RentalLeadStatus | null
    assignedToId: string | null
    ipAddress: string | null
    userAgent: string | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RentalLeadMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    countryCode: string | null
    propertyType: string | null
    bedrooms: string | null
    budget: string | null
    rentalDuration: string | null
    preferredAreas: string | null
    moveInDate: string | null
    furnished: string | null
    pets: string | null
    message: string | null
    newsletter: boolean | null
    status: $Enums.RentalLeadStatus | null
    assignedToId: string | null
    ipAddress: string | null
    userAgent: string | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RentalLeadCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    countryCode: number
    propertyType: number
    bedrooms: number
    budget: number
    rentalDuration: number
    preferredAreas: number
    moveInDate: number
    furnished: number
    pets: number
    message: number
    newsletter: number
    status: number
    assignedToId: number
    ipAddress: number
    userAgent: number
    source: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RentalLeadMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    countryCode?: true
    propertyType?: true
    bedrooms?: true
    budget?: true
    rentalDuration?: true
    preferredAreas?: true
    moveInDate?: true
    furnished?: true
    pets?: true
    message?: true
    newsletter?: true
    status?: true
    assignedToId?: true
    ipAddress?: true
    userAgent?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RentalLeadMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    countryCode?: true
    propertyType?: true
    bedrooms?: true
    budget?: true
    rentalDuration?: true
    preferredAreas?: true
    moveInDate?: true
    furnished?: true
    pets?: true
    message?: true
    newsletter?: true
    status?: true
    assignedToId?: true
    ipAddress?: true
    userAgent?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RentalLeadCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    countryCode?: true
    propertyType?: true
    bedrooms?: true
    budget?: true
    rentalDuration?: true
    preferredAreas?: true
    moveInDate?: true
    furnished?: true
    pets?: true
    message?: true
    newsletter?: true
    status?: true
    assignedToId?: true
    ipAddress?: true
    userAgent?: true
    source?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RentalLeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RentalLead to aggregate.
     */
    where?: RentalLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalLeads to fetch.
     */
    orderBy?: RentalLeadOrderByWithRelationInput | RentalLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RentalLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalLeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RentalLeads
    **/
    _count?: true | RentalLeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RentalLeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RentalLeadMaxAggregateInputType
  }

  export type GetRentalLeadAggregateType<T extends RentalLeadAggregateArgs> = {
        [P in keyof T & keyof AggregateRentalLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRentalLead[P]>
      : GetScalarType<T[P], AggregateRentalLead[P]>
  }




  export type RentalLeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RentalLeadWhereInput
    orderBy?: RentalLeadOrderByWithAggregationInput | RentalLeadOrderByWithAggregationInput[]
    by: RentalLeadScalarFieldEnum[] | RentalLeadScalarFieldEnum
    having?: RentalLeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RentalLeadCountAggregateInputType | true
    _min?: RentalLeadMinAggregateInputType
    _max?: RentalLeadMaxAggregateInputType
  }

  export type RentalLeadGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string
    countryCode: string
    propertyType: string
    bedrooms: string
    budget: string
    rentalDuration: string
    preferredAreas: string | null
    moveInDate: string | null
    furnished: string | null
    pets: string | null
    message: string | null
    newsletter: boolean
    status: $Enums.RentalLeadStatus
    assignedToId: string | null
    ipAddress: string | null
    userAgent: string | null
    source: string | null
    createdAt: Date
    updatedAt: Date
    _count: RentalLeadCountAggregateOutputType | null
    _min: RentalLeadMinAggregateOutputType | null
    _max: RentalLeadMaxAggregateOutputType | null
  }

  type GetRentalLeadGroupByPayload<T extends RentalLeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RentalLeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RentalLeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RentalLeadGroupByOutputType[P]>
            : GetScalarType<T[P], RentalLeadGroupByOutputType[P]>
        }
      >
    >


  export type RentalLeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    countryCode?: boolean
    propertyType?: boolean
    bedrooms?: boolean
    budget?: boolean
    rentalDuration?: boolean
    preferredAreas?: boolean
    moveInDate?: boolean
    furnished?: boolean
    pets?: boolean
    message?: boolean
    newsletter?: boolean
    status?: boolean
    assignedToId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedTo?: boolean | RentalLead$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["rentalLead"]>

  export type RentalLeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    countryCode?: boolean
    propertyType?: boolean
    bedrooms?: boolean
    budget?: boolean
    rentalDuration?: boolean
    preferredAreas?: boolean
    moveInDate?: boolean
    furnished?: boolean
    pets?: boolean
    message?: boolean
    newsletter?: boolean
    status?: boolean
    assignedToId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedTo?: boolean | RentalLead$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["rentalLead"]>

  export type RentalLeadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    countryCode?: boolean
    propertyType?: boolean
    bedrooms?: boolean
    budget?: boolean
    rentalDuration?: boolean
    preferredAreas?: boolean
    moveInDate?: boolean
    furnished?: boolean
    pets?: boolean
    message?: boolean
    newsletter?: boolean
    status?: boolean
    assignedToId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedTo?: boolean | RentalLead$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["rentalLead"]>

  export type RentalLeadSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    countryCode?: boolean
    propertyType?: boolean
    bedrooms?: boolean
    budget?: boolean
    rentalDuration?: boolean
    preferredAreas?: boolean
    moveInDate?: boolean
    furnished?: boolean
    pets?: boolean
    message?: boolean
    newsletter?: boolean
    status?: boolean
    assignedToId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RentalLeadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "countryCode" | "propertyType" | "bedrooms" | "budget" | "rentalDuration" | "preferredAreas" | "moveInDate" | "furnished" | "pets" | "message" | "newsletter" | "status" | "assignedToId" | "ipAddress" | "userAgent" | "source" | "createdAt" | "updatedAt", ExtArgs["result"]["rentalLead"]>
  export type RentalLeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | RentalLead$assignedToArgs<ExtArgs>
  }
  export type RentalLeadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | RentalLead$assignedToArgs<ExtArgs>
  }
  export type RentalLeadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | RentalLead$assignedToArgs<ExtArgs>
  }

  export type $RentalLeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RentalLead"
    objects: {
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string
      countryCode: string
      propertyType: string
      bedrooms: string
      budget: string
      rentalDuration: string
      preferredAreas: string | null
      moveInDate: string | null
      furnished: string | null
      pets: string | null
      message: string | null
      newsletter: boolean
      status: $Enums.RentalLeadStatus
      assignedToId: string | null
      ipAddress: string | null
      userAgent: string | null
      source: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rentalLead"]>
    composites: {}
  }

  type RentalLeadGetPayload<S extends boolean | null | undefined | RentalLeadDefaultArgs> = $Result.GetResult<Prisma.$RentalLeadPayload, S>

  type RentalLeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RentalLeadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RentalLeadCountAggregateInputType | true
    }

  export interface RentalLeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RentalLead'], meta: { name: 'RentalLead' } }
    /**
     * Find zero or one RentalLead that matches the filter.
     * @param {RentalLeadFindUniqueArgs} args - Arguments to find a RentalLead
     * @example
     * // Get one RentalLead
     * const rentalLead = await prisma.rentalLead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RentalLeadFindUniqueArgs>(args: SelectSubset<T, RentalLeadFindUniqueArgs<ExtArgs>>): Prisma__RentalLeadClient<$Result.GetResult<Prisma.$RentalLeadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RentalLead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RentalLeadFindUniqueOrThrowArgs} args - Arguments to find a RentalLead
     * @example
     * // Get one RentalLead
     * const rentalLead = await prisma.rentalLead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RentalLeadFindUniqueOrThrowArgs>(args: SelectSubset<T, RentalLeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RentalLeadClient<$Result.GetResult<Prisma.$RentalLeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RentalLead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalLeadFindFirstArgs} args - Arguments to find a RentalLead
     * @example
     * // Get one RentalLead
     * const rentalLead = await prisma.rentalLead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RentalLeadFindFirstArgs>(args?: SelectSubset<T, RentalLeadFindFirstArgs<ExtArgs>>): Prisma__RentalLeadClient<$Result.GetResult<Prisma.$RentalLeadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RentalLead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalLeadFindFirstOrThrowArgs} args - Arguments to find a RentalLead
     * @example
     * // Get one RentalLead
     * const rentalLead = await prisma.rentalLead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RentalLeadFindFirstOrThrowArgs>(args?: SelectSubset<T, RentalLeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__RentalLeadClient<$Result.GetResult<Prisma.$RentalLeadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RentalLeads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalLeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RentalLeads
     * const rentalLeads = await prisma.rentalLead.findMany()
     * 
     * // Get first 10 RentalLeads
     * const rentalLeads = await prisma.rentalLead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rentalLeadWithIdOnly = await prisma.rentalLead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RentalLeadFindManyArgs>(args?: SelectSubset<T, RentalLeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalLeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RentalLead.
     * @param {RentalLeadCreateArgs} args - Arguments to create a RentalLead.
     * @example
     * // Create one RentalLead
     * const RentalLead = await prisma.rentalLead.create({
     *   data: {
     *     // ... data to create a RentalLead
     *   }
     * })
     * 
     */
    create<T extends RentalLeadCreateArgs>(args: SelectSubset<T, RentalLeadCreateArgs<ExtArgs>>): Prisma__RentalLeadClient<$Result.GetResult<Prisma.$RentalLeadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RentalLeads.
     * @param {RentalLeadCreateManyArgs} args - Arguments to create many RentalLeads.
     * @example
     * // Create many RentalLeads
     * const rentalLead = await prisma.rentalLead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RentalLeadCreateManyArgs>(args?: SelectSubset<T, RentalLeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RentalLeads and returns the data saved in the database.
     * @param {RentalLeadCreateManyAndReturnArgs} args - Arguments to create many RentalLeads.
     * @example
     * // Create many RentalLeads
     * const rentalLead = await prisma.rentalLead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RentalLeads and only return the `id`
     * const rentalLeadWithIdOnly = await prisma.rentalLead.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RentalLeadCreateManyAndReturnArgs>(args?: SelectSubset<T, RentalLeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalLeadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RentalLead.
     * @param {RentalLeadDeleteArgs} args - Arguments to delete one RentalLead.
     * @example
     * // Delete one RentalLead
     * const RentalLead = await prisma.rentalLead.delete({
     *   where: {
     *     // ... filter to delete one RentalLead
     *   }
     * })
     * 
     */
    delete<T extends RentalLeadDeleteArgs>(args: SelectSubset<T, RentalLeadDeleteArgs<ExtArgs>>): Prisma__RentalLeadClient<$Result.GetResult<Prisma.$RentalLeadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RentalLead.
     * @param {RentalLeadUpdateArgs} args - Arguments to update one RentalLead.
     * @example
     * // Update one RentalLead
     * const rentalLead = await prisma.rentalLead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RentalLeadUpdateArgs>(args: SelectSubset<T, RentalLeadUpdateArgs<ExtArgs>>): Prisma__RentalLeadClient<$Result.GetResult<Prisma.$RentalLeadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RentalLeads.
     * @param {RentalLeadDeleteManyArgs} args - Arguments to filter RentalLeads to delete.
     * @example
     * // Delete a few RentalLeads
     * const { count } = await prisma.rentalLead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RentalLeadDeleteManyArgs>(args?: SelectSubset<T, RentalLeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RentalLeads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalLeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RentalLeads
     * const rentalLead = await prisma.rentalLead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RentalLeadUpdateManyArgs>(args: SelectSubset<T, RentalLeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RentalLeads and returns the data updated in the database.
     * @param {RentalLeadUpdateManyAndReturnArgs} args - Arguments to update many RentalLeads.
     * @example
     * // Update many RentalLeads
     * const rentalLead = await prisma.rentalLead.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RentalLeads and only return the `id`
     * const rentalLeadWithIdOnly = await prisma.rentalLead.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RentalLeadUpdateManyAndReturnArgs>(args: SelectSubset<T, RentalLeadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalLeadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RentalLead.
     * @param {RentalLeadUpsertArgs} args - Arguments to update or create a RentalLead.
     * @example
     * // Update or create a RentalLead
     * const rentalLead = await prisma.rentalLead.upsert({
     *   create: {
     *     // ... data to create a RentalLead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RentalLead we want to update
     *   }
     * })
     */
    upsert<T extends RentalLeadUpsertArgs>(args: SelectSubset<T, RentalLeadUpsertArgs<ExtArgs>>): Prisma__RentalLeadClient<$Result.GetResult<Prisma.$RentalLeadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RentalLeads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalLeadCountArgs} args - Arguments to filter RentalLeads to count.
     * @example
     * // Count the number of RentalLeads
     * const count = await prisma.rentalLead.count({
     *   where: {
     *     // ... the filter for the RentalLeads we want to count
     *   }
     * })
    **/
    count<T extends RentalLeadCountArgs>(
      args?: Subset<T, RentalLeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RentalLeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RentalLead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalLeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RentalLeadAggregateArgs>(args: Subset<T, RentalLeadAggregateArgs>): Prisma.PrismaPromise<GetRentalLeadAggregateType<T>>

    /**
     * Group by RentalLead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalLeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RentalLeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RentalLeadGroupByArgs['orderBy'] }
        : { orderBy?: RentalLeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RentalLeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRentalLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RentalLead model
   */
  readonly fields: RentalLeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RentalLead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RentalLeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedTo<T extends RentalLead$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, RentalLead$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RentalLead model
   */
  interface RentalLeadFieldRefs {
    readonly id: FieldRef<"RentalLead", 'String'>
    readonly name: FieldRef<"RentalLead", 'String'>
    readonly email: FieldRef<"RentalLead", 'String'>
    readonly phone: FieldRef<"RentalLead", 'String'>
    readonly countryCode: FieldRef<"RentalLead", 'String'>
    readonly propertyType: FieldRef<"RentalLead", 'String'>
    readonly bedrooms: FieldRef<"RentalLead", 'String'>
    readonly budget: FieldRef<"RentalLead", 'String'>
    readonly rentalDuration: FieldRef<"RentalLead", 'String'>
    readonly preferredAreas: FieldRef<"RentalLead", 'String'>
    readonly moveInDate: FieldRef<"RentalLead", 'String'>
    readonly furnished: FieldRef<"RentalLead", 'String'>
    readonly pets: FieldRef<"RentalLead", 'String'>
    readonly message: FieldRef<"RentalLead", 'String'>
    readonly newsletter: FieldRef<"RentalLead", 'Boolean'>
    readonly status: FieldRef<"RentalLead", 'RentalLeadStatus'>
    readonly assignedToId: FieldRef<"RentalLead", 'String'>
    readonly ipAddress: FieldRef<"RentalLead", 'String'>
    readonly userAgent: FieldRef<"RentalLead", 'String'>
    readonly source: FieldRef<"RentalLead", 'String'>
    readonly createdAt: FieldRef<"RentalLead", 'DateTime'>
    readonly updatedAt: FieldRef<"RentalLead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RentalLead findUnique
   */
  export type RentalLeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalLead
     */
    select?: RentalLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalLead
     */
    omit?: RentalLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalLeadInclude<ExtArgs> | null
    /**
     * Filter, which RentalLead to fetch.
     */
    where: RentalLeadWhereUniqueInput
  }

  /**
   * RentalLead findUniqueOrThrow
   */
  export type RentalLeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalLead
     */
    select?: RentalLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalLead
     */
    omit?: RentalLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalLeadInclude<ExtArgs> | null
    /**
     * Filter, which RentalLead to fetch.
     */
    where: RentalLeadWhereUniqueInput
  }

  /**
   * RentalLead findFirst
   */
  export type RentalLeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalLead
     */
    select?: RentalLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalLead
     */
    omit?: RentalLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalLeadInclude<ExtArgs> | null
    /**
     * Filter, which RentalLead to fetch.
     */
    where?: RentalLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalLeads to fetch.
     */
    orderBy?: RentalLeadOrderByWithRelationInput | RentalLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RentalLeads.
     */
    cursor?: RentalLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalLeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RentalLeads.
     */
    distinct?: RentalLeadScalarFieldEnum | RentalLeadScalarFieldEnum[]
  }

  /**
   * RentalLead findFirstOrThrow
   */
  export type RentalLeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalLead
     */
    select?: RentalLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalLead
     */
    omit?: RentalLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalLeadInclude<ExtArgs> | null
    /**
     * Filter, which RentalLead to fetch.
     */
    where?: RentalLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalLeads to fetch.
     */
    orderBy?: RentalLeadOrderByWithRelationInput | RentalLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RentalLeads.
     */
    cursor?: RentalLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalLeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RentalLeads.
     */
    distinct?: RentalLeadScalarFieldEnum | RentalLeadScalarFieldEnum[]
  }

  /**
   * RentalLead findMany
   */
  export type RentalLeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalLead
     */
    select?: RentalLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalLead
     */
    omit?: RentalLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalLeadInclude<ExtArgs> | null
    /**
     * Filter, which RentalLeads to fetch.
     */
    where?: RentalLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalLeads to fetch.
     */
    orderBy?: RentalLeadOrderByWithRelationInput | RentalLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RentalLeads.
     */
    cursor?: RentalLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalLeads.
     */
    skip?: number
    distinct?: RentalLeadScalarFieldEnum | RentalLeadScalarFieldEnum[]
  }

  /**
   * RentalLead create
   */
  export type RentalLeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalLead
     */
    select?: RentalLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalLead
     */
    omit?: RentalLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalLeadInclude<ExtArgs> | null
    /**
     * The data needed to create a RentalLead.
     */
    data: XOR<RentalLeadCreateInput, RentalLeadUncheckedCreateInput>
  }

  /**
   * RentalLead createMany
   */
  export type RentalLeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RentalLeads.
     */
    data: RentalLeadCreateManyInput | RentalLeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RentalLead createManyAndReturn
   */
  export type RentalLeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalLead
     */
    select?: RentalLeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RentalLead
     */
    omit?: RentalLeadOmit<ExtArgs> | null
    /**
     * The data used to create many RentalLeads.
     */
    data: RentalLeadCreateManyInput | RentalLeadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalLeadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RentalLead update
   */
  export type RentalLeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalLead
     */
    select?: RentalLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalLead
     */
    omit?: RentalLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalLeadInclude<ExtArgs> | null
    /**
     * The data needed to update a RentalLead.
     */
    data: XOR<RentalLeadUpdateInput, RentalLeadUncheckedUpdateInput>
    /**
     * Choose, which RentalLead to update.
     */
    where: RentalLeadWhereUniqueInput
  }

  /**
   * RentalLead updateMany
   */
  export type RentalLeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RentalLeads.
     */
    data: XOR<RentalLeadUpdateManyMutationInput, RentalLeadUncheckedUpdateManyInput>
    /**
     * Filter which RentalLeads to update
     */
    where?: RentalLeadWhereInput
    /**
     * Limit how many RentalLeads to update.
     */
    limit?: number
  }

  /**
   * RentalLead updateManyAndReturn
   */
  export type RentalLeadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalLead
     */
    select?: RentalLeadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RentalLead
     */
    omit?: RentalLeadOmit<ExtArgs> | null
    /**
     * The data used to update RentalLeads.
     */
    data: XOR<RentalLeadUpdateManyMutationInput, RentalLeadUncheckedUpdateManyInput>
    /**
     * Filter which RentalLeads to update
     */
    where?: RentalLeadWhereInput
    /**
     * Limit how many RentalLeads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalLeadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RentalLead upsert
   */
  export type RentalLeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalLead
     */
    select?: RentalLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalLead
     */
    omit?: RentalLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalLeadInclude<ExtArgs> | null
    /**
     * The filter to search for the RentalLead to update in case it exists.
     */
    where: RentalLeadWhereUniqueInput
    /**
     * In case the RentalLead found by the `where` argument doesn't exist, create a new RentalLead with this data.
     */
    create: XOR<RentalLeadCreateInput, RentalLeadUncheckedCreateInput>
    /**
     * In case the RentalLead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RentalLeadUpdateInput, RentalLeadUncheckedUpdateInput>
  }

  /**
   * RentalLead delete
   */
  export type RentalLeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalLead
     */
    select?: RentalLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalLead
     */
    omit?: RentalLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalLeadInclude<ExtArgs> | null
    /**
     * Filter which RentalLead to delete.
     */
    where: RentalLeadWhereUniqueInput
  }

  /**
   * RentalLead deleteMany
   */
  export type RentalLeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RentalLeads to delete
     */
    where?: RentalLeadWhereInput
    /**
     * Limit how many RentalLeads to delete.
     */
    limit?: number
  }

  /**
   * RentalLead.assignedTo
   */
  export type RentalLead$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * RentalLead without action
   */
  export type RentalLeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalLead
     */
    select?: RentalLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalLead
     */
    omit?: RentalLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalLeadInclude<ExtArgs> | null
  }


  /**
   * Model Blog
   */

  export type AggregateBlog = {
    _count: BlogCountAggregateOutputType | null
    _avg: BlogAvgAggregateOutputType | null
    _sum: BlogSumAggregateOutputType | null
    _min: BlogMinAggregateOutputType | null
    _max: BlogMaxAggregateOutputType | null
  }

  export type BlogAvgAggregateOutputType = {
    internalLinkCount: number | null
  }

  export type BlogSumAggregateOutputType = {
    internalLinkCount: number | null
  }

  export type BlogMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    excerpt: string | null
    content: string | null
    coverImage: string | null
    coverImageAlt: string | null
    tag: string | null
    metaTitle: string | null
    metaDescription: string | null
    categoryId: string | null
    published: boolean | null
    publishedAt: Date | null
    originalContent: string | null
    linkOptimizedAt: Date | null
    internalLinkCount: number | null
    hasDynamicProperties: boolean | null
    poiQueryParams: string | null
    poiTemplateId: string | null
    authorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    excerpt: string | null
    content: string | null
    coverImage: string | null
    coverImageAlt: string | null
    tag: string | null
    metaTitle: string | null
    metaDescription: string | null
    categoryId: string | null
    published: boolean | null
    publishedAt: Date | null
    originalContent: string | null
    linkOptimizedAt: Date | null
    internalLinkCount: number | null
    hasDynamicProperties: boolean | null
    poiQueryParams: string | null
    poiTemplateId: string | null
    authorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    excerpt: number
    content: number
    coverImage: number
    coverImageAlt: number
    tag: number
    metaTitle: number
    metaDescription: number
    categoryId: number
    published: number
    publishedAt: number
    originalContent: number
    linkOptimizedAt: number
    internalLinkCount: number
    hasDynamicProperties: number
    poiQueryParams: number
    poiTemplateId: number
    authorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogAvgAggregateInputType = {
    internalLinkCount?: true
  }

  export type BlogSumAggregateInputType = {
    internalLinkCount?: true
  }

  export type BlogMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    excerpt?: true
    content?: true
    coverImage?: true
    coverImageAlt?: true
    tag?: true
    metaTitle?: true
    metaDescription?: true
    categoryId?: true
    published?: true
    publishedAt?: true
    originalContent?: true
    linkOptimizedAt?: true
    internalLinkCount?: true
    hasDynamicProperties?: true
    poiQueryParams?: true
    poiTemplateId?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    excerpt?: true
    content?: true
    coverImage?: true
    coverImageAlt?: true
    tag?: true
    metaTitle?: true
    metaDescription?: true
    categoryId?: true
    published?: true
    publishedAt?: true
    originalContent?: true
    linkOptimizedAt?: true
    internalLinkCount?: true
    hasDynamicProperties?: true
    poiQueryParams?: true
    poiTemplateId?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    excerpt?: true
    content?: true
    coverImage?: true
    coverImageAlt?: true
    tag?: true
    metaTitle?: true
    metaDescription?: true
    categoryId?: true
    published?: true
    publishedAt?: true
    originalContent?: true
    linkOptimizedAt?: true
    internalLinkCount?: true
    hasDynamicProperties?: true
    poiQueryParams?: true
    poiTemplateId?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blog to aggregate.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blogs
    **/
    _count?: true | BlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogMaxAggregateInputType
  }

  export type GetBlogAggregateType<T extends BlogAggregateArgs> = {
        [P in keyof T & keyof AggregateBlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlog[P]>
      : GetScalarType<T[P], AggregateBlog[P]>
  }




  export type BlogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogWhereInput
    orderBy?: BlogOrderByWithAggregationInput | BlogOrderByWithAggregationInput[]
    by: BlogScalarFieldEnum[] | BlogScalarFieldEnum
    having?: BlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogCountAggregateInputType | true
    _avg?: BlogAvgAggregateInputType
    _sum?: BlogSumAggregateInputType
    _min?: BlogMinAggregateInputType
    _max?: BlogMaxAggregateInputType
  }

  export type BlogGroupByOutputType = {
    id: string
    title: string
    slug: string
    excerpt: string
    content: string
    coverImage: string | null
    coverImageAlt: string | null
    tag: string | null
    metaTitle: string | null
    metaDescription: string | null
    categoryId: string | null
    published: boolean
    publishedAt: Date | null
    originalContent: string | null
    linkOptimizedAt: Date | null
    internalLinkCount: number
    hasDynamicProperties: boolean
    poiQueryParams: string | null
    poiTemplateId: string | null
    authorId: string
    createdAt: Date
    updatedAt: Date
    _count: BlogCountAggregateOutputType | null
    _avg: BlogAvgAggregateOutputType | null
    _sum: BlogSumAggregateOutputType | null
    _min: BlogMinAggregateOutputType | null
    _max: BlogMaxAggregateOutputType | null
  }

  type GetBlogGroupByPayload<T extends BlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogGroupByOutputType[P]>
            : GetScalarType<T[P], BlogGroupByOutputType[P]>
        }
      >
    >


  export type BlogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    excerpt?: boolean
    content?: boolean
    coverImage?: boolean
    coverImageAlt?: boolean
    tag?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    categoryId?: boolean
    published?: boolean
    publishedAt?: boolean
    originalContent?: boolean
    linkOptimizedAt?: boolean
    internalLinkCount?: boolean
    hasDynamicProperties?: boolean
    poiQueryParams?: boolean
    poiTemplateId?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Blog$categoryArgs<ExtArgs>
    linkUsages?: boolean | Blog$linkUsagesArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | BlogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blog"]>

  export type BlogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    excerpt?: boolean
    content?: boolean
    coverImage?: boolean
    coverImageAlt?: boolean
    tag?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    categoryId?: boolean
    published?: boolean
    publishedAt?: boolean
    originalContent?: boolean
    linkOptimizedAt?: boolean
    internalLinkCount?: boolean
    hasDynamicProperties?: boolean
    poiQueryParams?: boolean
    poiTemplateId?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Blog$categoryArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blog"]>

  export type BlogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    excerpt?: boolean
    content?: boolean
    coverImage?: boolean
    coverImageAlt?: boolean
    tag?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    categoryId?: boolean
    published?: boolean
    publishedAt?: boolean
    originalContent?: boolean
    linkOptimizedAt?: boolean
    internalLinkCount?: boolean
    hasDynamicProperties?: boolean
    poiQueryParams?: boolean
    poiTemplateId?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Blog$categoryArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blog"]>

  export type BlogSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    excerpt?: boolean
    content?: boolean
    coverImage?: boolean
    coverImageAlt?: boolean
    tag?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    categoryId?: boolean
    published?: boolean
    publishedAt?: boolean
    originalContent?: boolean
    linkOptimizedAt?: boolean
    internalLinkCount?: boolean
    hasDynamicProperties?: boolean
    poiQueryParams?: boolean
    poiTemplateId?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "excerpt" | "content" | "coverImage" | "coverImageAlt" | "tag" | "metaTitle" | "metaDescription" | "categoryId" | "published" | "publishedAt" | "originalContent" | "linkOptimizedAt" | "internalLinkCount" | "hasDynamicProperties" | "poiQueryParams" | "poiTemplateId" | "authorId" | "createdAt" | "updatedAt", ExtArgs["result"]["blog"]>
  export type BlogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Blog$categoryArgs<ExtArgs>
    linkUsages?: boolean | Blog$linkUsagesArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | BlogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Blog$categoryArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Blog$categoryArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BlogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Blog"
    objects: {
      category: Prisma.$BlogCategoryPayload<ExtArgs> | null
      linkUsages: Prisma.$LinkUsagePayload<ExtArgs>[]
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      excerpt: string
      content: string
      coverImage: string | null
      coverImageAlt: string | null
      tag: string | null
      metaTitle: string | null
      metaDescription: string | null
      categoryId: string | null
      published: boolean
      publishedAt: Date | null
      originalContent: string | null
      linkOptimizedAt: Date | null
      internalLinkCount: number
      hasDynamicProperties: boolean
      poiQueryParams: string | null
      poiTemplateId: string | null
      authorId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blog"]>
    composites: {}
  }

  type BlogGetPayload<S extends boolean | null | undefined | BlogDefaultArgs> = $Result.GetResult<Prisma.$BlogPayload, S>

  type BlogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogCountAggregateInputType | true
    }

  export interface BlogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Blog'], meta: { name: 'Blog' } }
    /**
     * Find zero or one Blog that matches the filter.
     * @param {BlogFindUniqueArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogFindUniqueArgs>(args: SelectSubset<T, BlogFindUniqueArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Blog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogFindUniqueOrThrowArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindFirstArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogFindFirstArgs>(args?: SelectSubset<T, BlogFindFirstArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindFirstOrThrowArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blogs
     * const blogs = await prisma.blog.findMany()
     * 
     * // Get first 10 Blogs
     * const blogs = await prisma.blog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogWithIdOnly = await prisma.blog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogFindManyArgs>(args?: SelectSubset<T, BlogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Blog.
     * @param {BlogCreateArgs} args - Arguments to create a Blog.
     * @example
     * // Create one Blog
     * const Blog = await prisma.blog.create({
     *   data: {
     *     // ... data to create a Blog
     *   }
     * })
     * 
     */
    create<T extends BlogCreateArgs>(args: SelectSubset<T, BlogCreateArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blogs.
     * @param {BlogCreateManyArgs} args - Arguments to create many Blogs.
     * @example
     * // Create many Blogs
     * const blog = await prisma.blog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogCreateManyArgs>(args?: SelectSubset<T, BlogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blogs and returns the data saved in the database.
     * @param {BlogCreateManyAndReturnArgs} args - Arguments to create many Blogs.
     * @example
     * // Create many Blogs
     * const blog = await prisma.blog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blogs and only return the `id`
     * const blogWithIdOnly = await prisma.blog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Blog.
     * @param {BlogDeleteArgs} args - Arguments to delete one Blog.
     * @example
     * // Delete one Blog
     * const Blog = await prisma.blog.delete({
     *   where: {
     *     // ... filter to delete one Blog
     *   }
     * })
     * 
     */
    delete<T extends BlogDeleteArgs>(args: SelectSubset<T, BlogDeleteArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Blog.
     * @param {BlogUpdateArgs} args - Arguments to update one Blog.
     * @example
     * // Update one Blog
     * const blog = await prisma.blog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogUpdateArgs>(args: SelectSubset<T, BlogUpdateArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blogs.
     * @param {BlogDeleteManyArgs} args - Arguments to filter Blogs to delete.
     * @example
     * // Delete a few Blogs
     * const { count } = await prisma.blog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogDeleteManyArgs>(args?: SelectSubset<T, BlogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blogs
     * const blog = await prisma.blog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogUpdateManyArgs>(args: SelectSubset<T, BlogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogs and returns the data updated in the database.
     * @param {BlogUpdateManyAndReturnArgs} args - Arguments to update many Blogs.
     * @example
     * // Update many Blogs
     * const blog = await prisma.blog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Blogs and only return the `id`
     * const blogWithIdOnly = await prisma.blog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Blog.
     * @param {BlogUpsertArgs} args - Arguments to update or create a Blog.
     * @example
     * // Update or create a Blog
     * const blog = await prisma.blog.upsert({
     *   create: {
     *     // ... data to create a Blog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blog we want to update
     *   }
     * })
     */
    upsert<T extends BlogUpsertArgs>(args: SelectSubset<T, BlogUpsertArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCountArgs} args - Arguments to filter Blogs to count.
     * @example
     * // Count the number of Blogs
     * const count = await prisma.blog.count({
     *   where: {
     *     // ... the filter for the Blogs we want to count
     *   }
     * })
    **/
    count<T extends BlogCountArgs>(
      args?: Subset<T, BlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogAggregateArgs>(args: Subset<T, BlogAggregateArgs>): Prisma.PrismaPromise<GetBlogAggregateType<T>>

    /**
     * Group by Blog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogGroupByArgs['orderBy'] }
        : { orderBy?: BlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Blog model
   */
  readonly fields: BlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Blog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends Blog$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Blog$categoryArgs<ExtArgs>>): Prisma__BlogCategoryClient<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    linkUsages<T extends Blog$linkUsagesArgs<ExtArgs> = {}>(args?: Subset<T, Blog$linkUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Blog model
   */
  interface BlogFieldRefs {
    readonly id: FieldRef<"Blog", 'String'>
    readonly title: FieldRef<"Blog", 'String'>
    readonly slug: FieldRef<"Blog", 'String'>
    readonly excerpt: FieldRef<"Blog", 'String'>
    readonly content: FieldRef<"Blog", 'String'>
    readonly coverImage: FieldRef<"Blog", 'String'>
    readonly coverImageAlt: FieldRef<"Blog", 'String'>
    readonly tag: FieldRef<"Blog", 'String'>
    readonly metaTitle: FieldRef<"Blog", 'String'>
    readonly metaDescription: FieldRef<"Blog", 'String'>
    readonly categoryId: FieldRef<"Blog", 'String'>
    readonly published: FieldRef<"Blog", 'Boolean'>
    readonly publishedAt: FieldRef<"Blog", 'DateTime'>
    readonly originalContent: FieldRef<"Blog", 'String'>
    readonly linkOptimizedAt: FieldRef<"Blog", 'DateTime'>
    readonly internalLinkCount: FieldRef<"Blog", 'Int'>
    readonly hasDynamicProperties: FieldRef<"Blog", 'Boolean'>
    readonly poiQueryParams: FieldRef<"Blog", 'String'>
    readonly poiTemplateId: FieldRef<"Blog", 'String'>
    readonly authorId: FieldRef<"Blog", 'String'>
    readonly createdAt: FieldRef<"Blog", 'DateTime'>
    readonly updatedAt: FieldRef<"Blog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Blog findUnique
   */
  export type BlogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog findUniqueOrThrow
   */
  export type BlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog findFirst
   */
  export type BlogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blogs.
     */
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * Blog findFirstOrThrow
   */
  export type BlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blogs.
     */
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * Blog findMany
   */
  export type BlogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blogs to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * Blog create
   */
  export type BlogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * The data needed to create a Blog.
     */
    data: XOR<BlogCreateInput, BlogUncheckedCreateInput>
  }

  /**
   * Blog createMany
   */
  export type BlogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blogs.
     */
    data: BlogCreateManyInput | BlogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Blog createManyAndReturn
   */
  export type BlogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * The data used to create many Blogs.
     */
    data: BlogCreateManyInput | BlogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Blog update
   */
  export type BlogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * The data needed to update a Blog.
     */
    data: XOR<BlogUpdateInput, BlogUncheckedUpdateInput>
    /**
     * Choose, which Blog to update.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog updateMany
   */
  export type BlogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blogs.
     */
    data: XOR<BlogUpdateManyMutationInput, BlogUncheckedUpdateManyInput>
    /**
     * Filter which Blogs to update
     */
    where?: BlogWhereInput
    /**
     * Limit how many Blogs to update.
     */
    limit?: number
  }

  /**
   * Blog updateManyAndReturn
   */
  export type BlogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * The data used to update Blogs.
     */
    data: XOR<BlogUpdateManyMutationInput, BlogUncheckedUpdateManyInput>
    /**
     * Filter which Blogs to update
     */
    where?: BlogWhereInput
    /**
     * Limit how many Blogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Blog upsert
   */
  export type BlogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * The filter to search for the Blog to update in case it exists.
     */
    where: BlogWhereUniqueInput
    /**
     * In case the Blog found by the `where` argument doesn't exist, create a new Blog with this data.
     */
    create: XOR<BlogCreateInput, BlogUncheckedCreateInput>
    /**
     * In case the Blog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogUpdateInput, BlogUncheckedUpdateInput>
  }

  /**
   * Blog delete
   */
  export type BlogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter which Blog to delete.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog deleteMany
   */
  export type BlogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blogs to delete
     */
    where?: BlogWhereInput
    /**
     * Limit how many Blogs to delete.
     */
    limit?: number
  }

  /**
   * Blog.category
   */
  export type Blog$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
    where?: BlogCategoryWhereInput
  }

  /**
   * Blog.linkUsages
   */
  export type Blog$linkUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkUsage
     */
    select?: LinkUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkUsage
     */
    omit?: LinkUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkUsageInclude<ExtArgs> | null
    where?: LinkUsageWhereInput
    orderBy?: LinkUsageOrderByWithRelationInput | LinkUsageOrderByWithRelationInput[]
    cursor?: LinkUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LinkUsageScalarFieldEnum | LinkUsageScalarFieldEnum[]
  }

  /**
   * Blog without action
   */
  export type BlogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
  }


  /**
   * Model BlogCategory
   */

  export type AggregateBlogCategory = {
    _count: BlogCategoryCountAggregateOutputType | null
    _avg: BlogCategoryAvgAggregateOutputType | null
    _sum: BlogCategorySumAggregateOutputType | null
    _min: BlogCategoryMinAggregateOutputType | null
    _max: BlogCategoryMaxAggregateOutputType | null
  }

  export type BlogCategoryAvgAggregateOutputType = {
    order: number | null
  }

  export type BlogCategorySumAggregateOutputType = {
    order: number | null
  }

  export type BlogCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    parentId: string | null
    metaTitle: string | null
    metaDescription: string | null
    icon: string | null
    color: string | null
    order: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    parentId: string | null
    metaTitle: string | null
    metaDescription: string | null
    icon: string | null
    color: string | null
    order: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogCategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    parentId: number
    metaTitle: number
    metaDescription: number
    icon: number
    color: number
    order: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogCategoryAvgAggregateInputType = {
    order?: true
  }

  export type BlogCategorySumAggregateInputType = {
    order?: true
  }

  export type BlogCategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    parentId?: true
    metaTitle?: true
    metaDescription?: true
    icon?: true
    color?: true
    order?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    parentId?: true
    metaTitle?: true
    metaDescription?: true
    icon?: true
    color?: true
    order?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogCategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    parentId?: true
    metaTitle?: true
    metaDescription?: true
    icon?: true
    color?: true
    order?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogCategory to aggregate.
     */
    where?: BlogCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogCategories to fetch.
     */
    orderBy?: BlogCategoryOrderByWithRelationInput | BlogCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogCategories
    **/
    _count?: true | BlogCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogCategoryMaxAggregateInputType
  }

  export type GetBlogCategoryAggregateType<T extends BlogCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogCategory[P]>
      : GetScalarType<T[P], AggregateBlogCategory[P]>
  }




  export type BlogCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogCategoryWhereInput
    orderBy?: BlogCategoryOrderByWithAggregationInput | BlogCategoryOrderByWithAggregationInput[]
    by: BlogCategoryScalarFieldEnum[] | BlogCategoryScalarFieldEnum
    having?: BlogCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogCategoryCountAggregateInputType | true
    _avg?: BlogCategoryAvgAggregateInputType
    _sum?: BlogCategorySumAggregateInputType
    _min?: BlogCategoryMinAggregateInputType
    _max?: BlogCategoryMaxAggregateInputType
  }

  export type BlogCategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    parentId: string | null
    metaTitle: string | null
    metaDescription: string | null
    icon: string | null
    color: string | null
    order: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BlogCategoryCountAggregateOutputType | null
    _avg: BlogCategoryAvgAggregateOutputType | null
    _sum: BlogCategorySumAggregateOutputType | null
    _min: BlogCategoryMinAggregateOutputType | null
    _max: BlogCategoryMaxAggregateOutputType | null
  }

  type GetBlogCategoryGroupByPayload<T extends BlogCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], BlogCategoryGroupByOutputType[P]>
        }
      >
    >


  export type BlogCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    icon?: boolean
    color?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | BlogCategory$parentArgs<ExtArgs>
    children?: boolean | BlogCategory$childrenArgs<ExtArgs>
    blogs?: boolean | BlogCategory$blogsArgs<ExtArgs>
    _count?: boolean | BlogCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogCategory"]>

  export type BlogCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    icon?: boolean
    color?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | BlogCategory$parentArgs<ExtArgs>
  }, ExtArgs["result"]["blogCategory"]>

  export type BlogCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    icon?: boolean
    color?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | BlogCategory$parentArgs<ExtArgs>
  }, ExtArgs["result"]["blogCategory"]>

  export type BlogCategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    icon?: boolean
    color?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlogCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "parentId" | "metaTitle" | "metaDescription" | "icon" | "color" | "order" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["blogCategory"]>
  export type BlogCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | BlogCategory$parentArgs<ExtArgs>
    children?: boolean | BlogCategory$childrenArgs<ExtArgs>
    blogs?: boolean | BlogCategory$blogsArgs<ExtArgs>
    _count?: boolean | BlogCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlogCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | BlogCategory$parentArgs<ExtArgs>
  }
  export type BlogCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | BlogCategory$parentArgs<ExtArgs>
  }

  export type $BlogCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogCategory"
    objects: {
      parent: Prisma.$BlogCategoryPayload<ExtArgs> | null
      children: Prisma.$BlogCategoryPayload<ExtArgs>[]
      blogs: Prisma.$BlogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      parentId: string | null
      metaTitle: string | null
      metaDescription: string | null
      icon: string | null
      color: string | null
      order: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blogCategory"]>
    composites: {}
  }

  type BlogCategoryGetPayload<S extends boolean | null | undefined | BlogCategoryDefaultArgs> = $Result.GetResult<Prisma.$BlogCategoryPayload, S>

  type BlogCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogCategoryCountAggregateInputType | true
    }

  export interface BlogCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogCategory'], meta: { name: 'BlogCategory' } }
    /**
     * Find zero or one BlogCategory that matches the filter.
     * @param {BlogCategoryFindUniqueArgs} args - Arguments to find a BlogCategory
     * @example
     * // Get one BlogCategory
     * const blogCategory = await prisma.blogCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogCategoryFindUniqueArgs>(args: SelectSubset<T, BlogCategoryFindUniqueArgs<ExtArgs>>): Prisma__BlogCategoryClient<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogCategoryFindUniqueOrThrowArgs} args - Arguments to find a BlogCategory
     * @example
     * // Get one BlogCategory
     * const blogCategory = await prisma.blogCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogCategoryClient<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCategoryFindFirstArgs} args - Arguments to find a BlogCategory
     * @example
     * // Get one BlogCategory
     * const blogCategory = await prisma.blogCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogCategoryFindFirstArgs>(args?: SelectSubset<T, BlogCategoryFindFirstArgs<ExtArgs>>): Prisma__BlogCategoryClient<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCategoryFindFirstOrThrowArgs} args - Arguments to find a BlogCategory
     * @example
     * // Get one BlogCategory
     * const blogCategory = await prisma.blogCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogCategoryClient<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogCategories
     * const blogCategories = await prisma.blogCategory.findMany()
     * 
     * // Get first 10 BlogCategories
     * const blogCategories = await prisma.blogCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogCategoryWithIdOnly = await prisma.blogCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogCategoryFindManyArgs>(args?: SelectSubset<T, BlogCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogCategory.
     * @param {BlogCategoryCreateArgs} args - Arguments to create a BlogCategory.
     * @example
     * // Create one BlogCategory
     * const BlogCategory = await prisma.blogCategory.create({
     *   data: {
     *     // ... data to create a BlogCategory
     *   }
     * })
     * 
     */
    create<T extends BlogCategoryCreateArgs>(args: SelectSubset<T, BlogCategoryCreateArgs<ExtArgs>>): Prisma__BlogCategoryClient<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogCategories.
     * @param {BlogCategoryCreateManyArgs} args - Arguments to create many BlogCategories.
     * @example
     * // Create many BlogCategories
     * const blogCategory = await prisma.blogCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogCategoryCreateManyArgs>(args?: SelectSubset<T, BlogCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogCategories and returns the data saved in the database.
     * @param {BlogCategoryCreateManyAndReturnArgs} args - Arguments to create many BlogCategories.
     * @example
     * // Create many BlogCategories
     * const blogCategory = await prisma.blogCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogCategories and only return the `id`
     * const blogCategoryWithIdOnly = await prisma.blogCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlogCategory.
     * @param {BlogCategoryDeleteArgs} args - Arguments to delete one BlogCategory.
     * @example
     * // Delete one BlogCategory
     * const BlogCategory = await prisma.blogCategory.delete({
     *   where: {
     *     // ... filter to delete one BlogCategory
     *   }
     * })
     * 
     */
    delete<T extends BlogCategoryDeleteArgs>(args: SelectSubset<T, BlogCategoryDeleteArgs<ExtArgs>>): Prisma__BlogCategoryClient<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogCategory.
     * @param {BlogCategoryUpdateArgs} args - Arguments to update one BlogCategory.
     * @example
     * // Update one BlogCategory
     * const blogCategory = await prisma.blogCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogCategoryUpdateArgs>(args: SelectSubset<T, BlogCategoryUpdateArgs<ExtArgs>>): Prisma__BlogCategoryClient<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogCategories.
     * @param {BlogCategoryDeleteManyArgs} args - Arguments to filter BlogCategories to delete.
     * @example
     * // Delete a few BlogCategories
     * const { count } = await prisma.blogCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogCategoryDeleteManyArgs>(args?: SelectSubset<T, BlogCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogCategories
     * const blogCategory = await prisma.blogCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogCategoryUpdateManyArgs>(args: SelectSubset<T, BlogCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogCategories and returns the data updated in the database.
     * @param {BlogCategoryUpdateManyAndReturnArgs} args - Arguments to update many BlogCategories.
     * @example
     * // Update many BlogCategories
     * const blogCategory = await prisma.blogCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlogCategories and only return the `id`
     * const blogCategoryWithIdOnly = await prisma.blogCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlogCategory.
     * @param {BlogCategoryUpsertArgs} args - Arguments to update or create a BlogCategory.
     * @example
     * // Update or create a BlogCategory
     * const blogCategory = await prisma.blogCategory.upsert({
     *   create: {
     *     // ... data to create a BlogCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogCategory we want to update
     *   }
     * })
     */
    upsert<T extends BlogCategoryUpsertArgs>(args: SelectSubset<T, BlogCategoryUpsertArgs<ExtArgs>>): Prisma__BlogCategoryClient<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlogCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCategoryCountArgs} args - Arguments to filter BlogCategories to count.
     * @example
     * // Count the number of BlogCategories
     * const count = await prisma.blogCategory.count({
     *   where: {
     *     // ... the filter for the BlogCategories we want to count
     *   }
     * })
    **/
    count<T extends BlogCategoryCountArgs>(
      args?: Subset<T, BlogCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogCategoryAggregateArgs>(args: Subset<T, BlogCategoryAggregateArgs>): Prisma.PrismaPromise<GetBlogCategoryAggregateType<T>>

    /**
     * Group by BlogCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogCategoryGroupByArgs['orderBy'] }
        : { orderBy?: BlogCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogCategory model
   */
  readonly fields: BlogCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends BlogCategory$parentArgs<ExtArgs> = {}>(args?: Subset<T, BlogCategory$parentArgs<ExtArgs>>): Prisma__BlogCategoryClient<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends BlogCategory$childrenArgs<ExtArgs> = {}>(args?: Subset<T, BlogCategory$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blogs<T extends BlogCategory$blogsArgs<ExtArgs> = {}>(args?: Subset<T, BlogCategory$blogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogCategory model
   */
  interface BlogCategoryFieldRefs {
    readonly id: FieldRef<"BlogCategory", 'String'>
    readonly name: FieldRef<"BlogCategory", 'String'>
    readonly slug: FieldRef<"BlogCategory", 'String'>
    readonly description: FieldRef<"BlogCategory", 'String'>
    readonly parentId: FieldRef<"BlogCategory", 'String'>
    readonly metaTitle: FieldRef<"BlogCategory", 'String'>
    readonly metaDescription: FieldRef<"BlogCategory", 'String'>
    readonly icon: FieldRef<"BlogCategory", 'String'>
    readonly color: FieldRef<"BlogCategory", 'String'>
    readonly order: FieldRef<"BlogCategory", 'Int'>
    readonly isActive: FieldRef<"BlogCategory", 'Boolean'>
    readonly createdAt: FieldRef<"BlogCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"BlogCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogCategory findUnique
   */
  export type BlogCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BlogCategory to fetch.
     */
    where: BlogCategoryWhereUniqueInput
  }

  /**
   * BlogCategory findUniqueOrThrow
   */
  export type BlogCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BlogCategory to fetch.
     */
    where: BlogCategoryWhereUniqueInput
  }

  /**
   * BlogCategory findFirst
   */
  export type BlogCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BlogCategory to fetch.
     */
    where?: BlogCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogCategories to fetch.
     */
    orderBy?: BlogCategoryOrderByWithRelationInput | BlogCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogCategories.
     */
    cursor?: BlogCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogCategories.
     */
    distinct?: BlogCategoryScalarFieldEnum | BlogCategoryScalarFieldEnum[]
  }

  /**
   * BlogCategory findFirstOrThrow
   */
  export type BlogCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BlogCategory to fetch.
     */
    where?: BlogCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogCategories to fetch.
     */
    orderBy?: BlogCategoryOrderByWithRelationInput | BlogCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogCategories.
     */
    cursor?: BlogCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogCategories.
     */
    distinct?: BlogCategoryScalarFieldEnum | BlogCategoryScalarFieldEnum[]
  }

  /**
   * BlogCategory findMany
   */
  export type BlogCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
    /**
     * Filter, which BlogCategories to fetch.
     */
    where?: BlogCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogCategories to fetch.
     */
    orderBy?: BlogCategoryOrderByWithRelationInput | BlogCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogCategories.
     */
    cursor?: BlogCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogCategories.
     */
    skip?: number
    distinct?: BlogCategoryScalarFieldEnum | BlogCategoryScalarFieldEnum[]
  }

  /**
   * BlogCategory create
   */
  export type BlogCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogCategory.
     */
    data: XOR<BlogCategoryCreateInput, BlogCategoryUncheckedCreateInput>
  }

  /**
   * BlogCategory createMany
   */
  export type BlogCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogCategories.
     */
    data: BlogCategoryCreateManyInput | BlogCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogCategory createManyAndReturn
   */
  export type BlogCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many BlogCategories.
     */
    data: BlogCategoryCreateManyInput | BlogCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogCategory update
   */
  export type BlogCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogCategory.
     */
    data: XOR<BlogCategoryUpdateInput, BlogCategoryUncheckedUpdateInput>
    /**
     * Choose, which BlogCategory to update.
     */
    where: BlogCategoryWhereUniqueInput
  }

  /**
   * BlogCategory updateMany
   */
  export type BlogCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogCategories.
     */
    data: XOR<BlogCategoryUpdateManyMutationInput, BlogCategoryUncheckedUpdateManyInput>
    /**
     * Filter which BlogCategories to update
     */
    where?: BlogCategoryWhereInput
    /**
     * Limit how many BlogCategories to update.
     */
    limit?: number
  }

  /**
   * BlogCategory updateManyAndReturn
   */
  export type BlogCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * The data used to update BlogCategories.
     */
    data: XOR<BlogCategoryUpdateManyMutationInput, BlogCategoryUncheckedUpdateManyInput>
    /**
     * Filter which BlogCategories to update
     */
    where?: BlogCategoryWhereInput
    /**
     * Limit how many BlogCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogCategory upsert
   */
  export type BlogCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogCategory to update in case it exists.
     */
    where: BlogCategoryWhereUniqueInput
    /**
     * In case the BlogCategory found by the `where` argument doesn't exist, create a new BlogCategory with this data.
     */
    create: XOR<BlogCategoryCreateInput, BlogCategoryUncheckedCreateInput>
    /**
     * In case the BlogCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogCategoryUpdateInput, BlogCategoryUncheckedUpdateInput>
  }

  /**
   * BlogCategory delete
   */
  export type BlogCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
    /**
     * Filter which BlogCategory to delete.
     */
    where: BlogCategoryWhereUniqueInput
  }

  /**
   * BlogCategory deleteMany
   */
  export type BlogCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogCategories to delete
     */
    where?: BlogCategoryWhereInput
    /**
     * Limit how many BlogCategories to delete.
     */
    limit?: number
  }

  /**
   * BlogCategory.parent
   */
  export type BlogCategory$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
    where?: BlogCategoryWhereInput
  }

  /**
   * BlogCategory.children
   */
  export type BlogCategory$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
    where?: BlogCategoryWhereInput
    orderBy?: BlogCategoryOrderByWithRelationInput | BlogCategoryOrderByWithRelationInput[]
    cursor?: BlogCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogCategoryScalarFieldEnum | BlogCategoryScalarFieldEnum[]
  }

  /**
   * BlogCategory.blogs
   */
  export type BlogCategory$blogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogInclude<ExtArgs> | null
    where?: BlogWhereInput
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    cursor?: BlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * BlogCategory without action
   */
  export type BlogCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCategory
     */
    select?: BlogCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogCategory
     */
    omit?: BlogCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogCategoryInclude<ExtArgs> | null
  }


  /**
   * Model PropertySubmission
   */

  export type AggregatePropertySubmission = {
    _count: PropertySubmissionCountAggregateOutputType | null
    _avg: PropertySubmissionAvgAggregateOutputType | null
    _sum: PropertySubmissionSumAggregateOutputType | null
    _min: PropertySubmissionMinAggregateOutputType | null
    _max: PropertySubmissionMaxAggregateOutputType | null
  }

  export type PropertySubmissionAvgAggregateOutputType = {
    beds: number | null
    baths: number | null
    sqft: number | null
    commissionRate: number | null
  }

  export type PropertySubmissionSumAggregateOutputType = {
    beds: number | null
    baths: number | null
    sqft: number | null
    commissionRate: number | null
  }

  export type PropertySubmissionMinAggregateOutputType = {
    id: string | null
    ownerName: string | null
    ownerEmail: string | null
    ownerPhone: string | null
    ownerCountryCode: string | null
    accessToken: string | null
    propertyTitle: string | null
    propertyCategory: $Enums.PropertyCategory | null
    propertyType: $Enums.PropertyType | null
    location: string | null
    askingPrice: string | null
    beds: number | null
    baths: number | null
    sqft: number | null
    description: string | null
    exclusiveRights: boolean | null
    commissionRate: number | null
    agreementAccepted: boolean | null
    status: $Enums.SubmissionStatus | null
    reviewNotes: string | null
    reviewedBy: string | null
    reviewedByName: string | null
    reviewedAt: Date | null
    imagesApprovedAt: Date | null
    imagesApprovedBy: string | null
    publishedAt: Date | null
    publishedBy: string | null
    convertedPropertyId: string | null
    ipAddress: string | null
    userAgent: string | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertySubmissionMaxAggregateOutputType = {
    id: string | null
    ownerName: string | null
    ownerEmail: string | null
    ownerPhone: string | null
    ownerCountryCode: string | null
    accessToken: string | null
    propertyTitle: string | null
    propertyCategory: $Enums.PropertyCategory | null
    propertyType: $Enums.PropertyType | null
    location: string | null
    askingPrice: string | null
    beds: number | null
    baths: number | null
    sqft: number | null
    description: string | null
    exclusiveRights: boolean | null
    commissionRate: number | null
    agreementAccepted: boolean | null
    status: $Enums.SubmissionStatus | null
    reviewNotes: string | null
    reviewedBy: string | null
    reviewedByName: string | null
    reviewedAt: Date | null
    imagesApprovedAt: Date | null
    imagesApprovedBy: string | null
    publishedAt: Date | null
    publishedBy: string | null
    convertedPropertyId: string | null
    ipAddress: string | null
    userAgent: string | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertySubmissionCountAggregateOutputType = {
    id: number
    ownerName: number
    ownerEmail: number
    ownerPhone: number
    ownerCountryCode: number
    accessToken: number
    propertyTitle: number
    propertyCategory: number
    propertyType: number
    location: number
    askingPrice: number
    beds: number
    baths: number
    sqft: number
    description: number
    images: number
    exclusiveRights: number
    commissionRate: number
    agreementAccepted: number
    status: number
    reviewNotes: number
    reviewedBy: number
    reviewedByName: number
    reviewedAt: number
    imagesApprovedAt: number
    imagesApprovedBy: number
    publishedAt: number
    publishedBy: number
    convertedPropertyId: number
    ipAddress: number
    userAgent: number
    source: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertySubmissionAvgAggregateInputType = {
    beds?: true
    baths?: true
    sqft?: true
    commissionRate?: true
  }

  export type PropertySubmissionSumAggregateInputType = {
    beds?: true
    baths?: true
    sqft?: true
    commissionRate?: true
  }

  export type PropertySubmissionMinAggregateInputType = {
    id?: true
    ownerName?: true
    ownerEmail?: true
    ownerPhone?: true
    ownerCountryCode?: true
    accessToken?: true
    propertyTitle?: true
    propertyCategory?: true
    propertyType?: true
    location?: true
    askingPrice?: true
    beds?: true
    baths?: true
    sqft?: true
    description?: true
    exclusiveRights?: true
    commissionRate?: true
    agreementAccepted?: true
    status?: true
    reviewNotes?: true
    reviewedBy?: true
    reviewedByName?: true
    reviewedAt?: true
    imagesApprovedAt?: true
    imagesApprovedBy?: true
    publishedAt?: true
    publishedBy?: true
    convertedPropertyId?: true
    ipAddress?: true
    userAgent?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertySubmissionMaxAggregateInputType = {
    id?: true
    ownerName?: true
    ownerEmail?: true
    ownerPhone?: true
    ownerCountryCode?: true
    accessToken?: true
    propertyTitle?: true
    propertyCategory?: true
    propertyType?: true
    location?: true
    askingPrice?: true
    beds?: true
    baths?: true
    sqft?: true
    description?: true
    exclusiveRights?: true
    commissionRate?: true
    agreementAccepted?: true
    status?: true
    reviewNotes?: true
    reviewedBy?: true
    reviewedByName?: true
    reviewedAt?: true
    imagesApprovedAt?: true
    imagesApprovedBy?: true
    publishedAt?: true
    publishedBy?: true
    convertedPropertyId?: true
    ipAddress?: true
    userAgent?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertySubmissionCountAggregateInputType = {
    id?: true
    ownerName?: true
    ownerEmail?: true
    ownerPhone?: true
    ownerCountryCode?: true
    accessToken?: true
    propertyTitle?: true
    propertyCategory?: true
    propertyType?: true
    location?: true
    askingPrice?: true
    beds?: true
    baths?: true
    sqft?: true
    description?: true
    images?: true
    exclusiveRights?: true
    commissionRate?: true
    agreementAccepted?: true
    status?: true
    reviewNotes?: true
    reviewedBy?: true
    reviewedByName?: true
    reviewedAt?: true
    imagesApprovedAt?: true
    imagesApprovedBy?: true
    publishedAt?: true
    publishedBy?: true
    convertedPropertyId?: true
    ipAddress?: true
    userAgent?: true
    source?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertySubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertySubmission to aggregate.
     */
    where?: PropertySubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySubmissions to fetch.
     */
    orderBy?: PropertySubmissionOrderByWithRelationInput | PropertySubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertySubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertySubmissions
    **/
    _count?: true | PropertySubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertySubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertySubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertySubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertySubmissionMaxAggregateInputType
  }

  export type GetPropertySubmissionAggregateType<T extends PropertySubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertySubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertySubmission[P]>
      : GetScalarType<T[P], AggregatePropertySubmission[P]>
  }




  export type PropertySubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertySubmissionWhereInput
    orderBy?: PropertySubmissionOrderByWithAggregationInput | PropertySubmissionOrderByWithAggregationInput[]
    by: PropertySubmissionScalarFieldEnum[] | PropertySubmissionScalarFieldEnum
    having?: PropertySubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertySubmissionCountAggregateInputType | true
    _avg?: PropertySubmissionAvgAggregateInputType
    _sum?: PropertySubmissionSumAggregateInputType
    _min?: PropertySubmissionMinAggregateInputType
    _max?: PropertySubmissionMaxAggregateInputType
  }

  export type PropertySubmissionGroupByOutputType = {
    id: string
    ownerName: string
    ownerEmail: string
    ownerPhone: string
    ownerCountryCode: string
    accessToken: string
    propertyTitle: string
    propertyCategory: $Enums.PropertyCategory
    propertyType: $Enums.PropertyType
    location: string
    askingPrice: string
    beds: number
    baths: number
    sqft: number
    description: string
    images: string[]
    exclusiveRights: boolean
    commissionRate: number
    agreementAccepted: boolean
    status: $Enums.SubmissionStatus
    reviewNotes: string | null
    reviewedBy: string | null
    reviewedByName: string | null
    reviewedAt: Date | null
    imagesApprovedAt: Date | null
    imagesApprovedBy: string | null
    publishedAt: Date | null
    publishedBy: string | null
    convertedPropertyId: string | null
    ipAddress: string | null
    userAgent: string | null
    source: string | null
    createdAt: Date
    updatedAt: Date
    _count: PropertySubmissionCountAggregateOutputType | null
    _avg: PropertySubmissionAvgAggregateOutputType | null
    _sum: PropertySubmissionSumAggregateOutputType | null
    _min: PropertySubmissionMinAggregateOutputType | null
    _max: PropertySubmissionMaxAggregateOutputType | null
  }

  type GetPropertySubmissionGroupByPayload<T extends PropertySubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertySubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertySubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertySubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], PropertySubmissionGroupByOutputType[P]>
        }
      >
    >


  export type PropertySubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerName?: boolean
    ownerEmail?: boolean
    ownerPhone?: boolean
    ownerCountryCode?: boolean
    accessToken?: boolean
    propertyTitle?: boolean
    propertyCategory?: boolean
    propertyType?: boolean
    location?: boolean
    askingPrice?: boolean
    beds?: boolean
    baths?: boolean
    sqft?: boolean
    description?: boolean
    images?: boolean
    exclusiveRights?: boolean
    commissionRate?: boolean
    agreementAccepted?: boolean
    status?: boolean
    reviewNotes?: boolean
    reviewedBy?: boolean
    reviewedByName?: boolean
    reviewedAt?: boolean
    imagesApprovedAt?: boolean
    imagesApprovedBy?: boolean
    publishedAt?: boolean
    publishedBy?: boolean
    convertedPropertyId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["propertySubmission"]>

  export type PropertySubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerName?: boolean
    ownerEmail?: boolean
    ownerPhone?: boolean
    ownerCountryCode?: boolean
    accessToken?: boolean
    propertyTitle?: boolean
    propertyCategory?: boolean
    propertyType?: boolean
    location?: boolean
    askingPrice?: boolean
    beds?: boolean
    baths?: boolean
    sqft?: boolean
    description?: boolean
    images?: boolean
    exclusiveRights?: boolean
    commissionRate?: boolean
    agreementAccepted?: boolean
    status?: boolean
    reviewNotes?: boolean
    reviewedBy?: boolean
    reviewedByName?: boolean
    reviewedAt?: boolean
    imagesApprovedAt?: boolean
    imagesApprovedBy?: boolean
    publishedAt?: boolean
    publishedBy?: boolean
    convertedPropertyId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["propertySubmission"]>

  export type PropertySubmissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerName?: boolean
    ownerEmail?: boolean
    ownerPhone?: boolean
    ownerCountryCode?: boolean
    accessToken?: boolean
    propertyTitle?: boolean
    propertyCategory?: boolean
    propertyType?: boolean
    location?: boolean
    askingPrice?: boolean
    beds?: boolean
    baths?: boolean
    sqft?: boolean
    description?: boolean
    images?: boolean
    exclusiveRights?: boolean
    commissionRate?: boolean
    agreementAccepted?: boolean
    status?: boolean
    reviewNotes?: boolean
    reviewedBy?: boolean
    reviewedByName?: boolean
    reviewedAt?: boolean
    imagesApprovedAt?: boolean
    imagesApprovedBy?: boolean
    publishedAt?: boolean
    publishedBy?: boolean
    convertedPropertyId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["propertySubmission"]>

  export type PropertySubmissionSelectScalar = {
    id?: boolean
    ownerName?: boolean
    ownerEmail?: boolean
    ownerPhone?: boolean
    ownerCountryCode?: boolean
    accessToken?: boolean
    propertyTitle?: boolean
    propertyCategory?: boolean
    propertyType?: boolean
    location?: boolean
    askingPrice?: boolean
    beds?: boolean
    baths?: boolean
    sqft?: boolean
    description?: boolean
    images?: boolean
    exclusiveRights?: boolean
    commissionRate?: boolean
    agreementAccepted?: boolean
    status?: boolean
    reviewNotes?: boolean
    reviewedBy?: boolean
    reviewedByName?: boolean
    reviewedAt?: boolean
    imagesApprovedAt?: boolean
    imagesApprovedBy?: boolean
    publishedAt?: boolean
    publishedBy?: boolean
    convertedPropertyId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertySubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ownerName" | "ownerEmail" | "ownerPhone" | "ownerCountryCode" | "accessToken" | "propertyTitle" | "propertyCategory" | "propertyType" | "location" | "askingPrice" | "beds" | "baths" | "sqft" | "description" | "images" | "exclusiveRights" | "commissionRate" | "agreementAccepted" | "status" | "reviewNotes" | "reviewedBy" | "reviewedByName" | "reviewedAt" | "imagesApprovedAt" | "imagesApprovedBy" | "publishedAt" | "publishedBy" | "convertedPropertyId" | "ipAddress" | "userAgent" | "source" | "createdAt" | "updatedAt", ExtArgs["result"]["propertySubmission"]>

  export type $PropertySubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertySubmission"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerName: string
      ownerEmail: string
      ownerPhone: string
      ownerCountryCode: string
      accessToken: string
      propertyTitle: string
      propertyCategory: $Enums.PropertyCategory
      propertyType: $Enums.PropertyType
      location: string
      askingPrice: string
      beds: number
      baths: number
      sqft: number
      description: string
      images: string[]
      exclusiveRights: boolean
      commissionRate: number
      agreementAccepted: boolean
      status: $Enums.SubmissionStatus
      reviewNotes: string | null
      reviewedBy: string | null
      reviewedByName: string | null
      reviewedAt: Date | null
      imagesApprovedAt: Date | null
      imagesApprovedBy: string | null
      publishedAt: Date | null
      publishedBy: string | null
      convertedPropertyId: string | null
      ipAddress: string | null
      userAgent: string | null
      source: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["propertySubmission"]>
    composites: {}
  }

  type PropertySubmissionGetPayload<S extends boolean | null | undefined | PropertySubmissionDefaultArgs> = $Result.GetResult<Prisma.$PropertySubmissionPayload, S>

  type PropertySubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertySubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertySubmissionCountAggregateInputType | true
    }

  export interface PropertySubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertySubmission'], meta: { name: 'PropertySubmission' } }
    /**
     * Find zero or one PropertySubmission that matches the filter.
     * @param {PropertySubmissionFindUniqueArgs} args - Arguments to find a PropertySubmission
     * @example
     * // Get one PropertySubmission
     * const propertySubmission = await prisma.propertySubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertySubmissionFindUniqueArgs>(args: SelectSubset<T, PropertySubmissionFindUniqueArgs<ExtArgs>>): Prisma__PropertySubmissionClient<$Result.GetResult<Prisma.$PropertySubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertySubmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertySubmissionFindUniqueOrThrowArgs} args - Arguments to find a PropertySubmission
     * @example
     * // Get one PropertySubmission
     * const propertySubmission = await prisma.propertySubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertySubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertySubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertySubmissionClient<$Result.GetResult<Prisma.$PropertySubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertySubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubmissionFindFirstArgs} args - Arguments to find a PropertySubmission
     * @example
     * // Get one PropertySubmission
     * const propertySubmission = await prisma.propertySubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertySubmissionFindFirstArgs>(args?: SelectSubset<T, PropertySubmissionFindFirstArgs<ExtArgs>>): Prisma__PropertySubmissionClient<$Result.GetResult<Prisma.$PropertySubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertySubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubmissionFindFirstOrThrowArgs} args - Arguments to find a PropertySubmission
     * @example
     * // Get one PropertySubmission
     * const propertySubmission = await prisma.propertySubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertySubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertySubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertySubmissionClient<$Result.GetResult<Prisma.$PropertySubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertySubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertySubmissions
     * const propertySubmissions = await prisma.propertySubmission.findMany()
     * 
     * // Get first 10 PropertySubmissions
     * const propertySubmissions = await prisma.propertySubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertySubmissionWithIdOnly = await prisma.propertySubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertySubmissionFindManyArgs>(args?: SelectSubset<T, PropertySubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertySubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertySubmission.
     * @param {PropertySubmissionCreateArgs} args - Arguments to create a PropertySubmission.
     * @example
     * // Create one PropertySubmission
     * const PropertySubmission = await prisma.propertySubmission.create({
     *   data: {
     *     // ... data to create a PropertySubmission
     *   }
     * })
     * 
     */
    create<T extends PropertySubmissionCreateArgs>(args: SelectSubset<T, PropertySubmissionCreateArgs<ExtArgs>>): Prisma__PropertySubmissionClient<$Result.GetResult<Prisma.$PropertySubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertySubmissions.
     * @param {PropertySubmissionCreateManyArgs} args - Arguments to create many PropertySubmissions.
     * @example
     * // Create many PropertySubmissions
     * const propertySubmission = await prisma.propertySubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertySubmissionCreateManyArgs>(args?: SelectSubset<T, PropertySubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertySubmissions and returns the data saved in the database.
     * @param {PropertySubmissionCreateManyAndReturnArgs} args - Arguments to create many PropertySubmissions.
     * @example
     * // Create many PropertySubmissions
     * const propertySubmission = await prisma.propertySubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertySubmissions and only return the `id`
     * const propertySubmissionWithIdOnly = await prisma.propertySubmission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertySubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertySubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertySubmissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertySubmission.
     * @param {PropertySubmissionDeleteArgs} args - Arguments to delete one PropertySubmission.
     * @example
     * // Delete one PropertySubmission
     * const PropertySubmission = await prisma.propertySubmission.delete({
     *   where: {
     *     // ... filter to delete one PropertySubmission
     *   }
     * })
     * 
     */
    delete<T extends PropertySubmissionDeleteArgs>(args: SelectSubset<T, PropertySubmissionDeleteArgs<ExtArgs>>): Prisma__PropertySubmissionClient<$Result.GetResult<Prisma.$PropertySubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertySubmission.
     * @param {PropertySubmissionUpdateArgs} args - Arguments to update one PropertySubmission.
     * @example
     * // Update one PropertySubmission
     * const propertySubmission = await prisma.propertySubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertySubmissionUpdateArgs>(args: SelectSubset<T, PropertySubmissionUpdateArgs<ExtArgs>>): Prisma__PropertySubmissionClient<$Result.GetResult<Prisma.$PropertySubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertySubmissions.
     * @param {PropertySubmissionDeleteManyArgs} args - Arguments to filter PropertySubmissions to delete.
     * @example
     * // Delete a few PropertySubmissions
     * const { count } = await prisma.propertySubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertySubmissionDeleteManyArgs>(args?: SelectSubset<T, PropertySubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertySubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertySubmissions
     * const propertySubmission = await prisma.propertySubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertySubmissionUpdateManyArgs>(args: SelectSubset<T, PropertySubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertySubmissions and returns the data updated in the database.
     * @param {PropertySubmissionUpdateManyAndReturnArgs} args - Arguments to update many PropertySubmissions.
     * @example
     * // Update many PropertySubmissions
     * const propertySubmission = await prisma.propertySubmission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertySubmissions and only return the `id`
     * const propertySubmissionWithIdOnly = await prisma.propertySubmission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertySubmissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertySubmissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertySubmissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertySubmission.
     * @param {PropertySubmissionUpsertArgs} args - Arguments to update or create a PropertySubmission.
     * @example
     * // Update or create a PropertySubmission
     * const propertySubmission = await prisma.propertySubmission.upsert({
     *   create: {
     *     // ... data to create a PropertySubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertySubmission we want to update
     *   }
     * })
     */
    upsert<T extends PropertySubmissionUpsertArgs>(args: SelectSubset<T, PropertySubmissionUpsertArgs<ExtArgs>>): Prisma__PropertySubmissionClient<$Result.GetResult<Prisma.$PropertySubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertySubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubmissionCountArgs} args - Arguments to filter PropertySubmissions to count.
     * @example
     * // Count the number of PropertySubmissions
     * const count = await prisma.propertySubmission.count({
     *   where: {
     *     // ... the filter for the PropertySubmissions we want to count
     *   }
     * })
    **/
    count<T extends PropertySubmissionCountArgs>(
      args?: Subset<T, PropertySubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertySubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertySubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertySubmissionAggregateArgs>(args: Subset<T, PropertySubmissionAggregateArgs>): Prisma.PrismaPromise<GetPropertySubmissionAggregateType<T>>

    /**
     * Group by PropertySubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertySubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertySubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertySubmissionGroupByArgs['orderBy'] }
        : { orderBy?: PropertySubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertySubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertySubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertySubmission model
   */
  readonly fields: PropertySubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertySubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertySubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertySubmission model
   */
  interface PropertySubmissionFieldRefs {
    readonly id: FieldRef<"PropertySubmission", 'String'>
    readonly ownerName: FieldRef<"PropertySubmission", 'String'>
    readonly ownerEmail: FieldRef<"PropertySubmission", 'String'>
    readonly ownerPhone: FieldRef<"PropertySubmission", 'String'>
    readonly ownerCountryCode: FieldRef<"PropertySubmission", 'String'>
    readonly accessToken: FieldRef<"PropertySubmission", 'String'>
    readonly propertyTitle: FieldRef<"PropertySubmission", 'String'>
    readonly propertyCategory: FieldRef<"PropertySubmission", 'PropertyCategory'>
    readonly propertyType: FieldRef<"PropertySubmission", 'PropertyType'>
    readonly location: FieldRef<"PropertySubmission", 'String'>
    readonly askingPrice: FieldRef<"PropertySubmission", 'String'>
    readonly beds: FieldRef<"PropertySubmission", 'Int'>
    readonly baths: FieldRef<"PropertySubmission", 'Float'>
    readonly sqft: FieldRef<"PropertySubmission", 'Int'>
    readonly description: FieldRef<"PropertySubmission", 'String'>
    readonly images: FieldRef<"PropertySubmission", 'String[]'>
    readonly exclusiveRights: FieldRef<"PropertySubmission", 'Boolean'>
    readonly commissionRate: FieldRef<"PropertySubmission", 'Float'>
    readonly agreementAccepted: FieldRef<"PropertySubmission", 'Boolean'>
    readonly status: FieldRef<"PropertySubmission", 'SubmissionStatus'>
    readonly reviewNotes: FieldRef<"PropertySubmission", 'String'>
    readonly reviewedBy: FieldRef<"PropertySubmission", 'String'>
    readonly reviewedByName: FieldRef<"PropertySubmission", 'String'>
    readonly reviewedAt: FieldRef<"PropertySubmission", 'DateTime'>
    readonly imagesApprovedAt: FieldRef<"PropertySubmission", 'DateTime'>
    readonly imagesApprovedBy: FieldRef<"PropertySubmission", 'String'>
    readonly publishedAt: FieldRef<"PropertySubmission", 'DateTime'>
    readonly publishedBy: FieldRef<"PropertySubmission", 'String'>
    readonly convertedPropertyId: FieldRef<"PropertySubmission", 'String'>
    readonly ipAddress: FieldRef<"PropertySubmission", 'String'>
    readonly userAgent: FieldRef<"PropertySubmission", 'String'>
    readonly source: FieldRef<"PropertySubmission", 'String'>
    readonly createdAt: FieldRef<"PropertySubmission", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertySubmission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertySubmission findUnique
   */
  export type PropertySubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmission
     */
    select?: PropertySubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmission
     */
    omit?: PropertySubmissionOmit<ExtArgs> | null
    /**
     * Filter, which PropertySubmission to fetch.
     */
    where: PropertySubmissionWhereUniqueInput
  }

  /**
   * PropertySubmission findUniqueOrThrow
   */
  export type PropertySubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmission
     */
    select?: PropertySubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmission
     */
    omit?: PropertySubmissionOmit<ExtArgs> | null
    /**
     * Filter, which PropertySubmission to fetch.
     */
    where: PropertySubmissionWhereUniqueInput
  }

  /**
   * PropertySubmission findFirst
   */
  export type PropertySubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmission
     */
    select?: PropertySubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmission
     */
    omit?: PropertySubmissionOmit<ExtArgs> | null
    /**
     * Filter, which PropertySubmission to fetch.
     */
    where?: PropertySubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySubmissions to fetch.
     */
    orderBy?: PropertySubmissionOrderByWithRelationInput | PropertySubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertySubmissions.
     */
    cursor?: PropertySubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertySubmissions.
     */
    distinct?: PropertySubmissionScalarFieldEnum | PropertySubmissionScalarFieldEnum[]
  }

  /**
   * PropertySubmission findFirstOrThrow
   */
  export type PropertySubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmission
     */
    select?: PropertySubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmission
     */
    omit?: PropertySubmissionOmit<ExtArgs> | null
    /**
     * Filter, which PropertySubmission to fetch.
     */
    where?: PropertySubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySubmissions to fetch.
     */
    orderBy?: PropertySubmissionOrderByWithRelationInput | PropertySubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertySubmissions.
     */
    cursor?: PropertySubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertySubmissions.
     */
    distinct?: PropertySubmissionScalarFieldEnum | PropertySubmissionScalarFieldEnum[]
  }

  /**
   * PropertySubmission findMany
   */
  export type PropertySubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmission
     */
    select?: PropertySubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmission
     */
    omit?: PropertySubmissionOmit<ExtArgs> | null
    /**
     * Filter, which PropertySubmissions to fetch.
     */
    where?: PropertySubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertySubmissions to fetch.
     */
    orderBy?: PropertySubmissionOrderByWithRelationInput | PropertySubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertySubmissions.
     */
    cursor?: PropertySubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertySubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertySubmissions.
     */
    skip?: number
    distinct?: PropertySubmissionScalarFieldEnum | PropertySubmissionScalarFieldEnum[]
  }

  /**
   * PropertySubmission create
   */
  export type PropertySubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmission
     */
    select?: PropertySubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmission
     */
    omit?: PropertySubmissionOmit<ExtArgs> | null
    /**
     * The data needed to create a PropertySubmission.
     */
    data: XOR<PropertySubmissionCreateInput, PropertySubmissionUncheckedCreateInput>
  }

  /**
   * PropertySubmission createMany
   */
  export type PropertySubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertySubmissions.
     */
    data: PropertySubmissionCreateManyInput | PropertySubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertySubmission createManyAndReturn
   */
  export type PropertySubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmission
     */
    select?: PropertySubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmission
     */
    omit?: PropertySubmissionOmit<ExtArgs> | null
    /**
     * The data used to create many PropertySubmissions.
     */
    data: PropertySubmissionCreateManyInput | PropertySubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertySubmission update
   */
  export type PropertySubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmission
     */
    select?: PropertySubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmission
     */
    omit?: PropertySubmissionOmit<ExtArgs> | null
    /**
     * The data needed to update a PropertySubmission.
     */
    data: XOR<PropertySubmissionUpdateInput, PropertySubmissionUncheckedUpdateInput>
    /**
     * Choose, which PropertySubmission to update.
     */
    where: PropertySubmissionWhereUniqueInput
  }

  /**
   * PropertySubmission updateMany
   */
  export type PropertySubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertySubmissions.
     */
    data: XOR<PropertySubmissionUpdateManyMutationInput, PropertySubmissionUncheckedUpdateManyInput>
    /**
     * Filter which PropertySubmissions to update
     */
    where?: PropertySubmissionWhereInput
    /**
     * Limit how many PropertySubmissions to update.
     */
    limit?: number
  }

  /**
   * PropertySubmission updateManyAndReturn
   */
  export type PropertySubmissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmission
     */
    select?: PropertySubmissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmission
     */
    omit?: PropertySubmissionOmit<ExtArgs> | null
    /**
     * The data used to update PropertySubmissions.
     */
    data: XOR<PropertySubmissionUpdateManyMutationInput, PropertySubmissionUncheckedUpdateManyInput>
    /**
     * Filter which PropertySubmissions to update
     */
    where?: PropertySubmissionWhereInput
    /**
     * Limit how many PropertySubmissions to update.
     */
    limit?: number
  }

  /**
   * PropertySubmission upsert
   */
  export type PropertySubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmission
     */
    select?: PropertySubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmission
     */
    omit?: PropertySubmissionOmit<ExtArgs> | null
    /**
     * The filter to search for the PropertySubmission to update in case it exists.
     */
    where: PropertySubmissionWhereUniqueInput
    /**
     * In case the PropertySubmission found by the `where` argument doesn't exist, create a new PropertySubmission with this data.
     */
    create: XOR<PropertySubmissionCreateInput, PropertySubmissionUncheckedCreateInput>
    /**
     * In case the PropertySubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertySubmissionUpdateInput, PropertySubmissionUncheckedUpdateInput>
  }

  /**
   * PropertySubmission delete
   */
  export type PropertySubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmission
     */
    select?: PropertySubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmission
     */
    omit?: PropertySubmissionOmit<ExtArgs> | null
    /**
     * Filter which PropertySubmission to delete.
     */
    where: PropertySubmissionWhereUniqueInput
  }

  /**
   * PropertySubmission deleteMany
   */
  export type PropertySubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertySubmissions to delete
     */
    where?: PropertySubmissionWhereInput
    /**
     * Limit how many PropertySubmissions to delete.
     */
    limit?: number
  }

  /**
   * PropertySubmission without action
   */
  export type PropertySubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertySubmission
     */
    select?: PropertySubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertySubmission
     */
    omit?: PropertySubmissionOmit<ExtArgs> | null
  }


  /**
   * Model SiteSettings
   */

  export type AggregateSiteSettings = {
    _count: SiteSettingsCountAggregateOutputType | null
    _avg: SiteSettingsAvgAggregateOutputType | null
    _sum: SiteSettingsSumAggregateOutputType | null
    _min: SiteSettingsMinAggregateOutputType | null
    _max: SiteSettingsMaxAggregateOutputType | null
  }

  export type SiteSettingsAvgAggregateOutputType = {
    smtpPort: number | null
    scannedPagesCount: number | null
    scanConfidence: number | null
  }

  export type SiteSettingsSumAggregateOutputType = {
    smtpPort: number | null
    scannedPagesCount: number | null
    scanConfidence: number | null
  }

  export type SiteSettingsMinAggregateOutputType = {
    id: string | null
    smtpHost: string | null
    smtpPort: number | null
    smtpSecure: boolean | null
    smtpUser: string | null
    smtpPassword: string | null
    smtpFromName: string | null
    smtpFromEmail: string | null
    siteName: string | null
    siteEmail: string | null
    adminNotifyEmail: string | null
    notifyOnSubmission: boolean | null
    notifyOnImageUpload: boolean | null
    companyDescription: string | null
    companyTone: string | null
    companyUSPs: string | null
    targetAudience: string | null
    brandKeywords: string | null
    avoidTopics: string | null
    websiteUrl: string | null
    lastScannedAt: Date | null
    scannedPagesCount: number | null
    scanConfidence: number | null
    detectedThemes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteSettingsMaxAggregateOutputType = {
    id: string | null
    smtpHost: string | null
    smtpPort: number | null
    smtpSecure: boolean | null
    smtpUser: string | null
    smtpPassword: string | null
    smtpFromName: string | null
    smtpFromEmail: string | null
    siteName: string | null
    siteEmail: string | null
    adminNotifyEmail: string | null
    notifyOnSubmission: boolean | null
    notifyOnImageUpload: boolean | null
    companyDescription: string | null
    companyTone: string | null
    companyUSPs: string | null
    targetAudience: string | null
    brandKeywords: string | null
    avoidTopics: string | null
    websiteUrl: string | null
    lastScannedAt: Date | null
    scannedPagesCount: number | null
    scanConfidence: number | null
    detectedThemes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteSettingsCountAggregateOutputType = {
    id: number
    smtpHost: number
    smtpPort: number
    smtpSecure: number
    smtpUser: number
    smtpPassword: number
    smtpFromName: number
    smtpFromEmail: number
    siteName: number
    siteEmail: number
    adminNotifyEmail: number
    notifyOnSubmission: number
    notifyOnImageUpload: number
    companyDescription: number
    companyTone: number
    companyUSPs: number
    targetAudience: number
    brandKeywords: number
    avoidTopics: number
    websiteUrl: number
    lastScannedAt: number
    scannedPagesCount: number
    scanConfidence: number
    detectedThemes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SiteSettingsAvgAggregateInputType = {
    smtpPort?: true
    scannedPagesCount?: true
    scanConfidence?: true
  }

  export type SiteSettingsSumAggregateInputType = {
    smtpPort?: true
    scannedPagesCount?: true
    scanConfidence?: true
  }

  export type SiteSettingsMinAggregateInputType = {
    id?: true
    smtpHost?: true
    smtpPort?: true
    smtpSecure?: true
    smtpUser?: true
    smtpPassword?: true
    smtpFromName?: true
    smtpFromEmail?: true
    siteName?: true
    siteEmail?: true
    adminNotifyEmail?: true
    notifyOnSubmission?: true
    notifyOnImageUpload?: true
    companyDescription?: true
    companyTone?: true
    companyUSPs?: true
    targetAudience?: true
    brandKeywords?: true
    avoidTopics?: true
    websiteUrl?: true
    lastScannedAt?: true
    scannedPagesCount?: true
    scanConfidence?: true
    detectedThemes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteSettingsMaxAggregateInputType = {
    id?: true
    smtpHost?: true
    smtpPort?: true
    smtpSecure?: true
    smtpUser?: true
    smtpPassword?: true
    smtpFromName?: true
    smtpFromEmail?: true
    siteName?: true
    siteEmail?: true
    adminNotifyEmail?: true
    notifyOnSubmission?: true
    notifyOnImageUpload?: true
    companyDescription?: true
    companyTone?: true
    companyUSPs?: true
    targetAudience?: true
    brandKeywords?: true
    avoidTopics?: true
    websiteUrl?: true
    lastScannedAt?: true
    scannedPagesCount?: true
    scanConfidence?: true
    detectedThemes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteSettingsCountAggregateInputType = {
    id?: true
    smtpHost?: true
    smtpPort?: true
    smtpSecure?: true
    smtpUser?: true
    smtpPassword?: true
    smtpFromName?: true
    smtpFromEmail?: true
    siteName?: true
    siteEmail?: true
    adminNotifyEmail?: true
    notifyOnSubmission?: true
    notifyOnImageUpload?: true
    companyDescription?: true
    companyTone?: true
    companyUSPs?: true
    targetAudience?: true
    brandKeywords?: true
    avoidTopics?: true
    websiteUrl?: true
    lastScannedAt?: true
    scannedPagesCount?: true
    scanConfidence?: true
    detectedThemes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SiteSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteSettings to aggregate.
     */
    where?: SiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingsOrderByWithRelationInput | SiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteSettings
    **/
    _count?: true | SiteSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SiteSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SiteSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteSettingsMaxAggregateInputType
  }

  export type GetSiteSettingsAggregateType<T extends SiteSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteSettings[P]>
      : GetScalarType<T[P], AggregateSiteSettings[P]>
  }




  export type SiteSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteSettingsWhereInput
    orderBy?: SiteSettingsOrderByWithAggregationInput | SiteSettingsOrderByWithAggregationInput[]
    by: SiteSettingsScalarFieldEnum[] | SiteSettingsScalarFieldEnum
    having?: SiteSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteSettingsCountAggregateInputType | true
    _avg?: SiteSettingsAvgAggregateInputType
    _sum?: SiteSettingsSumAggregateInputType
    _min?: SiteSettingsMinAggregateInputType
    _max?: SiteSettingsMaxAggregateInputType
  }

  export type SiteSettingsGroupByOutputType = {
    id: string
    smtpHost: string | null
    smtpPort: number | null
    smtpSecure: boolean
    smtpUser: string | null
    smtpPassword: string | null
    smtpFromName: string | null
    smtpFromEmail: string | null
    siteName: string | null
    siteEmail: string | null
    adminNotifyEmail: string | null
    notifyOnSubmission: boolean
    notifyOnImageUpload: boolean
    companyDescription: string | null
    companyTone: string | null
    companyUSPs: string | null
    targetAudience: string | null
    brandKeywords: string | null
    avoidTopics: string | null
    websiteUrl: string | null
    lastScannedAt: Date | null
    scannedPagesCount: number | null
    scanConfidence: number | null
    detectedThemes: string | null
    createdAt: Date
    updatedAt: Date
    _count: SiteSettingsCountAggregateOutputType | null
    _avg: SiteSettingsAvgAggregateOutputType | null
    _sum: SiteSettingsSumAggregateOutputType | null
    _min: SiteSettingsMinAggregateOutputType | null
    _max: SiteSettingsMaxAggregateOutputType | null
  }

  type GetSiteSettingsGroupByPayload<T extends SiteSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SiteSettingsGroupByOutputType[P]>
        }
      >
    >


  export type SiteSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    smtpHost?: boolean
    smtpPort?: boolean
    smtpSecure?: boolean
    smtpUser?: boolean
    smtpPassword?: boolean
    smtpFromName?: boolean
    smtpFromEmail?: boolean
    siteName?: boolean
    siteEmail?: boolean
    adminNotifyEmail?: boolean
    notifyOnSubmission?: boolean
    notifyOnImageUpload?: boolean
    companyDescription?: boolean
    companyTone?: boolean
    companyUSPs?: boolean
    targetAudience?: boolean
    brandKeywords?: boolean
    avoidTopics?: boolean
    websiteUrl?: boolean
    lastScannedAt?: boolean
    scannedPagesCount?: boolean
    scanConfidence?: boolean
    detectedThemes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["siteSettings"]>

  export type SiteSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    smtpHost?: boolean
    smtpPort?: boolean
    smtpSecure?: boolean
    smtpUser?: boolean
    smtpPassword?: boolean
    smtpFromName?: boolean
    smtpFromEmail?: boolean
    siteName?: boolean
    siteEmail?: boolean
    adminNotifyEmail?: boolean
    notifyOnSubmission?: boolean
    notifyOnImageUpload?: boolean
    companyDescription?: boolean
    companyTone?: boolean
    companyUSPs?: boolean
    targetAudience?: boolean
    brandKeywords?: boolean
    avoidTopics?: boolean
    websiteUrl?: boolean
    lastScannedAt?: boolean
    scannedPagesCount?: boolean
    scanConfidence?: boolean
    detectedThemes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["siteSettings"]>

  export type SiteSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    smtpHost?: boolean
    smtpPort?: boolean
    smtpSecure?: boolean
    smtpUser?: boolean
    smtpPassword?: boolean
    smtpFromName?: boolean
    smtpFromEmail?: boolean
    siteName?: boolean
    siteEmail?: boolean
    adminNotifyEmail?: boolean
    notifyOnSubmission?: boolean
    notifyOnImageUpload?: boolean
    companyDescription?: boolean
    companyTone?: boolean
    companyUSPs?: boolean
    targetAudience?: boolean
    brandKeywords?: boolean
    avoidTopics?: boolean
    websiteUrl?: boolean
    lastScannedAt?: boolean
    scannedPagesCount?: boolean
    scanConfidence?: boolean
    detectedThemes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["siteSettings"]>

  export type SiteSettingsSelectScalar = {
    id?: boolean
    smtpHost?: boolean
    smtpPort?: boolean
    smtpSecure?: boolean
    smtpUser?: boolean
    smtpPassword?: boolean
    smtpFromName?: boolean
    smtpFromEmail?: boolean
    siteName?: boolean
    siteEmail?: boolean
    adminNotifyEmail?: boolean
    notifyOnSubmission?: boolean
    notifyOnImageUpload?: boolean
    companyDescription?: boolean
    companyTone?: boolean
    companyUSPs?: boolean
    targetAudience?: boolean
    brandKeywords?: boolean
    avoidTopics?: boolean
    websiteUrl?: boolean
    lastScannedAt?: boolean
    scannedPagesCount?: boolean
    scanConfidence?: boolean
    detectedThemes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SiteSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "smtpHost" | "smtpPort" | "smtpSecure" | "smtpUser" | "smtpPassword" | "smtpFromName" | "smtpFromEmail" | "siteName" | "siteEmail" | "adminNotifyEmail" | "notifyOnSubmission" | "notifyOnImageUpload" | "companyDescription" | "companyTone" | "companyUSPs" | "targetAudience" | "brandKeywords" | "avoidTopics" | "websiteUrl" | "lastScannedAt" | "scannedPagesCount" | "scanConfidence" | "detectedThemes" | "createdAt" | "updatedAt", ExtArgs["result"]["siteSettings"]>

  export type $SiteSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SiteSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      smtpHost: string | null
      smtpPort: number | null
      smtpSecure: boolean
      smtpUser: string | null
      smtpPassword: string | null
      smtpFromName: string | null
      smtpFromEmail: string | null
      siteName: string | null
      siteEmail: string | null
      adminNotifyEmail: string | null
      notifyOnSubmission: boolean
      notifyOnImageUpload: boolean
      companyDescription: string | null
      companyTone: string | null
      companyUSPs: string | null
      targetAudience: string | null
      brandKeywords: string | null
      avoidTopics: string | null
      websiteUrl: string | null
      lastScannedAt: Date | null
      scannedPagesCount: number | null
      scanConfidence: number | null
      detectedThemes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["siteSettings"]>
    composites: {}
  }

  type SiteSettingsGetPayload<S extends boolean | null | undefined | SiteSettingsDefaultArgs> = $Result.GetResult<Prisma.$SiteSettingsPayload, S>

  type SiteSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SiteSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SiteSettingsCountAggregateInputType | true
    }

  export interface SiteSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SiteSettings'], meta: { name: 'SiteSettings' } }
    /**
     * Find zero or one SiteSettings that matches the filter.
     * @param {SiteSettingsFindUniqueArgs} args - Arguments to find a SiteSettings
     * @example
     * // Get one SiteSettings
     * const siteSettings = await prisma.siteSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteSettingsFindUniqueArgs>(args: SelectSubset<T, SiteSettingsFindUniqueArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SiteSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SiteSettingsFindUniqueOrThrowArgs} args - Arguments to find a SiteSettings
     * @example
     * // Get one SiteSettings
     * const siteSettings = await prisma.siteSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsFindFirstArgs} args - Arguments to find a SiteSettings
     * @example
     * // Get one SiteSettings
     * const siteSettings = await prisma.siteSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteSettingsFindFirstArgs>(args?: SelectSubset<T, SiteSettingsFindFirstArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsFindFirstOrThrowArgs} args - Arguments to find a SiteSettings
     * @example
     * // Get one SiteSettings
     * const siteSettings = await prisma.siteSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SiteSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteSettings
     * const siteSettings = await prisma.siteSettings.findMany()
     * 
     * // Get first 10 SiteSettings
     * const siteSettings = await prisma.siteSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const siteSettingsWithIdOnly = await prisma.siteSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SiteSettingsFindManyArgs>(args?: SelectSubset<T, SiteSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SiteSettings.
     * @param {SiteSettingsCreateArgs} args - Arguments to create a SiteSettings.
     * @example
     * // Create one SiteSettings
     * const SiteSettings = await prisma.siteSettings.create({
     *   data: {
     *     // ... data to create a SiteSettings
     *   }
     * })
     * 
     */
    create<T extends SiteSettingsCreateArgs>(args: SelectSubset<T, SiteSettingsCreateArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SiteSettings.
     * @param {SiteSettingsCreateManyArgs} args - Arguments to create many SiteSettings.
     * @example
     * // Create many SiteSettings
     * const siteSettings = await prisma.siteSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteSettingsCreateManyArgs>(args?: SelectSubset<T, SiteSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SiteSettings and returns the data saved in the database.
     * @param {SiteSettingsCreateManyAndReturnArgs} args - Arguments to create many SiteSettings.
     * @example
     * // Create many SiteSettings
     * const siteSettings = await prisma.siteSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SiteSettings and only return the `id`
     * const siteSettingsWithIdOnly = await prisma.siteSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SiteSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SiteSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SiteSettings.
     * @param {SiteSettingsDeleteArgs} args - Arguments to delete one SiteSettings.
     * @example
     * // Delete one SiteSettings
     * const SiteSettings = await prisma.siteSettings.delete({
     *   where: {
     *     // ... filter to delete one SiteSettings
     *   }
     * })
     * 
     */
    delete<T extends SiteSettingsDeleteArgs>(args: SelectSubset<T, SiteSettingsDeleteArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SiteSettings.
     * @param {SiteSettingsUpdateArgs} args - Arguments to update one SiteSettings.
     * @example
     * // Update one SiteSettings
     * const siteSettings = await prisma.siteSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteSettingsUpdateArgs>(args: SelectSubset<T, SiteSettingsUpdateArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SiteSettings.
     * @param {SiteSettingsDeleteManyArgs} args - Arguments to filter SiteSettings to delete.
     * @example
     * // Delete a few SiteSettings
     * const { count } = await prisma.siteSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteSettingsDeleteManyArgs>(args?: SelectSubset<T, SiteSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteSettings
     * const siteSettings = await prisma.siteSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteSettingsUpdateManyArgs>(args: SelectSubset<T, SiteSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteSettings and returns the data updated in the database.
     * @param {SiteSettingsUpdateManyAndReturnArgs} args - Arguments to update many SiteSettings.
     * @example
     * // Update many SiteSettings
     * const siteSettings = await prisma.siteSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SiteSettings and only return the `id`
     * const siteSettingsWithIdOnly = await prisma.siteSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SiteSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SiteSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SiteSettings.
     * @param {SiteSettingsUpsertArgs} args - Arguments to update or create a SiteSettings.
     * @example
     * // Update or create a SiteSettings
     * const siteSettings = await prisma.siteSettings.upsert({
     *   create: {
     *     // ... data to create a SiteSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteSettings we want to update
     *   }
     * })
     */
    upsert<T extends SiteSettingsUpsertArgs>(args: SelectSubset<T, SiteSettingsUpsertArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsCountArgs} args - Arguments to filter SiteSettings to count.
     * @example
     * // Count the number of SiteSettings
     * const count = await prisma.siteSettings.count({
     *   where: {
     *     // ... the filter for the SiteSettings we want to count
     *   }
     * })
    **/
    count<T extends SiteSettingsCountArgs>(
      args?: Subset<T, SiteSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteSettingsAggregateArgs>(args: Subset<T, SiteSettingsAggregateArgs>): Prisma.PrismaPromise<GetSiteSettingsAggregateType<T>>

    /**
     * Group by SiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteSettingsGroupByArgs['orderBy'] }
        : { orderBy?: SiteSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SiteSettings model
   */
  readonly fields: SiteSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SiteSettings model
   */
  interface SiteSettingsFieldRefs {
    readonly id: FieldRef<"SiteSettings", 'String'>
    readonly smtpHost: FieldRef<"SiteSettings", 'String'>
    readonly smtpPort: FieldRef<"SiteSettings", 'Int'>
    readonly smtpSecure: FieldRef<"SiteSettings", 'Boolean'>
    readonly smtpUser: FieldRef<"SiteSettings", 'String'>
    readonly smtpPassword: FieldRef<"SiteSettings", 'String'>
    readonly smtpFromName: FieldRef<"SiteSettings", 'String'>
    readonly smtpFromEmail: FieldRef<"SiteSettings", 'String'>
    readonly siteName: FieldRef<"SiteSettings", 'String'>
    readonly siteEmail: FieldRef<"SiteSettings", 'String'>
    readonly adminNotifyEmail: FieldRef<"SiteSettings", 'String'>
    readonly notifyOnSubmission: FieldRef<"SiteSettings", 'Boolean'>
    readonly notifyOnImageUpload: FieldRef<"SiteSettings", 'Boolean'>
    readonly companyDescription: FieldRef<"SiteSettings", 'String'>
    readonly companyTone: FieldRef<"SiteSettings", 'String'>
    readonly companyUSPs: FieldRef<"SiteSettings", 'String'>
    readonly targetAudience: FieldRef<"SiteSettings", 'String'>
    readonly brandKeywords: FieldRef<"SiteSettings", 'String'>
    readonly avoidTopics: FieldRef<"SiteSettings", 'String'>
    readonly websiteUrl: FieldRef<"SiteSettings", 'String'>
    readonly lastScannedAt: FieldRef<"SiteSettings", 'DateTime'>
    readonly scannedPagesCount: FieldRef<"SiteSettings", 'Int'>
    readonly scanConfidence: FieldRef<"SiteSettings", 'Float'>
    readonly detectedThemes: FieldRef<"SiteSettings", 'String'>
    readonly createdAt: FieldRef<"SiteSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"SiteSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SiteSettings findUnique
   */
  export type SiteSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SiteSettings to fetch.
     */
    where: SiteSettingsWhereUniqueInput
  }

  /**
   * SiteSettings findUniqueOrThrow
   */
  export type SiteSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SiteSettings to fetch.
     */
    where: SiteSettingsWhereUniqueInput
  }

  /**
   * SiteSettings findFirst
   */
  export type SiteSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SiteSettings to fetch.
     */
    where?: SiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingsOrderByWithRelationInput | SiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteSettings.
     */
    cursor?: SiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteSettings.
     */
    distinct?: SiteSettingsScalarFieldEnum | SiteSettingsScalarFieldEnum[]
  }

  /**
   * SiteSettings findFirstOrThrow
   */
  export type SiteSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SiteSettings to fetch.
     */
    where?: SiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingsOrderByWithRelationInput | SiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteSettings.
     */
    cursor?: SiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteSettings.
     */
    distinct?: SiteSettingsScalarFieldEnum | SiteSettingsScalarFieldEnum[]
  }

  /**
   * SiteSettings findMany
   */
  export type SiteSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SiteSettings to fetch.
     */
    where?: SiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingsOrderByWithRelationInput | SiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteSettings.
     */
    cursor?: SiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    distinct?: SiteSettingsScalarFieldEnum | SiteSettingsScalarFieldEnum[]
  }

  /**
   * SiteSettings create
   */
  export type SiteSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a SiteSettings.
     */
    data: XOR<SiteSettingsCreateInput, SiteSettingsUncheckedCreateInput>
  }

  /**
   * SiteSettings createMany
   */
  export type SiteSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SiteSettings.
     */
    data: SiteSettingsCreateManyInput | SiteSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SiteSettings createManyAndReturn
   */
  export type SiteSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many SiteSettings.
     */
    data: SiteSettingsCreateManyInput | SiteSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SiteSettings update
   */
  export type SiteSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a SiteSettings.
     */
    data: XOR<SiteSettingsUpdateInput, SiteSettingsUncheckedUpdateInput>
    /**
     * Choose, which SiteSettings to update.
     */
    where: SiteSettingsWhereUniqueInput
  }

  /**
   * SiteSettings updateMany
   */
  export type SiteSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SiteSettings.
     */
    data: XOR<SiteSettingsUpdateManyMutationInput, SiteSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SiteSettings to update
     */
    where?: SiteSettingsWhereInput
    /**
     * Limit how many SiteSettings to update.
     */
    limit?: number
  }

  /**
   * SiteSettings updateManyAndReturn
   */
  export type SiteSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * The data used to update SiteSettings.
     */
    data: XOR<SiteSettingsUpdateManyMutationInput, SiteSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SiteSettings to update
     */
    where?: SiteSettingsWhereInput
    /**
     * Limit how many SiteSettings to update.
     */
    limit?: number
  }

  /**
   * SiteSettings upsert
   */
  export type SiteSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the SiteSettings to update in case it exists.
     */
    where: SiteSettingsWhereUniqueInput
    /**
     * In case the SiteSettings found by the `where` argument doesn't exist, create a new SiteSettings with this data.
     */
    create: XOR<SiteSettingsCreateInput, SiteSettingsUncheckedCreateInput>
    /**
     * In case the SiteSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteSettingsUpdateInput, SiteSettingsUncheckedUpdateInput>
  }

  /**
   * SiteSettings delete
   */
  export type SiteSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter which SiteSettings to delete.
     */
    where: SiteSettingsWhereUniqueInput
  }

  /**
   * SiteSettings deleteMany
   */
  export type SiteSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteSettings to delete
     */
    where?: SiteSettingsWhereInput
    /**
     * Limit how many SiteSettings to delete.
     */
    limit?: number
  }

  /**
   * SiteSettings without action
   */
  export type SiteSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
  }


  /**
   * Model InternalLink
   */

  export type AggregateInternalLink = {
    _count: InternalLinkCountAggregateOutputType | null
    _avg: InternalLinkAvgAggregateOutputType | null
    _sum: InternalLinkSumAggregateOutputType | null
    _min: InternalLinkMinAggregateOutputType | null
    _max: InternalLinkMaxAggregateOutputType | null
  }

  export type InternalLinkAvgAggregateOutputType = {
    priority: number | null
    usageCount: number | null
  }

  export type InternalLinkSumAggregateOutputType = {
    priority: number | null
    usageCount: number | null
  }

  export type InternalLinkMinAggregateOutputType = {
    id: string | null
    url: string | null
    title: string | null
    description: string | null
    category: string | null
    subCategory: string | null
    keywords: string | null
    anchorTexts: string | null
    priority: number | null
    isActive: boolean | null
    usageCount: number | null
    pageExists: boolean | null
    lastChecked: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InternalLinkMaxAggregateOutputType = {
    id: string | null
    url: string | null
    title: string | null
    description: string | null
    category: string | null
    subCategory: string | null
    keywords: string | null
    anchorTexts: string | null
    priority: number | null
    isActive: boolean | null
    usageCount: number | null
    pageExists: boolean | null
    lastChecked: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InternalLinkCountAggregateOutputType = {
    id: number
    url: number
    title: number
    description: number
    category: number
    subCategory: number
    keywords: number
    anchorTexts: number
    priority: number
    isActive: number
    usageCount: number
    pageExists: number
    lastChecked: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InternalLinkAvgAggregateInputType = {
    priority?: true
    usageCount?: true
  }

  export type InternalLinkSumAggregateInputType = {
    priority?: true
    usageCount?: true
  }

  export type InternalLinkMinAggregateInputType = {
    id?: true
    url?: true
    title?: true
    description?: true
    category?: true
    subCategory?: true
    keywords?: true
    anchorTexts?: true
    priority?: true
    isActive?: true
    usageCount?: true
    pageExists?: true
    lastChecked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InternalLinkMaxAggregateInputType = {
    id?: true
    url?: true
    title?: true
    description?: true
    category?: true
    subCategory?: true
    keywords?: true
    anchorTexts?: true
    priority?: true
    isActive?: true
    usageCount?: true
    pageExists?: true
    lastChecked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InternalLinkCountAggregateInputType = {
    id?: true
    url?: true
    title?: true
    description?: true
    category?: true
    subCategory?: true
    keywords?: true
    anchorTexts?: true
    priority?: true
    isActive?: true
    usageCount?: true
    pageExists?: true
    lastChecked?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InternalLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InternalLink to aggregate.
     */
    where?: InternalLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternalLinks to fetch.
     */
    orderBy?: InternalLinkOrderByWithRelationInput | InternalLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InternalLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternalLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternalLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InternalLinks
    **/
    _count?: true | InternalLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InternalLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InternalLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InternalLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InternalLinkMaxAggregateInputType
  }

  export type GetInternalLinkAggregateType<T extends InternalLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateInternalLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInternalLink[P]>
      : GetScalarType<T[P], AggregateInternalLink[P]>
  }




  export type InternalLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InternalLinkWhereInput
    orderBy?: InternalLinkOrderByWithAggregationInput | InternalLinkOrderByWithAggregationInput[]
    by: InternalLinkScalarFieldEnum[] | InternalLinkScalarFieldEnum
    having?: InternalLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InternalLinkCountAggregateInputType | true
    _avg?: InternalLinkAvgAggregateInputType
    _sum?: InternalLinkSumAggregateInputType
    _min?: InternalLinkMinAggregateInputType
    _max?: InternalLinkMaxAggregateInputType
  }

  export type InternalLinkGroupByOutputType = {
    id: string
    url: string
    title: string
    description: string | null
    category: string | null
    subCategory: string | null
    keywords: string | null
    anchorTexts: string | null
    priority: number
    isActive: boolean
    usageCount: number
    pageExists: boolean
    lastChecked: Date | null
    createdAt: Date
    updatedAt: Date
    _count: InternalLinkCountAggregateOutputType | null
    _avg: InternalLinkAvgAggregateOutputType | null
    _sum: InternalLinkSumAggregateOutputType | null
    _min: InternalLinkMinAggregateOutputType | null
    _max: InternalLinkMaxAggregateOutputType | null
  }

  type GetInternalLinkGroupByPayload<T extends InternalLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InternalLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InternalLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InternalLinkGroupByOutputType[P]>
            : GetScalarType<T[P], InternalLinkGroupByOutputType[P]>
        }
      >
    >


  export type InternalLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    subCategory?: boolean
    keywords?: boolean
    anchorTexts?: boolean
    priority?: boolean
    isActive?: boolean
    usageCount?: boolean
    pageExists?: boolean
    lastChecked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usages?: boolean | InternalLink$usagesArgs<ExtArgs>
    _count?: boolean | InternalLinkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["internalLink"]>

  export type InternalLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    subCategory?: boolean
    keywords?: boolean
    anchorTexts?: boolean
    priority?: boolean
    isActive?: boolean
    usageCount?: boolean
    pageExists?: boolean
    lastChecked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["internalLink"]>

  export type InternalLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    subCategory?: boolean
    keywords?: boolean
    anchorTexts?: boolean
    priority?: boolean
    isActive?: boolean
    usageCount?: boolean
    pageExists?: boolean
    lastChecked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["internalLink"]>

  export type InternalLinkSelectScalar = {
    id?: boolean
    url?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    subCategory?: boolean
    keywords?: boolean
    anchorTexts?: boolean
    priority?: boolean
    isActive?: boolean
    usageCount?: boolean
    pageExists?: boolean
    lastChecked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InternalLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "title" | "description" | "category" | "subCategory" | "keywords" | "anchorTexts" | "priority" | "isActive" | "usageCount" | "pageExists" | "lastChecked" | "createdAt" | "updatedAt", ExtArgs["result"]["internalLink"]>
  export type InternalLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usages?: boolean | InternalLink$usagesArgs<ExtArgs>
    _count?: boolean | InternalLinkCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InternalLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InternalLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InternalLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InternalLink"
    objects: {
      usages: Prisma.$LinkUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      title: string
      description: string | null
      category: string | null
      subCategory: string | null
      keywords: string | null
      anchorTexts: string | null
      priority: number
      isActive: boolean
      usageCount: number
      pageExists: boolean
      lastChecked: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["internalLink"]>
    composites: {}
  }

  type InternalLinkGetPayload<S extends boolean | null | undefined | InternalLinkDefaultArgs> = $Result.GetResult<Prisma.$InternalLinkPayload, S>

  type InternalLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InternalLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InternalLinkCountAggregateInputType | true
    }

  export interface InternalLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InternalLink'], meta: { name: 'InternalLink' } }
    /**
     * Find zero or one InternalLink that matches the filter.
     * @param {InternalLinkFindUniqueArgs} args - Arguments to find a InternalLink
     * @example
     * // Get one InternalLink
     * const internalLink = await prisma.internalLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InternalLinkFindUniqueArgs>(args: SelectSubset<T, InternalLinkFindUniqueArgs<ExtArgs>>): Prisma__InternalLinkClient<$Result.GetResult<Prisma.$InternalLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InternalLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InternalLinkFindUniqueOrThrowArgs} args - Arguments to find a InternalLink
     * @example
     * // Get one InternalLink
     * const internalLink = await prisma.internalLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InternalLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, InternalLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InternalLinkClient<$Result.GetResult<Prisma.$InternalLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InternalLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalLinkFindFirstArgs} args - Arguments to find a InternalLink
     * @example
     * // Get one InternalLink
     * const internalLink = await prisma.internalLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InternalLinkFindFirstArgs>(args?: SelectSubset<T, InternalLinkFindFirstArgs<ExtArgs>>): Prisma__InternalLinkClient<$Result.GetResult<Prisma.$InternalLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InternalLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalLinkFindFirstOrThrowArgs} args - Arguments to find a InternalLink
     * @example
     * // Get one InternalLink
     * const internalLink = await prisma.internalLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InternalLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, InternalLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__InternalLinkClient<$Result.GetResult<Prisma.$InternalLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InternalLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InternalLinks
     * const internalLinks = await prisma.internalLink.findMany()
     * 
     * // Get first 10 InternalLinks
     * const internalLinks = await prisma.internalLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const internalLinkWithIdOnly = await prisma.internalLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InternalLinkFindManyArgs>(args?: SelectSubset<T, InternalLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternalLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InternalLink.
     * @param {InternalLinkCreateArgs} args - Arguments to create a InternalLink.
     * @example
     * // Create one InternalLink
     * const InternalLink = await prisma.internalLink.create({
     *   data: {
     *     // ... data to create a InternalLink
     *   }
     * })
     * 
     */
    create<T extends InternalLinkCreateArgs>(args: SelectSubset<T, InternalLinkCreateArgs<ExtArgs>>): Prisma__InternalLinkClient<$Result.GetResult<Prisma.$InternalLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InternalLinks.
     * @param {InternalLinkCreateManyArgs} args - Arguments to create many InternalLinks.
     * @example
     * // Create many InternalLinks
     * const internalLink = await prisma.internalLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InternalLinkCreateManyArgs>(args?: SelectSubset<T, InternalLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InternalLinks and returns the data saved in the database.
     * @param {InternalLinkCreateManyAndReturnArgs} args - Arguments to create many InternalLinks.
     * @example
     * // Create many InternalLinks
     * const internalLink = await prisma.internalLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InternalLinks and only return the `id`
     * const internalLinkWithIdOnly = await prisma.internalLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InternalLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, InternalLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternalLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InternalLink.
     * @param {InternalLinkDeleteArgs} args - Arguments to delete one InternalLink.
     * @example
     * // Delete one InternalLink
     * const InternalLink = await prisma.internalLink.delete({
     *   where: {
     *     // ... filter to delete one InternalLink
     *   }
     * })
     * 
     */
    delete<T extends InternalLinkDeleteArgs>(args: SelectSubset<T, InternalLinkDeleteArgs<ExtArgs>>): Prisma__InternalLinkClient<$Result.GetResult<Prisma.$InternalLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InternalLink.
     * @param {InternalLinkUpdateArgs} args - Arguments to update one InternalLink.
     * @example
     * // Update one InternalLink
     * const internalLink = await prisma.internalLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InternalLinkUpdateArgs>(args: SelectSubset<T, InternalLinkUpdateArgs<ExtArgs>>): Prisma__InternalLinkClient<$Result.GetResult<Prisma.$InternalLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InternalLinks.
     * @param {InternalLinkDeleteManyArgs} args - Arguments to filter InternalLinks to delete.
     * @example
     * // Delete a few InternalLinks
     * const { count } = await prisma.internalLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InternalLinkDeleteManyArgs>(args?: SelectSubset<T, InternalLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InternalLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InternalLinks
     * const internalLink = await prisma.internalLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InternalLinkUpdateManyArgs>(args: SelectSubset<T, InternalLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InternalLinks and returns the data updated in the database.
     * @param {InternalLinkUpdateManyAndReturnArgs} args - Arguments to update many InternalLinks.
     * @example
     * // Update many InternalLinks
     * const internalLink = await prisma.internalLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InternalLinks and only return the `id`
     * const internalLinkWithIdOnly = await prisma.internalLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InternalLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, InternalLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternalLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InternalLink.
     * @param {InternalLinkUpsertArgs} args - Arguments to update or create a InternalLink.
     * @example
     * // Update or create a InternalLink
     * const internalLink = await prisma.internalLink.upsert({
     *   create: {
     *     // ... data to create a InternalLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InternalLink we want to update
     *   }
     * })
     */
    upsert<T extends InternalLinkUpsertArgs>(args: SelectSubset<T, InternalLinkUpsertArgs<ExtArgs>>): Prisma__InternalLinkClient<$Result.GetResult<Prisma.$InternalLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InternalLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalLinkCountArgs} args - Arguments to filter InternalLinks to count.
     * @example
     * // Count the number of InternalLinks
     * const count = await prisma.internalLink.count({
     *   where: {
     *     // ... the filter for the InternalLinks we want to count
     *   }
     * })
    **/
    count<T extends InternalLinkCountArgs>(
      args?: Subset<T, InternalLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InternalLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InternalLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InternalLinkAggregateArgs>(args: Subset<T, InternalLinkAggregateArgs>): Prisma.PrismaPromise<GetInternalLinkAggregateType<T>>

    /**
     * Group by InternalLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InternalLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InternalLinkGroupByArgs['orderBy'] }
        : { orderBy?: InternalLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InternalLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInternalLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InternalLink model
   */
  readonly fields: InternalLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InternalLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InternalLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usages<T extends InternalLink$usagesArgs<ExtArgs> = {}>(args?: Subset<T, InternalLink$usagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InternalLink model
   */
  interface InternalLinkFieldRefs {
    readonly id: FieldRef<"InternalLink", 'String'>
    readonly url: FieldRef<"InternalLink", 'String'>
    readonly title: FieldRef<"InternalLink", 'String'>
    readonly description: FieldRef<"InternalLink", 'String'>
    readonly category: FieldRef<"InternalLink", 'String'>
    readonly subCategory: FieldRef<"InternalLink", 'String'>
    readonly keywords: FieldRef<"InternalLink", 'String'>
    readonly anchorTexts: FieldRef<"InternalLink", 'String'>
    readonly priority: FieldRef<"InternalLink", 'Int'>
    readonly isActive: FieldRef<"InternalLink", 'Boolean'>
    readonly usageCount: FieldRef<"InternalLink", 'Int'>
    readonly pageExists: FieldRef<"InternalLink", 'Boolean'>
    readonly lastChecked: FieldRef<"InternalLink", 'DateTime'>
    readonly createdAt: FieldRef<"InternalLink", 'DateTime'>
    readonly updatedAt: FieldRef<"InternalLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InternalLink findUnique
   */
  export type InternalLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalLink
     */
    select?: InternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InternalLink
     */
    omit?: InternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalLinkInclude<ExtArgs> | null
    /**
     * Filter, which InternalLink to fetch.
     */
    where: InternalLinkWhereUniqueInput
  }

  /**
   * InternalLink findUniqueOrThrow
   */
  export type InternalLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalLink
     */
    select?: InternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InternalLink
     */
    omit?: InternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalLinkInclude<ExtArgs> | null
    /**
     * Filter, which InternalLink to fetch.
     */
    where: InternalLinkWhereUniqueInput
  }

  /**
   * InternalLink findFirst
   */
  export type InternalLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalLink
     */
    select?: InternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InternalLink
     */
    omit?: InternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalLinkInclude<ExtArgs> | null
    /**
     * Filter, which InternalLink to fetch.
     */
    where?: InternalLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternalLinks to fetch.
     */
    orderBy?: InternalLinkOrderByWithRelationInput | InternalLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InternalLinks.
     */
    cursor?: InternalLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternalLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternalLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InternalLinks.
     */
    distinct?: InternalLinkScalarFieldEnum | InternalLinkScalarFieldEnum[]
  }

  /**
   * InternalLink findFirstOrThrow
   */
  export type InternalLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalLink
     */
    select?: InternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InternalLink
     */
    omit?: InternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalLinkInclude<ExtArgs> | null
    /**
     * Filter, which InternalLink to fetch.
     */
    where?: InternalLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternalLinks to fetch.
     */
    orderBy?: InternalLinkOrderByWithRelationInput | InternalLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InternalLinks.
     */
    cursor?: InternalLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternalLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternalLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InternalLinks.
     */
    distinct?: InternalLinkScalarFieldEnum | InternalLinkScalarFieldEnum[]
  }

  /**
   * InternalLink findMany
   */
  export type InternalLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalLink
     */
    select?: InternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InternalLink
     */
    omit?: InternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalLinkInclude<ExtArgs> | null
    /**
     * Filter, which InternalLinks to fetch.
     */
    where?: InternalLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternalLinks to fetch.
     */
    orderBy?: InternalLinkOrderByWithRelationInput | InternalLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InternalLinks.
     */
    cursor?: InternalLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternalLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternalLinks.
     */
    skip?: number
    distinct?: InternalLinkScalarFieldEnum | InternalLinkScalarFieldEnum[]
  }

  /**
   * InternalLink create
   */
  export type InternalLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalLink
     */
    select?: InternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InternalLink
     */
    omit?: InternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a InternalLink.
     */
    data: XOR<InternalLinkCreateInput, InternalLinkUncheckedCreateInput>
  }

  /**
   * InternalLink createMany
   */
  export type InternalLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InternalLinks.
     */
    data: InternalLinkCreateManyInput | InternalLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InternalLink createManyAndReturn
   */
  export type InternalLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalLink
     */
    select?: InternalLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InternalLink
     */
    omit?: InternalLinkOmit<ExtArgs> | null
    /**
     * The data used to create many InternalLinks.
     */
    data: InternalLinkCreateManyInput | InternalLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InternalLink update
   */
  export type InternalLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalLink
     */
    select?: InternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InternalLink
     */
    omit?: InternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a InternalLink.
     */
    data: XOR<InternalLinkUpdateInput, InternalLinkUncheckedUpdateInput>
    /**
     * Choose, which InternalLink to update.
     */
    where: InternalLinkWhereUniqueInput
  }

  /**
   * InternalLink updateMany
   */
  export type InternalLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InternalLinks.
     */
    data: XOR<InternalLinkUpdateManyMutationInput, InternalLinkUncheckedUpdateManyInput>
    /**
     * Filter which InternalLinks to update
     */
    where?: InternalLinkWhereInput
    /**
     * Limit how many InternalLinks to update.
     */
    limit?: number
  }

  /**
   * InternalLink updateManyAndReturn
   */
  export type InternalLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalLink
     */
    select?: InternalLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InternalLink
     */
    omit?: InternalLinkOmit<ExtArgs> | null
    /**
     * The data used to update InternalLinks.
     */
    data: XOR<InternalLinkUpdateManyMutationInput, InternalLinkUncheckedUpdateManyInput>
    /**
     * Filter which InternalLinks to update
     */
    where?: InternalLinkWhereInput
    /**
     * Limit how many InternalLinks to update.
     */
    limit?: number
  }

  /**
   * InternalLink upsert
   */
  export type InternalLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalLink
     */
    select?: InternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InternalLink
     */
    omit?: InternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the InternalLink to update in case it exists.
     */
    where: InternalLinkWhereUniqueInput
    /**
     * In case the InternalLink found by the `where` argument doesn't exist, create a new InternalLink with this data.
     */
    create: XOR<InternalLinkCreateInput, InternalLinkUncheckedCreateInput>
    /**
     * In case the InternalLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InternalLinkUpdateInput, InternalLinkUncheckedUpdateInput>
  }

  /**
   * InternalLink delete
   */
  export type InternalLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalLink
     */
    select?: InternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InternalLink
     */
    omit?: InternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalLinkInclude<ExtArgs> | null
    /**
     * Filter which InternalLink to delete.
     */
    where: InternalLinkWhereUniqueInput
  }

  /**
   * InternalLink deleteMany
   */
  export type InternalLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InternalLinks to delete
     */
    where?: InternalLinkWhereInput
    /**
     * Limit how many InternalLinks to delete.
     */
    limit?: number
  }

  /**
   * InternalLink.usages
   */
  export type InternalLink$usagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkUsage
     */
    select?: LinkUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkUsage
     */
    omit?: LinkUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkUsageInclude<ExtArgs> | null
    where?: LinkUsageWhereInput
    orderBy?: LinkUsageOrderByWithRelationInput | LinkUsageOrderByWithRelationInput[]
    cursor?: LinkUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LinkUsageScalarFieldEnum | LinkUsageScalarFieldEnum[]
  }

  /**
   * InternalLink without action
   */
  export type InternalLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalLink
     */
    select?: InternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InternalLink
     */
    omit?: InternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternalLinkInclude<ExtArgs> | null
  }


  /**
   * Model LinkUsage
   */

  export type AggregateLinkUsage = {
    _count: LinkUsageCountAggregateOutputType | null
    _avg: LinkUsageAvgAggregateOutputType | null
    _sum: LinkUsageSumAggregateOutputType | null
    _min: LinkUsageMinAggregateOutputType | null
    _max: LinkUsageMaxAggregateOutputType | null
  }

  export type LinkUsageAvgAggregateOutputType = {
    position: number | null
  }

  export type LinkUsageSumAggregateOutputType = {
    position: number | null
  }

  export type LinkUsageMinAggregateOutputType = {
    id: string | null
    linkId: string | null
    blogId: string | null
    anchorText: string | null
    context: string | null
    position: number | null
    wasAutoInserted: boolean | null
    insertedAt: Date | null
    createdAt: Date | null
  }

  export type LinkUsageMaxAggregateOutputType = {
    id: string | null
    linkId: string | null
    blogId: string | null
    anchorText: string | null
    context: string | null
    position: number | null
    wasAutoInserted: boolean | null
    insertedAt: Date | null
    createdAt: Date | null
  }

  export type LinkUsageCountAggregateOutputType = {
    id: number
    linkId: number
    blogId: number
    anchorText: number
    context: number
    position: number
    wasAutoInserted: number
    insertedAt: number
    createdAt: number
    _all: number
  }


  export type LinkUsageAvgAggregateInputType = {
    position?: true
  }

  export type LinkUsageSumAggregateInputType = {
    position?: true
  }

  export type LinkUsageMinAggregateInputType = {
    id?: true
    linkId?: true
    blogId?: true
    anchorText?: true
    context?: true
    position?: true
    wasAutoInserted?: true
    insertedAt?: true
    createdAt?: true
  }

  export type LinkUsageMaxAggregateInputType = {
    id?: true
    linkId?: true
    blogId?: true
    anchorText?: true
    context?: true
    position?: true
    wasAutoInserted?: true
    insertedAt?: true
    createdAt?: true
  }

  export type LinkUsageCountAggregateInputType = {
    id?: true
    linkId?: true
    blogId?: true
    anchorText?: true
    context?: true
    position?: true
    wasAutoInserted?: true
    insertedAt?: true
    createdAt?: true
    _all?: true
  }

  export type LinkUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LinkUsage to aggregate.
     */
    where?: LinkUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkUsages to fetch.
     */
    orderBy?: LinkUsageOrderByWithRelationInput | LinkUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LinkUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LinkUsages
    **/
    _count?: true | LinkUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LinkUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LinkUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LinkUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LinkUsageMaxAggregateInputType
  }

  export type GetLinkUsageAggregateType<T extends LinkUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateLinkUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLinkUsage[P]>
      : GetScalarType<T[P], AggregateLinkUsage[P]>
  }




  export type LinkUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkUsageWhereInput
    orderBy?: LinkUsageOrderByWithAggregationInput | LinkUsageOrderByWithAggregationInput[]
    by: LinkUsageScalarFieldEnum[] | LinkUsageScalarFieldEnum
    having?: LinkUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LinkUsageCountAggregateInputType | true
    _avg?: LinkUsageAvgAggregateInputType
    _sum?: LinkUsageSumAggregateInputType
    _min?: LinkUsageMinAggregateInputType
    _max?: LinkUsageMaxAggregateInputType
  }

  export type LinkUsageGroupByOutputType = {
    id: string
    linkId: string
    blogId: string
    anchorText: string
    context: string | null
    position: number | null
    wasAutoInserted: boolean
    insertedAt: Date
    createdAt: Date
    _count: LinkUsageCountAggregateOutputType | null
    _avg: LinkUsageAvgAggregateOutputType | null
    _sum: LinkUsageSumAggregateOutputType | null
    _min: LinkUsageMinAggregateOutputType | null
    _max: LinkUsageMaxAggregateOutputType | null
  }

  type GetLinkUsageGroupByPayload<T extends LinkUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LinkUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LinkUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LinkUsageGroupByOutputType[P]>
            : GetScalarType<T[P], LinkUsageGroupByOutputType[P]>
        }
      >
    >


  export type LinkUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    linkId?: boolean
    blogId?: boolean
    anchorText?: boolean
    context?: boolean
    position?: boolean
    wasAutoInserted?: boolean
    insertedAt?: boolean
    createdAt?: boolean
    link?: boolean | InternalLinkDefaultArgs<ExtArgs>
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkUsage"]>

  export type LinkUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    linkId?: boolean
    blogId?: boolean
    anchorText?: boolean
    context?: boolean
    position?: boolean
    wasAutoInserted?: boolean
    insertedAt?: boolean
    createdAt?: boolean
    link?: boolean | InternalLinkDefaultArgs<ExtArgs>
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkUsage"]>

  export type LinkUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    linkId?: boolean
    blogId?: boolean
    anchorText?: boolean
    context?: boolean
    position?: boolean
    wasAutoInserted?: boolean
    insertedAt?: boolean
    createdAt?: boolean
    link?: boolean | InternalLinkDefaultArgs<ExtArgs>
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkUsage"]>

  export type LinkUsageSelectScalar = {
    id?: boolean
    linkId?: boolean
    blogId?: boolean
    anchorText?: boolean
    context?: boolean
    position?: boolean
    wasAutoInserted?: boolean
    insertedAt?: boolean
    createdAt?: boolean
  }

  export type LinkUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "linkId" | "blogId" | "anchorText" | "context" | "position" | "wasAutoInserted" | "insertedAt" | "createdAt", ExtArgs["result"]["linkUsage"]>
  export type LinkUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    link?: boolean | InternalLinkDefaultArgs<ExtArgs>
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }
  export type LinkUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    link?: boolean | InternalLinkDefaultArgs<ExtArgs>
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }
  export type LinkUsageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    link?: boolean | InternalLinkDefaultArgs<ExtArgs>
    blog?: boolean | BlogDefaultArgs<ExtArgs>
  }

  export type $LinkUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LinkUsage"
    objects: {
      link: Prisma.$InternalLinkPayload<ExtArgs>
      blog: Prisma.$BlogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      linkId: string
      blogId: string
      anchorText: string
      context: string | null
      position: number | null
      wasAutoInserted: boolean
      insertedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["linkUsage"]>
    composites: {}
  }

  type LinkUsageGetPayload<S extends boolean | null | undefined | LinkUsageDefaultArgs> = $Result.GetResult<Prisma.$LinkUsagePayload, S>

  type LinkUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LinkUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LinkUsageCountAggregateInputType | true
    }

  export interface LinkUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LinkUsage'], meta: { name: 'LinkUsage' } }
    /**
     * Find zero or one LinkUsage that matches the filter.
     * @param {LinkUsageFindUniqueArgs} args - Arguments to find a LinkUsage
     * @example
     * // Get one LinkUsage
     * const linkUsage = await prisma.linkUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LinkUsageFindUniqueArgs>(args: SelectSubset<T, LinkUsageFindUniqueArgs<ExtArgs>>): Prisma__LinkUsageClient<$Result.GetResult<Prisma.$LinkUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LinkUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LinkUsageFindUniqueOrThrowArgs} args - Arguments to find a LinkUsage
     * @example
     * // Get one LinkUsage
     * const linkUsage = await prisma.linkUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LinkUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, LinkUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LinkUsageClient<$Result.GetResult<Prisma.$LinkUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LinkUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkUsageFindFirstArgs} args - Arguments to find a LinkUsage
     * @example
     * // Get one LinkUsage
     * const linkUsage = await prisma.linkUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LinkUsageFindFirstArgs>(args?: SelectSubset<T, LinkUsageFindFirstArgs<ExtArgs>>): Prisma__LinkUsageClient<$Result.GetResult<Prisma.$LinkUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LinkUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkUsageFindFirstOrThrowArgs} args - Arguments to find a LinkUsage
     * @example
     * // Get one LinkUsage
     * const linkUsage = await prisma.linkUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LinkUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, LinkUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LinkUsageClient<$Result.GetResult<Prisma.$LinkUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LinkUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LinkUsages
     * const linkUsages = await prisma.linkUsage.findMany()
     * 
     * // Get first 10 LinkUsages
     * const linkUsages = await prisma.linkUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const linkUsageWithIdOnly = await prisma.linkUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LinkUsageFindManyArgs>(args?: SelectSubset<T, LinkUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LinkUsage.
     * @param {LinkUsageCreateArgs} args - Arguments to create a LinkUsage.
     * @example
     * // Create one LinkUsage
     * const LinkUsage = await prisma.linkUsage.create({
     *   data: {
     *     // ... data to create a LinkUsage
     *   }
     * })
     * 
     */
    create<T extends LinkUsageCreateArgs>(args: SelectSubset<T, LinkUsageCreateArgs<ExtArgs>>): Prisma__LinkUsageClient<$Result.GetResult<Prisma.$LinkUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LinkUsages.
     * @param {LinkUsageCreateManyArgs} args - Arguments to create many LinkUsages.
     * @example
     * // Create many LinkUsages
     * const linkUsage = await prisma.linkUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LinkUsageCreateManyArgs>(args?: SelectSubset<T, LinkUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LinkUsages and returns the data saved in the database.
     * @param {LinkUsageCreateManyAndReturnArgs} args - Arguments to create many LinkUsages.
     * @example
     * // Create many LinkUsages
     * const linkUsage = await prisma.linkUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LinkUsages and only return the `id`
     * const linkUsageWithIdOnly = await prisma.linkUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LinkUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, LinkUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkUsagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LinkUsage.
     * @param {LinkUsageDeleteArgs} args - Arguments to delete one LinkUsage.
     * @example
     * // Delete one LinkUsage
     * const LinkUsage = await prisma.linkUsage.delete({
     *   where: {
     *     // ... filter to delete one LinkUsage
     *   }
     * })
     * 
     */
    delete<T extends LinkUsageDeleteArgs>(args: SelectSubset<T, LinkUsageDeleteArgs<ExtArgs>>): Prisma__LinkUsageClient<$Result.GetResult<Prisma.$LinkUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LinkUsage.
     * @param {LinkUsageUpdateArgs} args - Arguments to update one LinkUsage.
     * @example
     * // Update one LinkUsage
     * const linkUsage = await prisma.linkUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LinkUsageUpdateArgs>(args: SelectSubset<T, LinkUsageUpdateArgs<ExtArgs>>): Prisma__LinkUsageClient<$Result.GetResult<Prisma.$LinkUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LinkUsages.
     * @param {LinkUsageDeleteManyArgs} args - Arguments to filter LinkUsages to delete.
     * @example
     * // Delete a few LinkUsages
     * const { count } = await prisma.linkUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LinkUsageDeleteManyArgs>(args?: SelectSubset<T, LinkUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LinkUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LinkUsages
     * const linkUsage = await prisma.linkUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LinkUsageUpdateManyArgs>(args: SelectSubset<T, LinkUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LinkUsages and returns the data updated in the database.
     * @param {LinkUsageUpdateManyAndReturnArgs} args - Arguments to update many LinkUsages.
     * @example
     * // Update many LinkUsages
     * const linkUsage = await prisma.linkUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LinkUsages and only return the `id`
     * const linkUsageWithIdOnly = await prisma.linkUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LinkUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, LinkUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkUsagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LinkUsage.
     * @param {LinkUsageUpsertArgs} args - Arguments to update or create a LinkUsage.
     * @example
     * // Update or create a LinkUsage
     * const linkUsage = await prisma.linkUsage.upsert({
     *   create: {
     *     // ... data to create a LinkUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LinkUsage we want to update
     *   }
     * })
     */
    upsert<T extends LinkUsageUpsertArgs>(args: SelectSubset<T, LinkUsageUpsertArgs<ExtArgs>>): Prisma__LinkUsageClient<$Result.GetResult<Prisma.$LinkUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LinkUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkUsageCountArgs} args - Arguments to filter LinkUsages to count.
     * @example
     * // Count the number of LinkUsages
     * const count = await prisma.linkUsage.count({
     *   where: {
     *     // ... the filter for the LinkUsages we want to count
     *   }
     * })
    **/
    count<T extends LinkUsageCountArgs>(
      args?: Subset<T, LinkUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LinkUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LinkUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LinkUsageAggregateArgs>(args: Subset<T, LinkUsageAggregateArgs>): Prisma.PrismaPromise<GetLinkUsageAggregateType<T>>

    /**
     * Group by LinkUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LinkUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LinkUsageGroupByArgs['orderBy'] }
        : { orderBy?: LinkUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LinkUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLinkUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LinkUsage model
   */
  readonly fields: LinkUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LinkUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LinkUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    link<T extends InternalLinkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InternalLinkDefaultArgs<ExtArgs>>): Prisma__InternalLinkClient<$Result.GetResult<Prisma.$InternalLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    blog<T extends BlogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogDefaultArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LinkUsage model
   */
  interface LinkUsageFieldRefs {
    readonly id: FieldRef<"LinkUsage", 'String'>
    readonly linkId: FieldRef<"LinkUsage", 'String'>
    readonly blogId: FieldRef<"LinkUsage", 'String'>
    readonly anchorText: FieldRef<"LinkUsage", 'String'>
    readonly context: FieldRef<"LinkUsage", 'String'>
    readonly position: FieldRef<"LinkUsage", 'Int'>
    readonly wasAutoInserted: FieldRef<"LinkUsage", 'Boolean'>
    readonly insertedAt: FieldRef<"LinkUsage", 'DateTime'>
    readonly createdAt: FieldRef<"LinkUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LinkUsage findUnique
   */
  export type LinkUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkUsage
     */
    select?: LinkUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkUsage
     */
    omit?: LinkUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkUsageInclude<ExtArgs> | null
    /**
     * Filter, which LinkUsage to fetch.
     */
    where: LinkUsageWhereUniqueInput
  }

  /**
   * LinkUsage findUniqueOrThrow
   */
  export type LinkUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkUsage
     */
    select?: LinkUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkUsage
     */
    omit?: LinkUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkUsageInclude<ExtArgs> | null
    /**
     * Filter, which LinkUsage to fetch.
     */
    where: LinkUsageWhereUniqueInput
  }

  /**
   * LinkUsage findFirst
   */
  export type LinkUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkUsage
     */
    select?: LinkUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkUsage
     */
    omit?: LinkUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkUsageInclude<ExtArgs> | null
    /**
     * Filter, which LinkUsage to fetch.
     */
    where?: LinkUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkUsages to fetch.
     */
    orderBy?: LinkUsageOrderByWithRelationInput | LinkUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LinkUsages.
     */
    cursor?: LinkUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LinkUsages.
     */
    distinct?: LinkUsageScalarFieldEnum | LinkUsageScalarFieldEnum[]
  }

  /**
   * LinkUsage findFirstOrThrow
   */
  export type LinkUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkUsage
     */
    select?: LinkUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkUsage
     */
    omit?: LinkUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkUsageInclude<ExtArgs> | null
    /**
     * Filter, which LinkUsage to fetch.
     */
    where?: LinkUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkUsages to fetch.
     */
    orderBy?: LinkUsageOrderByWithRelationInput | LinkUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LinkUsages.
     */
    cursor?: LinkUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LinkUsages.
     */
    distinct?: LinkUsageScalarFieldEnum | LinkUsageScalarFieldEnum[]
  }

  /**
   * LinkUsage findMany
   */
  export type LinkUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkUsage
     */
    select?: LinkUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkUsage
     */
    omit?: LinkUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkUsageInclude<ExtArgs> | null
    /**
     * Filter, which LinkUsages to fetch.
     */
    where?: LinkUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkUsages to fetch.
     */
    orderBy?: LinkUsageOrderByWithRelationInput | LinkUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LinkUsages.
     */
    cursor?: LinkUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkUsages.
     */
    skip?: number
    distinct?: LinkUsageScalarFieldEnum | LinkUsageScalarFieldEnum[]
  }

  /**
   * LinkUsage create
   */
  export type LinkUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkUsage
     */
    select?: LinkUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkUsage
     */
    omit?: LinkUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a LinkUsage.
     */
    data: XOR<LinkUsageCreateInput, LinkUsageUncheckedCreateInput>
  }

  /**
   * LinkUsage createMany
   */
  export type LinkUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LinkUsages.
     */
    data: LinkUsageCreateManyInput | LinkUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LinkUsage createManyAndReturn
   */
  export type LinkUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkUsage
     */
    select?: LinkUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LinkUsage
     */
    omit?: LinkUsageOmit<ExtArgs> | null
    /**
     * The data used to create many LinkUsages.
     */
    data: LinkUsageCreateManyInput | LinkUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LinkUsage update
   */
  export type LinkUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkUsage
     */
    select?: LinkUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkUsage
     */
    omit?: LinkUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a LinkUsage.
     */
    data: XOR<LinkUsageUpdateInput, LinkUsageUncheckedUpdateInput>
    /**
     * Choose, which LinkUsage to update.
     */
    where: LinkUsageWhereUniqueInput
  }

  /**
   * LinkUsage updateMany
   */
  export type LinkUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LinkUsages.
     */
    data: XOR<LinkUsageUpdateManyMutationInput, LinkUsageUncheckedUpdateManyInput>
    /**
     * Filter which LinkUsages to update
     */
    where?: LinkUsageWhereInput
    /**
     * Limit how many LinkUsages to update.
     */
    limit?: number
  }

  /**
   * LinkUsage updateManyAndReturn
   */
  export type LinkUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkUsage
     */
    select?: LinkUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LinkUsage
     */
    omit?: LinkUsageOmit<ExtArgs> | null
    /**
     * The data used to update LinkUsages.
     */
    data: XOR<LinkUsageUpdateManyMutationInput, LinkUsageUncheckedUpdateManyInput>
    /**
     * Filter which LinkUsages to update
     */
    where?: LinkUsageWhereInput
    /**
     * Limit how many LinkUsages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkUsageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LinkUsage upsert
   */
  export type LinkUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkUsage
     */
    select?: LinkUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkUsage
     */
    omit?: LinkUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the LinkUsage to update in case it exists.
     */
    where: LinkUsageWhereUniqueInput
    /**
     * In case the LinkUsage found by the `where` argument doesn't exist, create a new LinkUsage with this data.
     */
    create: XOR<LinkUsageCreateInput, LinkUsageUncheckedCreateInput>
    /**
     * In case the LinkUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LinkUsageUpdateInput, LinkUsageUncheckedUpdateInput>
  }

  /**
   * LinkUsage delete
   */
  export type LinkUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkUsage
     */
    select?: LinkUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkUsage
     */
    omit?: LinkUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkUsageInclude<ExtArgs> | null
    /**
     * Filter which LinkUsage to delete.
     */
    where: LinkUsageWhereUniqueInput
  }

  /**
   * LinkUsage deleteMany
   */
  export type LinkUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LinkUsages to delete
     */
    where?: LinkUsageWhereInput
    /**
     * Limit how many LinkUsages to delete.
     */
    limit?: number
  }

  /**
   * LinkUsage without action
   */
  export type LinkUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkUsage
     */
    select?: LinkUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkUsage
     */
    omit?: LinkUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkUsageInclude<ExtArgs> | null
  }


  /**
   * Model LandingPageSuggestion
   */

  export type AggregateLandingPageSuggestion = {
    _count: LandingPageSuggestionCountAggregateOutputType | null
    _avg: LandingPageSuggestionAvgAggregateOutputType | null
    _sum: LandingPageSuggestionSumAggregateOutputType | null
    _min: LandingPageSuggestionMinAggregateOutputType | null
    _max: LandingPageSuggestionMaxAggregateOutputType | null
  }

  export type LandingPageSuggestionAvgAggregateOutputType = {
    mentionCount: number | null
  }

  export type LandingPageSuggestionSumAggregateOutputType = {
    mentionCount: number | null
  }

  export type LandingPageSuggestionMinAggregateOutputType = {
    id: string | null
    suggestedUrl: string | null
    suggestedTitle: string | null
    description: string | null
    category: string | null
    reason: string | null
    mentionCount: number | null
    sourceBlogs: string | null
    status: $Enums.LandingPageStatus | null
    createdPageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LandingPageSuggestionMaxAggregateOutputType = {
    id: string | null
    suggestedUrl: string | null
    suggestedTitle: string | null
    description: string | null
    category: string | null
    reason: string | null
    mentionCount: number | null
    sourceBlogs: string | null
    status: $Enums.LandingPageStatus | null
    createdPageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LandingPageSuggestionCountAggregateOutputType = {
    id: number
    suggestedUrl: number
    suggestedTitle: number
    description: number
    category: number
    reason: number
    mentionCount: number
    sourceBlogs: number
    status: number
    createdPageUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LandingPageSuggestionAvgAggregateInputType = {
    mentionCount?: true
  }

  export type LandingPageSuggestionSumAggregateInputType = {
    mentionCount?: true
  }

  export type LandingPageSuggestionMinAggregateInputType = {
    id?: true
    suggestedUrl?: true
    suggestedTitle?: true
    description?: true
    category?: true
    reason?: true
    mentionCount?: true
    sourceBlogs?: true
    status?: true
    createdPageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LandingPageSuggestionMaxAggregateInputType = {
    id?: true
    suggestedUrl?: true
    suggestedTitle?: true
    description?: true
    category?: true
    reason?: true
    mentionCount?: true
    sourceBlogs?: true
    status?: true
    createdPageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LandingPageSuggestionCountAggregateInputType = {
    id?: true
    suggestedUrl?: true
    suggestedTitle?: true
    description?: true
    category?: true
    reason?: true
    mentionCount?: true
    sourceBlogs?: true
    status?: true
    createdPageUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LandingPageSuggestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LandingPageSuggestion to aggregate.
     */
    where?: LandingPageSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LandingPageSuggestions to fetch.
     */
    orderBy?: LandingPageSuggestionOrderByWithRelationInput | LandingPageSuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LandingPageSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LandingPageSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LandingPageSuggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LandingPageSuggestions
    **/
    _count?: true | LandingPageSuggestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LandingPageSuggestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LandingPageSuggestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LandingPageSuggestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LandingPageSuggestionMaxAggregateInputType
  }

  export type GetLandingPageSuggestionAggregateType<T extends LandingPageSuggestionAggregateArgs> = {
        [P in keyof T & keyof AggregateLandingPageSuggestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLandingPageSuggestion[P]>
      : GetScalarType<T[P], AggregateLandingPageSuggestion[P]>
  }




  export type LandingPageSuggestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LandingPageSuggestionWhereInput
    orderBy?: LandingPageSuggestionOrderByWithAggregationInput | LandingPageSuggestionOrderByWithAggregationInput[]
    by: LandingPageSuggestionScalarFieldEnum[] | LandingPageSuggestionScalarFieldEnum
    having?: LandingPageSuggestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LandingPageSuggestionCountAggregateInputType | true
    _avg?: LandingPageSuggestionAvgAggregateInputType
    _sum?: LandingPageSuggestionSumAggregateInputType
    _min?: LandingPageSuggestionMinAggregateInputType
    _max?: LandingPageSuggestionMaxAggregateInputType
  }

  export type LandingPageSuggestionGroupByOutputType = {
    id: string
    suggestedUrl: string
    suggestedTitle: string
    description: string | null
    category: string
    reason: string | null
    mentionCount: number
    sourceBlogs: string | null
    status: $Enums.LandingPageStatus
    createdPageUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: LandingPageSuggestionCountAggregateOutputType | null
    _avg: LandingPageSuggestionAvgAggregateOutputType | null
    _sum: LandingPageSuggestionSumAggregateOutputType | null
    _min: LandingPageSuggestionMinAggregateOutputType | null
    _max: LandingPageSuggestionMaxAggregateOutputType | null
  }

  type GetLandingPageSuggestionGroupByPayload<T extends LandingPageSuggestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LandingPageSuggestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LandingPageSuggestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LandingPageSuggestionGroupByOutputType[P]>
            : GetScalarType<T[P], LandingPageSuggestionGroupByOutputType[P]>
        }
      >
    >


  export type LandingPageSuggestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    suggestedUrl?: boolean
    suggestedTitle?: boolean
    description?: boolean
    category?: boolean
    reason?: boolean
    mentionCount?: boolean
    sourceBlogs?: boolean
    status?: boolean
    createdPageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["landingPageSuggestion"]>

  export type LandingPageSuggestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    suggestedUrl?: boolean
    suggestedTitle?: boolean
    description?: boolean
    category?: boolean
    reason?: boolean
    mentionCount?: boolean
    sourceBlogs?: boolean
    status?: boolean
    createdPageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["landingPageSuggestion"]>

  export type LandingPageSuggestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    suggestedUrl?: boolean
    suggestedTitle?: boolean
    description?: boolean
    category?: boolean
    reason?: boolean
    mentionCount?: boolean
    sourceBlogs?: boolean
    status?: boolean
    createdPageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["landingPageSuggestion"]>

  export type LandingPageSuggestionSelectScalar = {
    id?: boolean
    suggestedUrl?: boolean
    suggestedTitle?: boolean
    description?: boolean
    category?: boolean
    reason?: boolean
    mentionCount?: boolean
    sourceBlogs?: boolean
    status?: boolean
    createdPageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LandingPageSuggestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "suggestedUrl" | "suggestedTitle" | "description" | "category" | "reason" | "mentionCount" | "sourceBlogs" | "status" | "createdPageUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["landingPageSuggestion"]>

  export type $LandingPageSuggestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LandingPageSuggestion"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      suggestedUrl: string
      suggestedTitle: string
      description: string | null
      category: string
      reason: string | null
      mentionCount: number
      sourceBlogs: string | null
      status: $Enums.LandingPageStatus
      createdPageUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["landingPageSuggestion"]>
    composites: {}
  }

  type LandingPageSuggestionGetPayload<S extends boolean | null | undefined | LandingPageSuggestionDefaultArgs> = $Result.GetResult<Prisma.$LandingPageSuggestionPayload, S>

  type LandingPageSuggestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LandingPageSuggestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LandingPageSuggestionCountAggregateInputType | true
    }

  export interface LandingPageSuggestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LandingPageSuggestion'], meta: { name: 'LandingPageSuggestion' } }
    /**
     * Find zero or one LandingPageSuggestion that matches the filter.
     * @param {LandingPageSuggestionFindUniqueArgs} args - Arguments to find a LandingPageSuggestion
     * @example
     * // Get one LandingPageSuggestion
     * const landingPageSuggestion = await prisma.landingPageSuggestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LandingPageSuggestionFindUniqueArgs>(args: SelectSubset<T, LandingPageSuggestionFindUniqueArgs<ExtArgs>>): Prisma__LandingPageSuggestionClient<$Result.GetResult<Prisma.$LandingPageSuggestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LandingPageSuggestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LandingPageSuggestionFindUniqueOrThrowArgs} args - Arguments to find a LandingPageSuggestion
     * @example
     * // Get one LandingPageSuggestion
     * const landingPageSuggestion = await prisma.landingPageSuggestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LandingPageSuggestionFindUniqueOrThrowArgs>(args: SelectSubset<T, LandingPageSuggestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LandingPageSuggestionClient<$Result.GetResult<Prisma.$LandingPageSuggestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LandingPageSuggestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingPageSuggestionFindFirstArgs} args - Arguments to find a LandingPageSuggestion
     * @example
     * // Get one LandingPageSuggestion
     * const landingPageSuggestion = await prisma.landingPageSuggestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LandingPageSuggestionFindFirstArgs>(args?: SelectSubset<T, LandingPageSuggestionFindFirstArgs<ExtArgs>>): Prisma__LandingPageSuggestionClient<$Result.GetResult<Prisma.$LandingPageSuggestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LandingPageSuggestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingPageSuggestionFindFirstOrThrowArgs} args - Arguments to find a LandingPageSuggestion
     * @example
     * // Get one LandingPageSuggestion
     * const landingPageSuggestion = await prisma.landingPageSuggestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LandingPageSuggestionFindFirstOrThrowArgs>(args?: SelectSubset<T, LandingPageSuggestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__LandingPageSuggestionClient<$Result.GetResult<Prisma.$LandingPageSuggestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LandingPageSuggestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingPageSuggestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LandingPageSuggestions
     * const landingPageSuggestions = await prisma.landingPageSuggestion.findMany()
     * 
     * // Get first 10 LandingPageSuggestions
     * const landingPageSuggestions = await prisma.landingPageSuggestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const landingPageSuggestionWithIdOnly = await prisma.landingPageSuggestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LandingPageSuggestionFindManyArgs>(args?: SelectSubset<T, LandingPageSuggestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandingPageSuggestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LandingPageSuggestion.
     * @param {LandingPageSuggestionCreateArgs} args - Arguments to create a LandingPageSuggestion.
     * @example
     * // Create one LandingPageSuggestion
     * const LandingPageSuggestion = await prisma.landingPageSuggestion.create({
     *   data: {
     *     // ... data to create a LandingPageSuggestion
     *   }
     * })
     * 
     */
    create<T extends LandingPageSuggestionCreateArgs>(args: SelectSubset<T, LandingPageSuggestionCreateArgs<ExtArgs>>): Prisma__LandingPageSuggestionClient<$Result.GetResult<Prisma.$LandingPageSuggestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LandingPageSuggestions.
     * @param {LandingPageSuggestionCreateManyArgs} args - Arguments to create many LandingPageSuggestions.
     * @example
     * // Create many LandingPageSuggestions
     * const landingPageSuggestion = await prisma.landingPageSuggestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LandingPageSuggestionCreateManyArgs>(args?: SelectSubset<T, LandingPageSuggestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LandingPageSuggestions and returns the data saved in the database.
     * @param {LandingPageSuggestionCreateManyAndReturnArgs} args - Arguments to create many LandingPageSuggestions.
     * @example
     * // Create many LandingPageSuggestions
     * const landingPageSuggestion = await prisma.landingPageSuggestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LandingPageSuggestions and only return the `id`
     * const landingPageSuggestionWithIdOnly = await prisma.landingPageSuggestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LandingPageSuggestionCreateManyAndReturnArgs>(args?: SelectSubset<T, LandingPageSuggestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandingPageSuggestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LandingPageSuggestion.
     * @param {LandingPageSuggestionDeleteArgs} args - Arguments to delete one LandingPageSuggestion.
     * @example
     * // Delete one LandingPageSuggestion
     * const LandingPageSuggestion = await prisma.landingPageSuggestion.delete({
     *   where: {
     *     // ... filter to delete one LandingPageSuggestion
     *   }
     * })
     * 
     */
    delete<T extends LandingPageSuggestionDeleteArgs>(args: SelectSubset<T, LandingPageSuggestionDeleteArgs<ExtArgs>>): Prisma__LandingPageSuggestionClient<$Result.GetResult<Prisma.$LandingPageSuggestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LandingPageSuggestion.
     * @param {LandingPageSuggestionUpdateArgs} args - Arguments to update one LandingPageSuggestion.
     * @example
     * // Update one LandingPageSuggestion
     * const landingPageSuggestion = await prisma.landingPageSuggestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LandingPageSuggestionUpdateArgs>(args: SelectSubset<T, LandingPageSuggestionUpdateArgs<ExtArgs>>): Prisma__LandingPageSuggestionClient<$Result.GetResult<Prisma.$LandingPageSuggestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LandingPageSuggestions.
     * @param {LandingPageSuggestionDeleteManyArgs} args - Arguments to filter LandingPageSuggestions to delete.
     * @example
     * // Delete a few LandingPageSuggestions
     * const { count } = await prisma.landingPageSuggestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LandingPageSuggestionDeleteManyArgs>(args?: SelectSubset<T, LandingPageSuggestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LandingPageSuggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingPageSuggestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LandingPageSuggestions
     * const landingPageSuggestion = await prisma.landingPageSuggestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LandingPageSuggestionUpdateManyArgs>(args: SelectSubset<T, LandingPageSuggestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LandingPageSuggestions and returns the data updated in the database.
     * @param {LandingPageSuggestionUpdateManyAndReturnArgs} args - Arguments to update many LandingPageSuggestions.
     * @example
     * // Update many LandingPageSuggestions
     * const landingPageSuggestion = await prisma.landingPageSuggestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LandingPageSuggestions and only return the `id`
     * const landingPageSuggestionWithIdOnly = await prisma.landingPageSuggestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LandingPageSuggestionUpdateManyAndReturnArgs>(args: SelectSubset<T, LandingPageSuggestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandingPageSuggestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LandingPageSuggestion.
     * @param {LandingPageSuggestionUpsertArgs} args - Arguments to update or create a LandingPageSuggestion.
     * @example
     * // Update or create a LandingPageSuggestion
     * const landingPageSuggestion = await prisma.landingPageSuggestion.upsert({
     *   create: {
     *     // ... data to create a LandingPageSuggestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LandingPageSuggestion we want to update
     *   }
     * })
     */
    upsert<T extends LandingPageSuggestionUpsertArgs>(args: SelectSubset<T, LandingPageSuggestionUpsertArgs<ExtArgs>>): Prisma__LandingPageSuggestionClient<$Result.GetResult<Prisma.$LandingPageSuggestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LandingPageSuggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingPageSuggestionCountArgs} args - Arguments to filter LandingPageSuggestions to count.
     * @example
     * // Count the number of LandingPageSuggestions
     * const count = await prisma.landingPageSuggestion.count({
     *   where: {
     *     // ... the filter for the LandingPageSuggestions we want to count
     *   }
     * })
    **/
    count<T extends LandingPageSuggestionCountArgs>(
      args?: Subset<T, LandingPageSuggestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LandingPageSuggestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LandingPageSuggestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingPageSuggestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LandingPageSuggestionAggregateArgs>(args: Subset<T, LandingPageSuggestionAggregateArgs>): Prisma.PrismaPromise<GetLandingPageSuggestionAggregateType<T>>

    /**
     * Group by LandingPageSuggestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingPageSuggestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LandingPageSuggestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LandingPageSuggestionGroupByArgs['orderBy'] }
        : { orderBy?: LandingPageSuggestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LandingPageSuggestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLandingPageSuggestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LandingPageSuggestion model
   */
  readonly fields: LandingPageSuggestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LandingPageSuggestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LandingPageSuggestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LandingPageSuggestion model
   */
  interface LandingPageSuggestionFieldRefs {
    readonly id: FieldRef<"LandingPageSuggestion", 'String'>
    readonly suggestedUrl: FieldRef<"LandingPageSuggestion", 'String'>
    readonly suggestedTitle: FieldRef<"LandingPageSuggestion", 'String'>
    readonly description: FieldRef<"LandingPageSuggestion", 'String'>
    readonly category: FieldRef<"LandingPageSuggestion", 'String'>
    readonly reason: FieldRef<"LandingPageSuggestion", 'String'>
    readonly mentionCount: FieldRef<"LandingPageSuggestion", 'Int'>
    readonly sourceBlogs: FieldRef<"LandingPageSuggestion", 'String'>
    readonly status: FieldRef<"LandingPageSuggestion", 'LandingPageStatus'>
    readonly createdPageUrl: FieldRef<"LandingPageSuggestion", 'String'>
    readonly createdAt: FieldRef<"LandingPageSuggestion", 'DateTime'>
    readonly updatedAt: FieldRef<"LandingPageSuggestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LandingPageSuggestion findUnique
   */
  export type LandingPageSuggestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPageSuggestion
     */
    select?: LandingPageSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPageSuggestion
     */
    omit?: LandingPageSuggestionOmit<ExtArgs> | null
    /**
     * Filter, which LandingPageSuggestion to fetch.
     */
    where: LandingPageSuggestionWhereUniqueInput
  }

  /**
   * LandingPageSuggestion findUniqueOrThrow
   */
  export type LandingPageSuggestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPageSuggestion
     */
    select?: LandingPageSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPageSuggestion
     */
    omit?: LandingPageSuggestionOmit<ExtArgs> | null
    /**
     * Filter, which LandingPageSuggestion to fetch.
     */
    where: LandingPageSuggestionWhereUniqueInput
  }

  /**
   * LandingPageSuggestion findFirst
   */
  export type LandingPageSuggestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPageSuggestion
     */
    select?: LandingPageSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPageSuggestion
     */
    omit?: LandingPageSuggestionOmit<ExtArgs> | null
    /**
     * Filter, which LandingPageSuggestion to fetch.
     */
    where?: LandingPageSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LandingPageSuggestions to fetch.
     */
    orderBy?: LandingPageSuggestionOrderByWithRelationInput | LandingPageSuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LandingPageSuggestions.
     */
    cursor?: LandingPageSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LandingPageSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LandingPageSuggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LandingPageSuggestions.
     */
    distinct?: LandingPageSuggestionScalarFieldEnum | LandingPageSuggestionScalarFieldEnum[]
  }

  /**
   * LandingPageSuggestion findFirstOrThrow
   */
  export type LandingPageSuggestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPageSuggestion
     */
    select?: LandingPageSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPageSuggestion
     */
    omit?: LandingPageSuggestionOmit<ExtArgs> | null
    /**
     * Filter, which LandingPageSuggestion to fetch.
     */
    where?: LandingPageSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LandingPageSuggestions to fetch.
     */
    orderBy?: LandingPageSuggestionOrderByWithRelationInput | LandingPageSuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LandingPageSuggestions.
     */
    cursor?: LandingPageSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LandingPageSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LandingPageSuggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LandingPageSuggestions.
     */
    distinct?: LandingPageSuggestionScalarFieldEnum | LandingPageSuggestionScalarFieldEnum[]
  }

  /**
   * LandingPageSuggestion findMany
   */
  export type LandingPageSuggestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPageSuggestion
     */
    select?: LandingPageSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPageSuggestion
     */
    omit?: LandingPageSuggestionOmit<ExtArgs> | null
    /**
     * Filter, which LandingPageSuggestions to fetch.
     */
    where?: LandingPageSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LandingPageSuggestions to fetch.
     */
    orderBy?: LandingPageSuggestionOrderByWithRelationInput | LandingPageSuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LandingPageSuggestions.
     */
    cursor?: LandingPageSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LandingPageSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LandingPageSuggestions.
     */
    skip?: number
    distinct?: LandingPageSuggestionScalarFieldEnum | LandingPageSuggestionScalarFieldEnum[]
  }

  /**
   * LandingPageSuggestion create
   */
  export type LandingPageSuggestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPageSuggestion
     */
    select?: LandingPageSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPageSuggestion
     */
    omit?: LandingPageSuggestionOmit<ExtArgs> | null
    /**
     * The data needed to create a LandingPageSuggestion.
     */
    data: XOR<LandingPageSuggestionCreateInput, LandingPageSuggestionUncheckedCreateInput>
  }

  /**
   * LandingPageSuggestion createMany
   */
  export type LandingPageSuggestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LandingPageSuggestions.
     */
    data: LandingPageSuggestionCreateManyInput | LandingPageSuggestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LandingPageSuggestion createManyAndReturn
   */
  export type LandingPageSuggestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPageSuggestion
     */
    select?: LandingPageSuggestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPageSuggestion
     */
    omit?: LandingPageSuggestionOmit<ExtArgs> | null
    /**
     * The data used to create many LandingPageSuggestions.
     */
    data: LandingPageSuggestionCreateManyInput | LandingPageSuggestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LandingPageSuggestion update
   */
  export type LandingPageSuggestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPageSuggestion
     */
    select?: LandingPageSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPageSuggestion
     */
    omit?: LandingPageSuggestionOmit<ExtArgs> | null
    /**
     * The data needed to update a LandingPageSuggestion.
     */
    data: XOR<LandingPageSuggestionUpdateInput, LandingPageSuggestionUncheckedUpdateInput>
    /**
     * Choose, which LandingPageSuggestion to update.
     */
    where: LandingPageSuggestionWhereUniqueInput
  }

  /**
   * LandingPageSuggestion updateMany
   */
  export type LandingPageSuggestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LandingPageSuggestions.
     */
    data: XOR<LandingPageSuggestionUpdateManyMutationInput, LandingPageSuggestionUncheckedUpdateManyInput>
    /**
     * Filter which LandingPageSuggestions to update
     */
    where?: LandingPageSuggestionWhereInput
    /**
     * Limit how many LandingPageSuggestions to update.
     */
    limit?: number
  }

  /**
   * LandingPageSuggestion updateManyAndReturn
   */
  export type LandingPageSuggestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPageSuggestion
     */
    select?: LandingPageSuggestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPageSuggestion
     */
    omit?: LandingPageSuggestionOmit<ExtArgs> | null
    /**
     * The data used to update LandingPageSuggestions.
     */
    data: XOR<LandingPageSuggestionUpdateManyMutationInput, LandingPageSuggestionUncheckedUpdateManyInput>
    /**
     * Filter which LandingPageSuggestions to update
     */
    where?: LandingPageSuggestionWhereInput
    /**
     * Limit how many LandingPageSuggestions to update.
     */
    limit?: number
  }

  /**
   * LandingPageSuggestion upsert
   */
  export type LandingPageSuggestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPageSuggestion
     */
    select?: LandingPageSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPageSuggestion
     */
    omit?: LandingPageSuggestionOmit<ExtArgs> | null
    /**
     * The filter to search for the LandingPageSuggestion to update in case it exists.
     */
    where: LandingPageSuggestionWhereUniqueInput
    /**
     * In case the LandingPageSuggestion found by the `where` argument doesn't exist, create a new LandingPageSuggestion with this data.
     */
    create: XOR<LandingPageSuggestionCreateInput, LandingPageSuggestionUncheckedCreateInput>
    /**
     * In case the LandingPageSuggestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LandingPageSuggestionUpdateInput, LandingPageSuggestionUncheckedUpdateInput>
  }

  /**
   * LandingPageSuggestion delete
   */
  export type LandingPageSuggestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPageSuggestion
     */
    select?: LandingPageSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPageSuggestion
     */
    omit?: LandingPageSuggestionOmit<ExtArgs> | null
    /**
     * Filter which LandingPageSuggestion to delete.
     */
    where: LandingPageSuggestionWhereUniqueInput
  }

  /**
   * LandingPageSuggestion deleteMany
   */
  export type LandingPageSuggestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LandingPageSuggestions to delete
     */
    where?: LandingPageSuggestionWhereInput
    /**
     * Limit how many LandingPageSuggestions to delete.
     */
    limit?: number
  }

  /**
   * LandingPageSuggestion without action
   */
  export type LandingPageSuggestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPageSuggestion
     */
    select?: LandingPageSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPageSuggestion
     */
    omit?: LandingPageSuggestionOmit<ExtArgs> | null
  }


  /**
   * Model LandingPage
   */

  export type AggregateLandingPage = {
    _count: LandingPageCountAggregateOutputType | null
    _min: LandingPageMinAggregateOutputType | null
    _max: LandingPageMaxAggregateOutputType | null
  }

  export type LandingPageMinAggregateOutputType = {
    id: string | null
    url: string | null
    title: string | null
    category: string | null
    metaTitle: string | null
    metaDescription: string | null
    content: string | null
    published: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LandingPageMaxAggregateOutputType = {
    id: string | null
    url: string | null
    title: string | null
    category: string | null
    metaTitle: string | null
    metaDescription: string | null
    content: string | null
    published: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LandingPageCountAggregateOutputType = {
    id: number
    url: number
    title: number
    category: number
    metaTitle: number
    metaDescription: number
    content: number
    faq: number
    published: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LandingPageMinAggregateInputType = {
    id?: true
    url?: true
    title?: true
    category?: true
    metaTitle?: true
    metaDescription?: true
    content?: true
    published?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LandingPageMaxAggregateInputType = {
    id?: true
    url?: true
    title?: true
    category?: true
    metaTitle?: true
    metaDescription?: true
    content?: true
    published?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LandingPageCountAggregateInputType = {
    id?: true
    url?: true
    title?: true
    category?: true
    metaTitle?: true
    metaDescription?: true
    content?: true
    faq?: true
    published?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LandingPageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LandingPage to aggregate.
     */
    where?: LandingPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LandingPages to fetch.
     */
    orderBy?: LandingPageOrderByWithRelationInput | LandingPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LandingPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LandingPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LandingPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LandingPages
    **/
    _count?: true | LandingPageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LandingPageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LandingPageMaxAggregateInputType
  }

  export type GetLandingPageAggregateType<T extends LandingPageAggregateArgs> = {
        [P in keyof T & keyof AggregateLandingPage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLandingPage[P]>
      : GetScalarType<T[P], AggregateLandingPage[P]>
  }




  export type LandingPageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LandingPageWhereInput
    orderBy?: LandingPageOrderByWithAggregationInput | LandingPageOrderByWithAggregationInput[]
    by: LandingPageScalarFieldEnum[] | LandingPageScalarFieldEnum
    having?: LandingPageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LandingPageCountAggregateInputType | true
    _min?: LandingPageMinAggregateInputType
    _max?: LandingPageMaxAggregateInputType
  }

  export type LandingPageGroupByOutputType = {
    id: string
    url: string
    title: string
    category: string
    metaTitle: string | null
    metaDescription: string | null
    content: string
    faq: JsonValue | null
    published: boolean
    createdAt: Date
    updatedAt: Date
    _count: LandingPageCountAggregateOutputType | null
    _min: LandingPageMinAggregateOutputType | null
    _max: LandingPageMaxAggregateOutputType | null
  }

  type GetLandingPageGroupByPayload<T extends LandingPageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LandingPageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LandingPageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LandingPageGroupByOutputType[P]>
            : GetScalarType<T[P], LandingPageGroupByOutputType[P]>
        }
      >
    >


  export type LandingPageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    title?: boolean
    category?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    content?: boolean
    faq?: boolean
    published?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["landingPage"]>

  export type LandingPageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    title?: boolean
    category?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    content?: boolean
    faq?: boolean
    published?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["landingPage"]>

  export type LandingPageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    title?: boolean
    category?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    content?: boolean
    faq?: boolean
    published?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["landingPage"]>

  export type LandingPageSelectScalar = {
    id?: boolean
    url?: boolean
    title?: boolean
    category?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    content?: boolean
    faq?: boolean
    published?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LandingPageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "title" | "category" | "metaTitle" | "metaDescription" | "content" | "faq" | "published" | "createdAt" | "updatedAt", ExtArgs["result"]["landingPage"]>

  export type $LandingPagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LandingPage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      title: string
      category: string
      metaTitle: string | null
      metaDescription: string | null
      content: string
      faq: Prisma.JsonValue | null
      published: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["landingPage"]>
    composites: {}
  }

  type LandingPageGetPayload<S extends boolean | null | undefined | LandingPageDefaultArgs> = $Result.GetResult<Prisma.$LandingPagePayload, S>

  type LandingPageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LandingPageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LandingPageCountAggregateInputType | true
    }

  export interface LandingPageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LandingPage'], meta: { name: 'LandingPage' } }
    /**
     * Find zero or one LandingPage that matches the filter.
     * @param {LandingPageFindUniqueArgs} args - Arguments to find a LandingPage
     * @example
     * // Get one LandingPage
     * const landingPage = await prisma.landingPage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LandingPageFindUniqueArgs>(args: SelectSubset<T, LandingPageFindUniqueArgs<ExtArgs>>): Prisma__LandingPageClient<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LandingPage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LandingPageFindUniqueOrThrowArgs} args - Arguments to find a LandingPage
     * @example
     * // Get one LandingPage
     * const landingPage = await prisma.landingPage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LandingPageFindUniqueOrThrowArgs>(args: SelectSubset<T, LandingPageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LandingPageClient<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LandingPage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingPageFindFirstArgs} args - Arguments to find a LandingPage
     * @example
     * // Get one LandingPage
     * const landingPage = await prisma.landingPage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LandingPageFindFirstArgs>(args?: SelectSubset<T, LandingPageFindFirstArgs<ExtArgs>>): Prisma__LandingPageClient<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LandingPage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingPageFindFirstOrThrowArgs} args - Arguments to find a LandingPage
     * @example
     * // Get one LandingPage
     * const landingPage = await prisma.landingPage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LandingPageFindFirstOrThrowArgs>(args?: SelectSubset<T, LandingPageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LandingPageClient<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LandingPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingPageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LandingPages
     * const landingPages = await prisma.landingPage.findMany()
     * 
     * // Get first 10 LandingPages
     * const landingPages = await prisma.landingPage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const landingPageWithIdOnly = await prisma.landingPage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LandingPageFindManyArgs>(args?: SelectSubset<T, LandingPageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LandingPage.
     * @param {LandingPageCreateArgs} args - Arguments to create a LandingPage.
     * @example
     * // Create one LandingPage
     * const LandingPage = await prisma.landingPage.create({
     *   data: {
     *     // ... data to create a LandingPage
     *   }
     * })
     * 
     */
    create<T extends LandingPageCreateArgs>(args: SelectSubset<T, LandingPageCreateArgs<ExtArgs>>): Prisma__LandingPageClient<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LandingPages.
     * @param {LandingPageCreateManyArgs} args - Arguments to create many LandingPages.
     * @example
     * // Create many LandingPages
     * const landingPage = await prisma.landingPage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LandingPageCreateManyArgs>(args?: SelectSubset<T, LandingPageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LandingPages and returns the data saved in the database.
     * @param {LandingPageCreateManyAndReturnArgs} args - Arguments to create many LandingPages.
     * @example
     * // Create many LandingPages
     * const landingPage = await prisma.landingPage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LandingPages and only return the `id`
     * const landingPageWithIdOnly = await prisma.landingPage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LandingPageCreateManyAndReturnArgs>(args?: SelectSubset<T, LandingPageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LandingPage.
     * @param {LandingPageDeleteArgs} args - Arguments to delete one LandingPage.
     * @example
     * // Delete one LandingPage
     * const LandingPage = await prisma.landingPage.delete({
     *   where: {
     *     // ... filter to delete one LandingPage
     *   }
     * })
     * 
     */
    delete<T extends LandingPageDeleteArgs>(args: SelectSubset<T, LandingPageDeleteArgs<ExtArgs>>): Prisma__LandingPageClient<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LandingPage.
     * @param {LandingPageUpdateArgs} args - Arguments to update one LandingPage.
     * @example
     * // Update one LandingPage
     * const landingPage = await prisma.landingPage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LandingPageUpdateArgs>(args: SelectSubset<T, LandingPageUpdateArgs<ExtArgs>>): Prisma__LandingPageClient<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LandingPages.
     * @param {LandingPageDeleteManyArgs} args - Arguments to filter LandingPages to delete.
     * @example
     * // Delete a few LandingPages
     * const { count } = await prisma.landingPage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LandingPageDeleteManyArgs>(args?: SelectSubset<T, LandingPageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LandingPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingPageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LandingPages
     * const landingPage = await prisma.landingPage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LandingPageUpdateManyArgs>(args: SelectSubset<T, LandingPageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LandingPages and returns the data updated in the database.
     * @param {LandingPageUpdateManyAndReturnArgs} args - Arguments to update many LandingPages.
     * @example
     * // Update many LandingPages
     * const landingPage = await prisma.landingPage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LandingPages and only return the `id`
     * const landingPageWithIdOnly = await prisma.landingPage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LandingPageUpdateManyAndReturnArgs>(args: SelectSubset<T, LandingPageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LandingPage.
     * @param {LandingPageUpsertArgs} args - Arguments to update or create a LandingPage.
     * @example
     * // Update or create a LandingPage
     * const landingPage = await prisma.landingPage.upsert({
     *   create: {
     *     // ... data to create a LandingPage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LandingPage we want to update
     *   }
     * })
     */
    upsert<T extends LandingPageUpsertArgs>(args: SelectSubset<T, LandingPageUpsertArgs<ExtArgs>>): Prisma__LandingPageClient<$Result.GetResult<Prisma.$LandingPagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LandingPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingPageCountArgs} args - Arguments to filter LandingPages to count.
     * @example
     * // Count the number of LandingPages
     * const count = await prisma.landingPage.count({
     *   where: {
     *     // ... the filter for the LandingPages we want to count
     *   }
     * })
    **/
    count<T extends LandingPageCountArgs>(
      args?: Subset<T, LandingPageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LandingPageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LandingPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingPageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LandingPageAggregateArgs>(args: Subset<T, LandingPageAggregateArgs>): Prisma.PrismaPromise<GetLandingPageAggregateType<T>>

    /**
     * Group by LandingPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingPageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LandingPageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LandingPageGroupByArgs['orderBy'] }
        : { orderBy?: LandingPageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LandingPageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLandingPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LandingPage model
   */
  readonly fields: LandingPageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LandingPage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LandingPageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LandingPage model
   */
  interface LandingPageFieldRefs {
    readonly id: FieldRef<"LandingPage", 'String'>
    readonly url: FieldRef<"LandingPage", 'String'>
    readonly title: FieldRef<"LandingPage", 'String'>
    readonly category: FieldRef<"LandingPage", 'String'>
    readonly metaTitle: FieldRef<"LandingPage", 'String'>
    readonly metaDescription: FieldRef<"LandingPage", 'String'>
    readonly content: FieldRef<"LandingPage", 'String'>
    readonly faq: FieldRef<"LandingPage", 'Json'>
    readonly published: FieldRef<"LandingPage", 'Boolean'>
    readonly createdAt: FieldRef<"LandingPage", 'DateTime'>
    readonly updatedAt: FieldRef<"LandingPage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LandingPage findUnique
   */
  export type LandingPageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * Filter, which LandingPage to fetch.
     */
    where: LandingPageWhereUniqueInput
  }

  /**
   * LandingPage findUniqueOrThrow
   */
  export type LandingPageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * Filter, which LandingPage to fetch.
     */
    where: LandingPageWhereUniqueInput
  }

  /**
   * LandingPage findFirst
   */
  export type LandingPageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * Filter, which LandingPage to fetch.
     */
    where?: LandingPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LandingPages to fetch.
     */
    orderBy?: LandingPageOrderByWithRelationInput | LandingPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LandingPages.
     */
    cursor?: LandingPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LandingPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LandingPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LandingPages.
     */
    distinct?: LandingPageScalarFieldEnum | LandingPageScalarFieldEnum[]
  }

  /**
   * LandingPage findFirstOrThrow
   */
  export type LandingPageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * Filter, which LandingPage to fetch.
     */
    where?: LandingPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LandingPages to fetch.
     */
    orderBy?: LandingPageOrderByWithRelationInput | LandingPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LandingPages.
     */
    cursor?: LandingPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LandingPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LandingPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LandingPages.
     */
    distinct?: LandingPageScalarFieldEnum | LandingPageScalarFieldEnum[]
  }

  /**
   * LandingPage findMany
   */
  export type LandingPageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * Filter, which LandingPages to fetch.
     */
    where?: LandingPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LandingPages to fetch.
     */
    orderBy?: LandingPageOrderByWithRelationInput | LandingPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LandingPages.
     */
    cursor?: LandingPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LandingPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LandingPages.
     */
    skip?: number
    distinct?: LandingPageScalarFieldEnum | LandingPageScalarFieldEnum[]
  }

  /**
   * LandingPage create
   */
  export type LandingPageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * The data needed to create a LandingPage.
     */
    data: XOR<LandingPageCreateInput, LandingPageUncheckedCreateInput>
  }

  /**
   * LandingPage createMany
   */
  export type LandingPageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LandingPages.
     */
    data: LandingPageCreateManyInput | LandingPageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LandingPage createManyAndReturn
   */
  export type LandingPageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * The data used to create many LandingPages.
     */
    data: LandingPageCreateManyInput | LandingPageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LandingPage update
   */
  export type LandingPageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * The data needed to update a LandingPage.
     */
    data: XOR<LandingPageUpdateInput, LandingPageUncheckedUpdateInput>
    /**
     * Choose, which LandingPage to update.
     */
    where: LandingPageWhereUniqueInput
  }

  /**
   * LandingPage updateMany
   */
  export type LandingPageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LandingPages.
     */
    data: XOR<LandingPageUpdateManyMutationInput, LandingPageUncheckedUpdateManyInput>
    /**
     * Filter which LandingPages to update
     */
    where?: LandingPageWhereInput
    /**
     * Limit how many LandingPages to update.
     */
    limit?: number
  }

  /**
   * LandingPage updateManyAndReturn
   */
  export type LandingPageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * The data used to update LandingPages.
     */
    data: XOR<LandingPageUpdateManyMutationInput, LandingPageUncheckedUpdateManyInput>
    /**
     * Filter which LandingPages to update
     */
    where?: LandingPageWhereInput
    /**
     * Limit how many LandingPages to update.
     */
    limit?: number
  }

  /**
   * LandingPage upsert
   */
  export type LandingPageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * The filter to search for the LandingPage to update in case it exists.
     */
    where: LandingPageWhereUniqueInput
    /**
     * In case the LandingPage found by the `where` argument doesn't exist, create a new LandingPage with this data.
     */
    create: XOR<LandingPageCreateInput, LandingPageUncheckedCreateInput>
    /**
     * In case the LandingPage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LandingPageUpdateInput, LandingPageUncheckedUpdateInput>
  }

  /**
   * LandingPage delete
   */
  export type LandingPageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
    /**
     * Filter which LandingPage to delete.
     */
    where: LandingPageWhereUniqueInput
  }

  /**
   * LandingPage deleteMany
   */
  export type LandingPageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LandingPages to delete
     */
    where?: LandingPageWhereInput
    /**
     * Limit how many LandingPages to delete.
     */
    limit?: number
  }

  /**
   * LandingPage without action
   */
  export type LandingPageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingPage
     */
    select?: LandingPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LandingPage
     */
    omit?: LandingPageOmit<ExtArgs> | null
  }


  /**
   * Model CompanyProfile
   */

  export type AggregateCompanyProfile = {
    _count: CompanyProfileCountAggregateOutputType | null
    _min: CompanyProfileMinAggregateOutputType | null
    _max: CompanyProfileMaxAggregateOutputType | null
  }

  export type CompanyProfileMinAggregateOutputType = {
    id: string | null
    companyName: string | null
    tagline: string | null
    description: string | null
    tone: string | null
    writingStyle: string | null
    targetAudience: string | null
    targetLocations: string | null
    usps: string | null
    expertise: string | null
    contentThemes: string | null
    brandKeywords: string | null
    avoidTopics: string | null
    competitors: string | null
    websiteUrl: string | null
    lastAnalyzedAt: Date | null
    analysisData: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyProfileMaxAggregateOutputType = {
    id: string | null
    companyName: string | null
    tagline: string | null
    description: string | null
    tone: string | null
    writingStyle: string | null
    targetAudience: string | null
    targetLocations: string | null
    usps: string | null
    expertise: string | null
    contentThemes: string | null
    brandKeywords: string | null
    avoidTopics: string | null
    competitors: string | null
    websiteUrl: string | null
    lastAnalyzedAt: Date | null
    analysisData: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyProfileCountAggregateOutputType = {
    id: number
    companyName: number
    tagline: number
    description: number
    tone: number
    writingStyle: number
    targetAudience: number
    targetLocations: number
    usps: number
    expertise: number
    contentThemes: number
    brandKeywords: number
    avoidTopics: number
    competitors: number
    websiteUrl: number
    lastAnalyzedAt: number
    analysisData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyProfileMinAggregateInputType = {
    id?: true
    companyName?: true
    tagline?: true
    description?: true
    tone?: true
    writingStyle?: true
    targetAudience?: true
    targetLocations?: true
    usps?: true
    expertise?: true
    contentThemes?: true
    brandKeywords?: true
    avoidTopics?: true
    competitors?: true
    websiteUrl?: true
    lastAnalyzedAt?: true
    analysisData?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyProfileMaxAggregateInputType = {
    id?: true
    companyName?: true
    tagline?: true
    description?: true
    tone?: true
    writingStyle?: true
    targetAudience?: true
    targetLocations?: true
    usps?: true
    expertise?: true
    contentThemes?: true
    brandKeywords?: true
    avoidTopics?: true
    competitors?: true
    websiteUrl?: true
    lastAnalyzedAt?: true
    analysisData?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyProfileCountAggregateInputType = {
    id?: true
    companyName?: true
    tagline?: true
    description?: true
    tone?: true
    writingStyle?: true
    targetAudience?: true
    targetLocations?: true
    usps?: true
    expertise?: true
    contentThemes?: true
    brandKeywords?: true
    avoidTopics?: true
    competitors?: true
    websiteUrl?: true
    lastAnalyzedAt?: true
    analysisData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyProfile to aggregate.
     */
    where?: CompanyProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyProfiles to fetch.
     */
    orderBy?: CompanyProfileOrderByWithRelationInput | CompanyProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyProfiles
    **/
    _count?: true | CompanyProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyProfileMaxAggregateInputType
  }

  export type GetCompanyProfileAggregateType<T extends CompanyProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyProfile[P]>
      : GetScalarType<T[P], AggregateCompanyProfile[P]>
  }




  export type CompanyProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyProfileWhereInput
    orderBy?: CompanyProfileOrderByWithAggregationInput | CompanyProfileOrderByWithAggregationInput[]
    by: CompanyProfileScalarFieldEnum[] | CompanyProfileScalarFieldEnum
    having?: CompanyProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyProfileCountAggregateInputType | true
    _min?: CompanyProfileMinAggregateInputType
    _max?: CompanyProfileMaxAggregateInputType
  }

  export type CompanyProfileGroupByOutputType = {
    id: string
    companyName: string | null
    tagline: string | null
    description: string | null
    tone: string | null
    writingStyle: string | null
    targetAudience: string | null
    targetLocations: string | null
    usps: string | null
    expertise: string | null
    contentThemes: string | null
    brandKeywords: string | null
    avoidTopics: string | null
    competitors: string | null
    websiteUrl: string | null
    lastAnalyzedAt: Date | null
    analysisData: string | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyProfileCountAggregateOutputType | null
    _min: CompanyProfileMinAggregateOutputType | null
    _max: CompanyProfileMaxAggregateOutputType | null
  }

  type GetCompanyProfileGroupByPayload<T extends CompanyProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyProfileGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyProfileGroupByOutputType[P]>
        }
      >
    >


  export type CompanyProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    tagline?: boolean
    description?: boolean
    tone?: boolean
    writingStyle?: boolean
    targetAudience?: boolean
    targetLocations?: boolean
    usps?: boolean
    expertise?: boolean
    contentThemes?: boolean
    brandKeywords?: boolean
    avoidTopics?: boolean
    competitors?: boolean
    websiteUrl?: boolean
    lastAnalyzedAt?: boolean
    analysisData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["companyProfile"]>

  export type CompanyProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    tagline?: boolean
    description?: boolean
    tone?: boolean
    writingStyle?: boolean
    targetAudience?: boolean
    targetLocations?: boolean
    usps?: boolean
    expertise?: boolean
    contentThemes?: boolean
    brandKeywords?: boolean
    avoidTopics?: boolean
    competitors?: boolean
    websiteUrl?: boolean
    lastAnalyzedAt?: boolean
    analysisData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["companyProfile"]>

  export type CompanyProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    tagline?: boolean
    description?: boolean
    tone?: boolean
    writingStyle?: boolean
    targetAudience?: boolean
    targetLocations?: boolean
    usps?: boolean
    expertise?: boolean
    contentThemes?: boolean
    brandKeywords?: boolean
    avoidTopics?: boolean
    competitors?: boolean
    websiteUrl?: boolean
    lastAnalyzedAt?: boolean
    analysisData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["companyProfile"]>

  export type CompanyProfileSelectScalar = {
    id?: boolean
    companyName?: boolean
    tagline?: boolean
    description?: boolean
    tone?: boolean
    writingStyle?: boolean
    targetAudience?: boolean
    targetLocations?: boolean
    usps?: boolean
    expertise?: boolean
    contentThemes?: boolean
    brandKeywords?: boolean
    avoidTopics?: boolean
    competitors?: boolean
    websiteUrl?: boolean
    lastAnalyzedAt?: boolean
    analysisData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyName" | "tagline" | "description" | "tone" | "writingStyle" | "targetAudience" | "targetLocations" | "usps" | "expertise" | "contentThemes" | "brandKeywords" | "avoidTopics" | "competitors" | "websiteUrl" | "lastAnalyzedAt" | "analysisData" | "createdAt" | "updatedAt", ExtArgs["result"]["companyProfile"]>

  export type $CompanyProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyProfile"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyName: string | null
      tagline: string | null
      description: string | null
      tone: string | null
      writingStyle: string | null
      targetAudience: string | null
      targetLocations: string | null
      usps: string | null
      expertise: string | null
      contentThemes: string | null
      brandKeywords: string | null
      avoidTopics: string | null
      competitors: string | null
      websiteUrl: string | null
      lastAnalyzedAt: Date | null
      analysisData: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["companyProfile"]>
    composites: {}
  }

  type CompanyProfileGetPayload<S extends boolean | null | undefined | CompanyProfileDefaultArgs> = $Result.GetResult<Prisma.$CompanyProfilePayload, S>

  type CompanyProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyProfileCountAggregateInputType | true
    }

  export interface CompanyProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyProfile'], meta: { name: 'CompanyProfile' } }
    /**
     * Find zero or one CompanyProfile that matches the filter.
     * @param {CompanyProfileFindUniqueArgs} args - Arguments to find a CompanyProfile
     * @example
     * // Get one CompanyProfile
     * const companyProfile = await prisma.companyProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyProfileFindUniqueArgs>(args: SelectSubset<T, CompanyProfileFindUniqueArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyProfileFindUniqueOrThrowArgs} args - Arguments to find a CompanyProfile
     * @example
     * // Get one CompanyProfile
     * const companyProfile = await prisma.companyProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProfileFindFirstArgs} args - Arguments to find a CompanyProfile
     * @example
     * // Get one CompanyProfile
     * const companyProfile = await prisma.companyProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyProfileFindFirstArgs>(args?: SelectSubset<T, CompanyProfileFindFirstArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProfileFindFirstOrThrowArgs} args - Arguments to find a CompanyProfile
     * @example
     * // Get one CompanyProfile
     * const companyProfile = await prisma.companyProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyProfiles
     * const companyProfiles = await prisma.companyProfile.findMany()
     * 
     * // Get first 10 CompanyProfiles
     * const companyProfiles = await prisma.companyProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyProfileWithIdOnly = await prisma.companyProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyProfileFindManyArgs>(args?: SelectSubset<T, CompanyProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyProfile.
     * @param {CompanyProfileCreateArgs} args - Arguments to create a CompanyProfile.
     * @example
     * // Create one CompanyProfile
     * const CompanyProfile = await prisma.companyProfile.create({
     *   data: {
     *     // ... data to create a CompanyProfile
     *   }
     * })
     * 
     */
    create<T extends CompanyProfileCreateArgs>(args: SelectSubset<T, CompanyProfileCreateArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyProfiles.
     * @param {CompanyProfileCreateManyArgs} args - Arguments to create many CompanyProfiles.
     * @example
     * // Create many CompanyProfiles
     * const companyProfile = await prisma.companyProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyProfileCreateManyArgs>(args?: SelectSubset<T, CompanyProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyProfiles and returns the data saved in the database.
     * @param {CompanyProfileCreateManyAndReturnArgs} args - Arguments to create many CompanyProfiles.
     * @example
     * // Create many CompanyProfiles
     * const companyProfile = await prisma.companyProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyProfiles and only return the `id`
     * const companyProfileWithIdOnly = await prisma.companyProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyProfile.
     * @param {CompanyProfileDeleteArgs} args - Arguments to delete one CompanyProfile.
     * @example
     * // Delete one CompanyProfile
     * const CompanyProfile = await prisma.companyProfile.delete({
     *   where: {
     *     // ... filter to delete one CompanyProfile
     *   }
     * })
     * 
     */
    delete<T extends CompanyProfileDeleteArgs>(args: SelectSubset<T, CompanyProfileDeleteArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyProfile.
     * @param {CompanyProfileUpdateArgs} args - Arguments to update one CompanyProfile.
     * @example
     * // Update one CompanyProfile
     * const companyProfile = await prisma.companyProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyProfileUpdateArgs>(args: SelectSubset<T, CompanyProfileUpdateArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyProfiles.
     * @param {CompanyProfileDeleteManyArgs} args - Arguments to filter CompanyProfiles to delete.
     * @example
     * // Delete a few CompanyProfiles
     * const { count } = await prisma.companyProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyProfileDeleteManyArgs>(args?: SelectSubset<T, CompanyProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyProfiles
     * const companyProfile = await prisma.companyProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyProfileUpdateManyArgs>(args: SelectSubset<T, CompanyProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyProfiles and returns the data updated in the database.
     * @param {CompanyProfileUpdateManyAndReturnArgs} args - Arguments to update many CompanyProfiles.
     * @example
     * // Update many CompanyProfiles
     * const companyProfile = await prisma.companyProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyProfiles and only return the `id`
     * const companyProfileWithIdOnly = await prisma.companyProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyProfile.
     * @param {CompanyProfileUpsertArgs} args - Arguments to update or create a CompanyProfile.
     * @example
     * // Update or create a CompanyProfile
     * const companyProfile = await prisma.companyProfile.upsert({
     *   create: {
     *     // ... data to create a CompanyProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyProfile we want to update
     *   }
     * })
     */
    upsert<T extends CompanyProfileUpsertArgs>(args: SelectSubset<T, CompanyProfileUpsertArgs<ExtArgs>>): Prisma__CompanyProfileClient<$Result.GetResult<Prisma.$CompanyProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProfileCountArgs} args - Arguments to filter CompanyProfiles to count.
     * @example
     * // Count the number of CompanyProfiles
     * const count = await prisma.companyProfile.count({
     *   where: {
     *     // ... the filter for the CompanyProfiles we want to count
     *   }
     * })
    **/
    count<T extends CompanyProfileCountArgs>(
      args?: Subset<T, CompanyProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyProfileAggregateArgs>(args: Subset<T, CompanyProfileAggregateArgs>): Prisma.PrismaPromise<GetCompanyProfileAggregateType<T>>

    /**
     * Group by CompanyProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyProfileGroupByArgs['orderBy'] }
        : { orderBy?: CompanyProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyProfile model
   */
  readonly fields: CompanyProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyProfile model
   */
  interface CompanyProfileFieldRefs {
    readonly id: FieldRef<"CompanyProfile", 'String'>
    readonly companyName: FieldRef<"CompanyProfile", 'String'>
    readonly tagline: FieldRef<"CompanyProfile", 'String'>
    readonly description: FieldRef<"CompanyProfile", 'String'>
    readonly tone: FieldRef<"CompanyProfile", 'String'>
    readonly writingStyle: FieldRef<"CompanyProfile", 'String'>
    readonly targetAudience: FieldRef<"CompanyProfile", 'String'>
    readonly targetLocations: FieldRef<"CompanyProfile", 'String'>
    readonly usps: FieldRef<"CompanyProfile", 'String'>
    readonly expertise: FieldRef<"CompanyProfile", 'String'>
    readonly contentThemes: FieldRef<"CompanyProfile", 'String'>
    readonly brandKeywords: FieldRef<"CompanyProfile", 'String'>
    readonly avoidTopics: FieldRef<"CompanyProfile", 'String'>
    readonly competitors: FieldRef<"CompanyProfile", 'String'>
    readonly websiteUrl: FieldRef<"CompanyProfile", 'String'>
    readonly lastAnalyzedAt: FieldRef<"CompanyProfile", 'DateTime'>
    readonly analysisData: FieldRef<"CompanyProfile", 'String'>
    readonly createdAt: FieldRef<"CompanyProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanyProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyProfile findUnique
   */
  export type CompanyProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyProfile
     */
    omit?: CompanyProfileOmit<ExtArgs> | null
    /**
     * Filter, which CompanyProfile to fetch.
     */
    where: CompanyProfileWhereUniqueInput
  }

  /**
   * CompanyProfile findUniqueOrThrow
   */
  export type CompanyProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyProfile
     */
    omit?: CompanyProfileOmit<ExtArgs> | null
    /**
     * Filter, which CompanyProfile to fetch.
     */
    where: CompanyProfileWhereUniqueInput
  }

  /**
   * CompanyProfile findFirst
   */
  export type CompanyProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyProfile
     */
    omit?: CompanyProfileOmit<ExtArgs> | null
    /**
     * Filter, which CompanyProfile to fetch.
     */
    where?: CompanyProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyProfiles to fetch.
     */
    orderBy?: CompanyProfileOrderByWithRelationInput | CompanyProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyProfiles.
     */
    cursor?: CompanyProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyProfiles.
     */
    distinct?: CompanyProfileScalarFieldEnum | CompanyProfileScalarFieldEnum[]
  }

  /**
   * CompanyProfile findFirstOrThrow
   */
  export type CompanyProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyProfile
     */
    omit?: CompanyProfileOmit<ExtArgs> | null
    /**
     * Filter, which CompanyProfile to fetch.
     */
    where?: CompanyProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyProfiles to fetch.
     */
    orderBy?: CompanyProfileOrderByWithRelationInput | CompanyProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyProfiles.
     */
    cursor?: CompanyProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyProfiles.
     */
    distinct?: CompanyProfileScalarFieldEnum | CompanyProfileScalarFieldEnum[]
  }

  /**
   * CompanyProfile findMany
   */
  export type CompanyProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyProfile
     */
    omit?: CompanyProfileOmit<ExtArgs> | null
    /**
     * Filter, which CompanyProfiles to fetch.
     */
    where?: CompanyProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyProfiles to fetch.
     */
    orderBy?: CompanyProfileOrderByWithRelationInput | CompanyProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyProfiles.
     */
    cursor?: CompanyProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyProfiles.
     */
    skip?: number
    distinct?: CompanyProfileScalarFieldEnum | CompanyProfileScalarFieldEnum[]
  }

  /**
   * CompanyProfile create
   */
  export type CompanyProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyProfile
     */
    omit?: CompanyProfileOmit<ExtArgs> | null
    /**
     * The data needed to create a CompanyProfile.
     */
    data: XOR<CompanyProfileCreateInput, CompanyProfileUncheckedCreateInput>
  }

  /**
   * CompanyProfile createMany
   */
  export type CompanyProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyProfiles.
     */
    data: CompanyProfileCreateManyInput | CompanyProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyProfile createManyAndReturn
   */
  export type CompanyProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyProfile
     */
    omit?: CompanyProfileOmit<ExtArgs> | null
    /**
     * The data used to create many CompanyProfiles.
     */
    data: CompanyProfileCreateManyInput | CompanyProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyProfile update
   */
  export type CompanyProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyProfile
     */
    omit?: CompanyProfileOmit<ExtArgs> | null
    /**
     * The data needed to update a CompanyProfile.
     */
    data: XOR<CompanyProfileUpdateInput, CompanyProfileUncheckedUpdateInput>
    /**
     * Choose, which CompanyProfile to update.
     */
    where: CompanyProfileWhereUniqueInput
  }

  /**
   * CompanyProfile updateMany
   */
  export type CompanyProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyProfiles.
     */
    data: XOR<CompanyProfileUpdateManyMutationInput, CompanyProfileUncheckedUpdateManyInput>
    /**
     * Filter which CompanyProfiles to update
     */
    where?: CompanyProfileWhereInput
    /**
     * Limit how many CompanyProfiles to update.
     */
    limit?: number
  }

  /**
   * CompanyProfile updateManyAndReturn
   */
  export type CompanyProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyProfile
     */
    omit?: CompanyProfileOmit<ExtArgs> | null
    /**
     * The data used to update CompanyProfiles.
     */
    data: XOR<CompanyProfileUpdateManyMutationInput, CompanyProfileUncheckedUpdateManyInput>
    /**
     * Filter which CompanyProfiles to update
     */
    where?: CompanyProfileWhereInput
    /**
     * Limit how many CompanyProfiles to update.
     */
    limit?: number
  }

  /**
   * CompanyProfile upsert
   */
  export type CompanyProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyProfile
     */
    omit?: CompanyProfileOmit<ExtArgs> | null
    /**
     * The filter to search for the CompanyProfile to update in case it exists.
     */
    where: CompanyProfileWhereUniqueInput
    /**
     * In case the CompanyProfile found by the `where` argument doesn't exist, create a new CompanyProfile with this data.
     */
    create: XOR<CompanyProfileCreateInput, CompanyProfileUncheckedCreateInput>
    /**
     * In case the CompanyProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyProfileUpdateInput, CompanyProfileUncheckedUpdateInput>
  }

  /**
   * CompanyProfile delete
   */
  export type CompanyProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyProfile
     */
    omit?: CompanyProfileOmit<ExtArgs> | null
    /**
     * Filter which CompanyProfile to delete.
     */
    where: CompanyProfileWhereUniqueInput
  }

  /**
   * CompanyProfile deleteMany
   */
  export type CompanyProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyProfiles to delete
     */
    where?: CompanyProfileWhereInput
    /**
     * Limit how many CompanyProfiles to delete.
     */
    limit?: number
  }

  /**
   * CompanyProfile without action
   */
  export type CompanyProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProfile
     */
    select?: CompanyProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyProfile
     */
    omit?: CompanyProfileOmit<ExtArgs> | null
  }


  /**
   * Model BlogScheduleSettings
   */

  export type AggregateBlogScheduleSettings = {
    _count: BlogScheduleSettingsCountAggregateOutputType | null
    _avg: BlogScheduleSettingsAvgAggregateOutputType | null
    _sum: BlogScheduleSettingsSumAggregateOutputType | null
    _min: BlogScheduleSettingsMinAggregateOutputType | null
    _max: BlogScheduleSettingsMaxAggregateOutputType | null
  }

  export type BlogScheduleSettingsAvgAggregateOutputType = {
    maxBlogsPerWeek: number | null
    minDaysBetweenPosts: number | null
  }

  export type BlogScheduleSettingsSumAggregateOutputType = {
    maxBlogsPerWeek: number | null
    minDaysBetweenPosts: number | null
  }

  export type BlogScheduleSettingsMinAggregateOutputType = {
    id: string | null
    maxBlogsPerWeek: number | null
    minDaysBetweenPosts: number | null
    preferredPostTime: string | null
    preferredPostDays: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogScheduleSettingsMaxAggregateOutputType = {
    id: string | null
    maxBlogsPerWeek: number | null
    minDaysBetweenPosts: number | null
    preferredPostTime: string | null
    preferredPostDays: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogScheduleSettingsCountAggregateOutputType = {
    id: number
    maxBlogsPerWeek: number
    minDaysBetweenPosts: number
    preferredPostTime: number
    preferredPostDays: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogScheduleSettingsAvgAggregateInputType = {
    maxBlogsPerWeek?: true
    minDaysBetweenPosts?: true
  }

  export type BlogScheduleSettingsSumAggregateInputType = {
    maxBlogsPerWeek?: true
    minDaysBetweenPosts?: true
  }

  export type BlogScheduleSettingsMinAggregateInputType = {
    id?: true
    maxBlogsPerWeek?: true
    minDaysBetweenPosts?: true
    preferredPostTime?: true
    preferredPostDays?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogScheduleSettingsMaxAggregateInputType = {
    id?: true
    maxBlogsPerWeek?: true
    minDaysBetweenPosts?: true
    preferredPostTime?: true
    preferredPostDays?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogScheduleSettingsCountAggregateInputType = {
    id?: true
    maxBlogsPerWeek?: true
    minDaysBetweenPosts?: true
    preferredPostTime?: true
    preferredPostDays?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogScheduleSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogScheduleSettings to aggregate.
     */
    where?: BlogScheduleSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogScheduleSettings to fetch.
     */
    orderBy?: BlogScheduleSettingsOrderByWithRelationInput | BlogScheduleSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogScheduleSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogScheduleSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogScheduleSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogScheduleSettings
    **/
    _count?: true | BlogScheduleSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogScheduleSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogScheduleSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogScheduleSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogScheduleSettingsMaxAggregateInputType
  }

  export type GetBlogScheduleSettingsAggregateType<T extends BlogScheduleSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogScheduleSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogScheduleSettings[P]>
      : GetScalarType<T[P], AggregateBlogScheduleSettings[P]>
  }




  export type BlogScheduleSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogScheduleSettingsWhereInput
    orderBy?: BlogScheduleSettingsOrderByWithAggregationInput | BlogScheduleSettingsOrderByWithAggregationInput[]
    by: BlogScheduleSettingsScalarFieldEnum[] | BlogScheduleSettingsScalarFieldEnum
    having?: BlogScheduleSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogScheduleSettingsCountAggregateInputType | true
    _avg?: BlogScheduleSettingsAvgAggregateInputType
    _sum?: BlogScheduleSettingsSumAggregateInputType
    _min?: BlogScheduleSettingsMinAggregateInputType
    _max?: BlogScheduleSettingsMaxAggregateInputType
  }

  export type BlogScheduleSettingsGroupByOutputType = {
    id: string
    maxBlogsPerWeek: number
    minDaysBetweenPosts: number
    preferredPostTime: string | null
    preferredPostDays: string | null
    createdAt: Date
    updatedAt: Date
    _count: BlogScheduleSettingsCountAggregateOutputType | null
    _avg: BlogScheduleSettingsAvgAggregateOutputType | null
    _sum: BlogScheduleSettingsSumAggregateOutputType | null
    _min: BlogScheduleSettingsMinAggregateOutputType | null
    _max: BlogScheduleSettingsMaxAggregateOutputType | null
  }

  type GetBlogScheduleSettingsGroupByPayload<T extends BlogScheduleSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogScheduleSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogScheduleSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogScheduleSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], BlogScheduleSettingsGroupByOutputType[P]>
        }
      >
    >


  export type BlogScheduleSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    maxBlogsPerWeek?: boolean
    minDaysBetweenPosts?: boolean
    preferredPostTime?: boolean
    preferredPostDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["blogScheduleSettings"]>

  export type BlogScheduleSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    maxBlogsPerWeek?: boolean
    minDaysBetweenPosts?: boolean
    preferredPostTime?: boolean
    preferredPostDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["blogScheduleSettings"]>

  export type BlogScheduleSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    maxBlogsPerWeek?: boolean
    minDaysBetweenPosts?: boolean
    preferredPostTime?: boolean
    preferredPostDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["blogScheduleSettings"]>

  export type BlogScheduleSettingsSelectScalar = {
    id?: boolean
    maxBlogsPerWeek?: boolean
    minDaysBetweenPosts?: boolean
    preferredPostTime?: boolean
    preferredPostDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlogScheduleSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "maxBlogsPerWeek" | "minDaysBetweenPosts" | "preferredPostTime" | "preferredPostDays" | "createdAt" | "updatedAt", ExtArgs["result"]["blogScheduleSettings"]>

  export type $BlogScheduleSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogScheduleSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      maxBlogsPerWeek: number
      minDaysBetweenPosts: number
      preferredPostTime: string | null
      preferredPostDays: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blogScheduleSettings"]>
    composites: {}
  }

  type BlogScheduleSettingsGetPayload<S extends boolean | null | undefined | BlogScheduleSettingsDefaultArgs> = $Result.GetResult<Prisma.$BlogScheduleSettingsPayload, S>

  type BlogScheduleSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogScheduleSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogScheduleSettingsCountAggregateInputType | true
    }

  export interface BlogScheduleSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogScheduleSettings'], meta: { name: 'BlogScheduleSettings' } }
    /**
     * Find zero or one BlogScheduleSettings that matches the filter.
     * @param {BlogScheduleSettingsFindUniqueArgs} args - Arguments to find a BlogScheduleSettings
     * @example
     * // Get one BlogScheduleSettings
     * const blogScheduleSettings = await prisma.blogScheduleSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogScheduleSettingsFindUniqueArgs>(args: SelectSubset<T, BlogScheduleSettingsFindUniqueArgs<ExtArgs>>): Prisma__BlogScheduleSettingsClient<$Result.GetResult<Prisma.$BlogScheduleSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogScheduleSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogScheduleSettingsFindUniqueOrThrowArgs} args - Arguments to find a BlogScheduleSettings
     * @example
     * // Get one BlogScheduleSettings
     * const blogScheduleSettings = await prisma.blogScheduleSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogScheduleSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogScheduleSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogScheduleSettingsClient<$Result.GetResult<Prisma.$BlogScheduleSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogScheduleSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogScheduleSettingsFindFirstArgs} args - Arguments to find a BlogScheduleSettings
     * @example
     * // Get one BlogScheduleSettings
     * const blogScheduleSettings = await prisma.blogScheduleSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogScheduleSettingsFindFirstArgs>(args?: SelectSubset<T, BlogScheduleSettingsFindFirstArgs<ExtArgs>>): Prisma__BlogScheduleSettingsClient<$Result.GetResult<Prisma.$BlogScheduleSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogScheduleSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogScheduleSettingsFindFirstOrThrowArgs} args - Arguments to find a BlogScheduleSettings
     * @example
     * // Get one BlogScheduleSettings
     * const blogScheduleSettings = await prisma.blogScheduleSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogScheduleSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogScheduleSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogScheduleSettingsClient<$Result.GetResult<Prisma.$BlogScheduleSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogScheduleSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogScheduleSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogScheduleSettings
     * const blogScheduleSettings = await prisma.blogScheduleSettings.findMany()
     * 
     * // Get first 10 BlogScheduleSettings
     * const blogScheduleSettings = await prisma.blogScheduleSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogScheduleSettingsWithIdOnly = await prisma.blogScheduleSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogScheduleSettingsFindManyArgs>(args?: SelectSubset<T, BlogScheduleSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogScheduleSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogScheduleSettings.
     * @param {BlogScheduleSettingsCreateArgs} args - Arguments to create a BlogScheduleSettings.
     * @example
     * // Create one BlogScheduleSettings
     * const BlogScheduleSettings = await prisma.blogScheduleSettings.create({
     *   data: {
     *     // ... data to create a BlogScheduleSettings
     *   }
     * })
     * 
     */
    create<T extends BlogScheduleSettingsCreateArgs>(args: SelectSubset<T, BlogScheduleSettingsCreateArgs<ExtArgs>>): Prisma__BlogScheduleSettingsClient<$Result.GetResult<Prisma.$BlogScheduleSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogScheduleSettings.
     * @param {BlogScheduleSettingsCreateManyArgs} args - Arguments to create many BlogScheduleSettings.
     * @example
     * // Create many BlogScheduleSettings
     * const blogScheduleSettings = await prisma.blogScheduleSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogScheduleSettingsCreateManyArgs>(args?: SelectSubset<T, BlogScheduleSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogScheduleSettings and returns the data saved in the database.
     * @param {BlogScheduleSettingsCreateManyAndReturnArgs} args - Arguments to create many BlogScheduleSettings.
     * @example
     * // Create many BlogScheduleSettings
     * const blogScheduleSettings = await prisma.blogScheduleSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogScheduleSettings and only return the `id`
     * const blogScheduleSettingsWithIdOnly = await prisma.blogScheduleSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogScheduleSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogScheduleSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogScheduleSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlogScheduleSettings.
     * @param {BlogScheduleSettingsDeleteArgs} args - Arguments to delete one BlogScheduleSettings.
     * @example
     * // Delete one BlogScheduleSettings
     * const BlogScheduleSettings = await prisma.blogScheduleSettings.delete({
     *   where: {
     *     // ... filter to delete one BlogScheduleSettings
     *   }
     * })
     * 
     */
    delete<T extends BlogScheduleSettingsDeleteArgs>(args: SelectSubset<T, BlogScheduleSettingsDeleteArgs<ExtArgs>>): Prisma__BlogScheduleSettingsClient<$Result.GetResult<Prisma.$BlogScheduleSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogScheduleSettings.
     * @param {BlogScheduleSettingsUpdateArgs} args - Arguments to update one BlogScheduleSettings.
     * @example
     * // Update one BlogScheduleSettings
     * const blogScheduleSettings = await prisma.blogScheduleSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogScheduleSettingsUpdateArgs>(args: SelectSubset<T, BlogScheduleSettingsUpdateArgs<ExtArgs>>): Prisma__BlogScheduleSettingsClient<$Result.GetResult<Prisma.$BlogScheduleSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogScheduleSettings.
     * @param {BlogScheduleSettingsDeleteManyArgs} args - Arguments to filter BlogScheduleSettings to delete.
     * @example
     * // Delete a few BlogScheduleSettings
     * const { count } = await prisma.blogScheduleSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogScheduleSettingsDeleteManyArgs>(args?: SelectSubset<T, BlogScheduleSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogScheduleSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogScheduleSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogScheduleSettings
     * const blogScheduleSettings = await prisma.blogScheduleSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogScheduleSettingsUpdateManyArgs>(args: SelectSubset<T, BlogScheduleSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogScheduleSettings and returns the data updated in the database.
     * @param {BlogScheduleSettingsUpdateManyAndReturnArgs} args - Arguments to update many BlogScheduleSettings.
     * @example
     * // Update many BlogScheduleSettings
     * const blogScheduleSettings = await prisma.blogScheduleSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlogScheduleSettings and only return the `id`
     * const blogScheduleSettingsWithIdOnly = await prisma.blogScheduleSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogScheduleSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogScheduleSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogScheduleSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlogScheduleSettings.
     * @param {BlogScheduleSettingsUpsertArgs} args - Arguments to update or create a BlogScheduleSettings.
     * @example
     * // Update or create a BlogScheduleSettings
     * const blogScheduleSettings = await prisma.blogScheduleSettings.upsert({
     *   create: {
     *     // ... data to create a BlogScheduleSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogScheduleSettings we want to update
     *   }
     * })
     */
    upsert<T extends BlogScheduleSettingsUpsertArgs>(args: SelectSubset<T, BlogScheduleSettingsUpsertArgs<ExtArgs>>): Prisma__BlogScheduleSettingsClient<$Result.GetResult<Prisma.$BlogScheduleSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlogScheduleSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogScheduleSettingsCountArgs} args - Arguments to filter BlogScheduleSettings to count.
     * @example
     * // Count the number of BlogScheduleSettings
     * const count = await prisma.blogScheduleSettings.count({
     *   where: {
     *     // ... the filter for the BlogScheduleSettings we want to count
     *   }
     * })
    **/
    count<T extends BlogScheduleSettingsCountArgs>(
      args?: Subset<T, BlogScheduleSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogScheduleSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogScheduleSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogScheduleSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogScheduleSettingsAggregateArgs>(args: Subset<T, BlogScheduleSettingsAggregateArgs>): Prisma.PrismaPromise<GetBlogScheduleSettingsAggregateType<T>>

    /**
     * Group by BlogScheduleSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogScheduleSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogScheduleSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogScheduleSettingsGroupByArgs['orderBy'] }
        : { orderBy?: BlogScheduleSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogScheduleSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogScheduleSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogScheduleSettings model
   */
  readonly fields: BlogScheduleSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogScheduleSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogScheduleSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogScheduleSettings model
   */
  interface BlogScheduleSettingsFieldRefs {
    readonly id: FieldRef<"BlogScheduleSettings", 'String'>
    readonly maxBlogsPerWeek: FieldRef<"BlogScheduleSettings", 'Int'>
    readonly minDaysBetweenPosts: FieldRef<"BlogScheduleSettings", 'Int'>
    readonly preferredPostTime: FieldRef<"BlogScheduleSettings", 'String'>
    readonly preferredPostDays: FieldRef<"BlogScheduleSettings", 'String'>
    readonly createdAt: FieldRef<"BlogScheduleSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"BlogScheduleSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogScheduleSettings findUnique
   */
  export type BlogScheduleSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogScheduleSettings
     */
    select?: BlogScheduleSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogScheduleSettings
     */
    omit?: BlogScheduleSettingsOmit<ExtArgs> | null
    /**
     * Filter, which BlogScheduleSettings to fetch.
     */
    where: BlogScheduleSettingsWhereUniqueInput
  }

  /**
   * BlogScheduleSettings findUniqueOrThrow
   */
  export type BlogScheduleSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogScheduleSettings
     */
    select?: BlogScheduleSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogScheduleSettings
     */
    omit?: BlogScheduleSettingsOmit<ExtArgs> | null
    /**
     * Filter, which BlogScheduleSettings to fetch.
     */
    where: BlogScheduleSettingsWhereUniqueInput
  }

  /**
   * BlogScheduleSettings findFirst
   */
  export type BlogScheduleSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogScheduleSettings
     */
    select?: BlogScheduleSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogScheduleSettings
     */
    omit?: BlogScheduleSettingsOmit<ExtArgs> | null
    /**
     * Filter, which BlogScheduleSettings to fetch.
     */
    where?: BlogScheduleSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogScheduleSettings to fetch.
     */
    orderBy?: BlogScheduleSettingsOrderByWithRelationInput | BlogScheduleSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogScheduleSettings.
     */
    cursor?: BlogScheduleSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogScheduleSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogScheduleSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogScheduleSettings.
     */
    distinct?: BlogScheduleSettingsScalarFieldEnum | BlogScheduleSettingsScalarFieldEnum[]
  }

  /**
   * BlogScheduleSettings findFirstOrThrow
   */
  export type BlogScheduleSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogScheduleSettings
     */
    select?: BlogScheduleSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogScheduleSettings
     */
    omit?: BlogScheduleSettingsOmit<ExtArgs> | null
    /**
     * Filter, which BlogScheduleSettings to fetch.
     */
    where?: BlogScheduleSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogScheduleSettings to fetch.
     */
    orderBy?: BlogScheduleSettingsOrderByWithRelationInput | BlogScheduleSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogScheduleSettings.
     */
    cursor?: BlogScheduleSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogScheduleSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogScheduleSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogScheduleSettings.
     */
    distinct?: BlogScheduleSettingsScalarFieldEnum | BlogScheduleSettingsScalarFieldEnum[]
  }

  /**
   * BlogScheduleSettings findMany
   */
  export type BlogScheduleSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogScheduleSettings
     */
    select?: BlogScheduleSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogScheduleSettings
     */
    omit?: BlogScheduleSettingsOmit<ExtArgs> | null
    /**
     * Filter, which BlogScheduleSettings to fetch.
     */
    where?: BlogScheduleSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogScheduleSettings to fetch.
     */
    orderBy?: BlogScheduleSettingsOrderByWithRelationInput | BlogScheduleSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogScheduleSettings.
     */
    cursor?: BlogScheduleSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogScheduleSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogScheduleSettings.
     */
    skip?: number
    distinct?: BlogScheduleSettingsScalarFieldEnum | BlogScheduleSettingsScalarFieldEnum[]
  }

  /**
   * BlogScheduleSettings create
   */
  export type BlogScheduleSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogScheduleSettings
     */
    select?: BlogScheduleSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogScheduleSettings
     */
    omit?: BlogScheduleSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a BlogScheduleSettings.
     */
    data: XOR<BlogScheduleSettingsCreateInput, BlogScheduleSettingsUncheckedCreateInput>
  }

  /**
   * BlogScheduleSettings createMany
   */
  export type BlogScheduleSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogScheduleSettings.
     */
    data: BlogScheduleSettingsCreateManyInput | BlogScheduleSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogScheduleSettings createManyAndReturn
   */
  export type BlogScheduleSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogScheduleSettings
     */
    select?: BlogScheduleSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogScheduleSettings
     */
    omit?: BlogScheduleSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many BlogScheduleSettings.
     */
    data: BlogScheduleSettingsCreateManyInput | BlogScheduleSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogScheduleSettings update
   */
  export type BlogScheduleSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogScheduleSettings
     */
    select?: BlogScheduleSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogScheduleSettings
     */
    omit?: BlogScheduleSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a BlogScheduleSettings.
     */
    data: XOR<BlogScheduleSettingsUpdateInput, BlogScheduleSettingsUncheckedUpdateInput>
    /**
     * Choose, which BlogScheduleSettings to update.
     */
    where: BlogScheduleSettingsWhereUniqueInput
  }

  /**
   * BlogScheduleSettings updateMany
   */
  export type BlogScheduleSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogScheduleSettings.
     */
    data: XOR<BlogScheduleSettingsUpdateManyMutationInput, BlogScheduleSettingsUncheckedUpdateManyInput>
    /**
     * Filter which BlogScheduleSettings to update
     */
    where?: BlogScheduleSettingsWhereInput
    /**
     * Limit how many BlogScheduleSettings to update.
     */
    limit?: number
  }

  /**
   * BlogScheduleSettings updateManyAndReturn
   */
  export type BlogScheduleSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogScheduleSettings
     */
    select?: BlogScheduleSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogScheduleSettings
     */
    omit?: BlogScheduleSettingsOmit<ExtArgs> | null
    /**
     * The data used to update BlogScheduleSettings.
     */
    data: XOR<BlogScheduleSettingsUpdateManyMutationInput, BlogScheduleSettingsUncheckedUpdateManyInput>
    /**
     * Filter which BlogScheduleSettings to update
     */
    where?: BlogScheduleSettingsWhereInput
    /**
     * Limit how many BlogScheduleSettings to update.
     */
    limit?: number
  }

  /**
   * BlogScheduleSettings upsert
   */
  export type BlogScheduleSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogScheduleSettings
     */
    select?: BlogScheduleSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogScheduleSettings
     */
    omit?: BlogScheduleSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the BlogScheduleSettings to update in case it exists.
     */
    where: BlogScheduleSettingsWhereUniqueInput
    /**
     * In case the BlogScheduleSettings found by the `where` argument doesn't exist, create a new BlogScheduleSettings with this data.
     */
    create: XOR<BlogScheduleSettingsCreateInput, BlogScheduleSettingsUncheckedCreateInput>
    /**
     * In case the BlogScheduleSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogScheduleSettingsUpdateInput, BlogScheduleSettingsUncheckedUpdateInput>
  }

  /**
   * BlogScheduleSettings delete
   */
  export type BlogScheduleSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogScheduleSettings
     */
    select?: BlogScheduleSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogScheduleSettings
     */
    omit?: BlogScheduleSettingsOmit<ExtArgs> | null
    /**
     * Filter which BlogScheduleSettings to delete.
     */
    where: BlogScheduleSettingsWhereUniqueInput
  }

  /**
   * BlogScheduleSettings deleteMany
   */
  export type BlogScheduleSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogScheduleSettings to delete
     */
    where?: BlogScheduleSettingsWhereInput
    /**
     * Limit how many BlogScheduleSettings to delete.
     */
    limit?: number
  }

  /**
   * BlogScheduleSettings without action
   */
  export type BlogScheduleSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogScheduleSettings
     */
    select?: BlogScheduleSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogScheduleSettings
     */
    omit?: BlogScheduleSettingsOmit<ExtArgs> | null
  }


  /**
   * Model TopicSuggestion
   */

  export type AggregateTopicSuggestion = {
    _count: TopicSuggestionCountAggregateOutputType | null
    _min: TopicSuggestionMinAggregateOutputType | null
    _max: TopicSuggestionMaxAggregateOutputType | null
  }

  export type TopicSuggestionMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: string | null
    priority: string | null
    difficulty: string | null
    estimatedImpact: string | null
    language: string | null
    status: $Enums.TopicStatus | null
    usedAt: Date | null
    generatedBlogId: string | null
    batchId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TopicSuggestionMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: string | null
    priority: string | null
    difficulty: string | null
    estimatedImpact: string | null
    language: string | null
    status: $Enums.TopicStatus | null
    usedAt: Date | null
    generatedBlogId: string | null
    batchId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TopicSuggestionCountAggregateOutputType = {
    id: number
    title: number
    description: number
    category: number
    priority: number
    difficulty: number
    estimatedImpact: number
    language: number
    status: number
    usedAt: number
    generatedBlogId: number
    batchId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TopicSuggestionMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    difficulty?: true
    estimatedImpact?: true
    language?: true
    status?: true
    usedAt?: true
    generatedBlogId?: true
    batchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TopicSuggestionMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    difficulty?: true
    estimatedImpact?: true
    language?: true
    status?: true
    usedAt?: true
    generatedBlogId?: true
    batchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TopicSuggestionCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    difficulty?: true
    estimatedImpact?: true
    language?: true
    status?: true
    usedAt?: true
    generatedBlogId?: true
    batchId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TopicSuggestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TopicSuggestion to aggregate.
     */
    where?: TopicSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicSuggestions to fetch.
     */
    orderBy?: TopicSuggestionOrderByWithRelationInput | TopicSuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopicSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicSuggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TopicSuggestions
    **/
    _count?: true | TopicSuggestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicSuggestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicSuggestionMaxAggregateInputType
  }

  export type GetTopicSuggestionAggregateType<T extends TopicSuggestionAggregateArgs> = {
        [P in keyof T & keyof AggregateTopicSuggestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopicSuggestion[P]>
      : GetScalarType<T[P], AggregateTopicSuggestion[P]>
  }




  export type TopicSuggestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicSuggestionWhereInput
    orderBy?: TopicSuggestionOrderByWithAggregationInput | TopicSuggestionOrderByWithAggregationInput[]
    by: TopicSuggestionScalarFieldEnum[] | TopicSuggestionScalarFieldEnum
    having?: TopicSuggestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicSuggestionCountAggregateInputType | true
    _min?: TopicSuggestionMinAggregateInputType
    _max?: TopicSuggestionMaxAggregateInputType
  }

  export type TopicSuggestionGroupByOutputType = {
    id: string
    title: string
    description: string | null
    category: string | null
    priority: string | null
    difficulty: string | null
    estimatedImpact: string | null
    language: string
    status: $Enums.TopicStatus
    usedAt: Date | null
    generatedBlogId: string | null
    batchId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TopicSuggestionCountAggregateOutputType | null
    _min: TopicSuggestionMinAggregateOutputType | null
    _max: TopicSuggestionMaxAggregateOutputType | null
  }

  type GetTopicSuggestionGroupByPayload<T extends TopicSuggestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicSuggestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicSuggestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicSuggestionGroupByOutputType[P]>
            : GetScalarType<T[P], TopicSuggestionGroupByOutputType[P]>
        }
      >
    >


  export type TopicSuggestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    difficulty?: boolean
    estimatedImpact?: boolean
    language?: boolean
    status?: boolean
    usedAt?: boolean
    generatedBlogId?: boolean
    batchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["topicSuggestion"]>

  export type TopicSuggestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    difficulty?: boolean
    estimatedImpact?: boolean
    language?: boolean
    status?: boolean
    usedAt?: boolean
    generatedBlogId?: boolean
    batchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["topicSuggestion"]>

  export type TopicSuggestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    difficulty?: boolean
    estimatedImpact?: boolean
    language?: boolean
    status?: boolean
    usedAt?: boolean
    generatedBlogId?: boolean
    batchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["topicSuggestion"]>

  export type TopicSuggestionSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    difficulty?: boolean
    estimatedImpact?: boolean
    language?: boolean
    status?: boolean
    usedAt?: boolean
    generatedBlogId?: boolean
    batchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TopicSuggestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "category" | "priority" | "difficulty" | "estimatedImpact" | "language" | "status" | "usedAt" | "generatedBlogId" | "batchId" | "createdAt" | "updatedAt", ExtArgs["result"]["topicSuggestion"]>

  export type $TopicSuggestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TopicSuggestion"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      category: string | null
      priority: string | null
      difficulty: string | null
      estimatedImpact: string | null
      language: string
      status: $Enums.TopicStatus
      usedAt: Date | null
      generatedBlogId: string | null
      batchId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["topicSuggestion"]>
    composites: {}
  }

  type TopicSuggestionGetPayload<S extends boolean | null | undefined | TopicSuggestionDefaultArgs> = $Result.GetResult<Prisma.$TopicSuggestionPayload, S>

  type TopicSuggestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TopicSuggestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TopicSuggestionCountAggregateInputType | true
    }

  export interface TopicSuggestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TopicSuggestion'], meta: { name: 'TopicSuggestion' } }
    /**
     * Find zero or one TopicSuggestion that matches the filter.
     * @param {TopicSuggestionFindUniqueArgs} args - Arguments to find a TopicSuggestion
     * @example
     * // Get one TopicSuggestion
     * const topicSuggestion = await prisma.topicSuggestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicSuggestionFindUniqueArgs>(args: SelectSubset<T, TopicSuggestionFindUniqueArgs<ExtArgs>>): Prisma__TopicSuggestionClient<$Result.GetResult<Prisma.$TopicSuggestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TopicSuggestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TopicSuggestionFindUniqueOrThrowArgs} args - Arguments to find a TopicSuggestion
     * @example
     * // Get one TopicSuggestion
     * const topicSuggestion = await prisma.topicSuggestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicSuggestionFindUniqueOrThrowArgs>(args: SelectSubset<T, TopicSuggestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TopicSuggestionClient<$Result.GetResult<Prisma.$TopicSuggestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TopicSuggestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicSuggestionFindFirstArgs} args - Arguments to find a TopicSuggestion
     * @example
     * // Get one TopicSuggestion
     * const topicSuggestion = await prisma.topicSuggestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicSuggestionFindFirstArgs>(args?: SelectSubset<T, TopicSuggestionFindFirstArgs<ExtArgs>>): Prisma__TopicSuggestionClient<$Result.GetResult<Prisma.$TopicSuggestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TopicSuggestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicSuggestionFindFirstOrThrowArgs} args - Arguments to find a TopicSuggestion
     * @example
     * // Get one TopicSuggestion
     * const topicSuggestion = await prisma.topicSuggestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicSuggestionFindFirstOrThrowArgs>(args?: SelectSubset<T, TopicSuggestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TopicSuggestionClient<$Result.GetResult<Prisma.$TopicSuggestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TopicSuggestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicSuggestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TopicSuggestions
     * const topicSuggestions = await prisma.topicSuggestion.findMany()
     * 
     * // Get first 10 TopicSuggestions
     * const topicSuggestions = await prisma.topicSuggestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topicSuggestionWithIdOnly = await prisma.topicSuggestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TopicSuggestionFindManyArgs>(args?: SelectSubset<T, TopicSuggestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicSuggestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TopicSuggestion.
     * @param {TopicSuggestionCreateArgs} args - Arguments to create a TopicSuggestion.
     * @example
     * // Create one TopicSuggestion
     * const TopicSuggestion = await prisma.topicSuggestion.create({
     *   data: {
     *     // ... data to create a TopicSuggestion
     *   }
     * })
     * 
     */
    create<T extends TopicSuggestionCreateArgs>(args: SelectSubset<T, TopicSuggestionCreateArgs<ExtArgs>>): Prisma__TopicSuggestionClient<$Result.GetResult<Prisma.$TopicSuggestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TopicSuggestions.
     * @param {TopicSuggestionCreateManyArgs} args - Arguments to create many TopicSuggestions.
     * @example
     * // Create many TopicSuggestions
     * const topicSuggestion = await prisma.topicSuggestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TopicSuggestionCreateManyArgs>(args?: SelectSubset<T, TopicSuggestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TopicSuggestions and returns the data saved in the database.
     * @param {TopicSuggestionCreateManyAndReturnArgs} args - Arguments to create many TopicSuggestions.
     * @example
     * // Create many TopicSuggestions
     * const topicSuggestion = await prisma.topicSuggestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TopicSuggestions and only return the `id`
     * const topicSuggestionWithIdOnly = await prisma.topicSuggestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TopicSuggestionCreateManyAndReturnArgs>(args?: SelectSubset<T, TopicSuggestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicSuggestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TopicSuggestion.
     * @param {TopicSuggestionDeleteArgs} args - Arguments to delete one TopicSuggestion.
     * @example
     * // Delete one TopicSuggestion
     * const TopicSuggestion = await prisma.topicSuggestion.delete({
     *   where: {
     *     // ... filter to delete one TopicSuggestion
     *   }
     * })
     * 
     */
    delete<T extends TopicSuggestionDeleteArgs>(args: SelectSubset<T, TopicSuggestionDeleteArgs<ExtArgs>>): Prisma__TopicSuggestionClient<$Result.GetResult<Prisma.$TopicSuggestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TopicSuggestion.
     * @param {TopicSuggestionUpdateArgs} args - Arguments to update one TopicSuggestion.
     * @example
     * // Update one TopicSuggestion
     * const topicSuggestion = await prisma.topicSuggestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TopicSuggestionUpdateArgs>(args: SelectSubset<T, TopicSuggestionUpdateArgs<ExtArgs>>): Prisma__TopicSuggestionClient<$Result.GetResult<Prisma.$TopicSuggestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TopicSuggestions.
     * @param {TopicSuggestionDeleteManyArgs} args - Arguments to filter TopicSuggestions to delete.
     * @example
     * // Delete a few TopicSuggestions
     * const { count } = await prisma.topicSuggestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TopicSuggestionDeleteManyArgs>(args?: SelectSubset<T, TopicSuggestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TopicSuggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicSuggestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TopicSuggestions
     * const topicSuggestion = await prisma.topicSuggestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TopicSuggestionUpdateManyArgs>(args: SelectSubset<T, TopicSuggestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TopicSuggestions and returns the data updated in the database.
     * @param {TopicSuggestionUpdateManyAndReturnArgs} args - Arguments to update many TopicSuggestions.
     * @example
     * // Update many TopicSuggestions
     * const topicSuggestion = await prisma.topicSuggestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TopicSuggestions and only return the `id`
     * const topicSuggestionWithIdOnly = await prisma.topicSuggestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TopicSuggestionUpdateManyAndReturnArgs>(args: SelectSubset<T, TopicSuggestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicSuggestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TopicSuggestion.
     * @param {TopicSuggestionUpsertArgs} args - Arguments to update or create a TopicSuggestion.
     * @example
     * // Update or create a TopicSuggestion
     * const topicSuggestion = await prisma.topicSuggestion.upsert({
     *   create: {
     *     // ... data to create a TopicSuggestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TopicSuggestion we want to update
     *   }
     * })
     */
    upsert<T extends TopicSuggestionUpsertArgs>(args: SelectSubset<T, TopicSuggestionUpsertArgs<ExtArgs>>): Prisma__TopicSuggestionClient<$Result.GetResult<Prisma.$TopicSuggestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TopicSuggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicSuggestionCountArgs} args - Arguments to filter TopicSuggestions to count.
     * @example
     * // Count the number of TopicSuggestions
     * const count = await prisma.topicSuggestion.count({
     *   where: {
     *     // ... the filter for the TopicSuggestions we want to count
     *   }
     * })
    **/
    count<T extends TopicSuggestionCountArgs>(
      args?: Subset<T, TopicSuggestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicSuggestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TopicSuggestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicSuggestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicSuggestionAggregateArgs>(args: Subset<T, TopicSuggestionAggregateArgs>): Prisma.PrismaPromise<GetTopicSuggestionAggregateType<T>>

    /**
     * Group by TopicSuggestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicSuggestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicSuggestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicSuggestionGroupByArgs['orderBy'] }
        : { orderBy?: TopicSuggestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicSuggestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicSuggestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TopicSuggestion model
   */
  readonly fields: TopicSuggestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TopicSuggestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicSuggestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TopicSuggestion model
   */
  interface TopicSuggestionFieldRefs {
    readonly id: FieldRef<"TopicSuggestion", 'String'>
    readonly title: FieldRef<"TopicSuggestion", 'String'>
    readonly description: FieldRef<"TopicSuggestion", 'String'>
    readonly category: FieldRef<"TopicSuggestion", 'String'>
    readonly priority: FieldRef<"TopicSuggestion", 'String'>
    readonly difficulty: FieldRef<"TopicSuggestion", 'String'>
    readonly estimatedImpact: FieldRef<"TopicSuggestion", 'String'>
    readonly language: FieldRef<"TopicSuggestion", 'String'>
    readonly status: FieldRef<"TopicSuggestion", 'TopicStatus'>
    readonly usedAt: FieldRef<"TopicSuggestion", 'DateTime'>
    readonly generatedBlogId: FieldRef<"TopicSuggestion", 'String'>
    readonly batchId: FieldRef<"TopicSuggestion", 'String'>
    readonly createdAt: FieldRef<"TopicSuggestion", 'DateTime'>
    readonly updatedAt: FieldRef<"TopicSuggestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TopicSuggestion findUnique
   */
  export type TopicSuggestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSuggestion
     */
    select?: TopicSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSuggestion
     */
    omit?: TopicSuggestionOmit<ExtArgs> | null
    /**
     * Filter, which TopicSuggestion to fetch.
     */
    where: TopicSuggestionWhereUniqueInput
  }

  /**
   * TopicSuggestion findUniqueOrThrow
   */
  export type TopicSuggestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSuggestion
     */
    select?: TopicSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSuggestion
     */
    omit?: TopicSuggestionOmit<ExtArgs> | null
    /**
     * Filter, which TopicSuggestion to fetch.
     */
    where: TopicSuggestionWhereUniqueInput
  }

  /**
   * TopicSuggestion findFirst
   */
  export type TopicSuggestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSuggestion
     */
    select?: TopicSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSuggestion
     */
    omit?: TopicSuggestionOmit<ExtArgs> | null
    /**
     * Filter, which TopicSuggestion to fetch.
     */
    where?: TopicSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicSuggestions to fetch.
     */
    orderBy?: TopicSuggestionOrderByWithRelationInput | TopicSuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TopicSuggestions.
     */
    cursor?: TopicSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicSuggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TopicSuggestions.
     */
    distinct?: TopicSuggestionScalarFieldEnum | TopicSuggestionScalarFieldEnum[]
  }

  /**
   * TopicSuggestion findFirstOrThrow
   */
  export type TopicSuggestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSuggestion
     */
    select?: TopicSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSuggestion
     */
    omit?: TopicSuggestionOmit<ExtArgs> | null
    /**
     * Filter, which TopicSuggestion to fetch.
     */
    where?: TopicSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicSuggestions to fetch.
     */
    orderBy?: TopicSuggestionOrderByWithRelationInput | TopicSuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TopicSuggestions.
     */
    cursor?: TopicSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicSuggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TopicSuggestions.
     */
    distinct?: TopicSuggestionScalarFieldEnum | TopicSuggestionScalarFieldEnum[]
  }

  /**
   * TopicSuggestion findMany
   */
  export type TopicSuggestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSuggestion
     */
    select?: TopicSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSuggestion
     */
    omit?: TopicSuggestionOmit<ExtArgs> | null
    /**
     * Filter, which TopicSuggestions to fetch.
     */
    where?: TopicSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicSuggestions to fetch.
     */
    orderBy?: TopicSuggestionOrderByWithRelationInput | TopicSuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TopicSuggestions.
     */
    cursor?: TopicSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicSuggestions.
     */
    skip?: number
    distinct?: TopicSuggestionScalarFieldEnum | TopicSuggestionScalarFieldEnum[]
  }

  /**
   * TopicSuggestion create
   */
  export type TopicSuggestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSuggestion
     */
    select?: TopicSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSuggestion
     */
    omit?: TopicSuggestionOmit<ExtArgs> | null
    /**
     * The data needed to create a TopicSuggestion.
     */
    data: XOR<TopicSuggestionCreateInput, TopicSuggestionUncheckedCreateInput>
  }

  /**
   * TopicSuggestion createMany
   */
  export type TopicSuggestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TopicSuggestions.
     */
    data: TopicSuggestionCreateManyInput | TopicSuggestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TopicSuggestion createManyAndReturn
   */
  export type TopicSuggestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSuggestion
     */
    select?: TopicSuggestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSuggestion
     */
    omit?: TopicSuggestionOmit<ExtArgs> | null
    /**
     * The data used to create many TopicSuggestions.
     */
    data: TopicSuggestionCreateManyInput | TopicSuggestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TopicSuggestion update
   */
  export type TopicSuggestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSuggestion
     */
    select?: TopicSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSuggestion
     */
    omit?: TopicSuggestionOmit<ExtArgs> | null
    /**
     * The data needed to update a TopicSuggestion.
     */
    data: XOR<TopicSuggestionUpdateInput, TopicSuggestionUncheckedUpdateInput>
    /**
     * Choose, which TopicSuggestion to update.
     */
    where: TopicSuggestionWhereUniqueInput
  }

  /**
   * TopicSuggestion updateMany
   */
  export type TopicSuggestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TopicSuggestions.
     */
    data: XOR<TopicSuggestionUpdateManyMutationInput, TopicSuggestionUncheckedUpdateManyInput>
    /**
     * Filter which TopicSuggestions to update
     */
    where?: TopicSuggestionWhereInput
    /**
     * Limit how many TopicSuggestions to update.
     */
    limit?: number
  }

  /**
   * TopicSuggestion updateManyAndReturn
   */
  export type TopicSuggestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSuggestion
     */
    select?: TopicSuggestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSuggestion
     */
    omit?: TopicSuggestionOmit<ExtArgs> | null
    /**
     * The data used to update TopicSuggestions.
     */
    data: XOR<TopicSuggestionUpdateManyMutationInput, TopicSuggestionUncheckedUpdateManyInput>
    /**
     * Filter which TopicSuggestions to update
     */
    where?: TopicSuggestionWhereInput
    /**
     * Limit how many TopicSuggestions to update.
     */
    limit?: number
  }

  /**
   * TopicSuggestion upsert
   */
  export type TopicSuggestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSuggestion
     */
    select?: TopicSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSuggestion
     */
    omit?: TopicSuggestionOmit<ExtArgs> | null
    /**
     * The filter to search for the TopicSuggestion to update in case it exists.
     */
    where: TopicSuggestionWhereUniqueInput
    /**
     * In case the TopicSuggestion found by the `where` argument doesn't exist, create a new TopicSuggestion with this data.
     */
    create: XOR<TopicSuggestionCreateInput, TopicSuggestionUncheckedCreateInput>
    /**
     * In case the TopicSuggestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopicSuggestionUpdateInput, TopicSuggestionUncheckedUpdateInput>
  }

  /**
   * TopicSuggestion delete
   */
  export type TopicSuggestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSuggestion
     */
    select?: TopicSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSuggestion
     */
    omit?: TopicSuggestionOmit<ExtArgs> | null
    /**
     * Filter which TopicSuggestion to delete.
     */
    where: TopicSuggestionWhereUniqueInput
  }

  /**
   * TopicSuggestion deleteMany
   */
  export type TopicSuggestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TopicSuggestions to delete
     */
    where?: TopicSuggestionWhereInput
    /**
     * Limit how many TopicSuggestions to delete.
     */
    limit?: number
  }

  /**
   * TopicSuggestion without action
   */
  export type TopicSuggestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSuggestion
     */
    select?: TopicSuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSuggestion
     */
    omit?: TopicSuggestionOmit<ExtArgs> | null
  }


  /**
   * Model ScheduledBlog
   */

  export type AggregateScheduledBlog = {
    _count: ScheduledBlogCountAggregateOutputType | null
    _min: ScheduledBlogMinAggregateOutputType | null
    _max: ScheduledBlogMaxAggregateOutputType | null
  }

  export type ScheduledBlogMinAggregateOutputType = {
    id: string | null
    topicId: string | null
    topicTitle: string | null
    language: string | null
    length: string | null
    tone: string | null
    includeResearch: boolean | null
    scheduledFor: Date | null
    scheduledBy: string | null
    status: $Enums.ScheduledBlogStatus | null
    generatedBlogId: string | null
    processingStartedAt: Date | null
    processedAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduledBlogMaxAggregateOutputType = {
    id: string | null
    topicId: string | null
    topicTitle: string | null
    language: string | null
    length: string | null
    tone: string | null
    includeResearch: boolean | null
    scheduledFor: Date | null
    scheduledBy: string | null
    status: $Enums.ScheduledBlogStatus | null
    generatedBlogId: string | null
    processingStartedAt: Date | null
    processedAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduledBlogCountAggregateOutputType = {
    id: number
    topicId: number
    topicTitle: number
    language: number
    length: number
    tone: number
    includeResearch: number
    scheduledFor: number
    scheduledBy: number
    status: number
    generatedBlogId: number
    processingStartedAt: number
    processedAt: number
    errorMessage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduledBlogMinAggregateInputType = {
    id?: true
    topicId?: true
    topicTitle?: true
    language?: true
    length?: true
    tone?: true
    includeResearch?: true
    scheduledFor?: true
    scheduledBy?: true
    status?: true
    generatedBlogId?: true
    processingStartedAt?: true
    processedAt?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduledBlogMaxAggregateInputType = {
    id?: true
    topicId?: true
    topicTitle?: true
    language?: true
    length?: true
    tone?: true
    includeResearch?: true
    scheduledFor?: true
    scheduledBy?: true
    status?: true
    generatedBlogId?: true
    processingStartedAt?: true
    processedAt?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduledBlogCountAggregateInputType = {
    id?: true
    topicId?: true
    topicTitle?: true
    language?: true
    length?: true
    tone?: true
    includeResearch?: true
    scheduledFor?: true
    scheduledBy?: true
    status?: true
    generatedBlogId?: true
    processingStartedAt?: true
    processedAt?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduledBlogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledBlog to aggregate.
     */
    where?: ScheduledBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledBlogs to fetch.
     */
    orderBy?: ScheduledBlogOrderByWithRelationInput | ScheduledBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduledBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledBlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduledBlogs
    **/
    _count?: true | ScheduledBlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduledBlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduledBlogMaxAggregateInputType
  }

  export type GetScheduledBlogAggregateType<T extends ScheduledBlogAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduledBlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduledBlog[P]>
      : GetScalarType<T[P], AggregateScheduledBlog[P]>
  }




  export type ScheduledBlogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledBlogWhereInput
    orderBy?: ScheduledBlogOrderByWithAggregationInput | ScheduledBlogOrderByWithAggregationInput[]
    by: ScheduledBlogScalarFieldEnum[] | ScheduledBlogScalarFieldEnum
    having?: ScheduledBlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduledBlogCountAggregateInputType | true
    _min?: ScheduledBlogMinAggregateInputType
    _max?: ScheduledBlogMaxAggregateInputType
  }

  export type ScheduledBlogGroupByOutputType = {
    id: string
    topicId: string | null
    topicTitle: string
    language: string
    length: string
    tone: string
    includeResearch: boolean
    scheduledFor: Date
    scheduledBy: string
    status: $Enums.ScheduledBlogStatus
    generatedBlogId: string | null
    processingStartedAt: Date | null
    processedAt: Date | null
    errorMessage: string | null
    createdAt: Date
    updatedAt: Date
    _count: ScheduledBlogCountAggregateOutputType | null
    _min: ScheduledBlogMinAggregateOutputType | null
    _max: ScheduledBlogMaxAggregateOutputType | null
  }

  type GetScheduledBlogGroupByPayload<T extends ScheduledBlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduledBlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduledBlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduledBlogGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduledBlogGroupByOutputType[P]>
        }
      >
    >


  export type ScheduledBlogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    topicTitle?: boolean
    language?: boolean
    length?: boolean
    tone?: boolean
    includeResearch?: boolean
    scheduledFor?: boolean
    scheduledBy?: boolean
    status?: boolean
    generatedBlogId?: boolean
    processingStartedAt?: boolean
    processedAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["scheduledBlog"]>

  export type ScheduledBlogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    topicTitle?: boolean
    language?: boolean
    length?: boolean
    tone?: boolean
    includeResearch?: boolean
    scheduledFor?: boolean
    scheduledBy?: boolean
    status?: boolean
    generatedBlogId?: boolean
    processingStartedAt?: boolean
    processedAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["scheduledBlog"]>

  export type ScheduledBlogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    topicTitle?: boolean
    language?: boolean
    length?: boolean
    tone?: boolean
    includeResearch?: boolean
    scheduledFor?: boolean
    scheduledBy?: boolean
    status?: boolean
    generatedBlogId?: boolean
    processingStartedAt?: boolean
    processedAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["scheduledBlog"]>

  export type ScheduledBlogSelectScalar = {
    id?: boolean
    topicId?: boolean
    topicTitle?: boolean
    language?: boolean
    length?: boolean
    tone?: boolean
    includeResearch?: boolean
    scheduledFor?: boolean
    scheduledBy?: boolean
    status?: boolean
    generatedBlogId?: boolean
    processingStartedAt?: boolean
    processedAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduledBlogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "topicId" | "topicTitle" | "language" | "length" | "tone" | "includeResearch" | "scheduledFor" | "scheduledBy" | "status" | "generatedBlogId" | "processingStartedAt" | "processedAt" | "errorMessage" | "createdAt" | "updatedAt", ExtArgs["result"]["scheduledBlog"]>

  export type $ScheduledBlogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduledBlog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      topicId: string | null
      topicTitle: string
      language: string
      length: string
      tone: string
      includeResearch: boolean
      scheduledFor: Date
      scheduledBy: string
      status: $Enums.ScheduledBlogStatus
      generatedBlogId: string | null
      processingStartedAt: Date | null
      processedAt: Date | null
      errorMessage: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scheduledBlog"]>
    composites: {}
  }

  type ScheduledBlogGetPayload<S extends boolean | null | undefined | ScheduledBlogDefaultArgs> = $Result.GetResult<Prisma.$ScheduledBlogPayload, S>

  type ScheduledBlogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduledBlogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduledBlogCountAggregateInputType | true
    }

  export interface ScheduledBlogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduledBlog'], meta: { name: 'ScheduledBlog' } }
    /**
     * Find zero or one ScheduledBlog that matches the filter.
     * @param {ScheduledBlogFindUniqueArgs} args - Arguments to find a ScheduledBlog
     * @example
     * // Get one ScheduledBlog
     * const scheduledBlog = await prisma.scheduledBlog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduledBlogFindUniqueArgs>(args: SelectSubset<T, ScheduledBlogFindUniqueArgs<ExtArgs>>): Prisma__ScheduledBlogClient<$Result.GetResult<Prisma.$ScheduledBlogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScheduledBlog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduledBlogFindUniqueOrThrowArgs} args - Arguments to find a ScheduledBlog
     * @example
     * // Get one ScheduledBlog
     * const scheduledBlog = await prisma.scheduledBlog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduledBlogFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduledBlogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduledBlogClient<$Result.GetResult<Prisma.$ScheduledBlogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduledBlog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledBlogFindFirstArgs} args - Arguments to find a ScheduledBlog
     * @example
     * // Get one ScheduledBlog
     * const scheduledBlog = await prisma.scheduledBlog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduledBlogFindFirstArgs>(args?: SelectSubset<T, ScheduledBlogFindFirstArgs<ExtArgs>>): Prisma__ScheduledBlogClient<$Result.GetResult<Prisma.$ScheduledBlogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduledBlog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledBlogFindFirstOrThrowArgs} args - Arguments to find a ScheduledBlog
     * @example
     * // Get one ScheduledBlog
     * const scheduledBlog = await prisma.scheduledBlog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduledBlogFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduledBlogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduledBlogClient<$Result.GetResult<Prisma.$ScheduledBlogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScheduledBlogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledBlogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduledBlogs
     * const scheduledBlogs = await prisma.scheduledBlog.findMany()
     * 
     * // Get first 10 ScheduledBlogs
     * const scheduledBlogs = await prisma.scheduledBlog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduledBlogWithIdOnly = await prisma.scheduledBlog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduledBlogFindManyArgs>(args?: SelectSubset<T, ScheduledBlogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledBlogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScheduledBlog.
     * @param {ScheduledBlogCreateArgs} args - Arguments to create a ScheduledBlog.
     * @example
     * // Create one ScheduledBlog
     * const ScheduledBlog = await prisma.scheduledBlog.create({
     *   data: {
     *     // ... data to create a ScheduledBlog
     *   }
     * })
     * 
     */
    create<T extends ScheduledBlogCreateArgs>(args: SelectSubset<T, ScheduledBlogCreateArgs<ExtArgs>>): Prisma__ScheduledBlogClient<$Result.GetResult<Prisma.$ScheduledBlogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScheduledBlogs.
     * @param {ScheduledBlogCreateManyArgs} args - Arguments to create many ScheduledBlogs.
     * @example
     * // Create many ScheduledBlogs
     * const scheduledBlog = await prisma.scheduledBlog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduledBlogCreateManyArgs>(args?: SelectSubset<T, ScheduledBlogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduledBlogs and returns the data saved in the database.
     * @param {ScheduledBlogCreateManyAndReturnArgs} args - Arguments to create many ScheduledBlogs.
     * @example
     * // Create many ScheduledBlogs
     * const scheduledBlog = await prisma.scheduledBlog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduledBlogs and only return the `id`
     * const scheduledBlogWithIdOnly = await prisma.scheduledBlog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduledBlogCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduledBlogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledBlogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScheduledBlog.
     * @param {ScheduledBlogDeleteArgs} args - Arguments to delete one ScheduledBlog.
     * @example
     * // Delete one ScheduledBlog
     * const ScheduledBlog = await prisma.scheduledBlog.delete({
     *   where: {
     *     // ... filter to delete one ScheduledBlog
     *   }
     * })
     * 
     */
    delete<T extends ScheduledBlogDeleteArgs>(args: SelectSubset<T, ScheduledBlogDeleteArgs<ExtArgs>>): Prisma__ScheduledBlogClient<$Result.GetResult<Prisma.$ScheduledBlogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScheduledBlog.
     * @param {ScheduledBlogUpdateArgs} args - Arguments to update one ScheduledBlog.
     * @example
     * // Update one ScheduledBlog
     * const scheduledBlog = await prisma.scheduledBlog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduledBlogUpdateArgs>(args: SelectSubset<T, ScheduledBlogUpdateArgs<ExtArgs>>): Prisma__ScheduledBlogClient<$Result.GetResult<Prisma.$ScheduledBlogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScheduledBlogs.
     * @param {ScheduledBlogDeleteManyArgs} args - Arguments to filter ScheduledBlogs to delete.
     * @example
     * // Delete a few ScheduledBlogs
     * const { count } = await prisma.scheduledBlog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduledBlogDeleteManyArgs>(args?: SelectSubset<T, ScheduledBlogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledBlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledBlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduledBlogs
     * const scheduledBlog = await prisma.scheduledBlog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduledBlogUpdateManyArgs>(args: SelectSubset<T, ScheduledBlogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledBlogs and returns the data updated in the database.
     * @param {ScheduledBlogUpdateManyAndReturnArgs} args - Arguments to update many ScheduledBlogs.
     * @example
     * // Update many ScheduledBlogs
     * const scheduledBlog = await prisma.scheduledBlog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScheduledBlogs and only return the `id`
     * const scheduledBlogWithIdOnly = await prisma.scheduledBlog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduledBlogUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduledBlogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledBlogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScheduledBlog.
     * @param {ScheduledBlogUpsertArgs} args - Arguments to update or create a ScheduledBlog.
     * @example
     * // Update or create a ScheduledBlog
     * const scheduledBlog = await prisma.scheduledBlog.upsert({
     *   create: {
     *     // ... data to create a ScheduledBlog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduledBlog we want to update
     *   }
     * })
     */
    upsert<T extends ScheduledBlogUpsertArgs>(args: SelectSubset<T, ScheduledBlogUpsertArgs<ExtArgs>>): Prisma__ScheduledBlogClient<$Result.GetResult<Prisma.$ScheduledBlogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScheduledBlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledBlogCountArgs} args - Arguments to filter ScheduledBlogs to count.
     * @example
     * // Count the number of ScheduledBlogs
     * const count = await prisma.scheduledBlog.count({
     *   where: {
     *     // ... the filter for the ScheduledBlogs we want to count
     *   }
     * })
    **/
    count<T extends ScheduledBlogCountArgs>(
      args?: Subset<T, ScheduledBlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduledBlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduledBlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledBlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduledBlogAggregateArgs>(args: Subset<T, ScheduledBlogAggregateArgs>): Prisma.PrismaPromise<GetScheduledBlogAggregateType<T>>

    /**
     * Group by ScheduledBlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledBlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduledBlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduledBlogGroupByArgs['orderBy'] }
        : { orderBy?: ScheduledBlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduledBlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduledBlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduledBlog model
   */
  readonly fields: ScheduledBlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduledBlog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduledBlogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduledBlog model
   */
  interface ScheduledBlogFieldRefs {
    readonly id: FieldRef<"ScheduledBlog", 'String'>
    readonly topicId: FieldRef<"ScheduledBlog", 'String'>
    readonly topicTitle: FieldRef<"ScheduledBlog", 'String'>
    readonly language: FieldRef<"ScheduledBlog", 'String'>
    readonly length: FieldRef<"ScheduledBlog", 'String'>
    readonly tone: FieldRef<"ScheduledBlog", 'String'>
    readonly includeResearch: FieldRef<"ScheduledBlog", 'Boolean'>
    readonly scheduledFor: FieldRef<"ScheduledBlog", 'DateTime'>
    readonly scheduledBy: FieldRef<"ScheduledBlog", 'String'>
    readonly status: FieldRef<"ScheduledBlog", 'ScheduledBlogStatus'>
    readonly generatedBlogId: FieldRef<"ScheduledBlog", 'String'>
    readonly processingStartedAt: FieldRef<"ScheduledBlog", 'DateTime'>
    readonly processedAt: FieldRef<"ScheduledBlog", 'DateTime'>
    readonly errorMessage: FieldRef<"ScheduledBlog", 'String'>
    readonly createdAt: FieldRef<"ScheduledBlog", 'DateTime'>
    readonly updatedAt: FieldRef<"ScheduledBlog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduledBlog findUnique
   */
  export type ScheduledBlogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledBlog
     */
    select?: ScheduledBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledBlog
     */
    omit?: ScheduledBlogOmit<ExtArgs> | null
    /**
     * Filter, which ScheduledBlog to fetch.
     */
    where: ScheduledBlogWhereUniqueInput
  }

  /**
   * ScheduledBlog findUniqueOrThrow
   */
  export type ScheduledBlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledBlog
     */
    select?: ScheduledBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledBlog
     */
    omit?: ScheduledBlogOmit<ExtArgs> | null
    /**
     * Filter, which ScheduledBlog to fetch.
     */
    where: ScheduledBlogWhereUniqueInput
  }

  /**
   * ScheduledBlog findFirst
   */
  export type ScheduledBlogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledBlog
     */
    select?: ScheduledBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledBlog
     */
    omit?: ScheduledBlogOmit<ExtArgs> | null
    /**
     * Filter, which ScheduledBlog to fetch.
     */
    where?: ScheduledBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledBlogs to fetch.
     */
    orderBy?: ScheduledBlogOrderByWithRelationInput | ScheduledBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledBlogs.
     */
    cursor?: ScheduledBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledBlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledBlogs.
     */
    distinct?: ScheduledBlogScalarFieldEnum | ScheduledBlogScalarFieldEnum[]
  }

  /**
   * ScheduledBlog findFirstOrThrow
   */
  export type ScheduledBlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledBlog
     */
    select?: ScheduledBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledBlog
     */
    omit?: ScheduledBlogOmit<ExtArgs> | null
    /**
     * Filter, which ScheduledBlog to fetch.
     */
    where?: ScheduledBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledBlogs to fetch.
     */
    orderBy?: ScheduledBlogOrderByWithRelationInput | ScheduledBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledBlogs.
     */
    cursor?: ScheduledBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledBlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledBlogs.
     */
    distinct?: ScheduledBlogScalarFieldEnum | ScheduledBlogScalarFieldEnum[]
  }

  /**
   * ScheduledBlog findMany
   */
  export type ScheduledBlogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledBlog
     */
    select?: ScheduledBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledBlog
     */
    omit?: ScheduledBlogOmit<ExtArgs> | null
    /**
     * Filter, which ScheduledBlogs to fetch.
     */
    where?: ScheduledBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledBlogs to fetch.
     */
    orderBy?: ScheduledBlogOrderByWithRelationInput | ScheduledBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduledBlogs.
     */
    cursor?: ScheduledBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledBlogs.
     */
    skip?: number
    distinct?: ScheduledBlogScalarFieldEnum | ScheduledBlogScalarFieldEnum[]
  }

  /**
   * ScheduledBlog create
   */
  export type ScheduledBlogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledBlog
     */
    select?: ScheduledBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledBlog
     */
    omit?: ScheduledBlogOmit<ExtArgs> | null
    /**
     * The data needed to create a ScheduledBlog.
     */
    data: XOR<ScheduledBlogCreateInput, ScheduledBlogUncheckedCreateInput>
  }

  /**
   * ScheduledBlog createMany
   */
  export type ScheduledBlogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduledBlogs.
     */
    data: ScheduledBlogCreateManyInput | ScheduledBlogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduledBlog createManyAndReturn
   */
  export type ScheduledBlogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledBlog
     */
    select?: ScheduledBlogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledBlog
     */
    omit?: ScheduledBlogOmit<ExtArgs> | null
    /**
     * The data used to create many ScheduledBlogs.
     */
    data: ScheduledBlogCreateManyInput | ScheduledBlogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduledBlog update
   */
  export type ScheduledBlogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledBlog
     */
    select?: ScheduledBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledBlog
     */
    omit?: ScheduledBlogOmit<ExtArgs> | null
    /**
     * The data needed to update a ScheduledBlog.
     */
    data: XOR<ScheduledBlogUpdateInput, ScheduledBlogUncheckedUpdateInput>
    /**
     * Choose, which ScheduledBlog to update.
     */
    where: ScheduledBlogWhereUniqueInput
  }

  /**
   * ScheduledBlog updateMany
   */
  export type ScheduledBlogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduledBlogs.
     */
    data: XOR<ScheduledBlogUpdateManyMutationInput, ScheduledBlogUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledBlogs to update
     */
    where?: ScheduledBlogWhereInput
    /**
     * Limit how many ScheduledBlogs to update.
     */
    limit?: number
  }

  /**
   * ScheduledBlog updateManyAndReturn
   */
  export type ScheduledBlogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledBlog
     */
    select?: ScheduledBlogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledBlog
     */
    omit?: ScheduledBlogOmit<ExtArgs> | null
    /**
     * The data used to update ScheduledBlogs.
     */
    data: XOR<ScheduledBlogUpdateManyMutationInput, ScheduledBlogUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledBlogs to update
     */
    where?: ScheduledBlogWhereInput
    /**
     * Limit how many ScheduledBlogs to update.
     */
    limit?: number
  }

  /**
   * ScheduledBlog upsert
   */
  export type ScheduledBlogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledBlog
     */
    select?: ScheduledBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledBlog
     */
    omit?: ScheduledBlogOmit<ExtArgs> | null
    /**
     * The filter to search for the ScheduledBlog to update in case it exists.
     */
    where: ScheduledBlogWhereUniqueInput
    /**
     * In case the ScheduledBlog found by the `where` argument doesn't exist, create a new ScheduledBlog with this data.
     */
    create: XOR<ScheduledBlogCreateInput, ScheduledBlogUncheckedCreateInput>
    /**
     * In case the ScheduledBlog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduledBlogUpdateInput, ScheduledBlogUncheckedUpdateInput>
  }

  /**
   * ScheduledBlog delete
   */
  export type ScheduledBlogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledBlog
     */
    select?: ScheduledBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledBlog
     */
    omit?: ScheduledBlogOmit<ExtArgs> | null
    /**
     * Filter which ScheduledBlog to delete.
     */
    where: ScheduledBlogWhereUniqueInput
  }

  /**
   * ScheduledBlog deleteMany
   */
  export type ScheduledBlogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledBlogs to delete
     */
    where?: ScheduledBlogWhereInput
    /**
     * Limit how many ScheduledBlogs to delete.
     */
    limit?: number
  }

  /**
   * ScheduledBlog without action
   */
  export type ScheduledBlogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledBlog
     */
    select?: ScheduledBlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledBlog
     */
    omit?: ScheduledBlogOmit<ExtArgs> | null
  }


  /**
   * Model HeroImage
   */

  export type AggregateHeroImage = {
    _count: HeroImageCountAggregateOutputType | null
    _avg: HeroImageAvgAggregateOutputType | null
    _sum: HeroImageSumAggregateOutputType | null
    _min: HeroImageMinAggregateOutputType | null
    _max: HeroImageMaxAggregateOutputType | null
  }

  export type HeroImageAvgAggregateOutputType = {
    width: number | null
    height: number | null
    originalSize: number | null
    optimizedSize: number | null
  }

  export type HeroImageSumAggregateOutputType = {
    width: number | null
    height: number | null
    originalSize: number | null
    optimizedSize: number | null
  }

  export type HeroImageMinAggregateOutputType = {
    id: string | null
    page: string | null
    deviceType: $Enums.HeroDeviceType | null
    imageUrl: string | null
    alt: string | null
    fileName: string | null
    originalUrl: string | null
    width: number | null
    height: number | null
    isAiGenerated: boolean | null
    aiPrompt: string | null
    originalSize: number | null
    optimizedSize: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HeroImageMaxAggregateOutputType = {
    id: string | null
    page: string | null
    deviceType: $Enums.HeroDeviceType | null
    imageUrl: string | null
    alt: string | null
    fileName: string | null
    originalUrl: string | null
    width: number | null
    height: number | null
    isAiGenerated: boolean | null
    aiPrompt: string | null
    originalSize: number | null
    optimizedSize: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HeroImageCountAggregateOutputType = {
    id: number
    page: number
    deviceType: number
    imageUrl: number
    alt: number
    fileName: number
    originalUrl: number
    width: number
    height: number
    isAiGenerated: number
    aiPrompt: number
    originalSize: number
    optimizedSize: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HeroImageAvgAggregateInputType = {
    width?: true
    height?: true
    originalSize?: true
    optimizedSize?: true
  }

  export type HeroImageSumAggregateInputType = {
    width?: true
    height?: true
    originalSize?: true
    optimizedSize?: true
  }

  export type HeroImageMinAggregateInputType = {
    id?: true
    page?: true
    deviceType?: true
    imageUrl?: true
    alt?: true
    fileName?: true
    originalUrl?: true
    width?: true
    height?: true
    isAiGenerated?: true
    aiPrompt?: true
    originalSize?: true
    optimizedSize?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HeroImageMaxAggregateInputType = {
    id?: true
    page?: true
    deviceType?: true
    imageUrl?: true
    alt?: true
    fileName?: true
    originalUrl?: true
    width?: true
    height?: true
    isAiGenerated?: true
    aiPrompt?: true
    originalSize?: true
    optimizedSize?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HeroImageCountAggregateInputType = {
    id?: true
    page?: true
    deviceType?: true
    imageUrl?: true
    alt?: true
    fileName?: true
    originalUrl?: true
    width?: true
    height?: true
    isAiGenerated?: true
    aiPrompt?: true
    originalSize?: true
    optimizedSize?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HeroImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HeroImage to aggregate.
     */
    where?: HeroImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroImages to fetch.
     */
    orderBy?: HeroImageOrderByWithRelationInput | HeroImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HeroImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HeroImages
    **/
    _count?: true | HeroImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HeroImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HeroImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HeroImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HeroImageMaxAggregateInputType
  }

  export type GetHeroImageAggregateType<T extends HeroImageAggregateArgs> = {
        [P in keyof T & keyof AggregateHeroImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHeroImage[P]>
      : GetScalarType<T[P], AggregateHeroImage[P]>
  }




  export type HeroImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HeroImageWhereInput
    orderBy?: HeroImageOrderByWithAggregationInput | HeroImageOrderByWithAggregationInput[]
    by: HeroImageScalarFieldEnum[] | HeroImageScalarFieldEnum
    having?: HeroImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HeroImageCountAggregateInputType | true
    _avg?: HeroImageAvgAggregateInputType
    _sum?: HeroImageSumAggregateInputType
    _min?: HeroImageMinAggregateInputType
    _max?: HeroImageMaxAggregateInputType
  }

  export type HeroImageGroupByOutputType = {
    id: string
    page: string
    deviceType: $Enums.HeroDeviceType
    imageUrl: string
    alt: string
    fileName: string | null
    originalUrl: string | null
    width: number | null
    height: number | null
    isAiGenerated: boolean
    aiPrompt: string | null
    originalSize: number | null
    optimizedSize: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: HeroImageCountAggregateOutputType | null
    _avg: HeroImageAvgAggregateOutputType | null
    _sum: HeroImageSumAggregateOutputType | null
    _min: HeroImageMinAggregateOutputType | null
    _max: HeroImageMaxAggregateOutputType | null
  }

  type GetHeroImageGroupByPayload<T extends HeroImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HeroImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HeroImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HeroImageGroupByOutputType[P]>
            : GetScalarType<T[P], HeroImageGroupByOutputType[P]>
        }
      >
    >


  export type HeroImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    page?: boolean
    deviceType?: boolean
    imageUrl?: boolean
    alt?: boolean
    fileName?: boolean
    originalUrl?: boolean
    width?: boolean
    height?: boolean
    isAiGenerated?: boolean
    aiPrompt?: boolean
    originalSize?: boolean
    optimizedSize?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["heroImage"]>

  export type HeroImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    page?: boolean
    deviceType?: boolean
    imageUrl?: boolean
    alt?: boolean
    fileName?: boolean
    originalUrl?: boolean
    width?: boolean
    height?: boolean
    isAiGenerated?: boolean
    aiPrompt?: boolean
    originalSize?: boolean
    optimizedSize?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["heroImage"]>

  export type HeroImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    page?: boolean
    deviceType?: boolean
    imageUrl?: boolean
    alt?: boolean
    fileName?: boolean
    originalUrl?: boolean
    width?: boolean
    height?: boolean
    isAiGenerated?: boolean
    aiPrompt?: boolean
    originalSize?: boolean
    optimizedSize?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["heroImage"]>

  export type HeroImageSelectScalar = {
    id?: boolean
    page?: boolean
    deviceType?: boolean
    imageUrl?: boolean
    alt?: boolean
    fileName?: boolean
    originalUrl?: boolean
    width?: boolean
    height?: boolean
    isAiGenerated?: boolean
    aiPrompt?: boolean
    originalSize?: boolean
    optimizedSize?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HeroImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "page" | "deviceType" | "imageUrl" | "alt" | "fileName" | "originalUrl" | "width" | "height" | "isAiGenerated" | "aiPrompt" | "originalSize" | "optimizedSize" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["heroImage"]>

  export type $HeroImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HeroImage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      page: string
      deviceType: $Enums.HeroDeviceType
      imageUrl: string
      alt: string
      fileName: string | null
      originalUrl: string | null
      width: number | null
      height: number | null
      isAiGenerated: boolean
      aiPrompt: string | null
      originalSize: number | null
      optimizedSize: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["heroImage"]>
    composites: {}
  }

  type HeroImageGetPayload<S extends boolean | null | undefined | HeroImageDefaultArgs> = $Result.GetResult<Prisma.$HeroImagePayload, S>

  type HeroImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HeroImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HeroImageCountAggregateInputType | true
    }

  export interface HeroImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HeroImage'], meta: { name: 'HeroImage' } }
    /**
     * Find zero or one HeroImage that matches the filter.
     * @param {HeroImageFindUniqueArgs} args - Arguments to find a HeroImage
     * @example
     * // Get one HeroImage
     * const heroImage = await prisma.heroImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HeroImageFindUniqueArgs>(args: SelectSubset<T, HeroImageFindUniqueArgs<ExtArgs>>): Prisma__HeroImageClient<$Result.GetResult<Prisma.$HeroImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HeroImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HeroImageFindUniqueOrThrowArgs} args - Arguments to find a HeroImage
     * @example
     * // Get one HeroImage
     * const heroImage = await prisma.heroImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HeroImageFindUniqueOrThrowArgs>(args: SelectSubset<T, HeroImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HeroImageClient<$Result.GetResult<Prisma.$HeroImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HeroImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroImageFindFirstArgs} args - Arguments to find a HeroImage
     * @example
     * // Get one HeroImage
     * const heroImage = await prisma.heroImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HeroImageFindFirstArgs>(args?: SelectSubset<T, HeroImageFindFirstArgs<ExtArgs>>): Prisma__HeroImageClient<$Result.GetResult<Prisma.$HeroImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HeroImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroImageFindFirstOrThrowArgs} args - Arguments to find a HeroImage
     * @example
     * // Get one HeroImage
     * const heroImage = await prisma.heroImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HeroImageFindFirstOrThrowArgs>(args?: SelectSubset<T, HeroImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__HeroImageClient<$Result.GetResult<Prisma.$HeroImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HeroImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HeroImages
     * const heroImages = await prisma.heroImage.findMany()
     * 
     * // Get first 10 HeroImages
     * const heroImages = await prisma.heroImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const heroImageWithIdOnly = await prisma.heroImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HeroImageFindManyArgs>(args?: SelectSubset<T, HeroImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeroImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HeroImage.
     * @param {HeroImageCreateArgs} args - Arguments to create a HeroImage.
     * @example
     * // Create one HeroImage
     * const HeroImage = await prisma.heroImage.create({
     *   data: {
     *     // ... data to create a HeroImage
     *   }
     * })
     * 
     */
    create<T extends HeroImageCreateArgs>(args: SelectSubset<T, HeroImageCreateArgs<ExtArgs>>): Prisma__HeroImageClient<$Result.GetResult<Prisma.$HeroImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HeroImages.
     * @param {HeroImageCreateManyArgs} args - Arguments to create many HeroImages.
     * @example
     * // Create many HeroImages
     * const heroImage = await prisma.heroImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HeroImageCreateManyArgs>(args?: SelectSubset<T, HeroImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HeroImages and returns the data saved in the database.
     * @param {HeroImageCreateManyAndReturnArgs} args - Arguments to create many HeroImages.
     * @example
     * // Create many HeroImages
     * const heroImage = await prisma.heroImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HeroImages and only return the `id`
     * const heroImageWithIdOnly = await prisma.heroImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HeroImageCreateManyAndReturnArgs>(args?: SelectSubset<T, HeroImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeroImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HeroImage.
     * @param {HeroImageDeleteArgs} args - Arguments to delete one HeroImage.
     * @example
     * // Delete one HeroImage
     * const HeroImage = await prisma.heroImage.delete({
     *   where: {
     *     // ... filter to delete one HeroImage
     *   }
     * })
     * 
     */
    delete<T extends HeroImageDeleteArgs>(args: SelectSubset<T, HeroImageDeleteArgs<ExtArgs>>): Prisma__HeroImageClient<$Result.GetResult<Prisma.$HeroImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HeroImage.
     * @param {HeroImageUpdateArgs} args - Arguments to update one HeroImage.
     * @example
     * // Update one HeroImage
     * const heroImage = await prisma.heroImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HeroImageUpdateArgs>(args: SelectSubset<T, HeroImageUpdateArgs<ExtArgs>>): Prisma__HeroImageClient<$Result.GetResult<Prisma.$HeroImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HeroImages.
     * @param {HeroImageDeleteManyArgs} args - Arguments to filter HeroImages to delete.
     * @example
     * // Delete a few HeroImages
     * const { count } = await prisma.heroImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HeroImageDeleteManyArgs>(args?: SelectSubset<T, HeroImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HeroImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HeroImages
     * const heroImage = await prisma.heroImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HeroImageUpdateManyArgs>(args: SelectSubset<T, HeroImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HeroImages and returns the data updated in the database.
     * @param {HeroImageUpdateManyAndReturnArgs} args - Arguments to update many HeroImages.
     * @example
     * // Update many HeroImages
     * const heroImage = await prisma.heroImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HeroImages and only return the `id`
     * const heroImageWithIdOnly = await prisma.heroImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HeroImageUpdateManyAndReturnArgs>(args: SelectSubset<T, HeroImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeroImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HeroImage.
     * @param {HeroImageUpsertArgs} args - Arguments to update or create a HeroImage.
     * @example
     * // Update or create a HeroImage
     * const heroImage = await prisma.heroImage.upsert({
     *   create: {
     *     // ... data to create a HeroImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HeroImage we want to update
     *   }
     * })
     */
    upsert<T extends HeroImageUpsertArgs>(args: SelectSubset<T, HeroImageUpsertArgs<ExtArgs>>): Prisma__HeroImageClient<$Result.GetResult<Prisma.$HeroImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HeroImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroImageCountArgs} args - Arguments to filter HeroImages to count.
     * @example
     * // Count the number of HeroImages
     * const count = await prisma.heroImage.count({
     *   where: {
     *     // ... the filter for the HeroImages we want to count
     *   }
     * })
    **/
    count<T extends HeroImageCountArgs>(
      args?: Subset<T, HeroImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HeroImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HeroImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HeroImageAggregateArgs>(args: Subset<T, HeroImageAggregateArgs>): Prisma.PrismaPromise<GetHeroImageAggregateType<T>>

    /**
     * Group by HeroImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HeroImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HeroImageGroupByArgs['orderBy'] }
        : { orderBy?: HeroImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HeroImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHeroImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HeroImage model
   */
  readonly fields: HeroImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HeroImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HeroImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HeroImage model
   */
  interface HeroImageFieldRefs {
    readonly id: FieldRef<"HeroImage", 'String'>
    readonly page: FieldRef<"HeroImage", 'String'>
    readonly deviceType: FieldRef<"HeroImage", 'HeroDeviceType'>
    readonly imageUrl: FieldRef<"HeroImage", 'String'>
    readonly alt: FieldRef<"HeroImage", 'String'>
    readonly fileName: FieldRef<"HeroImage", 'String'>
    readonly originalUrl: FieldRef<"HeroImage", 'String'>
    readonly width: FieldRef<"HeroImage", 'Int'>
    readonly height: FieldRef<"HeroImage", 'Int'>
    readonly isAiGenerated: FieldRef<"HeroImage", 'Boolean'>
    readonly aiPrompt: FieldRef<"HeroImage", 'String'>
    readonly originalSize: FieldRef<"HeroImage", 'Int'>
    readonly optimizedSize: FieldRef<"HeroImage", 'Int'>
    readonly isActive: FieldRef<"HeroImage", 'Boolean'>
    readonly createdAt: FieldRef<"HeroImage", 'DateTime'>
    readonly updatedAt: FieldRef<"HeroImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HeroImage findUnique
   */
  export type HeroImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroImage
     */
    select?: HeroImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroImage
     */
    omit?: HeroImageOmit<ExtArgs> | null
    /**
     * Filter, which HeroImage to fetch.
     */
    where: HeroImageWhereUniqueInput
  }

  /**
   * HeroImage findUniqueOrThrow
   */
  export type HeroImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroImage
     */
    select?: HeroImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroImage
     */
    omit?: HeroImageOmit<ExtArgs> | null
    /**
     * Filter, which HeroImage to fetch.
     */
    where: HeroImageWhereUniqueInput
  }

  /**
   * HeroImage findFirst
   */
  export type HeroImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroImage
     */
    select?: HeroImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroImage
     */
    omit?: HeroImageOmit<ExtArgs> | null
    /**
     * Filter, which HeroImage to fetch.
     */
    where?: HeroImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroImages to fetch.
     */
    orderBy?: HeroImageOrderByWithRelationInput | HeroImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HeroImages.
     */
    cursor?: HeroImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HeroImages.
     */
    distinct?: HeroImageScalarFieldEnum | HeroImageScalarFieldEnum[]
  }

  /**
   * HeroImage findFirstOrThrow
   */
  export type HeroImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroImage
     */
    select?: HeroImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroImage
     */
    omit?: HeroImageOmit<ExtArgs> | null
    /**
     * Filter, which HeroImage to fetch.
     */
    where?: HeroImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroImages to fetch.
     */
    orderBy?: HeroImageOrderByWithRelationInput | HeroImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HeroImages.
     */
    cursor?: HeroImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HeroImages.
     */
    distinct?: HeroImageScalarFieldEnum | HeroImageScalarFieldEnum[]
  }

  /**
   * HeroImage findMany
   */
  export type HeroImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroImage
     */
    select?: HeroImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroImage
     */
    omit?: HeroImageOmit<ExtArgs> | null
    /**
     * Filter, which HeroImages to fetch.
     */
    where?: HeroImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroImages to fetch.
     */
    orderBy?: HeroImageOrderByWithRelationInput | HeroImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HeroImages.
     */
    cursor?: HeroImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroImages.
     */
    skip?: number
    distinct?: HeroImageScalarFieldEnum | HeroImageScalarFieldEnum[]
  }

  /**
   * HeroImage create
   */
  export type HeroImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroImage
     */
    select?: HeroImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroImage
     */
    omit?: HeroImageOmit<ExtArgs> | null
    /**
     * The data needed to create a HeroImage.
     */
    data: XOR<HeroImageCreateInput, HeroImageUncheckedCreateInput>
  }

  /**
   * HeroImage createMany
   */
  export type HeroImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HeroImages.
     */
    data: HeroImageCreateManyInput | HeroImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HeroImage createManyAndReturn
   */
  export type HeroImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroImage
     */
    select?: HeroImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HeroImage
     */
    omit?: HeroImageOmit<ExtArgs> | null
    /**
     * The data used to create many HeroImages.
     */
    data: HeroImageCreateManyInput | HeroImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HeroImage update
   */
  export type HeroImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroImage
     */
    select?: HeroImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroImage
     */
    omit?: HeroImageOmit<ExtArgs> | null
    /**
     * The data needed to update a HeroImage.
     */
    data: XOR<HeroImageUpdateInput, HeroImageUncheckedUpdateInput>
    /**
     * Choose, which HeroImage to update.
     */
    where: HeroImageWhereUniqueInput
  }

  /**
   * HeroImage updateMany
   */
  export type HeroImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HeroImages.
     */
    data: XOR<HeroImageUpdateManyMutationInput, HeroImageUncheckedUpdateManyInput>
    /**
     * Filter which HeroImages to update
     */
    where?: HeroImageWhereInput
    /**
     * Limit how many HeroImages to update.
     */
    limit?: number
  }

  /**
   * HeroImage updateManyAndReturn
   */
  export type HeroImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroImage
     */
    select?: HeroImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HeroImage
     */
    omit?: HeroImageOmit<ExtArgs> | null
    /**
     * The data used to update HeroImages.
     */
    data: XOR<HeroImageUpdateManyMutationInput, HeroImageUncheckedUpdateManyInput>
    /**
     * Filter which HeroImages to update
     */
    where?: HeroImageWhereInput
    /**
     * Limit how many HeroImages to update.
     */
    limit?: number
  }

  /**
   * HeroImage upsert
   */
  export type HeroImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroImage
     */
    select?: HeroImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroImage
     */
    omit?: HeroImageOmit<ExtArgs> | null
    /**
     * The filter to search for the HeroImage to update in case it exists.
     */
    where: HeroImageWhereUniqueInput
    /**
     * In case the HeroImage found by the `where` argument doesn't exist, create a new HeroImage with this data.
     */
    create: XOR<HeroImageCreateInput, HeroImageUncheckedCreateInput>
    /**
     * In case the HeroImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HeroImageUpdateInput, HeroImageUncheckedUpdateInput>
  }

  /**
   * HeroImage delete
   */
  export type HeroImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroImage
     */
    select?: HeroImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroImage
     */
    omit?: HeroImageOmit<ExtArgs> | null
    /**
     * Filter which HeroImage to delete.
     */
    where: HeroImageWhereUniqueInput
  }

  /**
   * HeroImage deleteMany
   */
  export type HeroImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HeroImages to delete
     */
    where?: HeroImageWhereInput
    /**
     * Limit how many HeroImages to delete.
     */
    limit?: number
  }

  /**
   * HeroImage without action
   */
  export type HeroImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroImage
     */
    select?: HeroImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroImage
     */
    omit?: HeroImageOmit<ExtArgs> | null
  }


  /**
   * Model PropertyAlert
   */

  export type AggregatePropertyAlert = {
    _count: PropertyAlertCountAggregateOutputType | null
    _avg: PropertyAlertAvgAggregateOutputType | null
    _sum: PropertyAlertSumAggregateOutputType | null
    _min: PropertyAlertMinAggregateOutputType | null
    _max: PropertyAlertMaxAggregateOutputType | null
  }

  export type PropertyAlertAvgAggregateOutputType = {
    minPrice: number | null
    maxPrice: number | null
    minBeds: number | null
    maxBeds: number | null
    minBaths: number | null
    maxBaths: number | null
    minSqft: number | null
    maxSqft: number | null
    matchCount: number | null
    notificationCount: number | null
  }

  export type PropertyAlertSumAggregateOutputType = {
    minPrice: number | null
    maxPrice: number | null
    minBeds: number | null
    maxBeds: number | null
    minBaths: number | null
    maxBaths: number | null
    minSqft: number | null
    maxSqft: number | null
    matchCount: number | null
    notificationCount: number | null
  }

  export type PropertyAlertMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    phone: string | null
    countryCode: string | null
    userId: string | null
    propertyType: $Enums.PropertyType | null
    category: $Enums.PropertyCategory | null
    locations: string | null
    minPrice: number | null
    maxPrice: number | null
    minBeds: number | null
    maxBeds: number | null
    minBaths: number | null
    maxBaths: number | null
    minSqft: number | null
    maxSqft: number | null
    notifyImmediately: boolean | null
    notifyDigest: boolean | null
    digestDay: string | null
    isActive: boolean | null
    lastNotifiedAt: Date | null
    matchCount: number | null
    notificationCount: number | null
    verificationToken: string | null
    isVerified: boolean | null
    verifiedAt: Date | null
    unsubscribeToken: string | null
    ipAddress: string | null
    userAgent: string | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyAlertMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    phone: string | null
    countryCode: string | null
    userId: string | null
    propertyType: $Enums.PropertyType | null
    category: $Enums.PropertyCategory | null
    locations: string | null
    minPrice: number | null
    maxPrice: number | null
    minBeds: number | null
    maxBeds: number | null
    minBaths: number | null
    maxBaths: number | null
    minSqft: number | null
    maxSqft: number | null
    notifyImmediately: boolean | null
    notifyDigest: boolean | null
    digestDay: string | null
    isActive: boolean | null
    lastNotifiedAt: Date | null
    matchCount: number | null
    notificationCount: number | null
    verificationToken: string | null
    isVerified: boolean | null
    verifiedAt: Date | null
    unsubscribeToken: string | null
    ipAddress: string | null
    userAgent: string | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyAlertCountAggregateOutputType = {
    id: number
    email: number
    name: number
    phone: number
    countryCode: number
    userId: number
    propertyType: number
    category: number
    locations: number
    minPrice: number
    maxPrice: number
    minBeds: number
    maxBeds: number
    minBaths: number
    maxBaths: number
    minSqft: number
    maxSqft: number
    notifyImmediately: number
    notifyDigest: number
    digestDay: number
    isActive: number
    lastNotifiedAt: number
    matchCount: number
    notificationCount: number
    verificationToken: number
    isVerified: number
    verifiedAt: number
    unsubscribeToken: number
    ipAddress: number
    userAgent: number
    source: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyAlertAvgAggregateInputType = {
    minPrice?: true
    maxPrice?: true
    minBeds?: true
    maxBeds?: true
    minBaths?: true
    maxBaths?: true
    minSqft?: true
    maxSqft?: true
    matchCount?: true
    notificationCount?: true
  }

  export type PropertyAlertSumAggregateInputType = {
    minPrice?: true
    maxPrice?: true
    minBeds?: true
    maxBeds?: true
    minBaths?: true
    maxBaths?: true
    minSqft?: true
    maxSqft?: true
    matchCount?: true
    notificationCount?: true
  }

  export type PropertyAlertMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    phone?: true
    countryCode?: true
    userId?: true
    propertyType?: true
    category?: true
    locations?: true
    minPrice?: true
    maxPrice?: true
    minBeds?: true
    maxBeds?: true
    minBaths?: true
    maxBaths?: true
    minSqft?: true
    maxSqft?: true
    notifyImmediately?: true
    notifyDigest?: true
    digestDay?: true
    isActive?: true
    lastNotifiedAt?: true
    matchCount?: true
    notificationCount?: true
    verificationToken?: true
    isVerified?: true
    verifiedAt?: true
    unsubscribeToken?: true
    ipAddress?: true
    userAgent?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyAlertMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    phone?: true
    countryCode?: true
    userId?: true
    propertyType?: true
    category?: true
    locations?: true
    minPrice?: true
    maxPrice?: true
    minBeds?: true
    maxBeds?: true
    minBaths?: true
    maxBaths?: true
    minSqft?: true
    maxSqft?: true
    notifyImmediately?: true
    notifyDigest?: true
    digestDay?: true
    isActive?: true
    lastNotifiedAt?: true
    matchCount?: true
    notificationCount?: true
    verificationToken?: true
    isVerified?: true
    verifiedAt?: true
    unsubscribeToken?: true
    ipAddress?: true
    userAgent?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyAlertCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    phone?: true
    countryCode?: true
    userId?: true
    propertyType?: true
    category?: true
    locations?: true
    minPrice?: true
    maxPrice?: true
    minBeds?: true
    maxBeds?: true
    minBaths?: true
    maxBaths?: true
    minSqft?: true
    maxSqft?: true
    notifyImmediately?: true
    notifyDigest?: true
    digestDay?: true
    isActive?: true
    lastNotifiedAt?: true
    matchCount?: true
    notificationCount?: true
    verificationToken?: true
    isVerified?: true
    verifiedAt?: true
    unsubscribeToken?: true
    ipAddress?: true
    userAgent?: true
    source?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyAlert to aggregate.
     */
    where?: PropertyAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAlerts to fetch.
     */
    orderBy?: PropertyAlertOrderByWithRelationInput | PropertyAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyAlerts
    **/
    _count?: true | PropertyAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyAlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyAlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyAlertMaxAggregateInputType
  }

  export type GetPropertyAlertAggregateType<T extends PropertyAlertAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyAlert[P]>
      : GetScalarType<T[P], AggregatePropertyAlert[P]>
  }




  export type PropertyAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyAlertWhereInput
    orderBy?: PropertyAlertOrderByWithAggregationInput | PropertyAlertOrderByWithAggregationInput[]
    by: PropertyAlertScalarFieldEnum[] | PropertyAlertScalarFieldEnum
    having?: PropertyAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyAlertCountAggregateInputType | true
    _avg?: PropertyAlertAvgAggregateInputType
    _sum?: PropertyAlertSumAggregateInputType
    _min?: PropertyAlertMinAggregateInputType
    _max?: PropertyAlertMaxAggregateInputType
  }

  export type PropertyAlertGroupByOutputType = {
    id: string
    email: string
    name: string | null
    phone: string | null
    countryCode: string
    userId: string | null
    propertyType: $Enums.PropertyType | null
    category: $Enums.PropertyCategory | null
    locations: string | null
    minPrice: number | null
    maxPrice: number | null
    minBeds: number | null
    maxBeds: number | null
    minBaths: number | null
    maxBaths: number | null
    minSqft: number | null
    maxSqft: number | null
    notifyImmediately: boolean
    notifyDigest: boolean
    digestDay: string | null
    isActive: boolean
    lastNotifiedAt: Date | null
    matchCount: number
    notificationCount: number
    verificationToken: string | null
    isVerified: boolean
    verifiedAt: Date | null
    unsubscribeToken: string
    ipAddress: string | null
    userAgent: string | null
    source: string | null
    createdAt: Date
    updatedAt: Date
    _count: PropertyAlertCountAggregateOutputType | null
    _avg: PropertyAlertAvgAggregateOutputType | null
    _sum: PropertyAlertSumAggregateOutputType | null
    _min: PropertyAlertMinAggregateOutputType | null
    _max: PropertyAlertMaxAggregateOutputType | null
  }

  type GetPropertyAlertGroupByPayload<T extends PropertyAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyAlertGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyAlertGroupByOutputType[P]>
        }
      >
    >


  export type PropertyAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    countryCode?: boolean
    userId?: boolean
    propertyType?: boolean
    category?: boolean
    locations?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    minBeds?: boolean
    maxBeds?: boolean
    minBaths?: boolean
    maxBaths?: boolean
    minSqft?: boolean
    maxSqft?: boolean
    notifyImmediately?: boolean
    notifyDigest?: boolean
    digestDay?: boolean
    isActive?: boolean
    lastNotifiedAt?: boolean
    matchCount?: boolean
    notificationCount?: boolean
    verificationToken?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    unsubscribeToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["propertyAlert"]>

  export type PropertyAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    countryCode?: boolean
    userId?: boolean
    propertyType?: boolean
    category?: boolean
    locations?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    minBeds?: boolean
    maxBeds?: boolean
    minBaths?: boolean
    maxBaths?: boolean
    minSqft?: boolean
    maxSqft?: boolean
    notifyImmediately?: boolean
    notifyDigest?: boolean
    digestDay?: boolean
    isActive?: boolean
    lastNotifiedAt?: boolean
    matchCount?: boolean
    notificationCount?: boolean
    verificationToken?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    unsubscribeToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["propertyAlert"]>

  export type PropertyAlertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    countryCode?: boolean
    userId?: boolean
    propertyType?: boolean
    category?: boolean
    locations?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    minBeds?: boolean
    maxBeds?: boolean
    minBaths?: boolean
    maxBaths?: boolean
    minSqft?: boolean
    maxSqft?: boolean
    notifyImmediately?: boolean
    notifyDigest?: boolean
    digestDay?: boolean
    isActive?: boolean
    lastNotifiedAt?: boolean
    matchCount?: boolean
    notificationCount?: boolean
    verificationToken?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    unsubscribeToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["propertyAlert"]>

  export type PropertyAlertSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    countryCode?: boolean
    userId?: boolean
    propertyType?: boolean
    category?: boolean
    locations?: boolean
    minPrice?: boolean
    maxPrice?: boolean
    minBeds?: boolean
    maxBeds?: boolean
    minBaths?: boolean
    maxBaths?: boolean
    minSqft?: boolean
    maxSqft?: boolean
    notifyImmediately?: boolean
    notifyDigest?: boolean
    digestDay?: boolean
    isActive?: boolean
    lastNotifiedAt?: boolean
    matchCount?: boolean
    notificationCount?: boolean
    verificationToken?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    unsubscribeToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyAlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "phone" | "countryCode" | "userId" | "propertyType" | "category" | "locations" | "minPrice" | "maxPrice" | "minBeds" | "maxBeds" | "minBaths" | "maxBaths" | "minSqft" | "maxSqft" | "notifyImmediately" | "notifyDigest" | "digestDay" | "isActive" | "lastNotifiedAt" | "matchCount" | "notificationCount" | "verificationToken" | "isVerified" | "verifiedAt" | "unsubscribeToken" | "ipAddress" | "userAgent" | "source" | "createdAt" | "updatedAt", ExtArgs["result"]["propertyAlert"]>

  export type $PropertyAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyAlert"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      phone: string | null
      countryCode: string
      userId: string | null
      propertyType: $Enums.PropertyType | null
      category: $Enums.PropertyCategory | null
      locations: string | null
      minPrice: number | null
      maxPrice: number | null
      minBeds: number | null
      maxBeds: number | null
      minBaths: number | null
      maxBaths: number | null
      minSqft: number | null
      maxSqft: number | null
      notifyImmediately: boolean
      notifyDigest: boolean
      digestDay: string | null
      isActive: boolean
      lastNotifiedAt: Date | null
      matchCount: number
      notificationCount: number
      verificationToken: string | null
      isVerified: boolean
      verifiedAt: Date | null
      unsubscribeToken: string
      ipAddress: string | null
      userAgent: string | null
      source: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["propertyAlert"]>
    composites: {}
  }

  type PropertyAlertGetPayload<S extends boolean | null | undefined | PropertyAlertDefaultArgs> = $Result.GetResult<Prisma.$PropertyAlertPayload, S>

  type PropertyAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyAlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyAlertCountAggregateInputType | true
    }

  export interface PropertyAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyAlert'], meta: { name: 'PropertyAlert' } }
    /**
     * Find zero or one PropertyAlert that matches the filter.
     * @param {PropertyAlertFindUniqueArgs} args - Arguments to find a PropertyAlert
     * @example
     * // Get one PropertyAlert
     * const propertyAlert = await prisma.propertyAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyAlertFindUniqueArgs>(args: SelectSubset<T, PropertyAlertFindUniqueArgs<ExtArgs>>): Prisma__PropertyAlertClient<$Result.GetResult<Prisma.$PropertyAlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyAlert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyAlertFindUniqueOrThrowArgs} args - Arguments to find a PropertyAlert
     * @example
     * // Get one PropertyAlert
     * const propertyAlert = await prisma.propertyAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyAlertClient<$Result.GetResult<Prisma.$PropertyAlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAlertFindFirstArgs} args - Arguments to find a PropertyAlert
     * @example
     * // Get one PropertyAlert
     * const propertyAlert = await prisma.propertyAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyAlertFindFirstArgs>(args?: SelectSubset<T, PropertyAlertFindFirstArgs<ExtArgs>>): Prisma__PropertyAlertClient<$Result.GetResult<Prisma.$PropertyAlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAlertFindFirstOrThrowArgs} args - Arguments to find a PropertyAlert
     * @example
     * // Get one PropertyAlert
     * const propertyAlert = await prisma.propertyAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyAlertClient<$Result.GetResult<Prisma.$PropertyAlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyAlerts
     * const propertyAlerts = await prisma.propertyAlert.findMany()
     * 
     * // Get first 10 PropertyAlerts
     * const propertyAlerts = await prisma.propertyAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyAlertWithIdOnly = await prisma.propertyAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyAlertFindManyArgs>(args?: SelectSubset<T, PropertyAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyAlert.
     * @param {PropertyAlertCreateArgs} args - Arguments to create a PropertyAlert.
     * @example
     * // Create one PropertyAlert
     * const PropertyAlert = await prisma.propertyAlert.create({
     *   data: {
     *     // ... data to create a PropertyAlert
     *   }
     * })
     * 
     */
    create<T extends PropertyAlertCreateArgs>(args: SelectSubset<T, PropertyAlertCreateArgs<ExtArgs>>): Prisma__PropertyAlertClient<$Result.GetResult<Prisma.$PropertyAlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyAlerts.
     * @param {PropertyAlertCreateManyArgs} args - Arguments to create many PropertyAlerts.
     * @example
     * // Create many PropertyAlerts
     * const propertyAlert = await prisma.propertyAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyAlertCreateManyArgs>(args?: SelectSubset<T, PropertyAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyAlerts and returns the data saved in the database.
     * @param {PropertyAlertCreateManyAndReturnArgs} args - Arguments to create many PropertyAlerts.
     * @example
     * // Create many PropertyAlerts
     * const propertyAlert = await prisma.propertyAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyAlerts and only return the `id`
     * const propertyAlertWithIdOnly = await prisma.propertyAlert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAlertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyAlert.
     * @param {PropertyAlertDeleteArgs} args - Arguments to delete one PropertyAlert.
     * @example
     * // Delete one PropertyAlert
     * const PropertyAlert = await prisma.propertyAlert.delete({
     *   where: {
     *     // ... filter to delete one PropertyAlert
     *   }
     * })
     * 
     */
    delete<T extends PropertyAlertDeleteArgs>(args: SelectSubset<T, PropertyAlertDeleteArgs<ExtArgs>>): Prisma__PropertyAlertClient<$Result.GetResult<Prisma.$PropertyAlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyAlert.
     * @param {PropertyAlertUpdateArgs} args - Arguments to update one PropertyAlert.
     * @example
     * // Update one PropertyAlert
     * const propertyAlert = await prisma.propertyAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyAlertUpdateArgs>(args: SelectSubset<T, PropertyAlertUpdateArgs<ExtArgs>>): Prisma__PropertyAlertClient<$Result.GetResult<Prisma.$PropertyAlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyAlerts.
     * @param {PropertyAlertDeleteManyArgs} args - Arguments to filter PropertyAlerts to delete.
     * @example
     * // Delete a few PropertyAlerts
     * const { count } = await prisma.propertyAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyAlertDeleteManyArgs>(args?: SelectSubset<T, PropertyAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyAlerts
     * const propertyAlert = await prisma.propertyAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyAlertUpdateManyArgs>(args: SelectSubset<T, PropertyAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyAlerts and returns the data updated in the database.
     * @param {PropertyAlertUpdateManyAndReturnArgs} args - Arguments to update many PropertyAlerts.
     * @example
     * // Update many PropertyAlerts
     * const propertyAlert = await prisma.propertyAlert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyAlerts and only return the `id`
     * const propertyAlertWithIdOnly = await prisma.propertyAlert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyAlertUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyAlertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAlertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyAlert.
     * @param {PropertyAlertUpsertArgs} args - Arguments to update or create a PropertyAlert.
     * @example
     * // Update or create a PropertyAlert
     * const propertyAlert = await prisma.propertyAlert.upsert({
     *   create: {
     *     // ... data to create a PropertyAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyAlert we want to update
     *   }
     * })
     */
    upsert<T extends PropertyAlertUpsertArgs>(args: SelectSubset<T, PropertyAlertUpsertArgs<ExtArgs>>): Prisma__PropertyAlertClient<$Result.GetResult<Prisma.$PropertyAlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAlertCountArgs} args - Arguments to filter PropertyAlerts to count.
     * @example
     * // Count the number of PropertyAlerts
     * const count = await prisma.propertyAlert.count({
     *   where: {
     *     // ... the filter for the PropertyAlerts we want to count
     *   }
     * })
    **/
    count<T extends PropertyAlertCountArgs>(
      args?: Subset<T, PropertyAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAlertAggregateArgs>(args: Subset<T, PropertyAlertAggregateArgs>): Prisma.PrismaPromise<GetPropertyAlertAggregateType<T>>

    /**
     * Group by PropertyAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyAlertGroupByArgs['orderBy'] }
        : { orderBy?: PropertyAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyAlert model
   */
  readonly fields: PropertyAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyAlert model
   */
  interface PropertyAlertFieldRefs {
    readonly id: FieldRef<"PropertyAlert", 'String'>
    readonly email: FieldRef<"PropertyAlert", 'String'>
    readonly name: FieldRef<"PropertyAlert", 'String'>
    readonly phone: FieldRef<"PropertyAlert", 'String'>
    readonly countryCode: FieldRef<"PropertyAlert", 'String'>
    readonly userId: FieldRef<"PropertyAlert", 'String'>
    readonly propertyType: FieldRef<"PropertyAlert", 'PropertyType'>
    readonly category: FieldRef<"PropertyAlert", 'PropertyCategory'>
    readonly locations: FieldRef<"PropertyAlert", 'String'>
    readonly minPrice: FieldRef<"PropertyAlert", 'Int'>
    readonly maxPrice: FieldRef<"PropertyAlert", 'Int'>
    readonly minBeds: FieldRef<"PropertyAlert", 'Int'>
    readonly maxBeds: FieldRef<"PropertyAlert", 'Int'>
    readonly minBaths: FieldRef<"PropertyAlert", 'Int'>
    readonly maxBaths: FieldRef<"PropertyAlert", 'Int'>
    readonly minSqft: FieldRef<"PropertyAlert", 'Int'>
    readonly maxSqft: FieldRef<"PropertyAlert", 'Int'>
    readonly notifyImmediately: FieldRef<"PropertyAlert", 'Boolean'>
    readonly notifyDigest: FieldRef<"PropertyAlert", 'Boolean'>
    readonly digestDay: FieldRef<"PropertyAlert", 'String'>
    readonly isActive: FieldRef<"PropertyAlert", 'Boolean'>
    readonly lastNotifiedAt: FieldRef<"PropertyAlert", 'DateTime'>
    readonly matchCount: FieldRef<"PropertyAlert", 'Int'>
    readonly notificationCount: FieldRef<"PropertyAlert", 'Int'>
    readonly verificationToken: FieldRef<"PropertyAlert", 'String'>
    readonly isVerified: FieldRef<"PropertyAlert", 'Boolean'>
    readonly verifiedAt: FieldRef<"PropertyAlert", 'DateTime'>
    readonly unsubscribeToken: FieldRef<"PropertyAlert", 'String'>
    readonly ipAddress: FieldRef<"PropertyAlert", 'String'>
    readonly userAgent: FieldRef<"PropertyAlert", 'String'>
    readonly source: FieldRef<"PropertyAlert", 'String'>
    readonly createdAt: FieldRef<"PropertyAlert", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertyAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyAlert findUnique
   */
  export type PropertyAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlert
     */
    select?: PropertyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlert
     */
    omit?: PropertyAlertOmit<ExtArgs> | null
    /**
     * Filter, which PropertyAlert to fetch.
     */
    where: PropertyAlertWhereUniqueInput
  }

  /**
   * PropertyAlert findUniqueOrThrow
   */
  export type PropertyAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlert
     */
    select?: PropertyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlert
     */
    omit?: PropertyAlertOmit<ExtArgs> | null
    /**
     * Filter, which PropertyAlert to fetch.
     */
    where: PropertyAlertWhereUniqueInput
  }

  /**
   * PropertyAlert findFirst
   */
  export type PropertyAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlert
     */
    select?: PropertyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlert
     */
    omit?: PropertyAlertOmit<ExtArgs> | null
    /**
     * Filter, which PropertyAlert to fetch.
     */
    where?: PropertyAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAlerts to fetch.
     */
    orderBy?: PropertyAlertOrderByWithRelationInput | PropertyAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyAlerts.
     */
    cursor?: PropertyAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyAlerts.
     */
    distinct?: PropertyAlertScalarFieldEnum | PropertyAlertScalarFieldEnum[]
  }

  /**
   * PropertyAlert findFirstOrThrow
   */
  export type PropertyAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlert
     */
    select?: PropertyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlert
     */
    omit?: PropertyAlertOmit<ExtArgs> | null
    /**
     * Filter, which PropertyAlert to fetch.
     */
    where?: PropertyAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAlerts to fetch.
     */
    orderBy?: PropertyAlertOrderByWithRelationInput | PropertyAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyAlerts.
     */
    cursor?: PropertyAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyAlerts.
     */
    distinct?: PropertyAlertScalarFieldEnum | PropertyAlertScalarFieldEnum[]
  }

  /**
   * PropertyAlert findMany
   */
  export type PropertyAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlert
     */
    select?: PropertyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlert
     */
    omit?: PropertyAlertOmit<ExtArgs> | null
    /**
     * Filter, which PropertyAlerts to fetch.
     */
    where?: PropertyAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAlerts to fetch.
     */
    orderBy?: PropertyAlertOrderByWithRelationInput | PropertyAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyAlerts.
     */
    cursor?: PropertyAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAlerts.
     */
    skip?: number
    distinct?: PropertyAlertScalarFieldEnum | PropertyAlertScalarFieldEnum[]
  }

  /**
   * PropertyAlert create
   */
  export type PropertyAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlert
     */
    select?: PropertyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlert
     */
    omit?: PropertyAlertOmit<ExtArgs> | null
    /**
     * The data needed to create a PropertyAlert.
     */
    data: XOR<PropertyAlertCreateInput, PropertyAlertUncheckedCreateInput>
  }

  /**
   * PropertyAlert createMany
   */
  export type PropertyAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyAlerts.
     */
    data: PropertyAlertCreateManyInput | PropertyAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyAlert createManyAndReturn
   */
  export type PropertyAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlert
     */
    select?: PropertyAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlert
     */
    omit?: PropertyAlertOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyAlerts.
     */
    data: PropertyAlertCreateManyInput | PropertyAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyAlert update
   */
  export type PropertyAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlert
     */
    select?: PropertyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlert
     */
    omit?: PropertyAlertOmit<ExtArgs> | null
    /**
     * The data needed to update a PropertyAlert.
     */
    data: XOR<PropertyAlertUpdateInput, PropertyAlertUncheckedUpdateInput>
    /**
     * Choose, which PropertyAlert to update.
     */
    where: PropertyAlertWhereUniqueInput
  }

  /**
   * PropertyAlert updateMany
   */
  export type PropertyAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyAlerts.
     */
    data: XOR<PropertyAlertUpdateManyMutationInput, PropertyAlertUncheckedUpdateManyInput>
    /**
     * Filter which PropertyAlerts to update
     */
    where?: PropertyAlertWhereInput
    /**
     * Limit how many PropertyAlerts to update.
     */
    limit?: number
  }

  /**
   * PropertyAlert updateManyAndReturn
   */
  export type PropertyAlertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlert
     */
    select?: PropertyAlertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlert
     */
    omit?: PropertyAlertOmit<ExtArgs> | null
    /**
     * The data used to update PropertyAlerts.
     */
    data: XOR<PropertyAlertUpdateManyMutationInput, PropertyAlertUncheckedUpdateManyInput>
    /**
     * Filter which PropertyAlerts to update
     */
    where?: PropertyAlertWhereInput
    /**
     * Limit how many PropertyAlerts to update.
     */
    limit?: number
  }

  /**
   * PropertyAlert upsert
   */
  export type PropertyAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlert
     */
    select?: PropertyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlert
     */
    omit?: PropertyAlertOmit<ExtArgs> | null
    /**
     * The filter to search for the PropertyAlert to update in case it exists.
     */
    where: PropertyAlertWhereUniqueInput
    /**
     * In case the PropertyAlert found by the `where` argument doesn't exist, create a new PropertyAlert with this data.
     */
    create: XOR<PropertyAlertCreateInput, PropertyAlertUncheckedCreateInput>
    /**
     * In case the PropertyAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyAlertUpdateInput, PropertyAlertUncheckedUpdateInput>
  }

  /**
   * PropertyAlert delete
   */
  export type PropertyAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlert
     */
    select?: PropertyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlert
     */
    omit?: PropertyAlertOmit<ExtArgs> | null
    /**
     * Filter which PropertyAlert to delete.
     */
    where: PropertyAlertWhereUniqueInput
  }

  /**
   * PropertyAlert deleteMany
   */
  export type PropertyAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyAlerts to delete
     */
    where?: PropertyAlertWhereInput
    /**
     * Limit how many PropertyAlerts to delete.
     */
    limit?: number
  }

  /**
   * PropertyAlert without action
   */
  export type PropertyAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlert
     */
    select?: PropertyAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlert
     */
    omit?: PropertyAlertOmit<ExtArgs> | null
  }


  /**
   * Model PropertyAlertNotification
   */

  export type AggregatePropertyAlertNotification = {
    _count: PropertyAlertNotificationCountAggregateOutputType | null
    _avg: PropertyAlertNotificationAvgAggregateOutputType | null
    _sum: PropertyAlertNotificationSumAggregateOutputType | null
    _min: PropertyAlertNotificationMinAggregateOutputType | null
    _max: PropertyAlertNotificationMaxAggregateOutputType | null
  }

  export type PropertyAlertNotificationAvgAggregateOutputType = {
    propertyCount: number | null
  }

  export type PropertyAlertNotificationSumAggregateOutputType = {
    propertyCount: number | null
  }

  export type PropertyAlertNotificationMinAggregateOutputType = {
    id: string | null
    alertId: string | null
    propertyIds: string | null
    propertyCount: number | null
    emailSent: boolean | null
    emailSentAt: Date | null
    emailError: string | null
    opened: boolean | null
    openedAt: Date | null
    clicked: boolean | null
    clickedAt: Date | null
    createdAt: Date | null
  }

  export type PropertyAlertNotificationMaxAggregateOutputType = {
    id: string | null
    alertId: string | null
    propertyIds: string | null
    propertyCount: number | null
    emailSent: boolean | null
    emailSentAt: Date | null
    emailError: string | null
    opened: boolean | null
    openedAt: Date | null
    clicked: boolean | null
    clickedAt: Date | null
    createdAt: Date | null
  }

  export type PropertyAlertNotificationCountAggregateOutputType = {
    id: number
    alertId: number
    propertyIds: number
    propertyCount: number
    emailSent: number
    emailSentAt: number
    emailError: number
    opened: number
    openedAt: number
    clicked: number
    clickedAt: number
    createdAt: number
    _all: number
  }


  export type PropertyAlertNotificationAvgAggregateInputType = {
    propertyCount?: true
  }

  export type PropertyAlertNotificationSumAggregateInputType = {
    propertyCount?: true
  }

  export type PropertyAlertNotificationMinAggregateInputType = {
    id?: true
    alertId?: true
    propertyIds?: true
    propertyCount?: true
    emailSent?: true
    emailSentAt?: true
    emailError?: true
    opened?: true
    openedAt?: true
    clicked?: true
    clickedAt?: true
    createdAt?: true
  }

  export type PropertyAlertNotificationMaxAggregateInputType = {
    id?: true
    alertId?: true
    propertyIds?: true
    propertyCount?: true
    emailSent?: true
    emailSentAt?: true
    emailError?: true
    opened?: true
    openedAt?: true
    clicked?: true
    clickedAt?: true
    createdAt?: true
  }

  export type PropertyAlertNotificationCountAggregateInputType = {
    id?: true
    alertId?: true
    propertyIds?: true
    propertyCount?: true
    emailSent?: true
    emailSentAt?: true
    emailError?: true
    opened?: true
    openedAt?: true
    clicked?: true
    clickedAt?: true
    createdAt?: true
    _all?: true
  }

  export type PropertyAlertNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyAlertNotification to aggregate.
     */
    where?: PropertyAlertNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAlertNotifications to fetch.
     */
    orderBy?: PropertyAlertNotificationOrderByWithRelationInput | PropertyAlertNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyAlertNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAlertNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAlertNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyAlertNotifications
    **/
    _count?: true | PropertyAlertNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyAlertNotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyAlertNotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyAlertNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyAlertNotificationMaxAggregateInputType
  }

  export type GetPropertyAlertNotificationAggregateType<T extends PropertyAlertNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyAlertNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyAlertNotification[P]>
      : GetScalarType<T[P], AggregatePropertyAlertNotification[P]>
  }




  export type PropertyAlertNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyAlertNotificationWhereInput
    orderBy?: PropertyAlertNotificationOrderByWithAggregationInput | PropertyAlertNotificationOrderByWithAggregationInput[]
    by: PropertyAlertNotificationScalarFieldEnum[] | PropertyAlertNotificationScalarFieldEnum
    having?: PropertyAlertNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyAlertNotificationCountAggregateInputType | true
    _avg?: PropertyAlertNotificationAvgAggregateInputType
    _sum?: PropertyAlertNotificationSumAggregateInputType
    _min?: PropertyAlertNotificationMinAggregateInputType
    _max?: PropertyAlertNotificationMaxAggregateInputType
  }

  export type PropertyAlertNotificationGroupByOutputType = {
    id: string
    alertId: string
    propertyIds: string
    propertyCount: number
    emailSent: boolean
    emailSentAt: Date | null
    emailError: string | null
    opened: boolean
    openedAt: Date | null
    clicked: boolean
    clickedAt: Date | null
    createdAt: Date
    _count: PropertyAlertNotificationCountAggregateOutputType | null
    _avg: PropertyAlertNotificationAvgAggregateOutputType | null
    _sum: PropertyAlertNotificationSumAggregateOutputType | null
    _min: PropertyAlertNotificationMinAggregateOutputType | null
    _max: PropertyAlertNotificationMaxAggregateOutputType | null
  }

  type GetPropertyAlertNotificationGroupByPayload<T extends PropertyAlertNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyAlertNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyAlertNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyAlertNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyAlertNotificationGroupByOutputType[P]>
        }
      >
    >


  export type PropertyAlertNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertId?: boolean
    propertyIds?: boolean
    propertyCount?: boolean
    emailSent?: boolean
    emailSentAt?: boolean
    emailError?: boolean
    opened?: boolean
    openedAt?: boolean
    clicked?: boolean
    clickedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["propertyAlertNotification"]>

  export type PropertyAlertNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertId?: boolean
    propertyIds?: boolean
    propertyCount?: boolean
    emailSent?: boolean
    emailSentAt?: boolean
    emailError?: boolean
    opened?: boolean
    openedAt?: boolean
    clicked?: boolean
    clickedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["propertyAlertNotification"]>

  export type PropertyAlertNotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alertId?: boolean
    propertyIds?: boolean
    propertyCount?: boolean
    emailSent?: boolean
    emailSentAt?: boolean
    emailError?: boolean
    opened?: boolean
    openedAt?: boolean
    clicked?: boolean
    clickedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["propertyAlertNotification"]>

  export type PropertyAlertNotificationSelectScalar = {
    id?: boolean
    alertId?: boolean
    propertyIds?: boolean
    propertyCount?: boolean
    emailSent?: boolean
    emailSentAt?: boolean
    emailError?: boolean
    opened?: boolean
    openedAt?: boolean
    clicked?: boolean
    clickedAt?: boolean
    createdAt?: boolean
  }

  export type PropertyAlertNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "alertId" | "propertyIds" | "propertyCount" | "emailSent" | "emailSentAt" | "emailError" | "opened" | "openedAt" | "clicked" | "clickedAt" | "createdAt", ExtArgs["result"]["propertyAlertNotification"]>

  export type $PropertyAlertNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyAlertNotification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      alertId: string
      propertyIds: string
      propertyCount: number
      emailSent: boolean
      emailSentAt: Date | null
      emailError: string | null
      opened: boolean
      openedAt: Date | null
      clicked: boolean
      clickedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["propertyAlertNotification"]>
    composites: {}
  }

  type PropertyAlertNotificationGetPayload<S extends boolean | null | undefined | PropertyAlertNotificationDefaultArgs> = $Result.GetResult<Prisma.$PropertyAlertNotificationPayload, S>

  type PropertyAlertNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyAlertNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyAlertNotificationCountAggregateInputType | true
    }

  export interface PropertyAlertNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyAlertNotification'], meta: { name: 'PropertyAlertNotification' } }
    /**
     * Find zero or one PropertyAlertNotification that matches the filter.
     * @param {PropertyAlertNotificationFindUniqueArgs} args - Arguments to find a PropertyAlertNotification
     * @example
     * // Get one PropertyAlertNotification
     * const propertyAlertNotification = await prisma.propertyAlertNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyAlertNotificationFindUniqueArgs>(args: SelectSubset<T, PropertyAlertNotificationFindUniqueArgs<ExtArgs>>): Prisma__PropertyAlertNotificationClient<$Result.GetResult<Prisma.$PropertyAlertNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyAlertNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyAlertNotificationFindUniqueOrThrowArgs} args - Arguments to find a PropertyAlertNotification
     * @example
     * // Get one PropertyAlertNotification
     * const propertyAlertNotification = await prisma.propertyAlertNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyAlertNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyAlertNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyAlertNotificationClient<$Result.GetResult<Prisma.$PropertyAlertNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyAlertNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAlertNotificationFindFirstArgs} args - Arguments to find a PropertyAlertNotification
     * @example
     * // Get one PropertyAlertNotification
     * const propertyAlertNotification = await prisma.propertyAlertNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyAlertNotificationFindFirstArgs>(args?: SelectSubset<T, PropertyAlertNotificationFindFirstArgs<ExtArgs>>): Prisma__PropertyAlertNotificationClient<$Result.GetResult<Prisma.$PropertyAlertNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyAlertNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAlertNotificationFindFirstOrThrowArgs} args - Arguments to find a PropertyAlertNotification
     * @example
     * // Get one PropertyAlertNotification
     * const propertyAlertNotification = await prisma.propertyAlertNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyAlertNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyAlertNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyAlertNotificationClient<$Result.GetResult<Prisma.$PropertyAlertNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyAlertNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAlertNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyAlertNotifications
     * const propertyAlertNotifications = await prisma.propertyAlertNotification.findMany()
     * 
     * // Get first 10 PropertyAlertNotifications
     * const propertyAlertNotifications = await prisma.propertyAlertNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyAlertNotificationWithIdOnly = await prisma.propertyAlertNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyAlertNotificationFindManyArgs>(args?: SelectSubset<T, PropertyAlertNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAlertNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyAlertNotification.
     * @param {PropertyAlertNotificationCreateArgs} args - Arguments to create a PropertyAlertNotification.
     * @example
     * // Create one PropertyAlertNotification
     * const PropertyAlertNotification = await prisma.propertyAlertNotification.create({
     *   data: {
     *     // ... data to create a PropertyAlertNotification
     *   }
     * })
     * 
     */
    create<T extends PropertyAlertNotificationCreateArgs>(args: SelectSubset<T, PropertyAlertNotificationCreateArgs<ExtArgs>>): Prisma__PropertyAlertNotificationClient<$Result.GetResult<Prisma.$PropertyAlertNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyAlertNotifications.
     * @param {PropertyAlertNotificationCreateManyArgs} args - Arguments to create many PropertyAlertNotifications.
     * @example
     * // Create many PropertyAlertNotifications
     * const propertyAlertNotification = await prisma.propertyAlertNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyAlertNotificationCreateManyArgs>(args?: SelectSubset<T, PropertyAlertNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyAlertNotifications and returns the data saved in the database.
     * @param {PropertyAlertNotificationCreateManyAndReturnArgs} args - Arguments to create many PropertyAlertNotifications.
     * @example
     * // Create many PropertyAlertNotifications
     * const propertyAlertNotification = await prisma.propertyAlertNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyAlertNotifications and only return the `id`
     * const propertyAlertNotificationWithIdOnly = await prisma.propertyAlertNotification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyAlertNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyAlertNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAlertNotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyAlertNotification.
     * @param {PropertyAlertNotificationDeleteArgs} args - Arguments to delete one PropertyAlertNotification.
     * @example
     * // Delete one PropertyAlertNotification
     * const PropertyAlertNotification = await prisma.propertyAlertNotification.delete({
     *   where: {
     *     // ... filter to delete one PropertyAlertNotification
     *   }
     * })
     * 
     */
    delete<T extends PropertyAlertNotificationDeleteArgs>(args: SelectSubset<T, PropertyAlertNotificationDeleteArgs<ExtArgs>>): Prisma__PropertyAlertNotificationClient<$Result.GetResult<Prisma.$PropertyAlertNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyAlertNotification.
     * @param {PropertyAlertNotificationUpdateArgs} args - Arguments to update one PropertyAlertNotification.
     * @example
     * // Update one PropertyAlertNotification
     * const propertyAlertNotification = await prisma.propertyAlertNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyAlertNotificationUpdateArgs>(args: SelectSubset<T, PropertyAlertNotificationUpdateArgs<ExtArgs>>): Prisma__PropertyAlertNotificationClient<$Result.GetResult<Prisma.$PropertyAlertNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyAlertNotifications.
     * @param {PropertyAlertNotificationDeleteManyArgs} args - Arguments to filter PropertyAlertNotifications to delete.
     * @example
     * // Delete a few PropertyAlertNotifications
     * const { count } = await prisma.propertyAlertNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyAlertNotificationDeleteManyArgs>(args?: SelectSubset<T, PropertyAlertNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyAlertNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAlertNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyAlertNotifications
     * const propertyAlertNotification = await prisma.propertyAlertNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyAlertNotificationUpdateManyArgs>(args: SelectSubset<T, PropertyAlertNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyAlertNotifications and returns the data updated in the database.
     * @param {PropertyAlertNotificationUpdateManyAndReturnArgs} args - Arguments to update many PropertyAlertNotifications.
     * @example
     * // Update many PropertyAlertNotifications
     * const propertyAlertNotification = await prisma.propertyAlertNotification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyAlertNotifications and only return the `id`
     * const propertyAlertNotificationWithIdOnly = await prisma.propertyAlertNotification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyAlertNotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyAlertNotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAlertNotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyAlertNotification.
     * @param {PropertyAlertNotificationUpsertArgs} args - Arguments to update or create a PropertyAlertNotification.
     * @example
     * // Update or create a PropertyAlertNotification
     * const propertyAlertNotification = await prisma.propertyAlertNotification.upsert({
     *   create: {
     *     // ... data to create a PropertyAlertNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyAlertNotification we want to update
     *   }
     * })
     */
    upsert<T extends PropertyAlertNotificationUpsertArgs>(args: SelectSubset<T, PropertyAlertNotificationUpsertArgs<ExtArgs>>): Prisma__PropertyAlertNotificationClient<$Result.GetResult<Prisma.$PropertyAlertNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyAlertNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAlertNotificationCountArgs} args - Arguments to filter PropertyAlertNotifications to count.
     * @example
     * // Count the number of PropertyAlertNotifications
     * const count = await prisma.propertyAlertNotification.count({
     *   where: {
     *     // ... the filter for the PropertyAlertNotifications we want to count
     *   }
     * })
    **/
    count<T extends PropertyAlertNotificationCountArgs>(
      args?: Subset<T, PropertyAlertNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyAlertNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyAlertNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAlertNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAlertNotificationAggregateArgs>(args: Subset<T, PropertyAlertNotificationAggregateArgs>): Prisma.PrismaPromise<GetPropertyAlertNotificationAggregateType<T>>

    /**
     * Group by PropertyAlertNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAlertNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyAlertNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyAlertNotificationGroupByArgs['orderBy'] }
        : { orderBy?: PropertyAlertNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyAlertNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyAlertNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyAlertNotification model
   */
  readonly fields: PropertyAlertNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyAlertNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyAlertNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyAlertNotification model
   */
  interface PropertyAlertNotificationFieldRefs {
    readonly id: FieldRef<"PropertyAlertNotification", 'String'>
    readonly alertId: FieldRef<"PropertyAlertNotification", 'String'>
    readonly propertyIds: FieldRef<"PropertyAlertNotification", 'String'>
    readonly propertyCount: FieldRef<"PropertyAlertNotification", 'Int'>
    readonly emailSent: FieldRef<"PropertyAlertNotification", 'Boolean'>
    readonly emailSentAt: FieldRef<"PropertyAlertNotification", 'DateTime'>
    readonly emailError: FieldRef<"PropertyAlertNotification", 'String'>
    readonly opened: FieldRef<"PropertyAlertNotification", 'Boolean'>
    readonly openedAt: FieldRef<"PropertyAlertNotification", 'DateTime'>
    readonly clicked: FieldRef<"PropertyAlertNotification", 'Boolean'>
    readonly clickedAt: FieldRef<"PropertyAlertNotification", 'DateTime'>
    readonly createdAt: FieldRef<"PropertyAlertNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyAlertNotification findUnique
   */
  export type PropertyAlertNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlertNotification
     */
    select?: PropertyAlertNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlertNotification
     */
    omit?: PropertyAlertNotificationOmit<ExtArgs> | null
    /**
     * Filter, which PropertyAlertNotification to fetch.
     */
    where: PropertyAlertNotificationWhereUniqueInput
  }

  /**
   * PropertyAlertNotification findUniqueOrThrow
   */
  export type PropertyAlertNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlertNotification
     */
    select?: PropertyAlertNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlertNotification
     */
    omit?: PropertyAlertNotificationOmit<ExtArgs> | null
    /**
     * Filter, which PropertyAlertNotification to fetch.
     */
    where: PropertyAlertNotificationWhereUniqueInput
  }

  /**
   * PropertyAlertNotification findFirst
   */
  export type PropertyAlertNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlertNotification
     */
    select?: PropertyAlertNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlertNotification
     */
    omit?: PropertyAlertNotificationOmit<ExtArgs> | null
    /**
     * Filter, which PropertyAlertNotification to fetch.
     */
    where?: PropertyAlertNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAlertNotifications to fetch.
     */
    orderBy?: PropertyAlertNotificationOrderByWithRelationInput | PropertyAlertNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyAlertNotifications.
     */
    cursor?: PropertyAlertNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAlertNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAlertNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyAlertNotifications.
     */
    distinct?: PropertyAlertNotificationScalarFieldEnum | PropertyAlertNotificationScalarFieldEnum[]
  }

  /**
   * PropertyAlertNotification findFirstOrThrow
   */
  export type PropertyAlertNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlertNotification
     */
    select?: PropertyAlertNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlertNotification
     */
    omit?: PropertyAlertNotificationOmit<ExtArgs> | null
    /**
     * Filter, which PropertyAlertNotification to fetch.
     */
    where?: PropertyAlertNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAlertNotifications to fetch.
     */
    orderBy?: PropertyAlertNotificationOrderByWithRelationInput | PropertyAlertNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyAlertNotifications.
     */
    cursor?: PropertyAlertNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAlertNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAlertNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyAlertNotifications.
     */
    distinct?: PropertyAlertNotificationScalarFieldEnum | PropertyAlertNotificationScalarFieldEnum[]
  }

  /**
   * PropertyAlertNotification findMany
   */
  export type PropertyAlertNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlertNotification
     */
    select?: PropertyAlertNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlertNotification
     */
    omit?: PropertyAlertNotificationOmit<ExtArgs> | null
    /**
     * Filter, which PropertyAlertNotifications to fetch.
     */
    where?: PropertyAlertNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAlertNotifications to fetch.
     */
    orderBy?: PropertyAlertNotificationOrderByWithRelationInput | PropertyAlertNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyAlertNotifications.
     */
    cursor?: PropertyAlertNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAlertNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAlertNotifications.
     */
    skip?: number
    distinct?: PropertyAlertNotificationScalarFieldEnum | PropertyAlertNotificationScalarFieldEnum[]
  }

  /**
   * PropertyAlertNotification create
   */
  export type PropertyAlertNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlertNotification
     */
    select?: PropertyAlertNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlertNotification
     */
    omit?: PropertyAlertNotificationOmit<ExtArgs> | null
    /**
     * The data needed to create a PropertyAlertNotification.
     */
    data: XOR<PropertyAlertNotificationCreateInput, PropertyAlertNotificationUncheckedCreateInput>
  }

  /**
   * PropertyAlertNotification createMany
   */
  export type PropertyAlertNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyAlertNotifications.
     */
    data: PropertyAlertNotificationCreateManyInput | PropertyAlertNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyAlertNotification createManyAndReturn
   */
  export type PropertyAlertNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlertNotification
     */
    select?: PropertyAlertNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlertNotification
     */
    omit?: PropertyAlertNotificationOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyAlertNotifications.
     */
    data: PropertyAlertNotificationCreateManyInput | PropertyAlertNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyAlertNotification update
   */
  export type PropertyAlertNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlertNotification
     */
    select?: PropertyAlertNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlertNotification
     */
    omit?: PropertyAlertNotificationOmit<ExtArgs> | null
    /**
     * The data needed to update a PropertyAlertNotification.
     */
    data: XOR<PropertyAlertNotificationUpdateInput, PropertyAlertNotificationUncheckedUpdateInput>
    /**
     * Choose, which PropertyAlertNotification to update.
     */
    where: PropertyAlertNotificationWhereUniqueInput
  }

  /**
   * PropertyAlertNotification updateMany
   */
  export type PropertyAlertNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyAlertNotifications.
     */
    data: XOR<PropertyAlertNotificationUpdateManyMutationInput, PropertyAlertNotificationUncheckedUpdateManyInput>
    /**
     * Filter which PropertyAlertNotifications to update
     */
    where?: PropertyAlertNotificationWhereInput
    /**
     * Limit how many PropertyAlertNotifications to update.
     */
    limit?: number
  }

  /**
   * PropertyAlertNotification updateManyAndReturn
   */
  export type PropertyAlertNotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlertNotification
     */
    select?: PropertyAlertNotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlertNotification
     */
    omit?: PropertyAlertNotificationOmit<ExtArgs> | null
    /**
     * The data used to update PropertyAlertNotifications.
     */
    data: XOR<PropertyAlertNotificationUpdateManyMutationInput, PropertyAlertNotificationUncheckedUpdateManyInput>
    /**
     * Filter which PropertyAlertNotifications to update
     */
    where?: PropertyAlertNotificationWhereInput
    /**
     * Limit how many PropertyAlertNotifications to update.
     */
    limit?: number
  }

  /**
   * PropertyAlertNotification upsert
   */
  export type PropertyAlertNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlertNotification
     */
    select?: PropertyAlertNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlertNotification
     */
    omit?: PropertyAlertNotificationOmit<ExtArgs> | null
    /**
     * The filter to search for the PropertyAlertNotification to update in case it exists.
     */
    where: PropertyAlertNotificationWhereUniqueInput
    /**
     * In case the PropertyAlertNotification found by the `where` argument doesn't exist, create a new PropertyAlertNotification with this data.
     */
    create: XOR<PropertyAlertNotificationCreateInput, PropertyAlertNotificationUncheckedCreateInput>
    /**
     * In case the PropertyAlertNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyAlertNotificationUpdateInput, PropertyAlertNotificationUncheckedUpdateInput>
  }

  /**
   * PropertyAlertNotification delete
   */
  export type PropertyAlertNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlertNotification
     */
    select?: PropertyAlertNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlertNotification
     */
    omit?: PropertyAlertNotificationOmit<ExtArgs> | null
    /**
     * Filter which PropertyAlertNotification to delete.
     */
    where: PropertyAlertNotificationWhereUniqueInput
  }

  /**
   * PropertyAlertNotification deleteMany
   */
  export type PropertyAlertNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyAlertNotifications to delete
     */
    where?: PropertyAlertNotificationWhereInput
    /**
     * Limit how many PropertyAlertNotifications to delete.
     */
    limit?: number
  }

  /**
   * PropertyAlertNotification without action
   */
  export type PropertyAlertNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAlertNotification
     */
    select?: PropertyAlertNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAlertNotification
     */
    omit?: PropertyAlertNotificationOmit<ExtArgs> | null
  }


  /**
   * Model Poi
   */

  export type AggregatePoi = {
    _count: PoiCountAggregateOutputType | null
    _avg: PoiAvgAggregateOutputType | null
    _sum: PoiSumAggregateOutputType | null
    _min: PoiMinAggregateOutputType | null
    _max: PoiMaxAggregateOutputType | null
  }

  export type PoiAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    importance: number | null
  }

  export type PoiSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    importance: number | null
  }

  export type PoiMinAggregateOutputType = {
    id: string | null
    externalId: string | null
    source: $Enums.PoiSource | null
    name: string | null
    nameTh: string | null
    nameLocal: string | null
    category: $Enums.PoiCategory | null
    subCategory: string | null
    latitude: number | null
    longitude: number | null
    address: string | null
    district: string | null
    importance: number | null
    isVerified: boolean | null
    isActive: boolean | null
    noiseLevel: $Enums.NoiseLevel | null
    trafficLevel: $Enums.TrafficLevel | null
    lastSyncedAt: Date | null
    syncError: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PoiMaxAggregateOutputType = {
    id: string | null
    externalId: string | null
    source: $Enums.PoiSource | null
    name: string | null
    nameTh: string | null
    nameLocal: string | null
    category: $Enums.PoiCategory | null
    subCategory: string | null
    latitude: number | null
    longitude: number | null
    address: string | null
    district: string | null
    importance: number | null
    isVerified: boolean | null
    isActive: boolean | null
    noiseLevel: $Enums.NoiseLevel | null
    trafficLevel: $Enums.TrafficLevel | null
    lastSyncedAt: Date | null
    syncError: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PoiCountAggregateOutputType = {
    id: number
    externalId: number
    source: number
    name: number
    nameTh: number
    nameLocal: number
    category: number
    subCategory: number
    latitude: number
    longitude: number
    address: number
    district: number
    osmTags: number
    importance: number
    isVerified: number
    isActive: number
    noiseLevel: number
    trafficLevel: number
    lastSyncedAt: number
    syncError: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PoiAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    importance?: true
  }

  export type PoiSumAggregateInputType = {
    latitude?: true
    longitude?: true
    importance?: true
  }

  export type PoiMinAggregateInputType = {
    id?: true
    externalId?: true
    source?: true
    name?: true
    nameTh?: true
    nameLocal?: true
    category?: true
    subCategory?: true
    latitude?: true
    longitude?: true
    address?: true
    district?: true
    importance?: true
    isVerified?: true
    isActive?: true
    noiseLevel?: true
    trafficLevel?: true
    lastSyncedAt?: true
    syncError?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PoiMaxAggregateInputType = {
    id?: true
    externalId?: true
    source?: true
    name?: true
    nameTh?: true
    nameLocal?: true
    category?: true
    subCategory?: true
    latitude?: true
    longitude?: true
    address?: true
    district?: true
    importance?: true
    isVerified?: true
    isActive?: true
    noiseLevel?: true
    trafficLevel?: true
    lastSyncedAt?: true
    syncError?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PoiCountAggregateInputType = {
    id?: true
    externalId?: true
    source?: true
    name?: true
    nameTh?: true
    nameLocal?: true
    category?: true
    subCategory?: true
    latitude?: true
    longitude?: true
    address?: true
    district?: true
    osmTags?: true
    importance?: true
    isVerified?: true
    isActive?: true
    noiseLevel?: true
    trafficLevel?: true
    lastSyncedAt?: true
    syncError?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PoiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Poi to aggregate.
     */
    where?: PoiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pois to fetch.
     */
    orderBy?: PoiOrderByWithRelationInput | PoiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PoiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pois
    **/
    _count?: true | PoiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PoiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PoiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PoiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PoiMaxAggregateInputType
  }

  export type GetPoiAggregateType<T extends PoiAggregateArgs> = {
        [P in keyof T & keyof AggregatePoi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePoi[P]>
      : GetScalarType<T[P], AggregatePoi[P]>
  }




  export type PoiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PoiWhereInput
    orderBy?: PoiOrderByWithAggregationInput | PoiOrderByWithAggregationInput[]
    by: PoiScalarFieldEnum[] | PoiScalarFieldEnum
    having?: PoiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PoiCountAggregateInputType | true
    _avg?: PoiAvgAggregateInputType
    _sum?: PoiSumAggregateInputType
    _min?: PoiMinAggregateInputType
    _max?: PoiMaxAggregateInputType
  }

  export type PoiGroupByOutputType = {
    id: string
    externalId: string | null
    source: $Enums.PoiSource
    name: string
    nameTh: string | null
    nameLocal: string | null
    category: $Enums.PoiCategory
    subCategory: string | null
    latitude: number
    longitude: number
    address: string | null
    district: string | null
    osmTags: JsonValue | null
    importance: number
    isVerified: boolean
    isActive: boolean
    noiseLevel: $Enums.NoiseLevel | null
    trafficLevel: $Enums.TrafficLevel | null
    lastSyncedAt: Date | null
    syncError: string | null
    createdAt: Date
    updatedAt: Date
    _count: PoiCountAggregateOutputType | null
    _avg: PoiAvgAggregateOutputType | null
    _sum: PoiSumAggregateOutputType | null
    _min: PoiMinAggregateOutputType | null
    _max: PoiMaxAggregateOutputType | null
  }

  type GetPoiGroupByPayload<T extends PoiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PoiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PoiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PoiGroupByOutputType[P]>
            : GetScalarType<T[P], PoiGroupByOutputType[P]>
        }
      >
    >


  export type PoiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    source?: boolean
    name?: boolean
    nameTh?: boolean
    nameLocal?: boolean
    category?: boolean
    subCategory?: boolean
    latitude?: boolean
    longitude?: boolean
    address?: boolean
    district?: boolean
    osmTags?: boolean
    importance?: boolean
    isVerified?: boolean
    isActive?: boolean
    noiseLevel?: boolean
    trafficLevel?: boolean
    lastSyncedAt?: boolean
    syncError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    propertyDistances?: boolean | Poi$propertyDistancesArgs<ExtArgs>
    _count?: boolean | PoiCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["poi"]>

  export type PoiSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    source?: boolean
    name?: boolean
    nameTh?: boolean
    nameLocal?: boolean
    category?: boolean
    subCategory?: boolean
    latitude?: boolean
    longitude?: boolean
    address?: boolean
    district?: boolean
    osmTags?: boolean
    importance?: boolean
    isVerified?: boolean
    isActive?: boolean
    noiseLevel?: boolean
    trafficLevel?: boolean
    lastSyncedAt?: boolean
    syncError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["poi"]>

  export type PoiSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalId?: boolean
    source?: boolean
    name?: boolean
    nameTh?: boolean
    nameLocal?: boolean
    category?: boolean
    subCategory?: boolean
    latitude?: boolean
    longitude?: boolean
    address?: boolean
    district?: boolean
    osmTags?: boolean
    importance?: boolean
    isVerified?: boolean
    isActive?: boolean
    noiseLevel?: boolean
    trafficLevel?: boolean
    lastSyncedAt?: boolean
    syncError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["poi"]>

  export type PoiSelectScalar = {
    id?: boolean
    externalId?: boolean
    source?: boolean
    name?: boolean
    nameTh?: boolean
    nameLocal?: boolean
    category?: boolean
    subCategory?: boolean
    latitude?: boolean
    longitude?: boolean
    address?: boolean
    district?: boolean
    osmTags?: boolean
    importance?: boolean
    isVerified?: boolean
    isActive?: boolean
    noiseLevel?: boolean
    trafficLevel?: boolean
    lastSyncedAt?: boolean
    syncError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PoiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "externalId" | "source" | "name" | "nameTh" | "nameLocal" | "category" | "subCategory" | "latitude" | "longitude" | "address" | "district" | "osmTags" | "importance" | "isVerified" | "isActive" | "noiseLevel" | "trafficLevel" | "lastSyncedAt" | "syncError" | "createdAt" | "updatedAt", ExtArgs["result"]["poi"]>
  export type PoiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyDistances?: boolean | Poi$propertyDistancesArgs<ExtArgs>
    _count?: boolean | PoiCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PoiIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PoiIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PoiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Poi"
    objects: {
      propertyDistances: Prisma.$PropertyPoiDistancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      externalId: string | null
      source: $Enums.PoiSource
      name: string
      nameTh: string | null
      nameLocal: string | null
      category: $Enums.PoiCategory
      subCategory: string | null
      latitude: number
      longitude: number
      address: string | null
      district: string | null
      osmTags: Prisma.JsonValue | null
      importance: number
      isVerified: boolean
      isActive: boolean
      noiseLevel: $Enums.NoiseLevel | null
      trafficLevel: $Enums.TrafficLevel | null
      lastSyncedAt: Date | null
      syncError: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["poi"]>
    composites: {}
  }

  type PoiGetPayload<S extends boolean | null | undefined | PoiDefaultArgs> = $Result.GetResult<Prisma.$PoiPayload, S>

  type PoiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PoiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PoiCountAggregateInputType | true
    }

  export interface PoiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Poi'], meta: { name: 'Poi' } }
    /**
     * Find zero or one Poi that matches the filter.
     * @param {PoiFindUniqueArgs} args - Arguments to find a Poi
     * @example
     * // Get one Poi
     * const poi = await prisma.poi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PoiFindUniqueArgs>(args: SelectSubset<T, PoiFindUniqueArgs<ExtArgs>>): Prisma__PoiClient<$Result.GetResult<Prisma.$PoiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Poi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PoiFindUniqueOrThrowArgs} args - Arguments to find a Poi
     * @example
     * // Get one Poi
     * const poi = await prisma.poi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PoiFindUniqueOrThrowArgs>(args: SelectSubset<T, PoiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PoiClient<$Result.GetResult<Prisma.$PoiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Poi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoiFindFirstArgs} args - Arguments to find a Poi
     * @example
     * // Get one Poi
     * const poi = await prisma.poi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PoiFindFirstArgs>(args?: SelectSubset<T, PoiFindFirstArgs<ExtArgs>>): Prisma__PoiClient<$Result.GetResult<Prisma.$PoiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Poi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoiFindFirstOrThrowArgs} args - Arguments to find a Poi
     * @example
     * // Get one Poi
     * const poi = await prisma.poi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PoiFindFirstOrThrowArgs>(args?: SelectSubset<T, PoiFindFirstOrThrowArgs<ExtArgs>>): Prisma__PoiClient<$Result.GetResult<Prisma.$PoiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pois that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pois
     * const pois = await prisma.poi.findMany()
     * 
     * // Get first 10 Pois
     * const pois = await prisma.poi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const poiWithIdOnly = await prisma.poi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PoiFindManyArgs>(args?: SelectSubset<T, PoiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PoiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Poi.
     * @param {PoiCreateArgs} args - Arguments to create a Poi.
     * @example
     * // Create one Poi
     * const Poi = await prisma.poi.create({
     *   data: {
     *     // ... data to create a Poi
     *   }
     * })
     * 
     */
    create<T extends PoiCreateArgs>(args: SelectSubset<T, PoiCreateArgs<ExtArgs>>): Prisma__PoiClient<$Result.GetResult<Prisma.$PoiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pois.
     * @param {PoiCreateManyArgs} args - Arguments to create many Pois.
     * @example
     * // Create many Pois
     * const poi = await prisma.poi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PoiCreateManyArgs>(args?: SelectSubset<T, PoiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pois and returns the data saved in the database.
     * @param {PoiCreateManyAndReturnArgs} args - Arguments to create many Pois.
     * @example
     * // Create many Pois
     * const poi = await prisma.poi.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pois and only return the `id`
     * const poiWithIdOnly = await prisma.poi.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PoiCreateManyAndReturnArgs>(args?: SelectSubset<T, PoiCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PoiPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Poi.
     * @param {PoiDeleteArgs} args - Arguments to delete one Poi.
     * @example
     * // Delete one Poi
     * const Poi = await prisma.poi.delete({
     *   where: {
     *     // ... filter to delete one Poi
     *   }
     * })
     * 
     */
    delete<T extends PoiDeleteArgs>(args: SelectSubset<T, PoiDeleteArgs<ExtArgs>>): Prisma__PoiClient<$Result.GetResult<Prisma.$PoiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Poi.
     * @param {PoiUpdateArgs} args - Arguments to update one Poi.
     * @example
     * // Update one Poi
     * const poi = await prisma.poi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PoiUpdateArgs>(args: SelectSubset<T, PoiUpdateArgs<ExtArgs>>): Prisma__PoiClient<$Result.GetResult<Prisma.$PoiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pois.
     * @param {PoiDeleteManyArgs} args - Arguments to filter Pois to delete.
     * @example
     * // Delete a few Pois
     * const { count } = await prisma.poi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PoiDeleteManyArgs>(args?: SelectSubset<T, PoiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pois
     * const poi = await prisma.poi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PoiUpdateManyArgs>(args: SelectSubset<T, PoiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pois and returns the data updated in the database.
     * @param {PoiUpdateManyAndReturnArgs} args - Arguments to update many Pois.
     * @example
     * // Update many Pois
     * const poi = await prisma.poi.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pois and only return the `id`
     * const poiWithIdOnly = await prisma.poi.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PoiUpdateManyAndReturnArgs>(args: SelectSubset<T, PoiUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PoiPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Poi.
     * @param {PoiUpsertArgs} args - Arguments to update or create a Poi.
     * @example
     * // Update or create a Poi
     * const poi = await prisma.poi.upsert({
     *   create: {
     *     // ... data to create a Poi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Poi we want to update
     *   }
     * })
     */
    upsert<T extends PoiUpsertArgs>(args: SelectSubset<T, PoiUpsertArgs<ExtArgs>>): Prisma__PoiClient<$Result.GetResult<Prisma.$PoiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoiCountArgs} args - Arguments to filter Pois to count.
     * @example
     * // Count the number of Pois
     * const count = await prisma.poi.count({
     *   where: {
     *     // ... the filter for the Pois we want to count
     *   }
     * })
    **/
    count<T extends PoiCountArgs>(
      args?: Subset<T, PoiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PoiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Poi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PoiAggregateArgs>(args: Subset<T, PoiAggregateArgs>): Prisma.PrismaPromise<GetPoiAggregateType<T>>

    /**
     * Group by Poi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PoiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PoiGroupByArgs['orderBy'] }
        : { orderBy?: PoiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PoiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPoiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Poi model
   */
  readonly fields: PoiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Poi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PoiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    propertyDistances<T extends Poi$propertyDistancesArgs<ExtArgs> = {}>(args?: Subset<T, Poi$propertyDistancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPoiDistancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Poi model
   */
  interface PoiFieldRefs {
    readonly id: FieldRef<"Poi", 'String'>
    readonly externalId: FieldRef<"Poi", 'String'>
    readonly source: FieldRef<"Poi", 'PoiSource'>
    readonly name: FieldRef<"Poi", 'String'>
    readonly nameTh: FieldRef<"Poi", 'String'>
    readonly nameLocal: FieldRef<"Poi", 'String'>
    readonly category: FieldRef<"Poi", 'PoiCategory'>
    readonly subCategory: FieldRef<"Poi", 'String'>
    readonly latitude: FieldRef<"Poi", 'Float'>
    readonly longitude: FieldRef<"Poi", 'Float'>
    readonly address: FieldRef<"Poi", 'String'>
    readonly district: FieldRef<"Poi", 'String'>
    readonly osmTags: FieldRef<"Poi", 'Json'>
    readonly importance: FieldRef<"Poi", 'Int'>
    readonly isVerified: FieldRef<"Poi", 'Boolean'>
    readonly isActive: FieldRef<"Poi", 'Boolean'>
    readonly noiseLevel: FieldRef<"Poi", 'NoiseLevel'>
    readonly trafficLevel: FieldRef<"Poi", 'TrafficLevel'>
    readonly lastSyncedAt: FieldRef<"Poi", 'DateTime'>
    readonly syncError: FieldRef<"Poi", 'String'>
    readonly createdAt: FieldRef<"Poi", 'DateTime'>
    readonly updatedAt: FieldRef<"Poi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Poi findUnique
   */
  export type PoiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poi
     */
    select?: PoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Poi
     */
    omit?: PoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoiInclude<ExtArgs> | null
    /**
     * Filter, which Poi to fetch.
     */
    where: PoiWhereUniqueInput
  }

  /**
   * Poi findUniqueOrThrow
   */
  export type PoiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poi
     */
    select?: PoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Poi
     */
    omit?: PoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoiInclude<ExtArgs> | null
    /**
     * Filter, which Poi to fetch.
     */
    where: PoiWhereUniqueInput
  }

  /**
   * Poi findFirst
   */
  export type PoiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poi
     */
    select?: PoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Poi
     */
    omit?: PoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoiInclude<ExtArgs> | null
    /**
     * Filter, which Poi to fetch.
     */
    where?: PoiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pois to fetch.
     */
    orderBy?: PoiOrderByWithRelationInput | PoiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pois.
     */
    cursor?: PoiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pois.
     */
    distinct?: PoiScalarFieldEnum | PoiScalarFieldEnum[]
  }

  /**
   * Poi findFirstOrThrow
   */
  export type PoiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poi
     */
    select?: PoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Poi
     */
    omit?: PoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoiInclude<ExtArgs> | null
    /**
     * Filter, which Poi to fetch.
     */
    where?: PoiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pois to fetch.
     */
    orderBy?: PoiOrderByWithRelationInput | PoiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pois.
     */
    cursor?: PoiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pois.
     */
    distinct?: PoiScalarFieldEnum | PoiScalarFieldEnum[]
  }

  /**
   * Poi findMany
   */
  export type PoiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poi
     */
    select?: PoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Poi
     */
    omit?: PoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoiInclude<ExtArgs> | null
    /**
     * Filter, which Pois to fetch.
     */
    where?: PoiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pois to fetch.
     */
    orderBy?: PoiOrderByWithRelationInput | PoiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pois.
     */
    cursor?: PoiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pois.
     */
    skip?: number
    distinct?: PoiScalarFieldEnum | PoiScalarFieldEnum[]
  }

  /**
   * Poi create
   */
  export type PoiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poi
     */
    select?: PoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Poi
     */
    omit?: PoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoiInclude<ExtArgs> | null
    /**
     * The data needed to create a Poi.
     */
    data: XOR<PoiCreateInput, PoiUncheckedCreateInput>
  }

  /**
   * Poi createMany
   */
  export type PoiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pois.
     */
    data: PoiCreateManyInput | PoiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Poi createManyAndReturn
   */
  export type PoiCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poi
     */
    select?: PoiSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Poi
     */
    omit?: PoiOmit<ExtArgs> | null
    /**
     * The data used to create many Pois.
     */
    data: PoiCreateManyInput | PoiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Poi update
   */
  export type PoiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poi
     */
    select?: PoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Poi
     */
    omit?: PoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoiInclude<ExtArgs> | null
    /**
     * The data needed to update a Poi.
     */
    data: XOR<PoiUpdateInput, PoiUncheckedUpdateInput>
    /**
     * Choose, which Poi to update.
     */
    where: PoiWhereUniqueInput
  }

  /**
   * Poi updateMany
   */
  export type PoiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pois.
     */
    data: XOR<PoiUpdateManyMutationInput, PoiUncheckedUpdateManyInput>
    /**
     * Filter which Pois to update
     */
    where?: PoiWhereInput
    /**
     * Limit how many Pois to update.
     */
    limit?: number
  }

  /**
   * Poi updateManyAndReturn
   */
  export type PoiUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poi
     */
    select?: PoiSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Poi
     */
    omit?: PoiOmit<ExtArgs> | null
    /**
     * The data used to update Pois.
     */
    data: XOR<PoiUpdateManyMutationInput, PoiUncheckedUpdateManyInput>
    /**
     * Filter which Pois to update
     */
    where?: PoiWhereInput
    /**
     * Limit how many Pois to update.
     */
    limit?: number
  }

  /**
   * Poi upsert
   */
  export type PoiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poi
     */
    select?: PoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Poi
     */
    omit?: PoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoiInclude<ExtArgs> | null
    /**
     * The filter to search for the Poi to update in case it exists.
     */
    where: PoiWhereUniqueInput
    /**
     * In case the Poi found by the `where` argument doesn't exist, create a new Poi with this data.
     */
    create: XOR<PoiCreateInput, PoiUncheckedCreateInput>
    /**
     * In case the Poi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PoiUpdateInput, PoiUncheckedUpdateInput>
  }

  /**
   * Poi delete
   */
  export type PoiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poi
     */
    select?: PoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Poi
     */
    omit?: PoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoiInclude<ExtArgs> | null
    /**
     * Filter which Poi to delete.
     */
    where: PoiWhereUniqueInput
  }

  /**
   * Poi deleteMany
   */
  export type PoiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pois to delete
     */
    where?: PoiWhereInput
    /**
     * Limit how many Pois to delete.
     */
    limit?: number
  }

  /**
   * Poi.propertyDistances
   */
  export type Poi$propertyDistancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPoiDistance
     */
    select?: PropertyPoiDistanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPoiDistance
     */
    omit?: PropertyPoiDistanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPoiDistanceInclude<ExtArgs> | null
    where?: PropertyPoiDistanceWhereInput
    orderBy?: PropertyPoiDistanceOrderByWithRelationInput | PropertyPoiDistanceOrderByWithRelationInput[]
    cursor?: PropertyPoiDistanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyPoiDistanceScalarFieldEnum | PropertyPoiDistanceScalarFieldEnum[]
  }

  /**
   * Poi without action
   */
  export type PoiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Poi
     */
    select?: PoiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Poi
     */
    omit?: PoiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PoiInclude<ExtArgs> | null
  }


  /**
   * Model PropertyPoiDistance
   */

  export type AggregatePropertyPoiDistance = {
    _count: PropertyPoiDistanceCountAggregateOutputType | null
    _avg: PropertyPoiDistanceAvgAggregateOutputType | null
    _sum: PropertyPoiDistanceSumAggregateOutputType | null
    _min: PropertyPoiDistanceMinAggregateOutputType | null
    _max: PropertyPoiDistanceMaxAggregateOutputType | null
  }

  export type PropertyPoiDistanceAvgAggregateOutputType = {
    distanceMeters: number | null
    walkingMinutes: number | null
    drivingMinutes: number | null
  }

  export type PropertyPoiDistanceSumAggregateOutputType = {
    distanceMeters: number | null
    walkingMinutes: number | null
    drivingMinutes: number | null
  }

  export type PropertyPoiDistanceMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    poiId: string | null
    distanceMeters: number | null
    walkingMinutes: number | null
    drivingMinutes: number | null
    isHighlight: boolean | null
    calculatedAt: Date | null
  }

  export type PropertyPoiDistanceMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    poiId: string | null
    distanceMeters: number | null
    walkingMinutes: number | null
    drivingMinutes: number | null
    isHighlight: boolean | null
    calculatedAt: Date | null
  }

  export type PropertyPoiDistanceCountAggregateOutputType = {
    id: number
    propertyId: number
    poiId: number
    distanceMeters: number
    walkingMinutes: number
    drivingMinutes: number
    isHighlight: number
    calculatedAt: number
    _all: number
  }


  export type PropertyPoiDistanceAvgAggregateInputType = {
    distanceMeters?: true
    walkingMinutes?: true
    drivingMinutes?: true
  }

  export type PropertyPoiDistanceSumAggregateInputType = {
    distanceMeters?: true
    walkingMinutes?: true
    drivingMinutes?: true
  }

  export type PropertyPoiDistanceMinAggregateInputType = {
    id?: true
    propertyId?: true
    poiId?: true
    distanceMeters?: true
    walkingMinutes?: true
    drivingMinutes?: true
    isHighlight?: true
    calculatedAt?: true
  }

  export type PropertyPoiDistanceMaxAggregateInputType = {
    id?: true
    propertyId?: true
    poiId?: true
    distanceMeters?: true
    walkingMinutes?: true
    drivingMinutes?: true
    isHighlight?: true
    calculatedAt?: true
  }

  export type PropertyPoiDistanceCountAggregateInputType = {
    id?: true
    propertyId?: true
    poiId?: true
    distanceMeters?: true
    walkingMinutes?: true
    drivingMinutes?: true
    isHighlight?: true
    calculatedAt?: true
    _all?: true
  }

  export type PropertyPoiDistanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyPoiDistance to aggregate.
     */
    where?: PropertyPoiDistanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyPoiDistances to fetch.
     */
    orderBy?: PropertyPoiDistanceOrderByWithRelationInput | PropertyPoiDistanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyPoiDistanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyPoiDistances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyPoiDistances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyPoiDistances
    **/
    _count?: true | PropertyPoiDistanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyPoiDistanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyPoiDistanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyPoiDistanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyPoiDistanceMaxAggregateInputType
  }

  export type GetPropertyPoiDistanceAggregateType<T extends PropertyPoiDistanceAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyPoiDistance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyPoiDistance[P]>
      : GetScalarType<T[P], AggregatePropertyPoiDistance[P]>
  }




  export type PropertyPoiDistanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyPoiDistanceWhereInput
    orderBy?: PropertyPoiDistanceOrderByWithAggregationInput | PropertyPoiDistanceOrderByWithAggregationInput[]
    by: PropertyPoiDistanceScalarFieldEnum[] | PropertyPoiDistanceScalarFieldEnum
    having?: PropertyPoiDistanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyPoiDistanceCountAggregateInputType | true
    _avg?: PropertyPoiDistanceAvgAggregateInputType
    _sum?: PropertyPoiDistanceSumAggregateInputType
    _min?: PropertyPoiDistanceMinAggregateInputType
    _max?: PropertyPoiDistanceMaxAggregateInputType
  }

  export type PropertyPoiDistanceGroupByOutputType = {
    id: string
    propertyId: string
    poiId: string
    distanceMeters: number
    walkingMinutes: number | null
    drivingMinutes: number | null
    isHighlight: boolean
    calculatedAt: Date
    _count: PropertyPoiDistanceCountAggregateOutputType | null
    _avg: PropertyPoiDistanceAvgAggregateOutputType | null
    _sum: PropertyPoiDistanceSumAggregateOutputType | null
    _min: PropertyPoiDistanceMinAggregateOutputType | null
    _max: PropertyPoiDistanceMaxAggregateOutputType | null
  }

  type GetPropertyPoiDistanceGroupByPayload<T extends PropertyPoiDistanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyPoiDistanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyPoiDistanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyPoiDistanceGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyPoiDistanceGroupByOutputType[P]>
        }
      >
    >


  export type PropertyPoiDistanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    poiId?: boolean
    distanceMeters?: boolean
    walkingMinutes?: boolean
    drivingMinutes?: boolean
    isHighlight?: boolean
    calculatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    poi?: boolean | PoiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyPoiDistance"]>

  export type PropertyPoiDistanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    poiId?: boolean
    distanceMeters?: boolean
    walkingMinutes?: boolean
    drivingMinutes?: boolean
    isHighlight?: boolean
    calculatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    poi?: boolean | PoiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyPoiDistance"]>

  export type PropertyPoiDistanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    poiId?: boolean
    distanceMeters?: boolean
    walkingMinutes?: boolean
    drivingMinutes?: boolean
    isHighlight?: boolean
    calculatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    poi?: boolean | PoiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyPoiDistance"]>

  export type PropertyPoiDistanceSelectScalar = {
    id?: boolean
    propertyId?: boolean
    poiId?: boolean
    distanceMeters?: boolean
    walkingMinutes?: boolean
    drivingMinutes?: boolean
    isHighlight?: boolean
    calculatedAt?: boolean
  }

  export type PropertyPoiDistanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "poiId" | "distanceMeters" | "walkingMinutes" | "drivingMinutes" | "isHighlight" | "calculatedAt", ExtArgs["result"]["propertyPoiDistance"]>
  export type PropertyPoiDistanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    poi?: boolean | PoiDefaultArgs<ExtArgs>
  }
  export type PropertyPoiDistanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    poi?: boolean | PoiDefaultArgs<ExtArgs>
  }
  export type PropertyPoiDistanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    poi?: boolean | PoiDefaultArgs<ExtArgs>
  }

  export type $PropertyPoiDistancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyPoiDistance"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      poi: Prisma.$PoiPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      poiId: string
      distanceMeters: number
      walkingMinutes: number | null
      drivingMinutes: number | null
      isHighlight: boolean
      calculatedAt: Date
    }, ExtArgs["result"]["propertyPoiDistance"]>
    composites: {}
  }

  type PropertyPoiDistanceGetPayload<S extends boolean | null | undefined | PropertyPoiDistanceDefaultArgs> = $Result.GetResult<Prisma.$PropertyPoiDistancePayload, S>

  type PropertyPoiDistanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyPoiDistanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyPoiDistanceCountAggregateInputType | true
    }

  export interface PropertyPoiDistanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyPoiDistance'], meta: { name: 'PropertyPoiDistance' } }
    /**
     * Find zero or one PropertyPoiDistance that matches the filter.
     * @param {PropertyPoiDistanceFindUniqueArgs} args - Arguments to find a PropertyPoiDistance
     * @example
     * // Get one PropertyPoiDistance
     * const propertyPoiDistance = await prisma.propertyPoiDistance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyPoiDistanceFindUniqueArgs>(args: SelectSubset<T, PropertyPoiDistanceFindUniqueArgs<ExtArgs>>): Prisma__PropertyPoiDistanceClient<$Result.GetResult<Prisma.$PropertyPoiDistancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyPoiDistance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyPoiDistanceFindUniqueOrThrowArgs} args - Arguments to find a PropertyPoiDistance
     * @example
     * // Get one PropertyPoiDistance
     * const propertyPoiDistance = await prisma.propertyPoiDistance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyPoiDistanceFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyPoiDistanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyPoiDistanceClient<$Result.GetResult<Prisma.$PropertyPoiDistancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyPoiDistance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPoiDistanceFindFirstArgs} args - Arguments to find a PropertyPoiDistance
     * @example
     * // Get one PropertyPoiDistance
     * const propertyPoiDistance = await prisma.propertyPoiDistance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyPoiDistanceFindFirstArgs>(args?: SelectSubset<T, PropertyPoiDistanceFindFirstArgs<ExtArgs>>): Prisma__PropertyPoiDistanceClient<$Result.GetResult<Prisma.$PropertyPoiDistancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyPoiDistance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPoiDistanceFindFirstOrThrowArgs} args - Arguments to find a PropertyPoiDistance
     * @example
     * // Get one PropertyPoiDistance
     * const propertyPoiDistance = await prisma.propertyPoiDistance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyPoiDistanceFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyPoiDistanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyPoiDistanceClient<$Result.GetResult<Prisma.$PropertyPoiDistancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyPoiDistances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPoiDistanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyPoiDistances
     * const propertyPoiDistances = await prisma.propertyPoiDistance.findMany()
     * 
     * // Get first 10 PropertyPoiDistances
     * const propertyPoiDistances = await prisma.propertyPoiDistance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyPoiDistanceWithIdOnly = await prisma.propertyPoiDistance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyPoiDistanceFindManyArgs>(args?: SelectSubset<T, PropertyPoiDistanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPoiDistancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyPoiDistance.
     * @param {PropertyPoiDistanceCreateArgs} args - Arguments to create a PropertyPoiDistance.
     * @example
     * // Create one PropertyPoiDistance
     * const PropertyPoiDistance = await prisma.propertyPoiDistance.create({
     *   data: {
     *     // ... data to create a PropertyPoiDistance
     *   }
     * })
     * 
     */
    create<T extends PropertyPoiDistanceCreateArgs>(args: SelectSubset<T, PropertyPoiDistanceCreateArgs<ExtArgs>>): Prisma__PropertyPoiDistanceClient<$Result.GetResult<Prisma.$PropertyPoiDistancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyPoiDistances.
     * @param {PropertyPoiDistanceCreateManyArgs} args - Arguments to create many PropertyPoiDistances.
     * @example
     * // Create many PropertyPoiDistances
     * const propertyPoiDistance = await prisma.propertyPoiDistance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyPoiDistanceCreateManyArgs>(args?: SelectSubset<T, PropertyPoiDistanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyPoiDistances and returns the data saved in the database.
     * @param {PropertyPoiDistanceCreateManyAndReturnArgs} args - Arguments to create many PropertyPoiDistances.
     * @example
     * // Create many PropertyPoiDistances
     * const propertyPoiDistance = await prisma.propertyPoiDistance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyPoiDistances and only return the `id`
     * const propertyPoiDistanceWithIdOnly = await prisma.propertyPoiDistance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyPoiDistanceCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyPoiDistanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPoiDistancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyPoiDistance.
     * @param {PropertyPoiDistanceDeleteArgs} args - Arguments to delete one PropertyPoiDistance.
     * @example
     * // Delete one PropertyPoiDistance
     * const PropertyPoiDistance = await prisma.propertyPoiDistance.delete({
     *   where: {
     *     // ... filter to delete one PropertyPoiDistance
     *   }
     * })
     * 
     */
    delete<T extends PropertyPoiDistanceDeleteArgs>(args: SelectSubset<T, PropertyPoiDistanceDeleteArgs<ExtArgs>>): Prisma__PropertyPoiDistanceClient<$Result.GetResult<Prisma.$PropertyPoiDistancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyPoiDistance.
     * @param {PropertyPoiDistanceUpdateArgs} args - Arguments to update one PropertyPoiDistance.
     * @example
     * // Update one PropertyPoiDistance
     * const propertyPoiDistance = await prisma.propertyPoiDistance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyPoiDistanceUpdateArgs>(args: SelectSubset<T, PropertyPoiDistanceUpdateArgs<ExtArgs>>): Prisma__PropertyPoiDistanceClient<$Result.GetResult<Prisma.$PropertyPoiDistancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyPoiDistances.
     * @param {PropertyPoiDistanceDeleteManyArgs} args - Arguments to filter PropertyPoiDistances to delete.
     * @example
     * // Delete a few PropertyPoiDistances
     * const { count } = await prisma.propertyPoiDistance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyPoiDistanceDeleteManyArgs>(args?: SelectSubset<T, PropertyPoiDistanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyPoiDistances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPoiDistanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyPoiDistances
     * const propertyPoiDistance = await prisma.propertyPoiDistance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyPoiDistanceUpdateManyArgs>(args: SelectSubset<T, PropertyPoiDistanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyPoiDistances and returns the data updated in the database.
     * @param {PropertyPoiDistanceUpdateManyAndReturnArgs} args - Arguments to update many PropertyPoiDistances.
     * @example
     * // Update many PropertyPoiDistances
     * const propertyPoiDistance = await prisma.propertyPoiDistance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyPoiDistances and only return the `id`
     * const propertyPoiDistanceWithIdOnly = await prisma.propertyPoiDistance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyPoiDistanceUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyPoiDistanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPoiDistancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyPoiDistance.
     * @param {PropertyPoiDistanceUpsertArgs} args - Arguments to update or create a PropertyPoiDistance.
     * @example
     * // Update or create a PropertyPoiDistance
     * const propertyPoiDistance = await prisma.propertyPoiDistance.upsert({
     *   create: {
     *     // ... data to create a PropertyPoiDistance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyPoiDistance we want to update
     *   }
     * })
     */
    upsert<T extends PropertyPoiDistanceUpsertArgs>(args: SelectSubset<T, PropertyPoiDistanceUpsertArgs<ExtArgs>>): Prisma__PropertyPoiDistanceClient<$Result.GetResult<Prisma.$PropertyPoiDistancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyPoiDistances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPoiDistanceCountArgs} args - Arguments to filter PropertyPoiDistances to count.
     * @example
     * // Count the number of PropertyPoiDistances
     * const count = await prisma.propertyPoiDistance.count({
     *   where: {
     *     // ... the filter for the PropertyPoiDistances we want to count
     *   }
     * })
    **/
    count<T extends PropertyPoiDistanceCountArgs>(
      args?: Subset<T, PropertyPoiDistanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyPoiDistanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyPoiDistance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPoiDistanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyPoiDistanceAggregateArgs>(args: Subset<T, PropertyPoiDistanceAggregateArgs>): Prisma.PrismaPromise<GetPropertyPoiDistanceAggregateType<T>>

    /**
     * Group by PropertyPoiDistance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyPoiDistanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyPoiDistanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyPoiDistanceGroupByArgs['orderBy'] }
        : { orderBy?: PropertyPoiDistanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyPoiDistanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyPoiDistanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyPoiDistance model
   */
  readonly fields: PropertyPoiDistanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyPoiDistance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyPoiDistanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    poi<T extends PoiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PoiDefaultArgs<ExtArgs>>): Prisma__PoiClient<$Result.GetResult<Prisma.$PoiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyPoiDistance model
   */
  interface PropertyPoiDistanceFieldRefs {
    readonly id: FieldRef<"PropertyPoiDistance", 'String'>
    readonly propertyId: FieldRef<"PropertyPoiDistance", 'String'>
    readonly poiId: FieldRef<"PropertyPoiDistance", 'String'>
    readonly distanceMeters: FieldRef<"PropertyPoiDistance", 'Int'>
    readonly walkingMinutes: FieldRef<"PropertyPoiDistance", 'Int'>
    readonly drivingMinutes: FieldRef<"PropertyPoiDistance", 'Int'>
    readonly isHighlight: FieldRef<"PropertyPoiDistance", 'Boolean'>
    readonly calculatedAt: FieldRef<"PropertyPoiDistance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyPoiDistance findUnique
   */
  export type PropertyPoiDistanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPoiDistance
     */
    select?: PropertyPoiDistanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPoiDistance
     */
    omit?: PropertyPoiDistanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPoiDistanceInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPoiDistance to fetch.
     */
    where: PropertyPoiDistanceWhereUniqueInput
  }

  /**
   * PropertyPoiDistance findUniqueOrThrow
   */
  export type PropertyPoiDistanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPoiDistance
     */
    select?: PropertyPoiDistanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPoiDistance
     */
    omit?: PropertyPoiDistanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPoiDistanceInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPoiDistance to fetch.
     */
    where: PropertyPoiDistanceWhereUniqueInput
  }

  /**
   * PropertyPoiDistance findFirst
   */
  export type PropertyPoiDistanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPoiDistance
     */
    select?: PropertyPoiDistanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPoiDistance
     */
    omit?: PropertyPoiDistanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPoiDistanceInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPoiDistance to fetch.
     */
    where?: PropertyPoiDistanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyPoiDistances to fetch.
     */
    orderBy?: PropertyPoiDistanceOrderByWithRelationInput | PropertyPoiDistanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyPoiDistances.
     */
    cursor?: PropertyPoiDistanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyPoiDistances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyPoiDistances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyPoiDistances.
     */
    distinct?: PropertyPoiDistanceScalarFieldEnum | PropertyPoiDistanceScalarFieldEnum[]
  }

  /**
   * PropertyPoiDistance findFirstOrThrow
   */
  export type PropertyPoiDistanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPoiDistance
     */
    select?: PropertyPoiDistanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPoiDistance
     */
    omit?: PropertyPoiDistanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPoiDistanceInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPoiDistance to fetch.
     */
    where?: PropertyPoiDistanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyPoiDistances to fetch.
     */
    orderBy?: PropertyPoiDistanceOrderByWithRelationInput | PropertyPoiDistanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyPoiDistances.
     */
    cursor?: PropertyPoiDistanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyPoiDistances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyPoiDistances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyPoiDistances.
     */
    distinct?: PropertyPoiDistanceScalarFieldEnum | PropertyPoiDistanceScalarFieldEnum[]
  }

  /**
   * PropertyPoiDistance findMany
   */
  export type PropertyPoiDistanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPoiDistance
     */
    select?: PropertyPoiDistanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPoiDistance
     */
    omit?: PropertyPoiDistanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPoiDistanceInclude<ExtArgs> | null
    /**
     * Filter, which PropertyPoiDistances to fetch.
     */
    where?: PropertyPoiDistanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyPoiDistances to fetch.
     */
    orderBy?: PropertyPoiDistanceOrderByWithRelationInput | PropertyPoiDistanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyPoiDistances.
     */
    cursor?: PropertyPoiDistanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyPoiDistances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyPoiDistances.
     */
    skip?: number
    distinct?: PropertyPoiDistanceScalarFieldEnum | PropertyPoiDistanceScalarFieldEnum[]
  }

  /**
   * PropertyPoiDistance create
   */
  export type PropertyPoiDistanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPoiDistance
     */
    select?: PropertyPoiDistanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPoiDistance
     */
    omit?: PropertyPoiDistanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPoiDistanceInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyPoiDistance.
     */
    data: XOR<PropertyPoiDistanceCreateInput, PropertyPoiDistanceUncheckedCreateInput>
  }

  /**
   * PropertyPoiDistance createMany
   */
  export type PropertyPoiDistanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyPoiDistances.
     */
    data: PropertyPoiDistanceCreateManyInput | PropertyPoiDistanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyPoiDistance createManyAndReturn
   */
  export type PropertyPoiDistanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPoiDistance
     */
    select?: PropertyPoiDistanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPoiDistance
     */
    omit?: PropertyPoiDistanceOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyPoiDistances.
     */
    data: PropertyPoiDistanceCreateManyInput | PropertyPoiDistanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPoiDistanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyPoiDistance update
   */
  export type PropertyPoiDistanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPoiDistance
     */
    select?: PropertyPoiDistanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPoiDistance
     */
    omit?: PropertyPoiDistanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPoiDistanceInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyPoiDistance.
     */
    data: XOR<PropertyPoiDistanceUpdateInput, PropertyPoiDistanceUncheckedUpdateInput>
    /**
     * Choose, which PropertyPoiDistance to update.
     */
    where: PropertyPoiDistanceWhereUniqueInput
  }

  /**
   * PropertyPoiDistance updateMany
   */
  export type PropertyPoiDistanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyPoiDistances.
     */
    data: XOR<PropertyPoiDistanceUpdateManyMutationInput, PropertyPoiDistanceUncheckedUpdateManyInput>
    /**
     * Filter which PropertyPoiDistances to update
     */
    where?: PropertyPoiDistanceWhereInput
    /**
     * Limit how many PropertyPoiDistances to update.
     */
    limit?: number
  }

  /**
   * PropertyPoiDistance updateManyAndReturn
   */
  export type PropertyPoiDistanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPoiDistance
     */
    select?: PropertyPoiDistanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPoiDistance
     */
    omit?: PropertyPoiDistanceOmit<ExtArgs> | null
    /**
     * The data used to update PropertyPoiDistances.
     */
    data: XOR<PropertyPoiDistanceUpdateManyMutationInput, PropertyPoiDistanceUncheckedUpdateManyInput>
    /**
     * Filter which PropertyPoiDistances to update
     */
    where?: PropertyPoiDistanceWhereInput
    /**
     * Limit how many PropertyPoiDistances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPoiDistanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyPoiDistance upsert
   */
  export type PropertyPoiDistanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPoiDistance
     */
    select?: PropertyPoiDistanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPoiDistance
     */
    omit?: PropertyPoiDistanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPoiDistanceInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyPoiDistance to update in case it exists.
     */
    where: PropertyPoiDistanceWhereUniqueInput
    /**
     * In case the PropertyPoiDistance found by the `where` argument doesn't exist, create a new PropertyPoiDistance with this data.
     */
    create: XOR<PropertyPoiDistanceCreateInput, PropertyPoiDistanceUncheckedCreateInput>
    /**
     * In case the PropertyPoiDistance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyPoiDistanceUpdateInput, PropertyPoiDistanceUncheckedUpdateInput>
  }

  /**
   * PropertyPoiDistance delete
   */
  export type PropertyPoiDistanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPoiDistance
     */
    select?: PropertyPoiDistanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPoiDistance
     */
    omit?: PropertyPoiDistanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPoiDistanceInclude<ExtArgs> | null
    /**
     * Filter which PropertyPoiDistance to delete.
     */
    where: PropertyPoiDistanceWhereUniqueInput
  }

  /**
   * PropertyPoiDistance deleteMany
   */
  export type PropertyPoiDistanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyPoiDistances to delete
     */
    where?: PropertyPoiDistanceWhereInput
    /**
     * Limit how many PropertyPoiDistances to delete.
     */
    limit?: number
  }

  /**
   * PropertyPoiDistance without action
   */
  export type PropertyPoiDistanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyPoiDistance
     */
    select?: PropertyPoiDistanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyPoiDistance
     */
    omit?: PropertyPoiDistanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyPoiDistanceInclude<ExtArgs> | null
  }


  /**
   * Model PoiSyncJob
   */

  export type AggregatePoiSyncJob = {
    _count: PoiSyncJobCountAggregateOutputType | null
    _avg: PoiSyncJobAvgAggregateOutputType | null
    _sum: PoiSyncJobSumAggregateOutputType | null
    _min: PoiSyncJobMinAggregateOutputType | null
    _max: PoiSyncJobMaxAggregateOutputType | null
  }

  export type PoiSyncJobAvgAggregateOutputType = {
    poisFetched: number | null
    poisCreated: number | null
    poisUpdated: number | null
    poisSkipped: number | null
  }

  export type PoiSyncJobSumAggregateOutputType = {
    poisFetched: number | null
    poisCreated: number | null
    poisUpdated: number | null
    poisSkipped: number | null
  }

  export type PoiSyncJobMinAggregateOutputType = {
    id: string | null
    jobType: $Enums.PoiSyncJobType | null
    status: $Enums.PoiSyncJobStatus | null
    category: $Enums.PoiCategory | null
    district: string | null
    poisFetched: number | null
    poisCreated: number | null
    poisUpdated: number | null
    poisSkipped: number | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    errorStack: string | null
    createdAt: Date | null
  }

  export type PoiSyncJobMaxAggregateOutputType = {
    id: string | null
    jobType: $Enums.PoiSyncJobType | null
    status: $Enums.PoiSyncJobStatus | null
    category: $Enums.PoiCategory | null
    district: string | null
    poisFetched: number | null
    poisCreated: number | null
    poisUpdated: number | null
    poisSkipped: number | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    errorStack: string | null
    createdAt: Date | null
  }

  export type PoiSyncJobCountAggregateOutputType = {
    id: number
    jobType: number
    status: number
    category: number
    district: number
    poisFetched: number
    poisCreated: number
    poisUpdated: number
    poisSkipped: number
    startedAt: number
    completedAt: number
    errorMessage: number
    errorStack: number
    createdAt: number
    _all: number
  }


  export type PoiSyncJobAvgAggregateInputType = {
    poisFetched?: true
    poisCreated?: true
    poisUpdated?: true
    poisSkipped?: true
  }

  export type PoiSyncJobSumAggregateInputType = {
    poisFetched?: true
    poisCreated?: true
    poisUpdated?: true
    poisSkipped?: true
  }

  export type PoiSyncJobMinAggregateInputType = {
    id?: true
    jobType?: true
    status?: true
    category?: true
    district?: true
    poisFetched?: true
    poisCreated?: true
    poisUpdated?: true
    poisSkipped?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    errorStack?: true
    createdAt?: true
  }

  export type PoiSyncJobMaxAggregateInputType = {
    id?: true
    jobType?: true
    status?: true
    category?: true
    district?: true
    poisFetched?: true
    poisCreated?: true
    poisUpdated?: true
    poisSkipped?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    errorStack?: true
    createdAt?: true
  }

  export type PoiSyncJobCountAggregateInputType = {
    id?: true
    jobType?: true
    status?: true
    category?: true
    district?: true
    poisFetched?: true
    poisCreated?: true
    poisUpdated?: true
    poisSkipped?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    errorStack?: true
    createdAt?: true
    _all?: true
  }

  export type PoiSyncJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PoiSyncJob to aggregate.
     */
    where?: PoiSyncJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PoiSyncJobs to fetch.
     */
    orderBy?: PoiSyncJobOrderByWithRelationInput | PoiSyncJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PoiSyncJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PoiSyncJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PoiSyncJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PoiSyncJobs
    **/
    _count?: true | PoiSyncJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PoiSyncJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PoiSyncJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PoiSyncJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PoiSyncJobMaxAggregateInputType
  }

  export type GetPoiSyncJobAggregateType<T extends PoiSyncJobAggregateArgs> = {
        [P in keyof T & keyof AggregatePoiSyncJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePoiSyncJob[P]>
      : GetScalarType<T[P], AggregatePoiSyncJob[P]>
  }




  export type PoiSyncJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PoiSyncJobWhereInput
    orderBy?: PoiSyncJobOrderByWithAggregationInput | PoiSyncJobOrderByWithAggregationInput[]
    by: PoiSyncJobScalarFieldEnum[] | PoiSyncJobScalarFieldEnum
    having?: PoiSyncJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PoiSyncJobCountAggregateInputType | true
    _avg?: PoiSyncJobAvgAggregateInputType
    _sum?: PoiSyncJobSumAggregateInputType
    _min?: PoiSyncJobMinAggregateInputType
    _max?: PoiSyncJobMaxAggregateInputType
  }

  export type PoiSyncJobGroupByOutputType = {
    id: string
    jobType: $Enums.PoiSyncJobType
    status: $Enums.PoiSyncJobStatus
    category: $Enums.PoiCategory | null
    district: string | null
    poisFetched: number
    poisCreated: number
    poisUpdated: number
    poisSkipped: number
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    errorStack: string | null
    createdAt: Date
    _count: PoiSyncJobCountAggregateOutputType | null
    _avg: PoiSyncJobAvgAggregateOutputType | null
    _sum: PoiSyncJobSumAggregateOutputType | null
    _min: PoiSyncJobMinAggregateOutputType | null
    _max: PoiSyncJobMaxAggregateOutputType | null
  }

  type GetPoiSyncJobGroupByPayload<T extends PoiSyncJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PoiSyncJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PoiSyncJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PoiSyncJobGroupByOutputType[P]>
            : GetScalarType<T[P], PoiSyncJobGroupByOutputType[P]>
        }
      >
    >


  export type PoiSyncJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobType?: boolean
    status?: boolean
    category?: boolean
    district?: boolean
    poisFetched?: boolean
    poisCreated?: boolean
    poisUpdated?: boolean
    poisSkipped?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    errorStack?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["poiSyncJob"]>

  export type PoiSyncJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobType?: boolean
    status?: boolean
    category?: boolean
    district?: boolean
    poisFetched?: boolean
    poisCreated?: boolean
    poisUpdated?: boolean
    poisSkipped?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    errorStack?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["poiSyncJob"]>

  export type PoiSyncJobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobType?: boolean
    status?: boolean
    category?: boolean
    district?: boolean
    poisFetched?: boolean
    poisCreated?: boolean
    poisUpdated?: boolean
    poisSkipped?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    errorStack?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["poiSyncJob"]>

  export type PoiSyncJobSelectScalar = {
    id?: boolean
    jobType?: boolean
    status?: boolean
    category?: boolean
    district?: boolean
    poisFetched?: boolean
    poisCreated?: boolean
    poisUpdated?: boolean
    poisSkipped?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    errorStack?: boolean
    createdAt?: boolean
  }

  export type PoiSyncJobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobType" | "status" | "category" | "district" | "poisFetched" | "poisCreated" | "poisUpdated" | "poisSkipped" | "startedAt" | "completedAt" | "errorMessage" | "errorStack" | "createdAt", ExtArgs["result"]["poiSyncJob"]>

  export type $PoiSyncJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PoiSyncJob"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobType: $Enums.PoiSyncJobType
      status: $Enums.PoiSyncJobStatus
      category: $Enums.PoiCategory | null
      district: string | null
      poisFetched: number
      poisCreated: number
      poisUpdated: number
      poisSkipped: number
      startedAt: Date | null
      completedAt: Date | null
      errorMessage: string | null
      errorStack: string | null
      createdAt: Date
    }, ExtArgs["result"]["poiSyncJob"]>
    composites: {}
  }

  type PoiSyncJobGetPayload<S extends boolean | null | undefined | PoiSyncJobDefaultArgs> = $Result.GetResult<Prisma.$PoiSyncJobPayload, S>

  type PoiSyncJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PoiSyncJobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PoiSyncJobCountAggregateInputType | true
    }

  export interface PoiSyncJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PoiSyncJob'], meta: { name: 'PoiSyncJob' } }
    /**
     * Find zero or one PoiSyncJob that matches the filter.
     * @param {PoiSyncJobFindUniqueArgs} args - Arguments to find a PoiSyncJob
     * @example
     * // Get one PoiSyncJob
     * const poiSyncJob = await prisma.poiSyncJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PoiSyncJobFindUniqueArgs>(args: SelectSubset<T, PoiSyncJobFindUniqueArgs<ExtArgs>>): Prisma__PoiSyncJobClient<$Result.GetResult<Prisma.$PoiSyncJobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PoiSyncJob that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PoiSyncJobFindUniqueOrThrowArgs} args - Arguments to find a PoiSyncJob
     * @example
     * // Get one PoiSyncJob
     * const poiSyncJob = await prisma.poiSyncJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PoiSyncJobFindUniqueOrThrowArgs>(args: SelectSubset<T, PoiSyncJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PoiSyncJobClient<$Result.GetResult<Prisma.$PoiSyncJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PoiSyncJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoiSyncJobFindFirstArgs} args - Arguments to find a PoiSyncJob
     * @example
     * // Get one PoiSyncJob
     * const poiSyncJob = await prisma.poiSyncJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PoiSyncJobFindFirstArgs>(args?: SelectSubset<T, PoiSyncJobFindFirstArgs<ExtArgs>>): Prisma__PoiSyncJobClient<$Result.GetResult<Prisma.$PoiSyncJobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PoiSyncJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoiSyncJobFindFirstOrThrowArgs} args - Arguments to find a PoiSyncJob
     * @example
     * // Get one PoiSyncJob
     * const poiSyncJob = await prisma.poiSyncJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PoiSyncJobFindFirstOrThrowArgs>(args?: SelectSubset<T, PoiSyncJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__PoiSyncJobClient<$Result.GetResult<Prisma.$PoiSyncJobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PoiSyncJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoiSyncJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PoiSyncJobs
     * const poiSyncJobs = await prisma.poiSyncJob.findMany()
     * 
     * // Get first 10 PoiSyncJobs
     * const poiSyncJobs = await prisma.poiSyncJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const poiSyncJobWithIdOnly = await prisma.poiSyncJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PoiSyncJobFindManyArgs>(args?: SelectSubset<T, PoiSyncJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PoiSyncJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PoiSyncJob.
     * @param {PoiSyncJobCreateArgs} args - Arguments to create a PoiSyncJob.
     * @example
     * // Create one PoiSyncJob
     * const PoiSyncJob = await prisma.poiSyncJob.create({
     *   data: {
     *     // ... data to create a PoiSyncJob
     *   }
     * })
     * 
     */
    create<T extends PoiSyncJobCreateArgs>(args: SelectSubset<T, PoiSyncJobCreateArgs<ExtArgs>>): Prisma__PoiSyncJobClient<$Result.GetResult<Prisma.$PoiSyncJobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PoiSyncJobs.
     * @param {PoiSyncJobCreateManyArgs} args - Arguments to create many PoiSyncJobs.
     * @example
     * // Create many PoiSyncJobs
     * const poiSyncJob = await prisma.poiSyncJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PoiSyncJobCreateManyArgs>(args?: SelectSubset<T, PoiSyncJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PoiSyncJobs and returns the data saved in the database.
     * @param {PoiSyncJobCreateManyAndReturnArgs} args - Arguments to create many PoiSyncJobs.
     * @example
     * // Create many PoiSyncJobs
     * const poiSyncJob = await prisma.poiSyncJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PoiSyncJobs and only return the `id`
     * const poiSyncJobWithIdOnly = await prisma.poiSyncJob.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PoiSyncJobCreateManyAndReturnArgs>(args?: SelectSubset<T, PoiSyncJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PoiSyncJobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PoiSyncJob.
     * @param {PoiSyncJobDeleteArgs} args - Arguments to delete one PoiSyncJob.
     * @example
     * // Delete one PoiSyncJob
     * const PoiSyncJob = await prisma.poiSyncJob.delete({
     *   where: {
     *     // ... filter to delete one PoiSyncJob
     *   }
     * })
     * 
     */
    delete<T extends PoiSyncJobDeleteArgs>(args: SelectSubset<T, PoiSyncJobDeleteArgs<ExtArgs>>): Prisma__PoiSyncJobClient<$Result.GetResult<Prisma.$PoiSyncJobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PoiSyncJob.
     * @param {PoiSyncJobUpdateArgs} args - Arguments to update one PoiSyncJob.
     * @example
     * // Update one PoiSyncJob
     * const poiSyncJob = await prisma.poiSyncJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PoiSyncJobUpdateArgs>(args: SelectSubset<T, PoiSyncJobUpdateArgs<ExtArgs>>): Prisma__PoiSyncJobClient<$Result.GetResult<Prisma.$PoiSyncJobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PoiSyncJobs.
     * @param {PoiSyncJobDeleteManyArgs} args - Arguments to filter PoiSyncJobs to delete.
     * @example
     * // Delete a few PoiSyncJobs
     * const { count } = await prisma.poiSyncJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PoiSyncJobDeleteManyArgs>(args?: SelectSubset<T, PoiSyncJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PoiSyncJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoiSyncJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PoiSyncJobs
     * const poiSyncJob = await prisma.poiSyncJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PoiSyncJobUpdateManyArgs>(args: SelectSubset<T, PoiSyncJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PoiSyncJobs and returns the data updated in the database.
     * @param {PoiSyncJobUpdateManyAndReturnArgs} args - Arguments to update many PoiSyncJobs.
     * @example
     * // Update many PoiSyncJobs
     * const poiSyncJob = await prisma.poiSyncJob.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PoiSyncJobs and only return the `id`
     * const poiSyncJobWithIdOnly = await prisma.poiSyncJob.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PoiSyncJobUpdateManyAndReturnArgs>(args: SelectSubset<T, PoiSyncJobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PoiSyncJobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PoiSyncJob.
     * @param {PoiSyncJobUpsertArgs} args - Arguments to update or create a PoiSyncJob.
     * @example
     * // Update or create a PoiSyncJob
     * const poiSyncJob = await prisma.poiSyncJob.upsert({
     *   create: {
     *     // ... data to create a PoiSyncJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PoiSyncJob we want to update
     *   }
     * })
     */
    upsert<T extends PoiSyncJobUpsertArgs>(args: SelectSubset<T, PoiSyncJobUpsertArgs<ExtArgs>>): Prisma__PoiSyncJobClient<$Result.GetResult<Prisma.$PoiSyncJobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PoiSyncJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoiSyncJobCountArgs} args - Arguments to filter PoiSyncJobs to count.
     * @example
     * // Count the number of PoiSyncJobs
     * const count = await prisma.poiSyncJob.count({
     *   where: {
     *     // ... the filter for the PoiSyncJobs we want to count
     *   }
     * })
    **/
    count<T extends PoiSyncJobCountArgs>(
      args?: Subset<T, PoiSyncJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PoiSyncJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PoiSyncJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoiSyncJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PoiSyncJobAggregateArgs>(args: Subset<T, PoiSyncJobAggregateArgs>): Prisma.PrismaPromise<GetPoiSyncJobAggregateType<T>>

    /**
     * Group by PoiSyncJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PoiSyncJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PoiSyncJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PoiSyncJobGroupByArgs['orderBy'] }
        : { orderBy?: PoiSyncJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PoiSyncJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPoiSyncJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PoiSyncJob model
   */
  readonly fields: PoiSyncJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PoiSyncJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PoiSyncJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PoiSyncJob model
   */
  interface PoiSyncJobFieldRefs {
    readonly id: FieldRef<"PoiSyncJob", 'String'>
    readonly jobType: FieldRef<"PoiSyncJob", 'PoiSyncJobType'>
    readonly status: FieldRef<"PoiSyncJob", 'PoiSyncJobStatus'>
    readonly category: FieldRef<"PoiSyncJob", 'PoiCategory'>
    readonly district: FieldRef<"PoiSyncJob", 'String'>
    readonly poisFetched: FieldRef<"PoiSyncJob", 'Int'>
    readonly poisCreated: FieldRef<"PoiSyncJob", 'Int'>
    readonly poisUpdated: FieldRef<"PoiSyncJob", 'Int'>
    readonly poisSkipped: FieldRef<"PoiSyncJob", 'Int'>
    readonly startedAt: FieldRef<"PoiSyncJob", 'DateTime'>
    readonly completedAt: FieldRef<"PoiSyncJob", 'DateTime'>
    readonly errorMessage: FieldRef<"PoiSyncJob", 'String'>
    readonly errorStack: FieldRef<"PoiSyncJob", 'String'>
    readonly createdAt: FieldRef<"PoiSyncJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PoiSyncJob findUnique
   */
  export type PoiSyncJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoiSyncJob
     */
    select?: PoiSyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoiSyncJob
     */
    omit?: PoiSyncJobOmit<ExtArgs> | null
    /**
     * Filter, which PoiSyncJob to fetch.
     */
    where: PoiSyncJobWhereUniqueInput
  }

  /**
   * PoiSyncJob findUniqueOrThrow
   */
  export type PoiSyncJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoiSyncJob
     */
    select?: PoiSyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoiSyncJob
     */
    omit?: PoiSyncJobOmit<ExtArgs> | null
    /**
     * Filter, which PoiSyncJob to fetch.
     */
    where: PoiSyncJobWhereUniqueInput
  }

  /**
   * PoiSyncJob findFirst
   */
  export type PoiSyncJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoiSyncJob
     */
    select?: PoiSyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoiSyncJob
     */
    omit?: PoiSyncJobOmit<ExtArgs> | null
    /**
     * Filter, which PoiSyncJob to fetch.
     */
    where?: PoiSyncJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PoiSyncJobs to fetch.
     */
    orderBy?: PoiSyncJobOrderByWithRelationInput | PoiSyncJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PoiSyncJobs.
     */
    cursor?: PoiSyncJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PoiSyncJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PoiSyncJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PoiSyncJobs.
     */
    distinct?: PoiSyncJobScalarFieldEnum | PoiSyncJobScalarFieldEnum[]
  }

  /**
   * PoiSyncJob findFirstOrThrow
   */
  export type PoiSyncJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoiSyncJob
     */
    select?: PoiSyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoiSyncJob
     */
    omit?: PoiSyncJobOmit<ExtArgs> | null
    /**
     * Filter, which PoiSyncJob to fetch.
     */
    where?: PoiSyncJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PoiSyncJobs to fetch.
     */
    orderBy?: PoiSyncJobOrderByWithRelationInput | PoiSyncJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PoiSyncJobs.
     */
    cursor?: PoiSyncJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PoiSyncJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PoiSyncJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PoiSyncJobs.
     */
    distinct?: PoiSyncJobScalarFieldEnum | PoiSyncJobScalarFieldEnum[]
  }

  /**
   * PoiSyncJob findMany
   */
  export type PoiSyncJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoiSyncJob
     */
    select?: PoiSyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoiSyncJob
     */
    omit?: PoiSyncJobOmit<ExtArgs> | null
    /**
     * Filter, which PoiSyncJobs to fetch.
     */
    where?: PoiSyncJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PoiSyncJobs to fetch.
     */
    orderBy?: PoiSyncJobOrderByWithRelationInput | PoiSyncJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PoiSyncJobs.
     */
    cursor?: PoiSyncJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PoiSyncJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PoiSyncJobs.
     */
    skip?: number
    distinct?: PoiSyncJobScalarFieldEnum | PoiSyncJobScalarFieldEnum[]
  }

  /**
   * PoiSyncJob create
   */
  export type PoiSyncJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoiSyncJob
     */
    select?: PoiSyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoiSyncJob
     */
    omit?: PoiSyncJobOmit<ExtArgs> | null
    /**
     * The data needed to create a PoiSyncJob.
     */
    data: XOR<PoiSyncJobCreateInput, PoiSyncJobUncheckedCreateInput>
  }

  /**
   * PoiSyncJob createMany
   */
  export type PoiSyncJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PoiSyncJobs.
     */
    data: PoiSyncJobCreateManyInput | PoiSyncJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PoiSyncJob createManyAndReturn
   */
  export type PoiSyncJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoiSyncJob
     */
    select?: PoiSyncJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PoiSyncJob
     */
    omit?: PoiSyncJobOmit<ExtArgs> | null
    /**
     * The data used to create many PoiSyncJobs.
     */
    data: PoiSyncJobCreateManyInput | PoiSyncJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PoiSyncJob update
   */
  export type PoiSyncJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoiSyncJob
     */
    select?: PoiSyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoiSyncJob
     */
    omit?: PoiSyncJobOmit<ExtArgs> | null
    /**
     * The data needed to update a PoiSyncJob.
     */
    data: XOR<PoiSyncJobUpdateInput, PoiSyncJobUncheckedUpdateInput>
    /**
     * Choose, which PoiSyncJob to update.
     */
    where: PoiSyncJobWhereUniqueInput
  }

  /**
   * PoiSyncJob updateMany
   */
  export type PoiSyncJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PoiSyncJobs.
     */
    data: XOR<PoiSyncJobUpdateManyMutationInput, PoiSyncJobUncheckedUpdateManyInput>
    /**
     * Filter which PoiSyncJobs to update
     */
    where?: PoiSyncJobWhereInput
    /**
     * Limit how many PoiSyncJobs to update.
     */
    limit?: number
  }

  /**
   * PoiSyncJob updateManyAndReturn
   */
  export type PoiSyncJobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoiSyncJob
     */
    select?: PoiSyncJobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PoiSyncJob
     */
    omit?: PoiSyncJobOmit<ExtArgs> | null
    /**
     * The data used to update PoiSyncJobs.
     */
    data: XOR<PoiSyncJobUpdateManyMutationInput, PoiSyncJobUncheckedUpdateManyInput>
    /**
     * Filter which PoiSyncJobs to update
     */
    where?: PoiSyncJobWhereInput
    /**
     * Limit how many PoiSyncJobs to update.
     */
    limit?: number
  }

  /**
   * PoiSyncJob upsert
   */
  export type PoiSyncJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoiSyncJob
     */
    select?: PoiSyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoiSyncJob
     */
    omit?: PoiSyncJobOmit<ExtArgs> | null
    /**
     * The filter to search for the PoiSyncJob to update in case it exists.
     */
    where: PoiSyncJobWhereUniqueInput
    /**
     * In case the PoiSyncJob found by the `where` argument doesn't exist, create a new PoiSyncJob with this data.
     */
    create: XOR<PoiSyncJobCreateInput, PoiSyncJobUncheckedCreateInput>
    /**
     * In case the PoiSyncJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PoiSyncJobUpdateInput, PoiSyncJobUncheckedUpdateInput>
  }

  /**
   * PoiSyncJob delete
   */
  export type PoiSyncJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoiSyncJob
     */
    select?: PoiSyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoiSyncJob
     */
    omit?: PoiSyncJobOmit<ExtArgs> | null
    /**
     * Filter which PoiSyncJob to delete.
     */
    where: PoiSyncJobWhereUniqueInput
  }

  /**
   * PoiSyncJob deleteMany
   */
  export type PoiSyncJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PoiSyncJobs to delete
     */
    where?: PoiSyncJobWhereInput
    /**
     * Limit how many PoiSyncJobs to delete.
     */
    limit?: number
  }

  /**
   * PoiSyncJob without action
   */
  export type PoiSyncJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PoiSyncJob
     */
    select?: PoiSyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PoiSyncJob
     */
    omit?: PoiSyncJobOmit<ExtArgs> | null
  }


  /**
   * Model RentalPricingConfig
   */

  export type AggregateRentalPricingConfig = {
    _count: RentalPricingConfigCountAggregateOutputType | null
    _avg: RentalPricingConfigAvgAggregateOutputType | null
    _sum: RentalPricingConfigSumAggregateOutputType | null
    _min: RentalPricingConfigMinAggregateOutputType | null
    _max: RentalPricingConfigMaxAggregateOutputType | null
  }

  export type RentalPricingConfigAvgAggregateOutputType = {
    peakSeasonMonths: number | null
    minimumStayDays: number | null
    maximumStayDays: number | null
  }

  export type RentalPricingConfigSumAggregateOutputType = {
    peakSeasonMonths: number[]
    minimumStayDays: number | null
    maximumStayDays: number | null
  }

  export type RentalPricingConfigMinAggregateOutputType = {
    id: string | null
    minimumStayDays: number | null
    maximumStayDays: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RentalPricingConfigMaxAggregateOutputType = {
    id: string | null
    minimumStayDays: number | null
    maximumStayDays: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RentalPricingConfigCountAggregateOutputType = {
    id: number
    peakSeasonMonths: number
    peakSeasonSurcharges: number
    lowSeasonSurcharges: number
    minimumStayDays: number
    maximumStayDays: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RentalPricingConfigAvgAggregateInputType = {
    peakSeasonMonths?: true
    minimumStayDays?: true
    maximumStayDays?: true
  }

  export type RentalPricingConfigSumAggregateInputType = {
    peakSeasonMonths?: true
    minimumStayDays?: true
    maximumStayDays?: true
  }

  export type RentalPricingConfigMinAggregateInputType = {
    id?: true
    minimumStayDays?: true
    maximumStayDays?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RentalPricingConfigMaxAggregateInputType = {
    id?: true
    minimumStayDays?: true
    maximumStayDays?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RentalPricingConfigCountAggregateInputType = {
    id?: true
    peakSeasonMonths?: true
    peakSeasonSurcharges?: true
    lowSeasonSurcharges?: true
    minimumStayDays?: true
    maximumStayDays?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RentalPricingConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RentalPricingConfig to aggregate.
     */
    where?: RentalPricingConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalPricingConfigs to fetch.
     */
    orderBy?: RentalPricingConfigOrderByWithRelationInput | RentalPricingConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RentalPricingConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalPricingConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalPricingConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RentalPricingConfigs
    **/
    _count?: true | RentalPricingConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RentalPricingConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RentalPricingConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RentalPricingConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RentalPricingConfigMaxAggregateInputType
  }

  export type GetRentalPricingConfigAggregateType<T extends RentalPricingConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateRentalPricingConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRentalPricingConfig[P]>
      : GetScalarType<T[P], AggregateRentalPricingConfig[P]>
  }




  export type RentalPricingConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RentalPricingConfigWhereInput
    orderBy?: RentalPricingConfigOrderByWithAggregationInput | RentalPricingConfigOrderByWithAggregationInput[]
    by: RentalPricingConfigScalarFieldEnum[] | RentalPricingConfigScalarFieldEnum
    having?: RentalPricingConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RentalPricingConfigCountAggregateInputType | true
    _avg?: RentalPricingConfigAvgAggregateInputType
    _sum?: RentalPricingConfigSumAggregateInputType
    _min?: RentalPricingConfigMinAggregateInputType
    _max?: RentalPricingConfigMaxAggregateInputType
  }

  export type RentalPricingConfigGroupByOutputType = {
    id: string
    peakSeasonMonths: number[]
    peakSeasonSurcharges: JsonValue
    lowSeasonSurcharges: JsonValue
    minimumStayDays: number
    maximumStayDays: number
    createdAt: Date
    updatedAt: Date
    _count: RentalPricingConfigCountAggregateOutputType | null
    _avg: RentalPricingConfigAvgAggregateOutputType | null
    _sum: RentalPricingConfigSumAggregateOutputType | null
    _min: RentalPricingConfigMinAggregateOutputType | null
    _max: RentalPricingConfigMaxAggregateOutputType | null
  }

  type GetRentalPricingConfigGroupByPayload<T extends RentalPricingConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RentalPricingConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RentalPricingConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RentalPricingConfigGroupByOutputType[P]>
            : GetScalarType<T[P], RentalPricingConfigGroupByOutputType[P]>
        }
      >
    >


  export type RentalPricingConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    peakSeasonMonths?: boolean
    peakSeasonSurcharges?: boolean
    lowSeasonSurcharges?: boolean
    minimumStayDays?: boolean
    maximumStayDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["rentalPricingConfig"]>

  export type RentalPricingConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    peakSeasonMonths?: boolean
    peakSeasonSurcharges?: boolean
    lowSeasonSurcharges?: boolean
    minimumStayDays?: boolean
    maximumStayDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["rentalPricingConfig"]>

  export type RentalPricingConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    peakSeasonMonths?: boolean
    peakSeasonSurcharges?: boolean
    lowSeasonSurcharges?: boolean
    minimumStayDays?: boolean
    maximumStayDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["rentalPricingConfig"]>

  export type RentalPricingConfigSelectScalar = {
    id?: boolean
    peakSeasonMonths?: boolean
    peakSeasonSurcharges?: boolean
    lowSeasonSurcharges?: boolean
    minimumStayDays?: boolean
    maximumStayDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RentalPricingConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "peakSeasonMonths" | "peakSeasonSurcharges" | "lowSeasonSurcharges" | "minimumStayDays" | "maximumStayDays" | "createdAt" | "updatedAt", ExtArgs["result"]["rentalPricingConfig"]>

  export type $RentalPricingConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RentalPricingConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      peakSeasonMonths: number[]
      peakSeasonSurcharges: Prisma.JsonValue
      lowSeasonSurcharges: Prisma.JsonValue
      minimumStayDays: number
      maximumStayDays: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rentalPricingConfig"]>
    composites: {}
  }

  type RentalPricingConfigGetPayload<S extends boolean | null | undefined | RentalPricingConfigDefaultArgs> = $Result.GetResult<Prisma.$RentalPricingConfigPayload, S>

  type RentalPricingConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RentalPricingConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RentalPricingConfigCountAggregateInputType | true
    }

  export interface RentalPricingConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RentalPricingConfig'], meta: { name: 'RentalPricingConfig' } }
    /**
     * Find zero or one RentalPricingConfig that matches the filter.
     * @param {RentalPricingConfigFindUniqueArgs} args - Arguments to find a RentalPricingConfig
     * @example
     * // Get one RentalPricingConfig
     * const rentalPricingConfig = await prisma.rentalPricingConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RentalPricingConfigFindUniqueArgs>(args: SelectSubset<T, RentalPricingConfigFindUniqueArgs<ExtArgs>>): Prisma__RentalPricingConfigClient<$Result.GetResult<Prisma.$RentalPricingConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RentalPricingConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RentalPricingConfigFindUniqueOrThrowArgs} args - Arguments to find a RentalPricingConfig
     * @example
     * // Get one RentalPricingConfig
     * const rentalPricingConfig = await prisma.rentalPricingConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RentalPricingConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, RentalPricingConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RentalPricingConfigClient<$Result.GetResult<Prisma.$RentalPricingConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RentalPricingConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPricingConfigFindFirstArgs} args - Arguments to find a RentalPricingConfig
     * @example
     * // Get one RentalPricingConfig
     * const rentalPricingConfig = await prisma.rentalPricingConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RentalPricingConfigFindFirstArgs>(args?: SelectSubset<T, RentalPricingConfigFindFirstArgs<ExtArgs>>): Prisma__RentalPricingConfigClient<$Result.GetResult<Prisma.$RentalPricingConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RentalPricingConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPricingConfigFindFirstOrThrowArgs} args - Arguments to find a RentalPricingConfig
     * @example
     * // Get one RentalPricingConfig
     * const rentalPricingConfig = await prisma.rentalPricingConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RentalPricingConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, RentalPricingConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__RentalPricingConfigClient<$Result.GetResult<Prisma.$RentalPricingConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RentalPricingConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPricingConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RentalPricingConfigs
     * const rentalPricingConfigs = await prisma.rentalPricingConfig.findMany()
     * 
     * // Get first 10 RentalPricingConfigs
     * const rentalPricingConfigs = await prisma.rentalPricingConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rentalPricingConfigWithIdOnly = await prisma.rentalPricingConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RentalPricingConfigFindManyArgs>(args?: SelectSubset<T, RentalPricingConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalPricingConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RentalPricingConfig.
     * @param {RentalPricingConfigCreateArgs} args - Arguments to create a RentalPricingConfig.
     * @example
     * // Create one RentalPricingConfig
     * const RentalPricingConfig = await prisma.rentalPricingConfig.create({
     *   data: {
     *     // ... data to create a RentalPricingConfig
     *   }
     * })
     * 
     */
    create<T extends RentalPricingConfigCreateArgs>(args: SelectSubset<T, RentalPricingConfigCreateArgs<ExtArgs>>): Prisma__RentalPricingConfigClient<$Result.GetResult<Prisma.$RentalPricingConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RentalPricingConfigs.
     * @param {RentalPricingConfigCreateManyArgs} args - Arguments to create many RentalPricingConfigs.
     * @example
     * // Create many RentalPricingConfigs
     * const rentalPricingConfig = await prisma.rentalPricingConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RentalPricingConfigCreateManyArgs>(args?: SelectSubset<T, RentalPricingConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RentalPricingConfigs and returns the data saved in the database.
     * @param {RentalPricingConfigCreateManyAndReturnArgs} args - Arguments to create many RentalPricingConfigs.
     * @example
     * // Create many RentalPricingConfigs
     * const rentalPricingConfig = await prisma.rentalPricingConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RentalPricingConfigs and only return the `id`
     * const rentalPricingConfigWithIdOnly = await prisma.rentalPricingConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RentalPricingConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, RentalPricingConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalPricingConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RentalPricingConfig.
     * @param {RentalPricingConfigDeleteArgs} args - Arguments to delete one RentalPricingConfig.
     * @example
     * // Delete one RentalPricingConfig
     * const RentalPricingConfig = await prisma.rentalPricingConfig.delete({
     *   where: {
     *     // ... filter to delete one RentalPricingConfig
     *   }
     * })
     * 
     */
    delete<T extends RentalPricingConfigDeleteArgs>(args: SelectSubset<T, RentalPricingConfigDeleteArgs<ExtArgs>>): Prisma__RentalPricingConfigClient<$Result.GetResult<Prisma.$RentalPricingConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RentalPricingConfig.
     * @param {RentalPricingConfigUpdateArgs} args - Arguments to update one RentalPricingConfig.
     * @example
     * // Update one RentalPricingConfig
     * const rentalPricingConfig = await prisma.rentalPricingConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RentalPricingConfigUpdateArgs>(args: SelectSubset<T, RentalPricingConfigUpdateArgs<ExtArgs>>): Prisma__RentalPricingConfigClient<$Result.GetResult<Prisma.$RentalPricingConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RentalPricingConfigs.
     * @param {RentalPricingConfigDeleteManyArgs} args - Arguments to filter RentalPricingConfigs to delete.
     * @example
     * // Delete a few RentalPricingConfigs
     * const { count } = await prisma.rentalPricingConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RentalPricingConfigDeleteManyArgs>(args?: SelectSubset<T, RentalPricingConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RentalPricingConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPricingConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RentalPricingConfigs
     * const rentalPricingConfig = await prisma.rentalPricingConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RentalPricingConfigUpdateManyArgs>(args: SelectSubset<T, RentalPricingConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RentalPricingConfigs and returns the data updated in the database.
     * @param {RentalPricingConfigUpdateManyAndReturnArgs} args - Arguments to update many RentalPricingConfigs.
     * @example
     * // Update many RentalPricingConfigs
     * const rentalPricingConfig = await prisma.rentalPricingConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RentalPricingConfigs and only return the `id`
     * const rentalPricingConfigWithIdOnly = await prisma.rentalPricingConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RentalPricingConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, RentalPricingConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalPricingConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RentalPricingConfig.
     * @param {RentalPricingConfigUpsertArgs} args - Arguments to update or create a RentalPricingConfig.
     * @example
     * // Update or create a RentalPricingConfig
     * const rentalPricingConfig = await prisma.rentalPricingConfig.upsert({
     *   create: {
     *     // ... data to create a RentalPricingConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RentalPricingConfig we want to update
     *   }
     * })
     */
    upsert<T extends RentalPricingConfigUpsertArgs>(args: SelectSubset<T, RentalPricingConfigUpsertArgs<ExtArgs>>): Prisma__RentalPricingConfigClient<$Result.GetResult<Prisma.$RentalPricingConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RentalPricingConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPricingConfigCountArgs} args - Arguments to filter RentalPricingConfigs to count.
     * @example
     * // Count the number of RentalPricingConfigs
     * const count = await prisma.rentalPricingConfig.count({
     *   where: {
     *     // ... the filter for the RentalPricingConfigs we want to count
     *   }
     * })
    **/
    count<T extends RentalPricingConfigCountArgs>(
      args?: Subset<T, RentalPricingConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RentalPricingConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RentalPricingConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPricingConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RentalPricingConfigAggregateArgs>(args: Subset<T, RentalPricingConfigAggregateArgs>): Prisma.PrismaPromise<GetRentalPricingConfigAggregateType<T>>

    /**
     * Group by RentalPricingConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalPricingConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RentalPricingConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RentalPricingConfigGroupByArgs['orderBy'] }
        : { orderBy?: RentalPricingConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RentalPricingConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRentalPricingConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RentalPricingConfig model
   */
  readonly fields: RentalPricingConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RentalPricingConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RentalPricingConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RentalPricingConfig model
   */
  interface RentalPricingConfigFieldRefs {
    readonly id: FieldRef<"RentalPricingConfig", 'String'>
    readonly peakSeasonMonths: FieldRef<"RentalPricingConfig", 'Int[]'>
    readonly peakSeasonSurcharges: FieldRef<"RentalPricingConfig", 'Json'>
    readonly lowSeasonSurcharges: FieldRef<"RentalPricingConfig", 'Json'>
    readonly minimumStayDays: FieldRef<"RentalPricingConfig", 'Int'>
    readonly maximumStayDays: FieldRef<"RentalPricingConfig", 'Int'>
    readonly createdAt: FieldRef<"RentalPricingConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"RentalPricingConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RentalPricingConfig findUnique
   */
  export type RentalPricingConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPricingConfig
     */
    select?: RentalPricingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPricingConfig
     */
    omit?: RentalPricingConfigOmit<ExtArgs> | null
    /**
     * Filter, which RentalPricingConfig to fetch.
     */
    where: RentalPricingConfigWhereUniqueInput
  }

  /**
   * RentalPricingConfig findUniqueOrThrow
   */
  export type RentalPricingConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPricingConfig
     */
    select?: RentalPricingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPricingConfig
     */
    omit?: RentalPricingConfigOmit<ExtArgs> | null
    /**
     * Filter, which RentalPricingConfig to fetch.
     */
    where: RentalPricingConfigWhereUniqueInput
  }

  /**
   * RentalPricingConfig findFirst
   */
  export type RentalPricingConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPricingConfig
     */
    select?: RentalPricingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPricingConfig
     */
    omit?: RentalPricingConfigOmit<ExtArgs> | null
    /**
     * Filter, which RentalPricingConfig to fetch.
     */
    where?: RentalPricingConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalPricingConfigs to fetch.
     */
    orderBy?: RentalPricingConfigOrderByWithRelationInput | RentalPricingConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RentalPricingConfigs.
     */
    cursor?: RentalPricingConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalPricingConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalPricingConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RentalPricingConfigs.
     */
    distinct?: RentalPricingConfigScalarFieldEnum | RentalPricingConfigScalarFieldEnum[]
  }

  /**
   * RentalPricingConfig findFirstOrThrow
   */
  export type RentalPricingConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPricingConfig
     */
    select?: RentalPricingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPricingConfig
     */
    omit?: RentalPricingConfigOmit<ExtArgs> | null
    /**
     * Filter, which RentalPricingConfig to fetch.
     */
    where?: RentalPricingConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalPricingConfigs to fetch.
     */
    orderBy?: RentalPricingConfigOrderByWithRelationInput | RentalPricingConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RentalPricingConfigs.
     */
    cursor?: RentalPricingConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalPricingConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalPricingConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RentalPricingConfigs.
     */
    distinct?: RentalPricingConfigScalarFieldEnum | RentalPricingConfigScalarFieldEnum[]
  }

  /**
   * RentalPricingConfig findMany
   */
  export type RentalPricingConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPricingConfig
     */
    select?: RentalPricingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPricingConfig
     */
    omit?: RentalPricingConfigOmit<ExtArgs> | null
    /**
     * Filter, which RentalPricingConfigs to fetch.
     */
    where?: RentalPricingConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalPricingConfigs to fetch.
     */
    orderBy?: RentalPricingConfigOrderByWithRelationInput | RentalPricingConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RentalPricingConfigs.
     */
    cursor?: RentalPricingConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalPricingConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalPricingConfigs.
     */
    skip?: number
    distinct?: RentalPricingConfigScalarFieldEnum | RentalPricingConfigScalarFieldEnum[]
  }

  /**
   * RentalPricingConfig create
   */
  export type RentalPricingConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPricingConfig
     */
    select?: RentalPricingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPricingConfig
     */
    omit?: RentalPricingConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a RentalPricingConfig.
     */
    data: XOR<RentalPricingConfigCreateInput, RentalPricingConfigUncheckedCreateInput>
  }

  /**
   * RentalPricingConfig createMany
   */
  export type RentalPricingConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RentalPricingConfigs.
     */
    data: RentalPricingConfigCreateManyInput | RentalPricingConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RentalPricingConfig createManyAndReturn
   */
  export type RentalPricingConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPricingConfig
     */
    select?: RentalPricingConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPricingConfig
     */
    omit?: RentalPricingConfigOmit<ExtArgs> | null
    /**
     * The data used to create many RentalPricingConfigs.
     */
    data: RentalPricingConfigCreateManyInput | RentalPricingConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RentalPricingConfig update
   */
  export type RentalPricingConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPricingConfig
     */
    select?: RentalPricingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPricingConfig
     */
    omit?: RentalPricingConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a RentalPricingConfig.
     */
    data: XOR<RentalPricingConfigUpdateInput, RentalPricingConfigUncheckedUpdateInput>
    /**
     * Choose, which RentalPricingConfig to update.
     */
    where: RentalPricingConfigWhereUniqueInput
  }

  /**
   * RentalPricingConfig updateMany
   */
  export type RentalPricingConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RentalPricingConfigs.
     */
    data: XOR<RentalPricingConfigUpdateManyMutationInput, RentalPricingConfigUncheckedUpdateManyInput>
    /**
     * Filter which RentalPricingConfigs to update
     */
    where?: RentalPricingConfigWhereInput
    /**
     * Limit how many RentalPricingConfigs to update.
     */
    limit?: number
  }

  /**
   * RentalPricingConfig updateManyAndReturn
   */
  export type RentalPricingConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPricingConfig
     */
    select?: RentalPricingConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPricingConfig
     */
    omit?: RentalPricingConfigOmit<ExtArgs> | null
    /**
     * The data used to update RentalPricingConfigs.
     */
    data: XOR<RentalPricingConfigUpdateManyMutationInput, RentalPricingConfigUncheckedUpdateManyInput>
    /**
     * Filter which RentalPricingConfigs to update
     */
    where?: RentalPricingConfigWhereInput
    /**
     * Limit how many RentalPricingConfigs to update.
     */
    limit?: number
  }

  /**
   * RentalPricingConfig upsert
   */
  export type RentalPricingConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPricingConfig
     */
    select?: RentalPricingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPricingConfig
     */
    omit?: RentalPricingConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the RentalPricingConfig to update in case it exists.
     */
    where: RentalPricingConfigWhereUniqueInput
    /**
     * In case the RentalPricingConfig found by the `where` argument doesn't exist, create a new RentalPricingConfig with this data.
     */
    create: XOR<RentalPricingConfigCreateInput, RentalPricingConfigUncheckedCreateInput>
    /**
     * In case the RentalPricingConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RentalPricingConfigUpdateInput, RentalPricingConfigUncheckedUpdateInput>
  }

  /**
   * RentalPricingConfig delete
   */
  export type RentalPricingConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPricingConfig
     */
    select?: RentalPricingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPricingConfig
     */
    omit?: RentalPricingConfigOmit<ExtArgs> | null
    /**
     * Filter which RentalPricingConfig to delete.
     */
    where: RentalPricingConfigWhereUniqueInput
  }

  /**
   * RentalPricingConfig deleteMany
   */
  export type RentalPricingConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RentalPricingConfigs to delete
     */
    where?: RentalPricingConfigWhereInput
    /**
     * Limit how many RentalPricingConfigs to delete.
     */
    limit?: number
  }

  /**
   * RentalPricingConfig without action
   */
  export type RentalPricingConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalPricingConfig
     */
    select?: RentalPricingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalPricingConfig
     */
    omit?: RentalPricingConfigOmit<ExtArgs> | null
  }


  /**
   * Model RentalBooking
   */

  export type AggregateRentalBooking = {
    _count: RentalBookingCountAggregateOutputType | null
    _avg: RentalBookingAvgAggregateOutputType | null
    _sum: RentalBookingSumAggregateOutputType | null
    _min: RentalBookingMinAggregateOutputType | null
    _max: RentalBookingMaxAggregateOutputType | null
  }

  export type RentalBookingAvgAggregateOutputType = {
    nights: number | null
    adults: number | null
    children: number | null
    babies: number | null
    pets: number | null
    basePrice: number | null
    discountPercent: number | null
    totalPrice: number | null
    passportsRequired: number | null
    passportsReceived: number | null
  }

  export type RentalBookingSumAggregateOutputType = {
    nights: number | null
    adults: number | null
    children: number | null
    babies: number | null
    pets: number | null
    basePrice: number | null
    discountPercent: number | null
    totalPrice: number | null
    passportsRequired: number | null
    passportsReceived: number | null
  }

  export type RentalBookingMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    userId: string | null
    checkIn: Date | null
    checkOut: Date | null
    nights: number | null
    adults: number | null
    children: number | null
    babies: number | null
    pets: number | null
    basePrice: number | null
    season: string | null
    discountPercent: number | null
    totalPrice: number | null
    guestName: string | null
    guestEmail: string | null
    guestPhone: string | null
    guestCountryCode: string | null
    guestMessage: string | null
    status: $Enums.RentalBookingStatus | null
    paymentStatus: string | null
    cancellationPolicy: string | null
    cancelledAt: Date | null
    cancellationReason: string | null
    internalNotes: string | null
    checkInTime: string | null
    checkOutTime: string | null
    propertyAddress: string | null
    propertyInstructions: string | null
    wifiName: string | null
    wifiPassword: string | null
    accessCode: string | null
    emergencyContact: string | null
    houseRules: string | null
    confirmedAt: Date | null
    agentId: string | null
    tm30Status: $Enums.TM30BookingStatus | null
    tm30SubmittedAt: Date | null
    tm30Reference: string | null
    tm30Error: string | null
    passportsRequired: number | null
    passportsReceived: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RentalBookingMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    userId: string | null
    checkIn: Date | null
    checkOut: Date | null
    nights: number | null
    adults: number | null
    children: number | null
    babies: number | null
    pets: number | null
    basePrice: number | null
    season: string | null
    discountPercent: number | null
    totalPrice: number | null
    guestName: string | null
    guestEmail: string | null
    guestPhone: string | null
    guestCountryCode: string | null
    guestMessage: string | null
    status: $Enums.RentalBookingStatus | null
    paymentStatus: string | null
    cancellationPolicy: string | null
    cancelledAt: Date | null
    cancellationReason: string | null
    internalNotes: string | null
    checkInTime: string | null
    checkOutTime: string | null
    propertyAddress: string | null
    propertyInstructions: string | null
    wifiName: string | null
    wifiPassword: string | null
    accessCode: string | null
    emergencyContact: string | null
    houseRules: string | null
    confirmedAt: Date | null
    agentId: string | null
    tm30Status: $Enums.TM30BookingStatus | null
    tm30SubmittedAt: Date | null
    tm30Reference: string | null
    tm30Error: string | null
    passportsRequired: number | null
    passportsReceived: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RentalBookingCountAggregateOutputType = {
    id: number
    propertyId: number
    userId: number
    checkIn: number
    checkOut: number
    nights: number
    adults: number
    children: number
    babies: number
    pets: number
    basePrice: number
    season: number
    discountPercent: number
    totalPrice: number
    guestName: number
    guestEmail: number
    guestPhone: number
    guestCountryCode: number
    guestMessage: number
    status: number
    paymentStatus: number
    cancellationPolicy: number
    cancelledAt: number
    cancellationReason: number
    internalNotes: number
    checkInTime: number
    checkOutTime: number
    propertyAddress: number
    propertyInstructions: number
    wifiName: number
    wifiPassword: number
    accessCode: number
    emergencyContact: number
    houseRules: number
    confirmedAt: number
    agentId: number
    tm30Status: number
    tm30SubmittedAt: number
    tm30Reference: number
    tm30Error: number
    passportsRequired: number
    passportsReceived: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RentalBookingAvgAggregateInputType = {
    nights?: true
    adults?: true
    children?: true
    babies?: true
    pets?: true
    basePrice?: true
    discountPercent?: true
    totalPrice?: true
    passportsRequired?: true
    passportsReceived?: true
  }

  export type RentalBookingSumAggregateInputType = {
    nights?: true
    adults?: true
    children?: true
    babies?: true
    pets?: true
    basePrice?: true
    discountPercent?: true
    totalPrice?: true
    passportsRequired?: true
    passportsReceived?: true
  }

  export type RentalBookingMinAggregateInputType = {
    id?: true
    propertyId?: true
    userId?: true
    checkIn?: true
    checkOut?: true
    nights?: true
    adults?: true
    children?: true
    babies?: true
    pets?: true
    basePrice?: true
    season?: true
    discountPercent?: true
    totalPrice?: true
    guestName?: true
    guestEmail?: true
    guestPhone?: true
    guestCountryCode?: true
    guestMessage?: true
    status?: true
    paymentStatus?: true
    cancellationPolicy?: true
    cancelledAt?: true
    cancellationReason?: true
    internalNotes?: true
    checkInTime?: true
    checkOutTime?: true
    propertyAddress?: true
    propertyInstructions?: true
    wifiName?: true
    wifiPassword?: true
    accessCode?: true
    emergencyContact?: true
    houseRules?: true
    confirmedAt?: true
    agentId?: true
    tm30Status?: true
    tm30SubmittedAt?: true
    tm30Reference?: true
    tm30Error?: true
    passportsRequired?: true
    passportsReceived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RentalBookingMaxAggregateInputType = {
    id?: true
    propertyId?: true
    userId?: true
    checkIn?: true
    checkOut?: true
    nights?: true
    adults?: true
    children?: true
    babies?: true
    pets?: true
    basePrice?: true
    season?: true
    discountPercent?: true
    totalPrice?: true
    guestName?: true
    guestEmail?: true
    guestPhone?: true
    guestCountryCode?: true
    guestMessage?: true
    status?: true
    paymentStatus?: true
    cancellationPolicy?: true
    cancelledAt?: true
    cancellationReason?: true
    internalNotes?: true
    checkInTime?: true
    checkOutTime?: true
    propertyAddress?: true
    propertyInstructions?: true
    wifiName?: true
    wifiPassword?: true
    accessCode?: true
    emergencyContact?: true
    houseRules?: true
    confirmedAt?: true
    agentId?: true
    tm30Status?: true
    tm30SubmittedAt?: true
    tm30Reference?: true
    tm30Error?: true
    passportsRequired?: true
    passportsReceived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RentalBookingCountAggregateInputType = {
    id?: true
    propertyId?: true
    userId?: true
    checkIn?: true
    checkOut?: true
    nights?: true
    adults?: true
    children?: true
    babies?: true
    pets?: true
    basePrice?: true
    season?: true
    discountPercent?: true
    totalPrice?: true
    guestName?: true
    guestEmail?: true
    guestPhone?: true
    guestCountryCode?: true
    guestMessage?: true
    status?: true
    paymentStatus?: true
    cancellationPolicy?: true
    cancelledAt?: true
    cancellationReason?: true
    internalNotes?: true
    checkInTime?: true
    checkOutTime?: true
    propertyAddress?: true
    propertyInstructions?: true
    wifiName?: true
    wifiPassword?: true
    accessCode?: true
    emergencyContact?: true
    houseRules?: true
    confirmedAt?: true
    agentId?: true
    tm30Status?: true
    tm30SubmittedAt?: true
    tm30Reference?: true
    tm30Error?: true
    passportsRequired?: true
    passportsReceived?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RentalBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RentalBooking to aggregate.
     */
    where?: RentalBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalBookings to fetch.
     */
    orderBy?: RentalBookingOrderByWithRelationInput | RentalBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RentalBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RentalBookings
    **/
    _count?: true | RentalBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RentalBookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RentalBookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RentalBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RentalBookingMaxAggregateInputType
  }

  export type GetRentalBookingAggregateType<T extends RentalBookingAggregateArgs> = {
        [P in keyof T & keyof AggregateRentalBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRentalBooking[P]>
      : GetScalarType<T[P], AggregateRentalBooking[P]>
  }




  export type RentalBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RentalBookingWhereInput
    orderBy?: RentalBookingOrderByWithAggregationInput | RentalBookingOrderByWithAggregationInput[]
    by: RentalBookingScalarFieldEnum[] | RentalBookingScalarFieldEnum
    having?: RentalBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RentalBookingCountAggregateInputType | true
    _avg?: RentalBookingAvgAggregateInputType
    _sum?: RentalBookingSumAggregateInputType
    _min?: RentalBookingMinAggregateInputType
    _max?: RentalBookingMaxAggregateInputType
  }

  export type RentalBookingGroupByOutputType = {
    id: string
    propertyId: string
    userId: string
    checkIn: Date
    checkOut: Date
    nights: number
    adults: number
    children: number
    babies: number
    pets: number
    basePrice: number
    season: string
    discountPercent: number
    totalPrice: number
    guestName: string
    guestEmail: string
    guestPhone: string
    guestCountryCode: string
    guestMessage: string | null
    status: $Enums.RentalBookingStatus
    paymentStatus: string | null
    cancellationPolicy: string | null
    cancelledAt: Date | null
    cancellationReason: string | null
    internalNotes: string | null
    checkInTime: string | null
    checkOutTime: string | null
    propertyAddress: string | null
    propertyInstructions: string | null
    wifiName: string | null
    wifiPassword: string | null
    accessCode: string | null
    emergencyContact: string | null
    houseRules: string | null
    confirmedAt: Date | null
    agentId: string | null
    tm30Status: $Enums.TM30BookingStatus
    tm30SubmittedAt: Date | null
    tm30Reference: string | null
    tm30Error: string | null
    passportsRequired: number
    passportsReceived: number
    createdAt: Date
    updatedAt: Date
    _count: RentalBookingCountAggregateOutputType | null
    _avg: RentalBookingAvgAggregateOutputType | null
    _sum: RentalBookingSumAggregateOutputType | null
    _min: RentalBookingMinAggregateOutputType | null
    _max: RentalBookingMaxAggregateOutputType | null
  }

  type GetRentalBookingGroupByPayload<T extends RentalBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RentalBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RentalBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RentalBookingGroupByOutputType[P]>
            : GetScalarType<T[P], RentalBookingGroupByOutputType[P]>
        }
      >
    >


  export type RentalBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    userId?: boolean
    checkIn?: boolean
    checkOut?: boolean
    nights?: boolean
    adults?: boolean
    children?: boolean
    babies?: boolean
    pets?: boolean
    basePrice?: boolean
    season?: boolean
    discountPercent?: boolean
    totalPrice?: boolean
    guestName?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    guestCountryCode?: boolean
    guestMessage?: boolean
    status?: boolean
    paymentStatus?: boolean
    cancellationPolicy?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    internalNotes?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    propertyAddress?: boolean
    propertyInstructions?: boolean
    wifiName?: boolean
    wifiPassword?: boolean
    accessCode?: boolean
    emergencyContact?: boolean
    houseRules?: boolean
    confirmedAt?: boolean
    agentId?: boolean
    tm30Status?: boolean
    tm30SubmittedAt?: boolean
    tm30Reference?: boolean
    tm30Error?: boolean
    passportsRequired?: boolean
    passportsReceived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    agent?: boolean | RentalBooking$agentArgs<ExtArgs>
    messages?: boolean | RentalBooking$messagesArgs<ExtArgs>
    guests?: boolean | RentalBooking$guestsArgs<ExtArgs>
    _count?: boolean | RentalBookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rentalBooking"]>

  export type RentalBookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    userId?: boolean
    checkIn?: boolean
    checkOut?: boolean
    nights?: boolean
    adults?: boolean
    children?: boolean
    babies?: boolean
    pets?: boolean
    basePrice?: boolean
    season?: boolean
    discountPercent?: boolean
    totalPrice?: boolean
    guestName?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    guestCountryCode?: boolean
    guestMessage?: boolean
    status?: boolean
    paymentStatus?: boolean
    cancellationPolicy?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    internalNotes?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    propertyAddress?: boolean
    propertyInstructions?: boolean
    wifiName?: boolean
    wifiPassword?: boolean
    accessCode?: boolean
    emergencyContact?: boolean
    houseRules?: boolean
    confirmedAt?: boolean
    agentId?: boolean
    tm30Status?: boolean
    tm30SubmittedAt?: boolean
    tm30Reference?: boolean
    tm30Error?: boolean
    passportsRequired?: boolean
    passportsReceived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    agent?: boolean | RentalBooking$agentArgs<ExtArgs>
  }, ExtArgs["result"]["rentalBooking"]>

  export type RentalBookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    userId?: boolean
    checkIn?: boolean
    checkOut?: boolean
    nights?: boolean
    adults?: boolean
    children?: boolean
    babies?: boolean
    pets?: boolean
    basePrice?: boolean
    season?: boolean
    discountPercent?: boolean
    totalPrice?: boolean
    guestName?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    guestCountryCode?: boolean
    guestMessage?: boolean
    status?: boolean
    paymentStatus?: boolean
    cancellationPolicy?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    internalNotes?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    propertyAddress?: boolean
    propertyInstructions?: boolean
    wifiName?: boolean
    wifiPassword?: boolean
    accessCode?: boolean
    emergencyContact?: boolean
    houseRules?: boolean
    confirmedAt?: boolean
    agentId?: boolean
    tm30Status?: boolean
    tm30SubmittedAt?: boolean
    tm30Reference?: boolean
    tm30Error?: boolean
    passportsRequired?: boolean
    passportsReceived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    agent?: boolean | RentalBooking$agentArgs<ExtArgs>
  }, ExtArgs["result"]["rentalBooking"]>

  export type RentalBookingSelectScalar = {
    id?: boolean
    propertyId?: boolean
    userId?: boolean
    checkIn?: boolean
    checkOut?: boolean
    nights?: boolean
    adults?: boolean
    children?: boolean
    babies?: boolean
    pets?: boolean
    basePrice?: boolean
    season?: boolean
    discountPercent?: boolean
    totalPrice?: boolean
    guestName?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    guestCountryCode?: boolean
    guestMessage?: boolean
    status?: boolean
    paymentStatus?: boolean
    cancellationPolicy?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    internalNotes?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    propertyAddress?: boolean
    propertyInstructions?: boolean
    wifiName?: boolean
    wifiPassword?: boolean
    accessCode?: boolean
    emergencyContact?: boolean
    houseRules?: boolean
    confirmedAt?: boolean
    agentId?: boolean
    tm30Status?: boolean
    tm30SubmittedAt?: boolean
    tm30Reference?: boolean
    tm30Error?: boolean
    passportsRequired?: boolean
    passportsReceived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RentalBookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "userId" | "checkIn" | "checkOut" | "nights" | "adults" | "children" | "babies" | "pets" | "basePrice" | "season" | "discountPercent" | "totalPrice" | "guestName" | "guestEmail" | "guestPhone" | "guestCountryCode" | "guestMessage" | "status" | "paymentStatus" | "cancellationPolicy" | "cancelledAt" | "cancellationReason" | "internalNotes" | "checkInTime" | "checkOutTime" | "propertyAddress" | "propertyInstructions" | "wifiName" | "wifiPassword" | "accessCode" | "emergencyContact" | "houseRules" | "confirmedAt" | "agentId" | "tm30Status" | "tm30SubmittedAt" | "tm30Reference" | "tm30Error" | "passportsRequired" | "passportsReceived" | "createdAt" | "updatedAt", ExtArgs["result"]["rentalBooking"]>
  export type RentalBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    agent?: boolean | RentalBooking$agentArgs<ExtArgs>
    messages?: boolean | RentalBooking$messagesArgs<ExtArgs>
    guests?: boolean | RentalBooking$guestsArgs<ExtArgs>
    _count?: boolean | RentalBookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RentalBookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    agent?: boolean | RentalBooking$agentArgs<ExtArgs>
  }
  export type RentalBookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    agent?: boolean | RentalBooking$agentArgs<ExtArgs>
  }

  export type $RentalBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RentalBooking"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      agent: Prisma.$UserPayload<ExtArgs> | null
      messages: Prisma.$BookingMessagePayload<ExtArgs>[]
      guests: Prisma.$BookingGuestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      userId: string
      checkIn: Date
      checkOut: Date
      nights: number
      adults: number
      children: number
      babies: number
      pets: number
      basePrice: number
      season: string
      discountPercent: number
      totalPrice: number
      guestName: string
      guestEmail: string
      guestPhone: string
      guestCountryCode: string
      guestMessage: string | null
      status: $Enums.RentalBookingStatus
      paymentStatus: string | null
      cancellationPolicy: string | null
      cancelledAt: Date | null
      cancellationReason: string | null
      internalNotes: string | null
      checkInTime: string | null
      checkOutTime: string | null
      propertyAddress: string | null
      propertyInstructions: string | null
      wifiName: string | null
      wifiPassword: string | null
      accessCode: string | null
      emergencyContact: string | null
      houseRules: string | null
      confirmedAt: Date | null
      agentId: string | null
      tm30Status: $Enums.TM30BookingStatus
      tm30SubmittedAt: Date | null
      tm30Reference: string | null
      tm30Error: string | null
      passportsRequired: number
      passportsReceived: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rentalBooking"]>
    composites: {}
  }

  type RentalBookingGetPayload<S extends boolean | null | undefined | RentalBookingDefaultArgs> = $Result.GetResult<Prisma.$RentalBookingPayload, S>

  type RentalBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RentalBookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RentalBookingCountAggregateInputType | true
    }

  export interface RentalBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RentalBooking'], meta: { name: 'RentalBooking' } }
    /**
     * Find zero or one RentalBooking that matches the filter.
     * @param {RentalBookingFindUniqueArgs} args - Arguments to find a RentalBooking
     * @example
     * // Get one RentalBooking
     * const rentalBooking = await prisma.rentalBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RentalBookingFindUniqueArgs>(args: SelectSubset<T, RentalBookingFindUniqueArgs<ExtArgs>>): Prisma__RentalBookingClient<$Result.GetResult<Prisma.$RentalBookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RentalBooking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RentalBookingFindUniqueOrThrowArgs} args - Arguments to find a RentalBooking
     * @example
     * // Get one RentalBooking
     * const rentalBooking = await prisma.rentalBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RentalBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, RentalBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RentalBookingClient<$Result.GetResult<Prisma.$RentalBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RentalBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalBookingFindFirstArgs} args - Arguments to find a RentalBooking
     * @example
     * // Get one RentalBooking
     * const rentalBooking = await prisma.rentalBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RentalBookingFindFirstArgs>(args?: SelectSubset<T, RentalBookingFindFirstArgs<ExtArgs>>): Prisma__RentalBookingClient<$Result.GetResult<Prisma.$RentalBookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RentalBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalBookingFindFirstOrThrowArgs} args - Arguments to find a RentalBooking
     * @example
     * // Get one RentalBooking
     * const rentalBooking = await prisma.rentalBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RentalBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, RentalBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__RentalBookingClient<$Result.GetResult<Prisma.$RentalBookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RentalBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RentalBookings
     * const rentalBookings = await prisma.rentalBooking.findMany()
     * 
     * // Get first 10 RentalBookings
     * const rentalBookings = await prisma.rentalBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rentalBookingWithIdOnly = await prisma.rentalBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RentalBookingFindManyArgs>(args?: SelectSubset<T, RentalBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RentalBooking.
     * @param {RentalBookingCreateArgs} args - Arguments to create a RentalBooking.
     * @example
     * // Create one RentalBooking
     * const RentalBooking = await prisma.rentalBooking.create({
     *   data: {
     *     // ... data to create a RentalBooking
     *   }
     * })
     * 
     */
    create<T extends RentalBookingCreateArgs>(args: SelectSubset<T, RentalBookingCreateArgs<ExtArgs>>): Prisma__RentalBookingClient<$Result.GetResult<Prisma.$RentalBookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RentalBookings.
     * @param {RentalBookingCreateManyArgs} args - Arguments to create many RentalBookings.
     * @example
     * // Create many RentalBookings
     * const rentalBooking = await prisma.rentalBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RentalBookingCreateManyArgs>(args?: SelectSubset<T, RentalBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RentalBookings and returns the data saved in the database.
     * @param {RentalBookingCreateManyAndReturnArgs} args - Arguments to create many RentalBookings.
     * @example
     * // Create many RentalBookings
     * const rentalBooking = await prisma.rentalBooking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RentalBookings and only return the `id`
     * const rentalBookingWithIdOnly = await prisma.rentalBooking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RentalBookingCreateManyAndReturnArgs>(args?: SelectSubset<T, RentalBookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalBookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RentalBooking.
     * @param {RentalBookingDeleteArgs} args - Arguments to delete one RentalBooking.
     * @example
     * // Delete one RentalBooking
     * const RentalBooking = await prisma.rentalBooking.delete({
     *   where: {
     *     // ... filter to delete one RentalBooking
     *   }
     * })
     * 
     */
    delete<T extends RentalBookingDeleteArgs>(args: SelectSubset<T, RentalBookingDeleteArgs<ExtArgs>>): Prisma__RentalBookingClient<$Result.GetResult<Prisma.$RentalBookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RentalBooking.
     * @param {RentalBookingUpdateArgs} args - Arguments to update one RentalBooking.
     * @example
     * // Update one RentalBooking
     * const rentalBooking = await prisma.rentalBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RentalBookingUpdateArgs>(args: SelectSubset<T, RentalBookingUpdateArgs<ExtArgs>>): Prisma__RentalBookingClient<$Result.GetResult<Prisma.$RentalBookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RentalBookings.
     * @param {RentalBookingDeleteManyArgs} args - Arguments to filter RentalBookings to delete.
     * @example
     * // Delete a few RentalBookings
     * const { count } = await prisma.rentalBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RentalBookingDeleteManyArgs>(args?: SelectSubset<T, RentalBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RentalBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RentalBookings
     * const rentalBooking = await prisma.rentalBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RentalBookingUpdateManyArgs>(args: SelectSubset<T, RentalBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RentalBookings and returns the data updated in the database.
     * @param {RentalBookingUpdateManyAndReturnArgs} args - Arguments to update many RentalBookings.
     * @example
     * // Update many RentalBookings
     * const rentalBooking = await prisma.rentalBooking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RentalBookings and only return the `id`
     * const rentalBookingWithIdOnly = await prisma.rentalBooking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RentalBookingUpdateManyAndReturnArgs>(args: SelectSubset<T, RentalBookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalBookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RentalBooking.
     * @param {RentalBookingUpsertArgs} args - Arguments to update or create a RentalBooking.
     * @example
     * // Update or create a RentalBooking
     * const rentalBooking = await prisma.rentalBooking.upsert({
     *   create: {
     *     // ... data to create a RentalBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RentalBooking we want to update
     *   }
     * })
     */
    upsert<T extends RentalBookingUpsertArgs>(args: SelectSubset<T, RentalBookingUpsertArgs<ExtArgs>>): Prisma__RentalBookingClient<$Result.GetResult<Prisma.$RentalBookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RentalBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalBookingCountArgs} args - Arguments to filter RentalBookings to count.
     * @example
     * // Count the number of RentalBookings
     * const count = await prisma.rentalBooking.count({
     *   where: {
     *     // ... the filter for the RentalBookings we want to count
     *   }
     * })
    **/
    count<T extends RentalBookingCountArgs>(
      args?: Subset<T, RentalBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RentalBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RentalBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RentalBookingAggregateArgs>(args: Subset<T, RentalBookingAggregateArgs>): Prisma.PrismaPromise<GetRentalBookingAggregateType<T>>

    /**
     * Group by RentalBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RentalBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RentalBookingGroupByArgs['orderBy'] }
        : { orderBy?: RentalBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RentalBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRentalBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RentalBooking model
   */
  readonly fields: RentalBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RentalBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RentalBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agent<T extends RentalBooking$agentArgs<ExtArgs> = {}>(args?: Subset<T, RentalBooking$agentArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    messages<T extends RentalBooking$messagesArgs<ExtArgs> = {}>(args?: Subset<T, RentalBooking$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    guests<T extends RentalBooking$guestsArgs<ExtArgs> = {}>(args?: Subset<T, RentalBooking$guestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingGuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RentalBooking model
   */
  interface RentalBookingFieldRefs {
    readonly id: FieldRef<"RentalBooking", 'String'>
    readonly propertyId: FieldRef<"RentalBooking", 'String'>
    readonly userId: FieldRef<"RentalBooking", 'String'>
    readonly checkIn: FieldRef<"RentalBooking", 'DateTime'>
    readonly checkOut: FieldRef<"RentalBooking", 'DateTime'>
    readonly nights: FieldRef<"RentalBooking", 'Int'>
    readonly adults: FieldRef<"RentalBooking", 'Int'>
    readonly children: FieldRef<"RentalBooking", 'Int'>
    readonly babies: FieldRef<"RentalBooking", 'Int'>
    readonly pets: FieldRef<"RentalBooking", 'Int'>
    readonly basePrice: FieldRef<"RentalBooking", 'Float'>
    readonly season: FieldRef<"RentalBooking", 'String'>
    readonly discountPercent: FieldRef<"RentalBooking", 'Float'>
    readonly totalPrice: FieldRef<"RentalBooking", 'Float'>
    readonly guestName: FieldRef<"RentalBooking", 'String'>
    readonly guestEmail: FieldRef<"RentalBooking", 'String'>
    readonly guestPhone: FieldRef<"RentalBooking", 'String'>
    readonly guestCountryCode: FieldRef<"RentalBooking", 'String'>
    readonly guestMessage: FieldRef<"RentalBooking", 'String'>
    readonly status: FieldRef<"RentalBooking", 'RentalBookingStatus'>
    readonly paymentStatus: FieldRef<"RentalBooking", 'String'>
    readonly cancellationPolicy: FieldRef<"RentalBooking", 'String'>
    readonly cancelledAt: FieldRef<"RentalBooking", 'DateTime'>
    readonly cancellationReason: FieldRef<"RentalBooking", 'String'>
    readonly internalNotes: FieldRef<"RentalBooking", 'String'>
    readonly checkInTime: FieldRef<"RentalBooking", 'String'>
    readonly checkOutTime: FieldRef<"RentalBooking", 'String'>
    readonly propertyAddress: FieldRef<"RentalBooking", 'String'>
    readonly propertyInstructions: FieldRef<"RentalBooking", 'String'>
    readonly wifiName: FieldRef<"RentalBooking", 'String'>
    readonly wifiPassword: FieldRef<"RentalBooking", 'String'>
    readonly accessCode: FieldRef<"RentalBooking", 'String'>
    readonly emergencyContact: FieldRef<"RentalBooking", 'String'>
    readonly houseRules: FieldRef<"RentalBooking", 'String'>
    readonly confirmedAt: FieldRef<"RentalBooking", 'DateTime'>
    readonly agentId: FieldRef<"RentalBooking", 'String'>
    readonly tm30Status: FieldRef<"RentalBooking", 'TM30BookingStatus'>
    readonly tm30SubmittedAt: FieldRef<"RentalBooking", 'DateTime'>
    readonly tm30Reference: FieldRef<"RentalBooking", 'String'>
    readonly tm30Error: FieldRef<"RentalBooking", 'String'>
    readonly passportsRequired: FieldRef<"RentalBooking", 'Int'>
    readonly passportsReceived: FieldRef<"RentalBooking", 'Int'>
    readonly createdAt: FieldRef<"RentalBooking", 'DateTime'>
    readonly updatedAt: FieldRef<"RentalBooking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RentalBooking findUnique
   */
  export type RentalBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalBooking
     */
    select?: RentalBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalBooking
     */
    omit?: RentalBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalBookingInclude<ExtArgs> | null
    /**
     * Filter, which RentalBooking to fetch.
     */
    where: RentalBookingWhereUniqueInput
  }

  /**
   * RentalBooking findUniqueOrThrow
   */
  export type RentalBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalBooking
     */
    select?: RentalBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalBooking
     */
    omit?: RentalBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalBookingInclude<ExtArgs> | null
    /**
     * Filter, which RentalBooking to fetch.
     */
    where: RentalBookingWhereUniqueInput
  }

  /**
   * RentalBooking findFirst
   */
  export type RentalBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalBooking
     */
    select?: RentalBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalBooking
     */
    omit?: RentalBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalBookingInclude<ExtArgs> | null
    /**
     * Filter, which RentalBooking to fetch.
     */
    where?: RentalBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalBookings to fetch.
     */
    orderBy?: RentalBookingOrderByWithRelationInput | RentalBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RentalBookings.
     */
    cursor?: RentalBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RentalBookings.
     */
    distinct?: RentalBookingScalarFieldEnum | RentalBookingScalarFieldEnum[]
  }

  /**
   * RentalBooking findFirstOrThrow
   */
  export type RentalBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalBooking
     */
    select?: RentalBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalBooking
     */
    omit?: RentalBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalBookingInclude<ExtArgs> | null
    /**
     * Filter, which RentalBooking to fetch.
     */
    where?: RentalBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalBookings to fetch.
     */
    orderBy?: RentalBookingOrderByWithRelationInput | RentalBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RentalBookings.
     */
    cursor?: RentalBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RentalBookings.
     */
    distinct?: RentalBookingScalarFieldEnum | RentalBookingScalarFieldEnum[]
  }

  /**
   * RentalBooking findMany
   */
  export type RentalBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalBooking
     */
    select?: RentalBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalBooking
     */
    omit?: RentalBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalBookingInclude<ExtArgs> | null
    /**
     * Filter, which RentalBookings to fetch.
     */
    where?: RentalBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalBookings to fetch.
     */
    orderBy?: RentalBookingOrderByWithRelationInput | RentalBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RentalBookings.
     */
    cursor?: RentalBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalBookings.
     */
    skip?: number
    distinct?: RentalBookingScalarFieldEnum | RentalBookingScalarFieldEnum[]
  }

  /**
   * RentalBooking create
   */
  export type RentalBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalBooking
     */
    select?: RentalBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalBooking
     */
    omit?: RentalBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a RentalBooking.
     */
    data: XOR<RentalBookingCreateInput, RentalBookingUncheckedCreateInput>
  }

  /**
   * RentalBooking createMany
   */
  export type RentalBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RentalBookings.
     */
    data: RentalBookingCreateManyInput | RentalBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RentalBooking createManyAndReturn
   */
  export type RentalBookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalBooking
     */
    select?: RentalBookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RentalBooking
     */
    omit?: RentalBookingOmit<ExtArgs> | null
    /**
     * The data used to create many RentalBookings.
     */
    data: RentalBookingCreateManyInput | RentalBookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalBookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RentalBooking update
   */
  export type RentalBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalBooking
     */
    select?: RentalBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalBooking
     */
    omit?: RentalBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a RentalBooking.
     */
    data: XOR<RentalBookingUpdateInput, RentalBookingUncheckedUpdateInput>
    /**
     * Choose, which RentalBooking to update.
     */
    where: RentalBookingWhereUniqueInput
  }

  /**
   * RentalBooking updateMany
   */
  export type RentalBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RentalBookings.
     */
    data: XOR<RentalBookingUpdateManyMutationInput, RentalBookingUncheckedUpdateManyInput>
    /**
     * Filter which RentalBookings to update
     */
    where?: RentalBookingWhereInput
    /**
     * Limit how many RentalBookings to update.
     */
    limit?: number
  }

  /**
   * RentalBooking updateManyAndReturn
   */
  export type RentalBookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalBooking
     */
    select?: RentalBookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RentalBooking
     */
    omit?: RentalBookingOmit<ExtArgs> | null
    /**
     * The data used to update RentalBookings.
     */
    data: XOR<RentalBookingUpdateManyMutationInput, RentalBookingUncheckedUpdateManyInput>
    /**
     * Filter which RentalBookings to update
     */
    where?: RentalBookingWhereInput
    /**
     * Limit how many RentalBookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalBookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RentalBooking upsert
   */
  export type RentalBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalBooking
     */
    select?: RentalBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalBooking
     */
    omit?: RentalBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the RentalBooking to update in case it exists.
     */
    where: RentalBookingWhereUniqueInput
    /**
     * In case the RentalBooking found by the `where` argument doesn't exist, create a new RentalBooking with this data.
     */
    create: XOR<RentalBookingCreateInput, RentalBookingUncheckedCreateInput>
    /**
     * In case the RentalBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RentalBookingUpdateInput, RentalBookingUncheckedUpdateInput>
  }

  /**
   * RentalBooking delete
   */
  export type RentalBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalBooking
     */
    select?: RentalBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalBooking
     */
    omit?: RentalBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalBookingInclude<ExtArgs> | null
    /**
     * Filter which RentalBooking to delete.
     */
    where: RentalBookingWhereUniqueInput
  }

  /**
   * RentalBooking deleteMany
   */
  export type RentalBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RentalBookings to delete
     */
    where?: RentalBookingWhereInput
    /**
     * Limit how many RentalBookings to delete.
     */
    limit?: number
  }

  /**
   * RentalBooking.agent
   */
  export type RentalBooking$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * RentalBooking.messages
   */
  export type RentalBooking$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingMessage
     */
    select?: BookingMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingMessage
     */
    omit?: BookingMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingMessageInclude<ExtArgs> | null
    where?: BookingMessageWhereInput
    orderBy?: BookingMessageOrderByWithRelationInput | BookingMessageOrderByWithRelationInput[]
    cursor?: BookingMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingMessageScalarFieldEnum | BookingMessageScalarFieldEnum[]
  }

  /**
   * RentalBooking.guests
   */
  export type RentalBooking$guestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingGuest
     */
    select?: BookingGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingGuest
     */
    omit?: BookingGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingGuestInclude<ExtArgs> | null
    where?: BookingGuestWhereInput
    orderBy?: BookingGuestOrderByWithRelationInput | BookingGuestOrderByWithRelationInput[]
    cursor?: BookingGuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingGuestScalarFieldEnum | BookingGuestScalarFieldEnum[]
  }

  /**
   * RentalBooking without action
   */
  export type RentalBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalBooking
     */
    select?: RentalBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalBooking
     */
    omit?: RentalBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalBookingInclude<ExtArgs> | null
  }


  /**
   * Model BookingMessage
   */

  export type AggregateBookingMessage = {
    _count: BookingMessageCountAggregateOutputType | null
    _min: BookingMessageMinAggregateOutputType | null
    _max: BookingMessageMaxAggregateOutputType | null
  }

  export type BookingMessageMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    senderId: string | null
    senderRole: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingMessageMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    senderId: string | null
    senderRole: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingMessageCountAggregateOutputType = {
    id: number
    bookingId: number
    senderId: number
    senderRole: number
    message: number
    isRead: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingMessageMinAggregateInputType = {
    id?: true
    bookingId?: true
    senderId?: true
    senderRole?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingMessageMaxAggregateInputType = {
    id?: true
    bookingId?: true
    senderId?: true
    senderRole?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingMessageCountAggregateInputType = {
    id?: true
    bookingId?: true
    senderId?: true
    senderRole?: true
    message?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingMessage to aggregate.
     */
    where?: BookingMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingMessages to fetch.
     */
    orderBy?: BookingMessageOrderByWithRelationInput | BookingMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingMessages
    **/
    _count?: true | BookingMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMessageMaxAggregateInputType
  }

  export type GetBookingMessageAggregateType<T extends BookingMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingMessage[P]>
      : GetScalarType<T[P], AggregateBookingMessage[P]>
  }




  export type BookingMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingMessageWhereInput
    orderBy?: BookingMessageOrderByWithAggregationInput | BookingMessageOrderByWithAggregationInput[]
    by: BookingMessageScalarFieldEnum[] | BookingMessageScalarFieldEnum
    having?: BookingMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingMessageCountAggregateInputType | true
    _min?: BookingMessageMinAggregateInputType
    _max?: BookingMessageMaxAggregateInputType
  }

  export type BookingMessageGroupByOutputType = {
    id: string
    bookingId: string
    senderId: string
    senderRole: string
    message: string
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    _count: BookingMessageCountAggregateOutputType | null
    _min: BookingMessageMinAggregateOutputType | null
    _max: BookingMessageMaxAggregateOutputType | null
  }

  type GetBookingMessageGroupByPayload<T extends BookingMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingMessageGroupByOutputType[P]>
            : GetScalarType<T[P], BookingMessageGroupByOutputType[P]>
        }
      >
    >


  export type BookingMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    senderId?: boolean
    senderRole?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | RentalBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingMessage"]>

  export type BookingMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    senderId?: boolean
    senderRole?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | RentalBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingMessage"]>

  export type BookingMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    senderId?: boolean
    senderRole?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | RentalBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingMessage"]>

  export type BookingMessageSelectScalar = {
    id?: boolean
    bookingId?: boolean
    senderId?: boolean
    senderRole?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "senderId" | "senderRole" | "message" | "isRead" | "createdAt" | "updatedAt", ExtArgs["result"]["bookingMessage"]>
  export type BookingMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | RentalBookingDefaultArgs<ExtArgs>
  }
  export type BookingMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | RentalBookingDefaultArgs<ExtArgs>
  }
  export type BookingMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | RentalBookingDefaultArgs<ExtArgs>
  }

  export type $BookingMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingMessage"
    objects: {
      booking: Prisma.$RentalBookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      senderId: string
      senderRole: string
      message: string
      isRead: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bookingMessage"]>
    composites: {}
  }

  type BookingMessageGetPayload<S extends boolean | null | undefined | BookingMessageDefaultArgs> = $Result.GetResult<Prisma.$BookingMessagePayload, S>

  type BookingMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingMessageCountAggregateInputType | true
    }

  export interface BookingMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingMessage'], meta: { name: 'BookingMessage' } }
    /**
     * Find zero or one BookingMessage that matches the filter.
     * @param {BookingMessageFindUniqueArgs} args - Arguments to find a BookingMessage
     * @example
     * // Get one BookingMessage
     * const bookingMessage = await prisma.bookingMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingMessageFindUniqueArgs>(args: SelectSubset<T, BookingMessageFindUniqueArgs<ExtArgs>>): Prisma__BookingMessageClient<$Result.GetResult<Prisma.$BookingMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingMessageFindUniqueOrThrowArgs} args - Arguments to find a BookingMessage
     * @example
     * // Get one BookingMessage
     * const bookingMessage = await prisma.bookingMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingMessageClient<$Result.GetResult<Prisma.$BookingMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingMessageFindFirstArgs} args - Arguments to find a BookingMessage
     * @example
     * // Get one BookingMessage
     * const bookingMessage = await prisma.bookingMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingMessageFindFirstArgs>(args?: SelectSubset<T, BookingMessageFindFirstArgs<ExtArgs>>): Prisma__BookingMessageClient<$Result.GetResult<Prisma.$BookingMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingMessageFindFirstOrThrowArgs} args - Arguments to find a BookingMessage
     * @example
     * // Get one BookingMessage
     * const bookingMessage = await prisma.bookingMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingMessageClient<$Result.GetResult<Prisma.$BookingMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingMessages
     * const bookingMessages = await prisma.bookingMessage.findMany()
     * 
     * // Get first 10 BookingMessages
     * const bookingMessages = await prisma.bookingMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingMessageWithIdOnly = await prisma.bookingMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingMessageFindManyArgs>(args?: SelectSubset<T, BookingMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingMessage.
     * @param {BookingMessageCreateArgs} args - Arguments to create a BookingMessage.
     * @example
     * // Create one BookingMessage
     * const BookingMessage = await prisma.bookingMessage.create({
     *   data: {
     *     // ... data to create a BookingMessage
     *   }
     * })
     * 
     */
    create<T extends BookingMessageCreateArgs>(args: SelectSubset<T, BookingMessageCreateArgs<ExtArgs>>): Prisma__BookingMessageClient<$Result.GetResult<Prisma.$BookingMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingMessages.
     * @param {BookingMessageCreateManyArgs} args - Arguments to create many BookingMessages.
     * @example
     * // Create many BookingMessages
     * const bookingMessage = await prisma.bookingMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingMessageCreateManyArgs>(args?: SelectSubset<T, BookingMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingMessages and returns the data saved in the database.
     * @param {BookingMessageCreateManyAndReturnArgs} args - Arguments to create many BookingMessages.
     * @example
     * // Create many BookingMessages
     * const bookingMessage = await prisma.bookingMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingMessages and only return the `id`
     * const bookingMessageWithIdOnly = await prisma.bookingMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingMessage.
     * @param {BookingMessageDeleteArgs} args - Arguments to delete one BookingMessage.
     * @example
     * // Delete one BookingMessage
     * const BookingMessage = await prisma.bookingMessage.delete({
     *   where: {
     *     // ... filter to delete one BookingMessage
     *   }
     * })
     * 
     */
    delete<T extends BookingMessageDeleteArgs>(args: SelectSubset<T, BookingMessageDeleteArgs<ExtArgs>>): Prisma__BookingMessageClient<$Result.GetResult<Prisma.$BookingMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingMessage.
     * @param {BookingMessageUpdateArgs} args - Arguments to update one BookingMessage.
     * @example
     * // Update one BookingMessage
     * const bookingMessage = await prisma.bookingMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingMessageUpdateArgs>(args: SelectSubset<T, BookingMessageUpdateArgs<ExtArgs>>): Prisma__BookingMessageClient<$Result.GetResult<Prisma.$BookingMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingMessages.
     * @param {BookingMessageDeleteManyArgs} args - Arguments to filter BookingMessages to delete.
     * @example
     * // Delete a few BookingMessages
     * const { count } = await prisma.bookingMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingMessageDeleteManyArgs>(args?: SelectSubset<T, BookingMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingMessages
     * const bookingMessage = await prisma.bookingMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingMessageUpdateManyArgs>(args: SelectSubset<T, BookingMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingMessages and returns the data updated in the database.
     * @param {BookingMessageUpdateManyAndReturnArgs} args - Arguments to update many BookingMessages.
     * @example
     * // Update many BookingMessages
     * const bookingMessage = await prisma.bookingMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingMessages and only return the `id`
     * const bookingMessageWithIdOnly = await prisma.bookingMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingMessage.
     * @param {BookingMessageUpsertArgs} args - Arguments to update or create a BookingMessage.
     * @example
     * // Update or create a BookingMessage
     * const bookingMessage = await prisma.bookingMessage.upsert({
     *   create: {
     *     // ... data to create a BookingMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingMessage we want to update
     *   }
     * })
     */
    upsert<T extends BookingMessageUpsertArgs>(args: SelectSubset<T, BookingMessageUpsertArgs<ExtArgs>>): Prisma__BookingMessageClient<$Result.GetResult<Prisma.$BookingMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingMessageCountArgs} args - Arguments to filter BookingMessages to count.
     * @example
     * // Count the number of BookingMessages
     * const count = await prisma.bookingMessage.count({
     *   where: {
     *     // ... the filter for the BookingMessages we want to count
     *   }
     * })
    **/
    count<T extends BookingMessageCountArgs>(
      args?: Subset<T, BookingMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingMessageAggregateArgs>(args: Subset<T, BookingMessageAggregateArgs>): Prisma.PrismaPromise<GetBookingMessageAggregateType<T>>

    /**
     * Group by BookingMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingMessageGroupByArgs['orderBy'] }
        : { orderBy?: BookingMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingMessage model
   */
  readonly fields: BookingMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends RentalBookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RentalBookingDefaultArgs<ExtArgs>>): Prisma__RentalBookingClient<$Result.GetResult<Prisma.$RentalBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingMessage model
   */
  interface BookingMessageFieldRefs {
    readonly id: FieldRef<"BookingMessage", 'String'>
    readonly bookingId: FieldRef<"BookingMessage", 'String'>
    readonly senderId: FieldRef<"BookingMessage", 'String'>
    readonly senderRole: FieldRef<"BookingMessage", 'String'>
    readonly message: FieldRef<"BookingMessage", 'String'>
    readonly isRead: FieldRef<"BookingMessage", 'Boolean'>
    readonly createdAt: FieldRef<"BookingMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"BookingMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookingMessage findUnique
   */
  export type BookingMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingMessage
     */
    select?: BookingMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingMessage
     */
    omit?: BookingMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingMessageInclude<ExtArgs> | null
    /**
     * Filter, which BookingMessage to fetch.
     */
    where: BookingMessageWhereUniqueInput
  }

  /**
   * BookingMessage findUniqueOrThrow
   */
  export type BookingMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingMessage
     */
    select?: BookingMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingMessage
     */
    omit?: BookingMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingMessageInclude<ExtArgs> | null
    /**
     * Filter, which BookingMessage to fetch.
     */
    where: BookingMessageWhereUniqueInput
  }

  /**
   * BookingMessage findFirst
   */
  export type BookingMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingMessage
     */
    select?: BookingMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingMessage
     */
    omit?: BookingMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingMessageInclude<ExtArgs> | null
    /**
     * Filter, which BookingMessage to fetch.
     */
    where?: BookingMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingMessages to fetch.
     */
    orderBy?: BookingMessageOrderByWithRelationInput | BookingMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingMessages.
     */
    cursor?: BookingMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingMessages.
     */
    distinct?: BookingMessageScalarFieldEnum | BookingMessageScalarFieldEnum[]
  }

  /**
   * BookingMessage findFirstOrThrow
   */
  export type BookingMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingMessage
     */
    select?: BookingMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingMessage
     */
    omit?: BookingMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingMessageInclude<ExtArgs> | null
    /**
     * Filter, which BookingMessage to fetch.
     */
    where?: BookingMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingMessages to fetch.
     */
    orderBy?: BookingMessageOrderByWithRelationInput | BookingMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingMessages.
     */
    cursor?: BookingMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingMessages.
     */
    distinct?: BookingMessageScalarFieldEnum | BookingMessageScalarFieldEnum[]
  }

  /**
   * BookingMessage findMany
   */
  export type BookingMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingMessage
     */
    select?: BookingMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingMessage
     */
    omit?: BookingMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingMessageInclude<ExtArgs> | null
    /**
     * Filter, which BookingMessages to fetch.
     */
    where?: BookingMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingMessages to fetch.
     */
    orderBy?: BookingMessageOrderByWithRelationInput | BookingMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingMessages.
     */
    cursor?: BookingMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingMessages.
     */
    skip?: number
    distinct?: BookingMessageScalarFieldEnum | BookingMessageScalarFieldEnum[]
  }

  /**
   * BookingMessage create
   */
  export type BookingMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingMessage
     */
    select?: BookingMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingMessage
     */
    omit?: BookingMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingMessage.
     */
    data: XOR<BookingMessageCreateInput, BookingMessageUncheckedCreateInput>
  }

  /**
   * BookingMessage createMany
   */
  export type BookingMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingMessages.
     */
    data: BookingMessageCreateManyInput | BookingMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingMessage createManyAndReturn
   */
  export type BookingMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingMessage
     */
    select?: BookingMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingMessage
     */
    omit?: BookingMessageOmit<ExtArgs> | null
    /**
     * The data used to create many BookingMessages.
     */
    data: BookingMessageCreateManyInput | BookingMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingMessage update
   */
  export type BookingMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingMessage
     */
    select?: BookingMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingMessage
     */
    omit?: BookingMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingMessage.
     */
    data: XOR<BookingMessageUpdateInput, BookingMessageUncheckedUpdateInput>
    /**
     * Choose, which BookingMessage to update.
     */
    where: BookingMessageWhereUniqueInput
  }

  /**
   * BookingMessage updateMany
   */
  export type BookingMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingMessages.
     */
    data: XOR<BookingMessageUpdateManyMutationInput, BookingMessageUncheckedUpdateManyInput>
    /**
     * Filter which BookingMessages to update
     */
    where?: BookingMessageWhereInput
    /**
     * Limit how many BookingMessages to update.
     */
    limit?: number
  }

  /**
   * BookingMessage updateManyAndReturn
   */
  export type BookingMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingMessage
     */
    select?: BookingMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingMessage
     */
    omit?: BookingMessageOmit<ExtArgs> | null
    /**
     * The data used to update BookingMessages.
     */
    data: XOR<BookingMessageUpdateManyMutationInput, BookingMessageUncheckedUpdateManyInput>
    /**
     * Filter which BookingMessages to update
     */
    where?: BookingMessageWhereInput
    /**
     * Limit how many BookingMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingMessage upsert
   */
  export type BookingMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingMessage
     */
    select?: BookingMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingMessage
     */
    omit?: BookingMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingMessage to update in case it exists.
     */
    where: BookingMessageWhereUniqueInput
    /**
     * In case the BookingMessage found by the `where` argument doesn't exist, create a new BookingMessage with this data.
     */
    create: XOR<BookingMessageCreateInput, BookingMessageUncheckedCreateInput>
    /**
     * In case the BookingMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingMessageUpdateInput, BookingMessageUncheckedUpdateInput>
  }

  /**
   * BookingMessage delete
   */
  export type BookingMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingMessage
     */
    select?: BookingMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingMessage
     */
    omit?: BookingMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingMessageInclude<ExtArgs> | null
    /**
     * Filter which BookingMessage to delete.
     */
    where: BookingMessageWhereUniqueInput
  }

  /**
   * BookingMessage deleteMany
   */
  export type BookingMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingMessages to delete
     */
    where?: BookingMessageWhereInput
    /**
     * Limit how many BookingMessages to delete.
     */
    limit?: number
  }

  /**
   * BookingMessage without action
   */
  export type BookingMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingMessage
     */
    select?: BookingMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingMessage
     */
    omit?: BookingMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingMessageInclude<ExtArgs> | null
  }


  /**
   * Model BookingGuest
   */

  export type AggregateBookingGuest = {
    _count: BookingGuestCountAggregateOutputType | null
    _avg: BookingGuestAvgAggregateOutputType | null
    _sum: BookingGuestSumAggregateOutputType | null
    _min: BookingGuestMinAggregateOutputType | null
    _max: BookingGuestMaxAggregateOutputType | null
  }

  export type BookingGuestAvgAggregateOutputType = {
    guestNumber: number | null
    ocrConfidence: number | null
  }

  export type BookingGuestSumAggregateOutputType = {
    guestNumber: number | null
    ocrConfidence: number | null
  }

  export type BookingGuestMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    guestType: string | null
    guestNumber: number | null
    firstName: string | null
    lastName: string | null
    fullName: string | null
    dateOfBirth: Date | null
    nationality: string | null
    gender: string | null
    passportNumber: string | null
    passportExpiry: Date | null
    passportIssueDate: Date | null
    passportCountry: string | null
    passportImageUrl: string | null
    passportImagePath: string | null
    ocrConfidence: number | null
    ocrProcessedAt: Date | null
    passportVerified: boolean | null
    verifiedBy: string | null
    verifiedAt: Date | null
    tm30Status: $Enums.TM30GuestStatus | null
    tm30SubmittedAt: Date | null
    tm30Error: string | null
    whatsappMessageId: string | null
    whatsappReceivedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingGuestMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    guestType: string | null
    guestNumber: number | null
    firstName: string | null
    lastName: string | null
    fullName: string | null
    dateOfBirth: Date | null
    nationality: string | null
    gender: string | null
    passportNumber: string | null
    passportExpiry: Date | null
    passportIssueDate: Date | null
    passportCountry: string | null
    passportImageUrl: string | null
    passportImagePath: string | null
    ocrConfidence: number | null
    ocrProcessedAt: Date | null
    passportVerified: boolean | null
    verifiedBy: string | null
    verifiedAt: Date | null
    tm30Status: $Enums.TM30GuestStatus | null
    tm30SubmittedAt: Date | null
    tm30Error: string | null
    whatsappMessageId: string | null
    whatsappReceivedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingGuestCountAggregateOutputType = {
    id: number
    bookingId: number
    guestType: number
    guestNumber: number
    firstName: number
    lastName: number
    fullName: number
    dateOfBirth: number
    nationality: number
    gender: number
    passportNumber: number
    passportExpiry: number
    passportIssueDate: number
    passportCountry: number
    passportImageUrl: number
    passportImagePath: number
    ocrConfidence: number
    ocrRawData: number
    ocrProcessedAt: number
    passportVerified: number
    verifiedBy: number
    verifiedAt: number
    tm30Status: number
    tm30SubmittedAt: number
    tm30Error: number
    whatsappMessageId: number
    whatsappReceivedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingGuestAvgAggregateInputType = {
    guestNumber?: true
    ocrConfidence?: true
  }

  export type BookingGuestSumAggregateInputType = {
    guestNumber?: true
    ocrConfidence?: true
  }

  export type BookingGuestMinAggregateInputType = {
    id?: true
    bookingId?: true
    guestType?: true
    guestNumber?: true
    firstName?: true
    lastName?: true
    fullName?: true
    dateOfBirth?: true
    nationality?: true
    gender?: true
    passportNumber?: true
    passportExpiry?: true
    passportIssueDate?: true
    passportCountry?: true
    passportImageUrl?: true
    passportImagePath?: true
    ocrConfidence?: true
    ocrProcessedAt?: true
    passportVerified?: true
    verifiedBy?: true
    verifiedAt?: true
    tm30Status?: true
    tm30SubmittedAt?: true
    tm30Error?: true
    whatsappMessageId?: true
    whatsappReceivedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingGuestMaxAggregateInputType = {
    id?: true
    bookingId?: true
    guestType?: true
    guestNumber?: true
    firstName?: true
    lastName?: true
    fullName?: true
    dateOfBirth?: true
    nationality?: true
    gender?: true
    passportNumber?: true
    passportExpiry?: true
    passportIssueDate?: true
    passportCountry?: true
    passportImageUrl?: true
    passportImagePath?: true
    ocrConfidence?: true
    ocrProcessedAt?: true
    passportVerified?: true
    verifiedBy?: true
    verifiedAt?: true
    tm30Status?: true
    tm30SubmittedAt?: true
    tm30Error?: true
    whatsappMessageId?: true
    whatsappReceivedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingGuestCountAggregateInputType = {
    id?: true
    bookingId?: true
    guestType?: true
    guestNumber?: true
    firstName?: true
    lastName?: true
    fullName?: true
    dateOfBirth?: true
    nationality?: true
    gender?: true
    passportNumber?: true
    passportExpiry?: true
    passportIssueDate?: true
    passportCountry?: true
    passportImageUrl?: true
    passportImagePath?: true
    ocrConfidence?: true
    ocrRawData?: true
    ocrProcessedAt?: true
    passportVerified?: true
    verifiedBy?: true
    verifiedAt?: true
    tm30Status?: true
    tm30SubmittedAt?: true
    tm30Error?: true
    whatsappMessageId?: true
    whatsappReceivedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingGuestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingGuest to aggregate.
     */
    where?: BookingGuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingGuests to fetch.
     */
    orderBy?: BookingGuestOrderByWithRelationInput | BookingGuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingGuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingGuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingGuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingGuests
    **/
    _count?: true | BookingGuestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingGuestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingGuestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingGuestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingGuestMaxAggregateInputType
  }

  export type GetBookingGuestAggregateType<T extends BookingGuestAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingGuest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingGuest[P]>
      : GetScalarType<T[P], AggregateBookingGuest[P]>
  }




  export type BookingGuestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingGuestWhereInput
    orderBy?: BookingGuestOrderByWithAggregationInput | BookingGuestOrderByWithAggregationInput[]
    by: BookingGuestScalarFieldEnum[] | BookingGuestScalarFieldEnum
    having?: BookingGuestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingGuestCountAggregateInputType | true
    _avg?: BookingGuestAvgAggregateInputType
    _sum?: BookingGuestSumAggregateInputType
    _min?: BookingGuestMinAggregateInputType
    _max?: BookingGuestMaxAggregateInputType
  }

  export type BookingGuestGroupByOutputType = {
    id: string
    bookingId: string
    guestType: string
    guestNumber: number
    firstName: string | null
    lastName: string | null
    fullName: string | null
    dateOfBirth: Date | null
    nationality: string | null
    gender: string | null
    passportNumber: string | null
    passportExpiry: Date | null
    passportIssueDate: Date | null
    passportCountry: string | null
    passportImageUrl: string | null
    passportImagePath: string | null
    ocrConfidence: number | null
    ocrRawData: JsonValue | null
    ocrProcessedAt: Date | null
    passportVerified: boolean
    verifiedBy: string | null
    verifiedAt: Date | null
    tm30Status: $Enums.TM30GuestStatus
    tm30SubmittedAt: Date | null
    tm30Error: string | null
    whatsappMessageId: string | null
    whatsappReceivedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: BookingGuestCountAggregateOutputType | null
    _avg: BookingGuestAvgAggregateOutputType | null
    _sum: BookingGuestSumAggregateOutputType | null
    _min: BookingGuestMinAggregateOutputType | null
    _max: BookingGuestMaxAggregateOutputType | null
  }

  type GetBookingGuestGroupByPayload<T extends BookingGuestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGuestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGuestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGuestGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGuestGroupByOutputType[P]>
        }
      >
    >


  export type BookingGuestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    guestType?: boolean
    guestNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    dateOfBirth?: boolean
    nationality?: boolean
    gender?: boolean
    passportNumber?: boolean
    passportExpiry?: boolean
    passportIssueDate?: boolean
    passportCountry?: boolean
    passportImageUrl?: boolean
    passportImagePath?: boolean
    ocrConfidence?: boolean
    ocrRawData?: boolean
    ocrProcessedAt?: boolean
    passportVerified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    tm30Status?: boolean
    tm30SubmittedAt?: boolean
    tm30Error?: boolean
    whatsappMessageId?: boolean
    whatsappReceivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | RentalBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingGuest"]>

  export type BookingGuestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    guestType?: boolean
    guestNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    dateOfBirth?: boolean
    nationality?: boolean
    gender?: boolean
    passportNumber?: boolean
    passportExpiry?: boolean
    passportIssueDate?: boolean
    passportCountry?: boolean
    passportImageUrl?: boolean
    passportImagePath?: boolean
    ocrConfidence?: boolean
    ocrRawData?: boolean
    ocrProcessedAt?: boolean
    passportVerified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    tm30Status?: boolean
    tm30SubmittedAt?: boolean
    tm30Error?: boolean
    whatsappMessageId?: boolean
    whatsappReceivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | RentalBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingGuest"]>

  export type BookingGuestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    guestType?: boolean
    guestNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    dateOfBirth?: boolean
    nationality?: boolean
    gender?: boolean
    passportNumber?: boolean
    passportExpiry?: boolean
    passportIssueDate?: boolean
    passportCountry?: boolean
    passportImageUrl?: boolean
    passportImagePath?: boolean
    ocrConfidence?: boolean
    ocrRawData?: boolean
    ocrProcessedAt?: boolean
    passportVerified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    tm30Status?: boolean
    tm30SubmittedAt?: boolean
    tm30Error?: boolean
    whatsappMessageId?: boolean
    whatsappReceivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | RentalBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingGuest"]>

  export type BookingGuestSelectScalar = {
    id?: boolean
    bookingId?: boolean
    guestType?: boolean
    guestNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    dateOfBirth?: boolean
    nationality?: boolean
    gender?: boolean
    passportNumber?: boolean
    passportExpiry?: boolean
    passportIssueDate?: boolean
    passportCountry?: boolean
    passportImageUrl?: boolean
    passportImagePath?: boolean
    ocrConfidence?: boolean
    ocrRawData?: boolean
    ocrProcessedAt?: boolean
    passportVerified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    tm30Status?: boolean
    tm30SubmittedAt?: boolean
    tm30Error?: boolean
    whatsappMessageId?: boolean
    whatsappReceivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingGuestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "guestType" | "guestNumber" | "firstName" | "lastName" | "fullName" | "dateOfBirth" | "nationality" | "gender" | "passportNumber" | "passportExpiry" | "passportIssueDate" | "passportCountry" | "passportImageUrl" | "passportImagePath" | "ocrConfidence" | "ocrRawData" | "ocrProcessedAt" | "passportVerified" | "verifiedBy" | "verifiedAt" | "tm30Status" | "tm30SubmittedAt" | "tm30Error" | "whatsappMessageId" | "whatsappReceivedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["bookingGuest"]>
  export type BookingGuestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | RentalBookingDefaultArgs<ExtArgs>
  }
  export type BookingGuestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | RentalBookingDefaultArgs<ExtArgs>
  }
  export type BookingGuestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | RentalBookingDefaultArgs<ExtArgs>
  }

  export type $BookingGuestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingGuest"
    objects: {
      booking: Prisma.$RentalBookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      guestType: string
      guestNumber: number
      firstName: string | null
      lastName: string | null
      fullName: string | null
      dateOfBirth: Date | null
      nationality: string | null
      gender: string | null
      passportNumber: string | null
      passportExpiry: Date | null
      passportIssueDate: Date | null
      passportCountry: string | null
      passportImageUrl: string | null
      passportImagePath: string | null
      ocrConfidence: number | null
      ocrRawData: Prisma.JsonValue | null
      ocrProcessedAt: Date | null
      passportVerified: boolean
      verifiedBy: string | null
      verifiedAt: Date | null
      tm30Status: $Enums.TM30GuestStatus
      tm30SubmittedAt: Date | null
      tm30Error: string | null
      whatsappMessageId: string | null
      whatsappReceivedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bookingGuest"]>
    composites: {}
  }

  type BookingGuestGetPayload<S extends boolean | null | undefined | BookingGuestDefaultArgs> = $Result.GetResult<Prisma.$BookingGuestPayload, S>

  type BookingGuestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingGuestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingGuestCountAggregateInputType | true
    }

  export interface BookingGuestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingGuest'], meta: { name: 'BookingGuest' } }
    /**
     * Find zero or one BookingGuest that matches the filter.
     * @param {BookingGuestFindUniqueArgs} args - Arguments to find a BookingGuest
     * @example
     * // Get one BookingGuest
     * const bookingGuest = await prisma.bookingGuest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingGuestFindUniqueArgs>(args: SelectSubset<T, BookingGuestFindUniqueArgs<ExtArgs>>): Prisma__BookingGuestClient<$Result.GetResult<Prisma.$BookingGuestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingGuest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingGuestFindUniqueOrThrowArgs} args - Arguments to find a BookingGuest
     * @example
     * // Get one BookingGuest
     * const bookingGuest = await prisma.bookingGuest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingGuestFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingGuestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingGuestClient<$Result.GetResult<Prisma.$BookingGuestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingGuest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGuestFindFirstArgs} args - Arguments to find a BookingGuest
     * @example
     * // Get one BookingGuest
     * const bookingGuest = await prisma.bookingGuest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingGuestFindFirstArgs>(args?: SelectSubset<T, BookingGuestFindFirstArgs<ExtArgs>>): Prisma__BookingGuestClient<$Result.GetResult<Prisma.$BookingGuestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingGuest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGuestFindFirstOrThrowArgs} args - Arguments to find a BookingGuest
     * @example
     * // Get one BookingGuest
     * const bookingGuest = await prisma.bookingGuest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingGuestFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingGuestFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingGuestClient<$Result.GetResult<Prisma.$BookingGuestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingGuests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGuestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingGuests
     * const bookingGuests = await prisma.bookingGuest.findMany()
     * 
     * // Get first 10 BookingGuests
     * const bookingGuests = await prisma.bookingGuest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingGuestWithIdOnly = await prisma.bookingGuest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingGuestFindManyArgs>(args?: SelectSubset<T, BookingGuestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingGuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingGuest.
     * @param {BookingGuestCreateArgs} args - Arguments to create a BookingGuest.
     * @example
     * // Create one BookingGuest
     * const BookingGuest = await prisma.bookingGuest.create({
     *   data: {
     *     // ... data to create a BookingGuest
     *   }
     * })
     * 
     */
    create<T extends BookingGuestCreateArgs>(args: SelectSubset<T, BookingGuestCreateArgs<ExtArgs>>): Prisma__BookingGuestClient<$Result.GetResult<Prisma.$BookingGuestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingGuests.
     * @param {BookingGuestCreateManyArgs} args - Arguments to create many BookingGuests.
     * @example
     * // Create many BookingGuests
     * const bookingGuest = await prisma.bookingGuest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingGuestCreateManyArgs>(args?: SelectSubset<T, BookingGuestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingGuests and returns the data saved in the database.
     * @param {BookingGuestCreateManyAndReturnArgs} args - Arguments to create many BookingGuests.
     * @example
     * // Create many BookingGuests
     * const bookingGuest = await prisma.bookingGuest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingGuests and only return the `id`
     * const bookingGuestWithIdOnly = await prisma.bookingGuest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingGuestCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingGuestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingGuestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingGuest.
     * @param {BookingGuestDeleteArgs} args - Arguments to delete one BookingGuest.
     * @example
     * // Delete one BookingGuest
     * const BookingGuest = await prisma.bookingGuest.delete({
     *   where: {
     *     // ... filter to delete one BookingGuest
     *   }
     * })
     * 
     */
    delete<T extends BookingGuestDeleteArgs>(args: SelectSubset<T, BookingGuestDeleteArgs<ExtArgs>>): Prisma__BookingGuestClient<$Result.GetResult<Prisma.$BookingGuestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingGuest.
     * @param {BookingGuestUpdateArgs} args - Arguments to update one BookingGuest.
     * @example
     * // Update one BookingGuest
     * const bookingGuest = await prisma.bookingGuest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingGuestUpdateArgs>(args: SelectSubset<T, BookingGuestUpdateArgs<ExtArgs>>): Prisma__BookingGuestClient<$Result.GetResult<Prisma.$BookingGuestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingGuests.
     * @param {BookingGuestDeleteManyArgs} args - Arguments to filter BookingGuests to delete.
     * @example
     * // Delete a few BookingGuests
     * const { count } = await prisma.bookingGuest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingGuestDeleteManyArgs>(args?: SelectSubset<T, BookingGuestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingGuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGuestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingGuests
     * const bookingGuest = await prisma.bookingGuest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingGuestUpdateManyArgs>(args: SelectSubset<T, BookingGuestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingGuests and returns the data updated in the database.
     * @param {BookingGuestUpdateManyAndReturnArgs} args - Arguments to update many BookingGuests.
     * @example
     * // Update many BookingGuests
     * const bookingGuest = await prisma.bookingGuest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingGuests and only return the `id`
     * const bookingGuestWithIdOnly = await prisma.bookingGuest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingGuestUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingGuestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingGuestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingGuest.
     * @param {BookingGuestUpsertArgs} args - Arguments to update or create a BookingGuest.
     * @example
     * // Update or create a BookingGuest
     * const bookingGuest = await prisma.bookingGuest.upsert({
     *   create: {
     *     // ... data to create a BookingGuest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingGuest we want to update
     *   }
     * })
     */
    upsert<T extends BookingGuestUpsertArgs>(args: SelectSubset<T, BookingGuestUpsertArgs<ExtArgs>>): Prisma__BookingGuestClient<$Result.GetResult<Prisma.$BookingGuestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingGuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGuestCountArgs} args - Arguments to filter BookingGuests to count.
     * @example
     * // Count the number of BookingGuests
     * const count = await prisma.bookingGuest.count({
     *   where: {
     *     // ... the filter for the BookingGuests we want to count
     *   }
     * })
    **/
    count<T extends BookingGuestCountArgs>(
      args?: Subset<T, BookingGuestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingGuestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingGuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGuestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingGuestAggregateArgs>(args: Subset<T, BookingGuestAggregateArgs>): Prisma.PrismaPromise<GetBookingGuestAggregateType<T>>

    /**
     * Group by BookingGuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGuestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGuestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGuestGroupByArgs['orderBy'] }
        : { orderBy?: BookingGuestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGuestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGuestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingGuest model
   */
  readonly fields: BookingGuestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingGuest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingGuestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends RentalBookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RentalBookingDefaultArgs<ExtArgs>>): Prisma__RentalBookingClient<$Result.GetResult<Prisma.$RentalBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingGuest model
   */
  interface BookingGuestFieldRefs {
    readonly id: FieldRef<"BookingGuest", 'String'>
    readonly bookingId: FieldRef<"BookingGuest", 'String'>
    readonly guestType: FieldRef<"BookingGuest", 'String'>
    readonly guestNumber: FieldRef<"BookingGuest", 'Int'>
    readonly firstName: FieldRef<"BookingGuest", 'String'>
    readonly lastName: FieldRef<"BookingGuest", 'String'>
    readonly fullName: FieldRef<"BookingGuest", 'String'>
    readonly dateOfBirth: FieldRef<"BookingGuest", 'DateTime'>
    readonly nationality: FieldRef<"BookingGuest", 'String'>
    readonly gender: FieldRef<"BookingGuest", 'String'>
    readonly passportNumber: FieldRef<"BookingGuest", 'String'>
    readonly passportExpiry: FieldRef<"BookingGuest", 'DateTime'>
    readonly passportIssueDate: FieldRef<"BookingGuest", 'DateTime'>
    readonly passportCountry: FieldRef<"BookingGuest", 'String'>
    readonly passportImageUrl: FieldRef<"BookingGuest", 'String'>
    readonly passportImagePath: FieldRef<"BookingGuest", 'String'>
    readonly ocrConfidence: FieldRef<"BookingGuest", 'Float'>
    readonly ocrRawData: FieldRef<"BookingGuest", 'Json'>
    readonly ocrProcessedAt: FieldRef<"BookingGuest", 'DateTime'>
    readonly passportVerified: FieldRef<"BookingGuest", 'Boolean'>
    readonly verifiedBy: FieldRef<"BookingGuest", 'String'>
    readonly verifiedAt: FieldRef<"BookingGuest", 'DateTime'>
    readonly tm30Status: FieldRef<"BookingGuest", 'TM30GuestStatus'>
    readonly tm30SubmittedAt: FieldRef<"BookingGuest", 'DateTime'>
    readonly tm30Error: FieldRef<"BookingGuest", 'String'>
    readonly whatsappMessageId: FieldRef<"BookingGuest", 'String'>
    readonly whatsappReceivedAt: FieldRef<"BookingGuest", 'DateTime'>
    readonly createdAt: FieldRef<"BookingGuest", 'DateTime'>
    readonly updatedAt: FieldRef<"BookingGuest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookingGuest findUnique
   */
  export type BookingGuestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingGuest
     */
    select?: BookingGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingGuest
     */
    omit?: BookingGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingGuestInclude<ExtArgs> | null
    /**
     * Filter, which BookingGuest to fetch.
     */
    where: BookingGuestWhereUniqueInput
  }

  /**
   * BookingGuest findUniqueOrThrow
   */
  export type BookingGuestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingGuest
     */
    select?: BookingGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingGuest
     */
    omit?: BookingGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingGuestInclude<ExtArgs> | null
    /**
     * Filter, which BookingGuest to fetch.
     */
    where: BookingGuestWhereUniqueInput
  }

  /**
   * BookingGuest findFirst
   */
  export type BookingGuestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingGuest
     */
    select?: BookingGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingGuest
     */
    omit?: BookingGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingGuestInclude<ExtArgs> | null
    /**
     * Filter, which BookingGuest to fetch.
     */
    where?: BookingGuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingGuests to fetch.
     */
    orderBy?: BookingGuestOrderByWithRelationInput | BookingGuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingGuests.
     */
    cursor?: BookingGuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingGuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingGuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingGuests.
     */
    distinct?: BookingGuestScalarFieldEnum | BookingGuestScalarFieldEnum[]
  }

  /**
   * BookingGuest findFirstOrThrow
   */
  export type BookingGuestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingGuest
     */
    select?: BookingGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingGuest
     */
    omit?: BookingGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingGuestInclude<ExtArgs> | null
    /**
     * Filter, which BookingGuest to fetch.
     */
    where?: BookingGuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingGuests to fetch.
     */
    orderBy?: BookingGuestOrderByWithRelationInput | BookingGuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingGuests.
     */
    cursor?: BookingGuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingGuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingGuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingGuests.
     */
    distinct?: BookingGuestScalarFieldEnum | BookingGuestScalarFieldEnum[]
  }

  /**
   * BookingGuest findMany
   */
  export type BookingGuestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingGuest
     */
    select?: BookingGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingGuest
     */
    omit?: BookingGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingGuestInclude<ExtArgs> | null
    /**
     * Filter, which BookingGuests to fetch.
     */
    where?: BookingGuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingGuests to fetch.
     */
    orderBy?: BookingGuestOrderByWithRelationInput | BookingGuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingGuests.
     */
    cursor?: BookingGuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingGuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingGuests.
     */
    skip?: number
    distinct?: BookingGuestScalarFieldEnum | BookingGuestScalarFieldEnum[]
  }

  /**
   * BookingGuest create
   */
  export type BookingGuestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingGuest
     */
    select?: BookingGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingGuest
     */
    omit?: BookingGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingGuestInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingGuest.
     */
    data: XOR<BookingGuestCreateInput, BookingGuestUncheckedCreateInput>
  }

  /**
   * BookingGuest createMany
   */
  export type BookingGuestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingGuests.
     */
    data: BookingGuestCreateManyInput | BookingGuestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingGuest createManyAndReturn
   */
  export type BookingGuestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingGuest
     */
    select?: BookingGuestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingGuest
     */
    omit?: BookingGuestOmit<ExtArgs> | null
    /**
     * The data used to create many BookingGuests.
     */
    data: BookingGuestCreateManyInput | BookingGuestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingGuestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingGuest update
   */
  export type BookingGuestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingGuest
     */
    select?: BookingGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingGuest
     */
    omit?: BookingGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingGuestInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingGuest.
     */
    data: XOR<BookingGuestUpdateInput, BookingGuestUncheckedUpdateInput>
    /**
     * Choose, which BookingGuest to update.
     */
    where: BookingGuestWhereUniqueInput
  }

  /**
   * BookingGuest updateMany
   */
  export type BookingGuestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingGuests.
     */
    data: XOR<BookingGuestUpdateManyMutationInput, BookingGuestUncheckedUpdateManyInput>
    /**
     * Filter which BookingGuests to update
     */
    where?: BookingGuestWhereInput
    /**
     * Limit how many BookingGuests to update.
     */
    limit?: number
  }

  /**
   * BookingGuest updateManyAndReturn
   */
  export type BookingGuestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingGuest
     */
    select?: BookingGuestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingGuest
     */
    omit?: BookingGuestOmit<ExtArgs> | null
    /**
     * The data used to update BookingGuests.
     */
    data: XOR<BookingGuestUpdateManyMutationInput, BookingGuestUncheckedUpdateManyInput>
    /**
     * Filter which BookingGuests to update
     */
    where?: BookingGuestWhereInput
    /**
     * Limit how many BookingGuests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingGuestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingGuest upsert
   */
  export type BookingGuestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingGuest
     */
    select?: BookingGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingGuest
     */
    omit?: BookingGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingGuestInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingGuest to update in case it exists.
     */
    where: BookingGuestWhereUniqueInput
    /**
     * In case the BookingGuest found by the `where` argument doesn't exist, create a new BookingGuest with this data.
     */
    create: XOR<BookingGuestCreateInput, BookingGuestUncheckedCreateInput>
    /**
     * In case the BookingGuest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingGuestUpdateInput, BookingGuestUncheckedUpdateInput>
  }

  /**
   * BookingGuest delete
   */
  export type BookingGuestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingGuest
     */
    select?: BookingGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingGuest
     */
    omit?: BookingGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingGuestInclude<ExtArgs> | null
    /**
     * Filter which BookingGuest to delete.
     */
    where: BookingGuestWhereUniqueInput
  }

  /**
   * BookingGuest deleteMany
   */
  export type BookingGuestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingGuests to delete
     */
    where?: BookingGuestWhereInput
    /**
     * Limit how many BookingGuests to delete.
     */
    limit?: number
  }

  /**
   * BookingGuest without action
   */
  export type BookingGuestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingGuest
     */
    select?: BookingGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingGuest
     */
    omit?: BookingGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingGuestInclude<ExtArgs> | null
  }


  /**
   * Model PropertyBlockedDate
   */

  export type AggregatePropertyBlockedDate = {
    _count: PropertyBlockedDateCountAggregateOutputType | null
    _min: PropertyBlockedDateMinAggregateOutputType | null
    _max: PropertyBlockedDateMaxAggregateOutputType | null
  }

  export type PropertyBlockedDateMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    startDate: Date | null
    endDate: Date | null
    reason: string | null
    blockedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyBlockedDateMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    startDate: Date | null
    endDate: Date | null
    reason: string | null
    blockedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyBlockedDateCountAggregateOutputType = {
    id: number
    propertyId: number
    startDate: number
    endDate: number
    reason: number
    blockedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyBlockedDateMinAggregateInputType = {
    id?: true
    propertyId?: true
    startDate?: true
    endDate?: true
    reason?: true
    blockedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyBlockedDateMaxAggregateInputType = {
    id?: true
    propertyId?: true
    startDate?: true
    endDate?: true
    reason?: true
    blockedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyBlockedDateCountAggregateInputType = {
    id?: true
    propertyId?: true
    startDate?: true
    endDate?: true
    reason?: true
    blockedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyBlockedDateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyBlockedDate to aggregate.
     */
    where?: PropertyBlockedDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyBlockedDates to fetch.
     */
    orderBy?: PropertyBlockedDateOrderByWithRelationInput | PropertyBlockedDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyBlockedDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyBlockedDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyBlockedDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyBlockedDates
    **/
    _count?: true | PropertyBlockedDateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyBlockedDateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyBlockedDateMaxAggregateInputType
  }

  export type GetPropertyBlockedDateAggregateType<T extends PropertyBlockedDateAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyBlockedDate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyBlockedDate[P]>
      : GetScalarType<T[P], AggregatePropertyBlockedDate[P]>
  }




  export type PropertyBlockedDateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyBlockedDateWhereInput
    orderBy?: PropertyBlockedDateOrderByWithAggregationInput | PropertyBlockedDateOrderByWithAggregationInput[]
    by: PropertyBlockedDateScalarFieldEnum[] | PropertyBlockedDateScalarFieldEnum
    having?: PropertyBlockedDateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyBlockedDateCountAggregateInputType | true
    _min?: PropertyBlockedDateMinAggregateInputType
    _max?: PropertyBlockedDateMaxAggregateInputType
  }

  export type PropertyBlockedDateGroupByOutputType = {
    id: string
    propertyId: string
    startDate: Date
    endDate: Date
    reason: string | null
    blockedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: PropertyBlockedDateCountAggregateOutputType | null
    _min: PropertyBlockedDateMinAggregateOutputType | null
    _max: PropertyBlockedDateMaxAggregateOutputType | null
  }

  type GetPropertyBlockedDateGroupByPayload<T extends PropertyBlockedDateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyBlockedDateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyBlockedDateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyBlockedDateGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyBlockedDateGroupByOutputType[P]>
        }
      >
    >


  export type PropertyBlockedDateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
    blockedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyBlockedDate"]>

  export type PropertyBlockedDateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
    blockedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyBlockedDate"]>

  export type PropertyBlockedDateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
    blockedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyBlockedDate"]>

  export type PropertyBlockedDateSelectScalar = {
    id?: boolean
    propertyId?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
    blockedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyBlockedDateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "startDate" | "endDate" | "reason" | "blockedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["propertyBlockedDate"]>
  export type PropertyBlockedDateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyBlockedDateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyBlockedDateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PropertyBlockedDatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyBlockedDate"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      startDate: Date
      endDate: Date
      reason: string | null
      blockedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["propertyBlockedDate"]>
    composites: {}
  }

  type PropertyBlockedDateGetPayload<S extends boolean | null | undefined | PropertyBlockedDateDefaultArgs> = $Result.GetResult<Prisma.$PropertyBlockedDatePayload, S>

  type PropertyBlockedDateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyBlockedDateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyBlockedDateCountAggregateInputType | true
    }

  export interface PropertyBlockedDateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyBlockedDate'], meta: { name: 'PropertyBlockedDate' } }
    /**
     * Find zero or one PropertyBlockedDate that matches the filter.
     * @param {PropertyBlockedDateFindUniqueArgs} args - Arguments to find a PropertyBlockedDate
     * @example
     * // Get one PropertyBlockedDate
     * const propertyBlockedDate = await prisma.propertyBlockedDate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyBlockedDateFindUniqueArgs>(args: SelectSubset<T, PropertyBlockedDateFindUniqueArgs<ExtArgs>>): Prisma__PropertyBlockedDateClient<$Result.GetResult<Prisma.$PropertyBlockedDatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyBlockedDate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyBlockedDateFindUniqueOrThrowArgs} args - Arguments to find a PropertyBlockedDate
     * @example
     * // Get one PropertyBlockedDate
     * const propertyBlockedDate = await prisma.propertyBlockedDate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyBlockedDateFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyBlockedDateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyBlockedDateClient<$Result.GetResult<Prisma.$PropertyBlockedDatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyBlockedDate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyBlockedDateFindFirstArgs} args - Arguments to find a PropertyBlockedDate
     * @example
     * // Get one PropertyBlockedDate
     * const propertyBlockedDate = await prisma.propertyBlockedDate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyBlockedDateFindFirstArgs>(args?: SelectSubset<T, PropertyBlockedDateFindFirstArgs<ExtArgs>>): Prisma__PropertyBlockedDateClient<$Result.GetResult<Prisma.$PropertyBlockedDatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyBlockedDate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyBlockedDateFindFirstOrThrowArgs} args - Arguments to find a PropertyBlockedDate
     * @example
     * // Get one PropertyBlockedDate
     * const propertyBlockedDate = await prisma.propertyBlockedDate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyBlockedDateFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyBlockedDateFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyBlockedDateClient<$Result.GetResult<Prisma.$PropertyBlockedDatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyBlockedDates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyBlockedDateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyBlockedDates
     * const propertyBlockedDates = await prisma.propertyBlockedDate.findMany()
     * 
     * // Get first 10 PropertyBlockedDates
     * const propertyBlockedDates = await prisma.propertyBlockedDate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyBlockedDateWithIdOnly = await prisma.propertyBlockedDate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyBlockedDateFindManyArgs>(args?: SelectSubset<T, PropertyBlockedDateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyBlockedDatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyBlockedDate.
     * @param {PropertyBlockedDateCreateArgs} args - Arguments to create a PropertyBlockedDate.
     * @example
     * // Create one PropertyBlockedDate
     * const PropertyBlockedDate = await prisma.propertyBlockedDate.create({
     *   data: {
     *     // ... data to create a PropertyBlockedDate
     *   }
     * })
     * 
     */
    create<T extends PropertyBlockedDateCreateArgs>(args: SelectSubset<T, PropertyBlockedDateCreateArgs<ExtArgs>>): Prisma__PropertyBlockedDateClient<$Result.GetResult<Prisma.$PropertyBlockedDatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyBlockedDates.
     * @param {PropertyBlockedDateCreateManyArgs} args - Arguments to create many PropertyBlockedDates.
     * @example
     * // Create many PropertyBlockedDates
     * const propertyBlockedDate = await prisma.propertyBlockedDate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyBlockedDateCreateManyArgs>(args?: SelectSubset<T, PropertyBlockedDateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyBlockedDates and returns the data saved in the database.
     * @param {PropertyBlockedDateCreateManyAndReturnArgs} args - Arguments to create many PropertyBlockedDates.
     * @example
     * // Create many PropertyBlockedDates
     * const propertyBlockedDate = await prisma.propertyBlockedDate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyBlockedDates and only return the `id`
     * const propertyBlockedDateWithIdOnly = await prisma.propertyBlockedDate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyBlockedDateCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyBlockedDateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyBlockedDatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyBlockedDate.
     * @param {PropertyBlockedDateDeleteArgs} args - Arguments to delete one PropertyBlockedDate.
     * @example
     * // Delete one PropertyBlockedDate
     * const PropertyBlockedDate = await prisma.propertyBlockedDate.delete({
     *   where: {
     *     // ... filter to delete one PropertyBlockedDate
     *   }
     * })
     * 
     */
    delete<T extends PropertyBlockedDateDeleteArgs>(args: SelectSubset<T, PropertyBlockedDateDeleteArgs<ExtArgs>>): Prisma__PropertyBlockedDateClient<$Result.GetResult<Prisma.$PropertyBlockedDatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyBlockedDate.
     * @param {PropertyBlockedDateUpdateArgs} args - Arguments to update one PropertyBlockedDate.
     * @example
     * // Update one PropertyBlockedDate
     * const propertyBlockedDate = await prisma.propertyBlockedDate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyBlockedDateUpdateArgs>(args: SelectSubset<T, PropertyBlockedDateUpdateArgs<ExtArgs>>): Prisma__PropertyBlockedDateClient<$Result.GetResult<Prisma.$PropertyBlockedDatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyBlockedDates.
     * @param {PropertyBlockedDateDeleteManyArgs} args - Arguments to filter PropertyBlockedDates to delete.
     * @example
     * // Delete a few PropertyBlockedDates
     * const { count } = await prisma.propertyBlockedDate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyBlockedDateDeleteManyArgs>(args?: SelectSubset<T, PropertyBlockedDateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyBlockedDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyBlockedDateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyBlockedDates
     * const propertyBlockedDate = await prisma.propertyBlockedDate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyBlockedDateUpdateManyArgs>(args: SelectSubset<T, PropertyBlockedDateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyBlockedDates and returns the data updated in the database.
     * @param {PropertyBlockedDateUpdateManyAndReturnArgs} args - Arguments to update many PropertyBlockedDates.
     * @example
     * // Update many PropertyBlockedDates
     * const propertyBlockedDate = await prisma.propertyBlockedDate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyBlockedDates and only return the `id`
     * const propertyBlockedDateWithIdOnly = await prisma.propertyBlockedDate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyBlockedDateUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyBlockedDateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyBlockedDatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyBlockedDate.
     * @param {PropertyBlockedDateUpsertArgs} args - Arguments to update or create a PropertyBlockedDate.
     * @example
     * // Update or create a PropertyBlockedDate
     * const propertyBlockedDate = await prisma.propertyBlockedDate.upsert({
     *   create: {
     *     // ... data to create a PropertyBlockedDate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyBlockedDate we want to update
     *   }
     * })
     */
    upsert<T extends PropertyBlockedDateUpsertArgs>(args: SelectSubset<T, PropertyBlockedDateUpsertArgs<ExtArgs>>): Prisma__PropertyBlockedDateClient<$Result.GetResult<Prisma.$PropertyBlockedDatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyBlockedDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyBlockedDateCountArgs} args - Arguments to filter PropertyBlockedDates to count.
     * @example
     * // Count the number of PropertyBlockedDates
     * const count = await prisma.propertyBlockedDate.count({
     *   where: {
     *     // ... the filter for the PropertyBlockedDates we want to count
     *   }
     * })
    **/
    count<T extends PropertyBlockedDateCountArgs>(
      args?: Subset<T, PropertyBlockedDateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyBlockedDateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyBlockedDate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyBlockedDateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyBlockedDateAggregateArgs>(args: Subset<T, PropertyBlockedDateAggregateArgs>): Prisma.PrismaPromise<GetPropertyBlockedDateAggregateType<T>>

    /**
     * Group by PropertyBlockedDate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyBlockedDateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyBlockedDateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyBlockedDateGroupByArgs['orderBy'] }
        : { orderBy?: PropertyBlockedDateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyBlockedDateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyBlockedDateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyBlockedDate model
   */
  readonly fields: PropertyBlockedDateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyBlockedDate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyBlockedDateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyBlockedDate model
   */
  interface PropertyBlockedDateFieldRefs {
    readonly id: FieldRef<"PropertyBlockedDate", 'String'>
    readonly propertyId: FieldRef<"PropertyBlockedDate", 'String'>
    readonly startDate: FieldRef<"PropertyBlockedDate", 'DateTime'>
    readonly endDate: FieldRef<"PropertyBlockedDate", 'DateTime'>
    readonly reason: FieldRef<"PropertyBlockedDate", 'String'>
    readonly blockedBy: FieldRef<"PropertyBlockedDate", 'String'>
    readonly createdAt: FieldRef<"PropertyBlockedDate", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertyBlockedDate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyBlockedDate findUnique
   */
  export type PropertyBlockedDateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyBlockedDate
     */
    select?: PropertyBlockedDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyBlockedDate
     */
    omit?: PropertyBlockedDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyBlockedDateInclude<ExtArgs> | null
    /**
     * Filter, which PropertyBlockedDate to fetch.
     */
    where: PropertyBlockedDateWhereUniqueInput
  }

  /**
   * PropertyBlockedDate findUniqueOrThrow
   */
  export type PropertyBlockedDateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyBlockedDate
     */
    select?: PropertyBlockedDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyBlockedDate
     */
    omit?: PropertyBlockedDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyBlockedDateInclude<ExtArgs> | null
    /**
     * Filter, which PropertyBlockedDate to fetch.
     */
    where: PropertyBlockedDateWhereUniqueInput
  }

  /**
   * PropertyBlockedDate findFirst
   */
  export type PropertyBlockedDateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyBlockedDate
     */
    select?: PropertyBlockedDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyBlockedDate
     */
    omit?: PropertyBlockedDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyBlockedDateInclude<ExtArgs> | null
    /**
     * Filter, which PropertyBlockedDate to fetch.
     */
    where?: PropertyBlockedDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyBlockedDates to fetch.
     */
    orderBy?: PropertyBlockedDateOrderByWithRelationInput | PropertyBlockedDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyBlockedDates.
     */
    cursor?: PropertyBlockedDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyBlockedDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyBlockedDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyBlockedDates.
     */
    distinct?: PropertyBlockedDateScalarFieldEnum | PropertyBlockedDateScalarFieldEnum[]
  }

  /**
   * PropertyBlockedDate findFirstOrThrow
   */
  export type PropertyBlockedDateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyBlockedDate
     */
    select?: PropertyBlockedDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyBlockedDate
     */
    omit?: PropertyBlockedDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyBlockedDateInclude<ExtArgs> | null
    /**
     * Filter, which PropertyBlockedDate to fetch.
     */
    where?: PropertyBlockedDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyBlockedDates to fetch.
     */
    orderBy?: PropertyBlockedDateOrderByWithRelationInput | PropertyBlockedDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyBlockedDates.
     */
    cursor?: PropertyBlockedDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyBlockedDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyBlockedDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyBlockedDates.
     */
    distinct?: PropertyBlockedDateScalarFieldEnum | PropertyBlockedDateScalarFieldEnum[]
  }

  /**
   * PropertyBlockedDate findMany
   */
  export type PropertyBlockedDateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyBlockedDate
     */
    select?: PropertyBlockedDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyBlockedDate
     */
    omit?: PropertyBlockedDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyBlockedDateInclude<ExtArgs> | null
    /**
     * Filter, which PropertyBlockedDates to fetch.
     */
    where?: PropertyBlockedDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyBlockedDates to fetch.
     */
    orderBy?: PropertyBlockedDateOrderByWithRelationInput | PropertyBlockedDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyBlockedDates.
     */
    cursor?: PropertyBlockedDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyBlockedDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyBlockedDates.
     */
    skip?: number
    distinct?: PropertyBlockedDateScalarFieldEnum | PropertyBlockedDateScalarFieldEnum[]
  }

  /**
   * PropertyBlockedDate create
   */
  export type PropertyBlockedDateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyBlockedDate
     */
    select?: PropertyBlockedDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyBlockedDate
     */
    omit?: PropertyBlockedDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyBlockedDateInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyBlockedDate.
     */
    data: XOR<PropertyBlockedDateCreateInput, PropertyBlockedDateUncheckedCreateInput>
  }

  /**
   * PropertyBlockedDate createMany
   */
  export type PropertyBlockedDateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyBlockedDates.
     */
    data: PropertyBlockedDateCreateManyInput | PropertyBlockedDateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyBlockedDate createManyAndReturn
   */
  export type PropertyBlockedDateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyBlockedDate
     */
    select?: PropertyBlockedDateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyBlockedDate
     */
    omit?: PropertyBlockedDateOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyBlockedDates.
     */
    data: PropertyBlockedDateCreateManyInput | PropertyBlockedDateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyBlockedDateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyBlockedDate update
   */
  export type PropertyBlockedDateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyBlockedDate
     */
    select?: PropertyBlockedDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyBlockedDate
     */
    omit?: PropertyBlockedDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyBlockedDateInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyBlockedDate.
     */
    data: XOR<PropertyBlockedDateUpdateInput, PropertyBlockedDateUncheckedUpdateInput>
    /**
     * Choose, which PropertyBlockedDate to update.
     */
    where: PropertyBlockedDateWhereUniqueInput
  }

  /**
   * PropertyBlockedDate updateMany
   */
  export type PropertyBlockedDateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyBlockedDates.
     */
    data: XOR<PropertyBlockedDateUpdateManyMutationInput, PropertyBlockedDateUncheckedUpdateManyInput>
    /**
     * Filter which PropertyBlockedDates to update
     */
    where?: PropertyBlockedDateWhereInput
    /**
     * Limit how many PropertyBlockedDates to update.
     */
    limit?: number
  }

  /**
   * PropertyBlockedDate updateManyAndReturn
   */
  export type PropertyBlockedDateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyBlockedDate
     */
    select?: PropertyBlockedDateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyBlockedDate
     */
    omit?: PropertyBlockedDateOmit<ExtArgs> | null
    /**
     * The data used to update PropertyBlockedDates.
     */
    data: XOR<PropertyBlockedDateUpdateManyMutationInput, PropertyBlockedDateUncheckedUpdateManyInput>
    /**
     * Filter which PropertyBlockedDates to update
     */
    where?: PropertyBlockedDateWhereInput
    /**
     * Limit how many PropertyBlockedDates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyBlockedDateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyBlockedDate upsert
   */
  export type PropertyBlockedDateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyBlockedDate
     */
    select?: PropertyBlockedDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyBlockedDate
     */
    omit?: PropertyBlockedDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyBlockedDateInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyBlockedDate to update in case it exists.
     */
    where: PropertyBlockedDateWhereUniqueInput
    /**
     * In case the PropertyBlockedDate found by the `where` argument doesn't exist, create a new PropertyBlockedDate with this data.
     */
    create: XOR<PropertyBlockedDateCreateInput, PropertyBlockedDateUncheckedCreateInput>
    /**
     * In case the PropertyBlockedDate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyBlockedDateUpdateInput, PropertyBlockedDateUncheckedUpdateInput>
  }

  /**
   * PropertyBlockedDate delete
   */
  export type PropertyBlockedDateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyBlockedDate
     */
    select?: PropertyBlockedDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyBlockedDate
     */
    omit?: PropertyBlockedDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyBlockedDateInclude<ExtArgs> | null
    /**
     * Filter which PropertyBlockedDate to delete.
     */
    where: PropertyBlockedDateWhereUniqueInput
  }

  /**
   * PropertyBlockedDate deleteMany
   */
  export type PropertyBlockedDateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyBlockedDates to delete
     */
    where?: PropertyBlockedDateWhereInput
    /**
     * Limit how many PropertyBlockedDates to delete.
     */
    limit?: number
  }

  /**
   * PropertyBlockedDate without action
   */
  export type PropertyBlockedDateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyBlockedDate
     */
    select?: PropertyBlockedDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyBlockedDate
     */
    omit?: PropertyBlockedDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyBlockedDateInclude<ExtArgs> | null
  }


  /**
   * Model Tm30Accommodation
   */

  export type AggregateTm30Accommodation = {
    _count: Tm30AccommodationCountAggregateOutputType | null
    _avg: Tm30AccommodationAvgAggregateOutputType | null
    _sum: Tm30AccommodationSumAggregateOutputType | null
    _min: Tm30AccommodationMinAggregateOutputType | null
    _max: Tm30AccommodationMaxAggregateOutputType | null
  }

  export type Tm30AccommodationAvgAggregateOutputType = {
    matchScore: number | null
  }

  export type Tm30AccommodationSumAggregateOutputType = {
    matchScore: number | null
  }

  export type Tm30AccommodationMinAggregateOutputType = {
    id: string | null
    tm30Id: string | null
    name: string | null
    address: string | null
    status: string | null
    propertyId: string | null
    matchScore: number | null
    matchedBy: string | null
    matchedAt: Date | null
    lastSyncedAt: Date | null
    syncSource: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tm30AccommodationMaxAggregateOutputType = {
    id: string | null
    tm30Id: string | null
    name: string | null
    address: string | null
    status: string | null
    propertyId: string | null
    matchScore: number | null
    matchedBy: string | null
    matchedAt: Date | null
    lastSyncedAt: Date | null
    syncSource: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tm30AccommodationCountAggregateOutputType = {
    id: number
    tm30Id: number
    name: number
    address: number
    status: number
    propertyId: number
    matchScore: number
    matchedBy: number
    matchedAt: number
    lastSyncedAt: number
    syncSource: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Tm30AccommodationAvgAggregateInputType = {
    matchScore?: true
  }

  export type Tm30AccommodationSumAggregateInputType = {
    matchScore?: true
  }

  export type Tm30AccommodationMinAggregateInputType = {
    id?: true
    tm30Id?: true
    name?: true
    address?: true
    status?: true
    propertyId?: true
    matchScore?: true
    matchedBy?: true
    matchedAt?: true
    lastSyncedAt?: true
    syncSource?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tm30AccommodationMaxAggregateInputType = {
    id?: true
    tm30Id?: true
    name?: true
    address?: true
    status?: true
    propertyId?: true
    matchScore?: true
    matchedBy?: true
    matchedAt?: true
    lastSyncedAt?: true
    syncSource?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tm30AccommodationCountAggregateInputType = {
    id?: true
    tm30Id?: true
    name?: true
    address?: true
    status?: true
    propertyId?: true
    matchScore?: true
    matchedBy?: true
    matchedAt?: true
    lastSyncedAt?: true
    syncSource?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Tm30AccommodationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tm30Accommodation to aggregate.
     */
    where?: Tm30AccommodationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tm30Accommodations to fetch.
     */
    orderBy?: Tm30AccommodationOrderByWithRelationInput | Tm30AccommodationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Tm30AccommodationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tm30Accommodations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tm30Accommodations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tm30Accommodations
    **/
    _count?: true | Tm30AccommodationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tm30AccommodationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tm30AccommodationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tm30AccommodationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tm30AccommodationMaxAggregateInputType
  }

  export type GetTm30AccommodationAggregateType<T extends Tm30AccommodationAggregateArgs> = {
        [P in keyof T & keyof AggregateTm30Accommodation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTm30Accommodation[P]>
      : GetScalarType<T[P], AggregateTm30Accommodation[P]>
  }




  export type Tm30AccommodationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tm30AccommodationWhereInput
    orderBy?: Tm30AccommodationOrderByWithAggregationInput | Tm30AccommodationOrderByWithAggregationInput[]
    by: Tm30AccommodationScalarFieldEnum[] | Tm30AccommodationScalarFieldEnum
    having?: Tm30AccommodationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tm30AccommodationCountAggregateInputType | true
    _avg?: Tm30AccommodationAvgAggregateInputType
    _sum?: Tm30AccommodationSumAggregateInputType
    _min?: Tm30AccommodationMinAggregateInputType
    _max?: Tm30AccommodationMaxAggregateInputType
  }

  export type Tm30AccommodationGroupByOutputType = {
    id: string
    tm30Id: string
    name: string
    address: string
    status: string | null
    propertyId: string | null
    matchScore: number | null
    matchedBy: string | null
    matchedAt: Date | null
    lastSyncedAt: Date | null
    syncSource: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: Tm30AccommodationCountAggregateOutputType | null
    _avg: Tm30AccommodationAvgAggregateOutputType | null
    _sum: Tm30AccommodationSumAggregateOutputType | null
    _min: Tm30AccommodationMinAggregateOutputType | null
    _max: Tm30AccommodationMaxAggregateOutputType | null
  }

  type GetTm30AccommodationGroupByPayload<T extends Tm30AccommodationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tm30AccommodationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tm30AccommodationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tm30AccommodationGroupByOutputType[P]>
            : GetScalarType<T[P], Tm30AccommodationGroupByOutputType[P]>
        }
      >
    >


  export type Tm30AccommodationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tm30Id?: boolean
    name?: boolean
    address?: boolean
    status?: boolean
    propertyId?: boolean
    matchScore?: boolean
    matchedBy?: boolean
    matchedAt?: boolean
    lastSyncedAt?: boolean
    syncSource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | Tm30Accommodation$propertyArgs<ExtArgs>
  }, ExtArgs["result"]["tm30Accommodation"]>

  export type Tm30AccommodationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tm30Id?: boolean
    name?: boolean
    address?: boolean
    status?: boolean
    propertyId?: boolean
    matchScore?: boolean
    matchedBy?: boolean
    matchedAt?: boolean
    lastSyncedAt?: boolean
    syncSource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | Tm30Accommodation$propertyArgs<ExtArgs>
  }, ExtArgs["result"]["tm30Accommodation"]>

  export type Tm30AccommodationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tm30Id?: boolean
    name?: boolean
    address?: boolean
    status?: boolean
    propertyId?: boolean
    matchScore?: boolean
    matchedBy?: boolean
    matchedAt?: boolean
    lastSyncedAt?: boolean
    syncSource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | Tm30Accommodation$propertyArgs<ExtArgs>
  }, ExtArgs["result"]["tm30Accommodation"]>

  export type Tm30AccommodationSelectScalar = {
    id?: boolean
    tm30Id?: boolean
    name?: boolean
    address?: boolean
    status?: boolean
    propertyId?: boolean
    matchScore?: boolean
    matchedBy?: boolean
    matchedAt?: boolean
    lastSyncedAt?: boolean
    syncSource?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type Tm30AccommodationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tm30Id" | "name" | "address" | "status" | "propertyId" | "matchScore" | "matchedBy" | "matchedAt" | "lastSyncedAt" | "syncSource" | "createdAt" | "updatedAt", ExtArgs["result"]["tm30Accommodation"]>
  export type Tm30AccommodationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | Tm30Accommodation$propertyArgs<ExtArgs>
  }
  export type Tm30AccommodationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | Tm30Accommodation$propertyArgs<ExtArgs>
  }
  export type Tm30AccommodationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | Tm30Accommodation$propertyArgs<ExtArgs>
  }

  export type $Tm30AccommodationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tm30Accommodation"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tm30Id: string
      name: string
      address: string
      status: string | null
      propertyId: string | null
      matchScore: number | null
      matchedBy: string | null
      matchedAt: Date | null
      lastSyncedAt: Date | null
      syncSource: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["tm30Accommodation"]>
    composites: {}
  }

  type Tm30AccommodationGetPayload<S extends boolean | null | undefined | Tm30AccommodationDefaultArgs> = $Result.GetResult<Prisma.$Tm30AccommodationPayload, S>

  type Tm30AccommodationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Tm30AccommodationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tm30AccommodationCountAggregateInputType | true
    }

  export interface Tm30AccommodationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tm30Accommodation'], meta: { name: 'Tm30Accommodation' } }
    /**
     * Find zero or one Tm30Accommodation that matches the filter.
     * @param {Tm30AccommodationFindUniqueArgs} args - Arguments to find a Tm30Accommodation
     * @example
     * // Get one Tm30Accommodation
     * const tm30Accommodation = await prisma.tm30Accommodation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Tm30AccommodationFindUniqueArgs>(args: SelectSubset<T, Tm30AccommodationFindUniqueArgs<ExtArgs>>): Prisma__Tm30AccommodationClient<$Result.GetResult<Prisma.$Tm30AccommodationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tm30Accommodation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Tm30AccommodationFindUniqueOrThrowArgs} args - Arguments to find a Tm30Accommodation
     * @example
     * // Get one Tm30Accommodation
     * const tm30Accommodation = await prisma.tm30Accommodation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Tm30AccommodationFindUniqueOrThrowArgs>(args: SelectSubset<T, Tm30AccommodationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Tm30AccommodationClient<$Result.GetResult<Prisma.$Tm30AccommodationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tm30Accommodation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tm30AccommodationFindFirstArgs} args - Arguments to find a Tm30Accommodation
     * @example
     * // Get one Tm30Accommodation
     * const tm30Accommodation = await prisma.tm30Accommodation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Tm30AccommodationFindFirstArgs>(args?: SelectSubset<T, Tm30AccommodationFindFirstArgs<ExtArgs>>): Prisma__Tm30AccommodationClient<$Result.GetResult<Prisma.$Tm30AccommodationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tm30Accommodation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tm30AccommodationFindFirstOrThrowArgs} args - Arguments to find a Tm30Accommodation
     * @example
     * // Get one Tm30Accommodation
     * const tm30Accommodation = await prisma.tm30Accommodation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Tm30AccommodationFindFirstOrThrowArgs>(args?: SelectSubset<T, Tm30AccommodationFindFirstOrThrowArgs<ExtArgs>>): Prisma__Tm30AccommodationClient<$Result.GetResult<Prisma.$Tm30AccommodationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tm30Accommodations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tm30AccommodationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tm30Accommodations
     * const tm30Accommodations = await prisma.tm30Accommodation.findMany()
     * 
     * // Get first 10 Tm30Accommodations
     * const tm30Accommodations = await prisma.tm30Accommodation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tm30AccommodationWithIdOnly = await prisma.tm30Accommodation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Tm30AccommodationFindManyArgs>(args?: SelectSubset<T, Tm30AccommodationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tm30AccommodationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tm30Accommodation.
     * @param {Tm30AccommodationCreateArgs} args - Arguments to create a Tm30Accommodation.
     * @example
     * // Create one Tm30Accommodation
     * const Tm30Accommodation = await prisma.tm30Accommodation.create({
     *   data: {
     *     // ... data to create a Tm30Accommodation
     *   }
     * })
     * 
     */
    create<T extends Tm30AccommodationCreateArgs>(args: SelectSubset<T, Tm30AccommodationCreateArgs<ExtArgs>>): Prisma__Tm30AccommodationClient<$Result.GetResult<Prisma.$Tm30AccommodationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tm30Accommodations.
     * @param {Tm30AccommodationCreateManyArgs} args - Arguments to create many Tm30Accommodations.
     * @example
     * // Create many Tm30Accommodations
     * const tm30Accommodation = await prisma.tm30Accommodation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Tm30AccommodationCreateManyArgs>(args?: SelectSubset<T, Tm30AccommodationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tm30Accommodations and returns the data saved in the database.
     * @param {Tm30AccommodationCreateManyAndReturnArgs} args - Arguments to create many Tm30Accommodations.
     * @example
     * // Create many Tm30Accommodations
     * const tm30Accommodation = await prisma.tm30Accommodation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tm30Accommodations and only return the `id`
     * const tm30AccommodationWithIdOnly = await prisma.tm30Accommodation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Tm30AccommodationCreateManyAndReturnArgs>(args?: SelectSubset<T, Tm30AccommodationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tm30AccommodationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tm30Accommodation.
     * @param {Tm30AccommodationDeleteArgs} args - Arguments to delete one Tm30Accommodation.
     * @example
     * // Delete one Tm30Accommodation
     * const Tm30Accommodation = await prisma.tm30Accommodation.delete({
     *   where: {
     *     // ... filter to delete one Tm30Accommodation
     *   }
     * })
     * 
     */
    delete<T extends Tm30AccommodationDeleteArgs>(args: SelectSubset<T, Tm30AccommodationDeleteArgs<ExtArgs>>): Prisma__Tm30AccommodationClient<$Result.GetResult<Prisma.$Tm30AccommodationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tm30Accommodation.
     * @param {Tm30AccommodationUpdateArgs} args - Arguments to update one Tm30Accommodation.
     * @example
     * // Update one Tm30Accommodation
     * const tm30Accommodation = await prisma.tm30Accommodation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Tm30AccommodationUpdateArgs>(args: SelectSubset<T, Tm30AccommodationUpdateArgs<ExtArgs>>): Prisma__Tm30AccommodationClient<$Result.GetResult<Prisma.$Tm30AccommodationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tm30Accommodations.
     * @param {Tm30AccommodationDeleteManyArgs} args - Arguments to filter Tm30Accommodations to delete.
     * @example
     * // Delete a few Tm30Accommodations
     * const { count } = await prisma.tm30Accommodation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Tm30AccommodationDeleteManyArgs>(args?: SelectSubset<T, Tm30AccommodationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tm30Accommodations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tm30AccommodationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tm30Accommodations
     * const tm30Accommodation = await prisma.tm30Accommodation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Tm30AccommodationUpdateManyArgs>(args: SelectSubset<T, Tm30AccommodationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tm30Accommodations and returns the data updated in the database.
     * @param {Tm30AccommodationUpdateManyAndReturnArgs} args - Arguments to update many Tm30Accommodations.
     * @example
     * // Update many Tm30Accommodations
     * const tm30Accommodation = await prisma.tm30Accommodation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tm30Accommodations and only return the `id`
     * const tm30AccommodationWithIdOnly = await prisma.tm30Accommodation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Tm30AccommodationUpdateManyAndReturnArgs>(args: SelectSubset<T, Tm30AccommodationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tm30AccommodationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tm30Accommodation.
     * @param {Tm30AccommodationUpsertArgs} args - Arguments to update or create a Tm30Accommodation.
     * @example
     * // Update or create a Tm30Accommodation
     * const tm30Accommodation = await prisma.tm30Accommodation.upsert({
     *   create: {
     *     // ... data to create a Tm30Accommodation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tm30Accommodation we want to update
     *   }
     * })
     */
    upsert<T extends Tm30AccommodationUpsertArgs>(args: SelectSubset<T, Tm30AccommodationUpsertArgs<ExtArgs>>): Prisma__Tm30AccommodationClient<$Result.GetResult<Prisma.$Tm30AccommodationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tm30Accommodations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tm30AccommodationCountArgs} args - Arguments to filter Tm30Accommodations to count.
     * @example
     * // Count the number of Tm30Accommodations
     * const count = await prisma.tm30Accommodation.count({
     *   where: {
     *     // ... the filter for the Tm30Accommodations we want to count
     *   }
     * })
    **/
    count<T extends Tm30AccommodationCountArgs>(
      args?: Subset<T, Tm30AccommodationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tm30AccommodationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tm30Accommodation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tm30AccommodationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tm30AccommodationAggregateArgs>(args: Subset<T, Tm30AccommodationAggregateArgs>): Prisma.PrismaPromise<GetTm30AccommodationAggregateType<T>>

    /**
     * Group by Tm30Accommodation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tm30AccommodationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tm30AccommodationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tm30AccommodationGroupByArgs['orderBy'] }
        : { orderBy?: Tm30AccommodationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tm30AccommodationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTm30AccommodationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tm30Accommodation model
   */
  readonly fields: Tm30AccommodationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tm30Accommodation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Tm30AccommodationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends Tm30Accommodation$propertyArgs<ExtArgs> = {}>(args?: Subset<T, Tm30Accommodation$propertyArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tm30Accommodation model
   */
  interface Tm30AccommodationFieldRefs {
    readonly id: FieldRef<"Tm30Accommodation", 'String'>
    readonly tm30Id: FieldRef<"Tm30Accommodation", 'String'>
    readonly name: FieldRef<"Tm30Accommodation", 'String'>
    readonly address: FieldRef<"Tm30Accommodation", 'String'>
    readonly status: FieldRef<"Tm30Accommodation", 'String'>
    readonly propertyId: FieldRef<"Tm30Accommodation", 'String'>
    readonly matchScore: FieldRef<"Tm30Accommodation", 'Float'>
    readonly matchedBy: FieldRef<"Tm30Accommodation", 'String'>
    readonly matchedAt: FieldRef<"Tm30Accommodation", 'DateTime'>
    readonly lastSyncedAt: FieldRef<"Tm30Accommodation", 'DateTime'>
    readonly syncSource: FieldRef<"Tm30Accommodation", 'String'>
    readonly createdAt: FieldRef<"Tm30Accommodation", 'DateTime'>
    readonly updatedAt: FieldRef<"Tm30Accommodation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tm30Accommodation findUnique
   */
  export type Tm30AccommodationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30Accommodation
     */
    select?: Tm30AccommodationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30Accommodation
     */
    omit?: Tm30AccommodationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationInclude<ExtArgs> | null
    /**
     * Filter, which Tm30Accommodation to fetch.
     */
    where: Tm30AccommodationWhereUniqueInput
  }

  /**
   * Tm30Accommodation findUniqueOrThrow
   */
  export type Tm30AccommodationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30Accommodation
     */
    select?: Tm30AccommodationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30Accommodation
     */
    omit?: Tm30AccommodationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationInclude<ExtArgs> | null
    /**
     * Filter, which Tm30Accommodation to fetch.
     */
    where: Tm30AccommodationWhereUniqueInput
  }

  /**
   * Tm30Accommodation findFirst
   */
  export type Tm30AccommodationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30Accommodation
     */
    select?: Tm30AccommodationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30Accommodation
     */
    omit?: Tm30AccommodationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationInclude<ExtArgs> | null
    /**
     * Filter, which Tm30Accommodation to fetch.
     */
    where?: Tm30AccommodationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tm30Accommodations to fetch.
     */
    orderBy?: Tm30AccommodationOrderByWithRelationInput | Tm30AccommodationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tm30Accommodations.
     */
    cursor?: Tm30AccommodationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tm30Accommodations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tm30Accommodations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tm30Accommodations.
     */
    distinct?: Tm30AccommodationScalarFieldEnum | Tm30AccommodationScalarFieldEnum[]
  }

  /**
   * Tm30Accommodation findFirstOrThrow
   */
  export type Tm30AccommodationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30Accommodation
     */
    select?: Tm30AccommodationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30Accommodation
     */
    omit?: Tm30AccommodationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationInclude<ExtArgs> | null
    /**
     * Filter, which Tm30Accommodation to fetch.
     */
    where?: Tm30AccommodationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tm30Accommodations to fetch.
     */
    orderBy?: Tm30AccommodationOrderByWithRelationInput | Tm30AccommodationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tm30Accommodations.
     */
    cursor?: Tm30AccommodationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tm30Accommodations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tm30Accommodations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tm30Accommodations.
     */
    distinct?: Tm30AccommodationScalarFieldEnum | Tm30AccommodationScalarFieldEnum[]
  }

  /**
   * Tm30Accommodation findMany
   */
  export type Tm30AccommodationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30Accommodation
     */
    select?: Tm30AccommodationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30Accommodation
     */
    omit?: Tm30AccommodationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationInclude<ExtArgs> | null
    /**
     * Filter, which Tm30Accommodations to fetch.
     */
    where?: Tm30AccommodationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tm30Accommodations to fetch.
     */
    orderBy?: Tm30AccommodationOrderByWithRelationInput | Tm30AccommodationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tm30Accommodations.
     */
    cursor?: Tm30AccommodationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tm30Accommodations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tm30Accommodations.
     */
    skip?: number
    distinct?: Tm30AccommodationScalarFieldEnum | Tm30AccommodationScalarFieldEnum[]
  }

  /**
   * Tm30Accommodation create
   */
  export type Tm30AccommodationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30Accommodation
     */
    select?: Tm30AccommodationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30Accommodation
     */
    omit?: Tm30AccommodationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationInclude<ExtArgs> | null
    /**
     * The data needed to create a Tm30Accommodation.
     */
    data: XOR<Tm30AccommodationCreateInput, Tm30AccommodationUncheckedCreateInput>
  }

  /**
   * Tm30Accommodation createMany
   */
  export type Tm30AccommodationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tm30Accommodations.
     */
    data: Tm30AccommodationCreateManyInput | Tm30AccommodationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tm30Accommodation createManyAndReturn
   */
  export type Tm30AccommodationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30Accommodation
     */
    select?: Tm30AccommodationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30Accommodation
     */
    omit?: Tm30AccommodationOmit<ExtArgs> | null
    /**
     * The data used to create many Tm30Accommodations.
     */
    data: Tm30AccommodationCreateManyInput | Tm30AccommodationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tm30Accommodation update
   */
  export type Tm30AccommodationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30Accommodation
     */
    select?: Tm30AccommodationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30Accommodation
     */
    omit?: Tm30AccommodationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationInclude<ExtArgs> | null
    /**
     * The data needed to update a Tm30Accommodation.
     */
    data: XOR<Tm30AccommodationUpdateInput, Tm30AccommodationUncheckedUpdateInput>
    /**
     * Choose, which Tm30Accommodation to update.
     */
    where: Tm30AccommodationWhereUniqueInput
  }

  /**
   * Tm30Accommodation updateMany
   */
  export type Tm30AccommodationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tm30Accommodations.
     */
    data: XOR<Tm30AccommodationUpdateManyMutationInput, Tm30AccommodationUncheckedUpdateManyInput>
    /**
     * Filter which Tm30Accommodations to update
     */
    where?: Tm30AccommodationWhereInput
    /**
     * Limit how many Tm30Accommodations to update.
     */
    limit?: number
  }

  /**
   * Tm30Accommodation updateManyAndReturn
   */
  export type Tm30AccommodationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30Accommodation
     */
    select?: Tm30AccommodationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30Accommodation
     */
    omit?: Tm30AccommodationOmit<ExtArgs> | null
    /**
     * The data used to update Tm30Accommodations.
     */
    data: XOR<Tm30AccommodationUpdateManyMutationInput, Tm30AccommodationUncheckedUpdateManyInput>
    /**
     * Filter which Tm30Accommodations to update
     */
    where?: Tm30AccommodationWhereInput
    /**
     * Limit how many Tm30Accommodations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tm30Accommodation upsert
   */
  export type Tm30AccommodationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30Accommodation
     */
    select?: Tm30AccommodationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30Accommodation
     */
    omit?: Tm30AccommodationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationInclude<ExtArgs> | null
    /**
     * The filter to search for the Tm30Accommodation to update in case it exists.
     */
    where: Tm30AccommodationWhereUniqueInput
    /**
     * In case the Tm30Accommodation found by the `where` argument doesn't exist, create a new Tm30Accommodation with this data.
     */
    create: XOR<Tm30AccommodationCreateInput, Tm30AccommodationUncheckedCreateInput>
    /**
     * In case the Tm30Accommodation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Tm30AccommodationUpdateInput, Tm30AccommodationUncheckedUpdateInput>
  }

  /**
   * Tm30Accommodation delete
   */
  export type Tm30AccommodationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30Accommodation
     */
    select?: Tm30AccommodationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30Accommodation
     */
    omit?: Tm30AccommodationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationInclude<ExtArgs> | null
    /**
     * Filter which Tm30Accommodation to delete.
     */
    where: Tm30AccommodationWhereUniqueInput
  }

  /**
   * Tm30Accommodation deleteMany
   */
  export type Tm30AccommodationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tm30Accommodations to delete
     */
    where?: Tm30AccommodationWhereInput
    /**
     * Limit how many Tm30Accommodations to delete.
     */
    limit?: number
  }

  /**
   * Tm30Accommodation.property
   */
  export type Tm30Accommodation$propertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
  }

  /**
   * Tm30Accommodation without action
   */
  export type Tm30AccommodationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30Accommodation
     */
    select?: Tm30AccommodationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30Accommodation
     */
    omit?: Tm30AccommodationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationInclude<ExtArgs> | null
  }


  /**
   * Model Tm30AccommodationRequest
   */

  export type AggregateTm30AccommodationRequest = {
    _count: Tm30AccommodationRequestCountAggregateOutputType | null
    _avg: Tm30AccommodationRequestAvgAggregateOutputType | null
    _sum: Tm30AccommodationRequestSumAggregateOutputType | null
    _min: Tm30AccommodationRequestMinAggregateOutputType | null
    _max: Tm30AccommodationRequestMaxAggregateOutputType | null
  }

  export type Tm30AccommodationRequestAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    ocrConfidence: number | null
  }

  export type Tm30AccommodationRequestSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    ocrConfidence: number | null
  }

  export type Tm30AccommodationRequestMinAggregateOutputType = {
    id: string | null
    ownerSameAsRegistrant: boolean | null
    ownerNationalType: string | null
    ownerNationalId: string | null
    ownerPassportNumber: string | null
    ownerFirstName: string | null
    ownerMiddleName: string | null
    ownerLastName: string | null
    ownerTelephone: string | null
    ownerGender: string | null
    entityType: string | null
    houseIdNumber: string | null
    accommodationType: string | null
    accommodationName: string | null
    position: string | null
    positionOther: string | null
    addressNumber: string | null
    villageNumber: string | null
    alley: string | null
    road: string | null
    province: string | null
    district: string | null
    subDistrict: string | null
    postalCode: string | null
    latitude: number | null
    longitude: number | null
    houseRegistrationUrl: string | null
    houseRegistrationPath: string | null
    ocrProcessed: boolean | null
    ocrProcessedAt: Date | null
    ocrConfidence: number | null
    status: $Enums.Tm30AccomRequestStatus | null
    tm30Id: string | null
    submittedAt: Date | null
    approvedAt: Date | null
    rejectedAt: Date | null
    rejectionReason: string | null
    errorMessage: string | null
    propertyId: string | null
    propertyOwnerId: string | null
    whatsappPhone: string | null
    whatsappSessionId: string | null
    createdBy: string | null
    updatedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tm30AccommodationRequestMaxAggregateOutputType = {
    id: string | null
    ownerSameAsRegistrant: boolean | null
    ownerNationalType: string | null
    ownerNationalId: string | null
    ownerPassportNumber: string | null
    ownerFirstName: string | null
    ownerMiddleName: string | null
    ownerLastName: string | null
    ownerTelephone: string | null
    ownerGender: string | null
    entityType: string | null
    houseIdNumber: string | null
    accommodationType: string | null
    accommodationName: string | null
    position: string | null
    positionOther: string | null
    addressNumber: string | null
    villageNumber: string | null
    alley: string | null
    road: string | null
    province: string | null
    district: string | null
    subDistrict: string | null
    postalCode: string | null
    latitude: number | null
    longitude: number | null
    houseRegistrationUrl: string | null
    houseRegistrationPath: string | null
    ocrProcessed: boolean | null
    ocrProcessedAt: Date | null
    ocrConfidence: number | null
    status: $Enums.Tm30AccomRequestStatus | null
    tm30Id: string | null
    submittedAt: Date | null
    approvedAt: Date | null
    rejectedAt: Date | null
    rejectionReason: string | null
    errorMessage: string | null
    propertyId: string | null
    propertyOwnerId: string | null
    whatsappPhone: string | null
    whatsappSessionId: string | null
    createdBy: string | null
    updatedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tm30AccommodationRequestCountAggregateOutputType = {
    id: number
    ownerSameAsRegistrant: number
    ownerNationalType: number
    ownerNationalId: number
    ownerPassportNumber: number
    ownerFirstName: number
    ownerMiddleName: number
    ownerLastName: number
    ownerTelephone: number
    ownerGender: number
    entityType: number
    houseIdNumber: number
    accommodationType: number
    accommodationName: number
    position: number
    positionOther: number
    addressNumber: number
    villageNumber: number
    alley: number
    road: number
    province: number
    district: number
    subDistrict: number
    postalCode: number
    latitude: number
    longitude: number
    houseRegistrationUrl: number
    houseRegistrationPath: number
    ocrProcessed: number
    ocrProcessedAt: number
    ocrRawData: number
    ocrConfidence: number
    status: number
    tm30Id: number
    submittedAt: number
    approvedAt: number
    rejectedAt: number
    rejectionReason: number
    errorMessage: number
    propertyId: number
    propertyOwnerId: number
    whatsappPhone: number
    whatsappSessionId: number
    createdBy: number
    updatedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Tm30AccommodationRequestAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    ocrConfidence?: true
  }

  export type Tm30AccommodationRequestSumAggregateInputType = {
    latitude?: true
    longitude?: true
    ocrConfidence?: true
  }

  export type Tm30AccommodationRequestMinAggregateInputType = {
    id?: true
    ownerSameAsRegistrant?: true
    ownerNationalType?: true
    ownerNationalId?: true
    ownerPassportNumber?: true
    ownerFirstName?: true
    ownerMiddleName?: true
    ownerLastName?: true
    ownerTelephone?: true
    ownerGender?: true
    entityType?: true
    houseIdNumber?: true
    accommodationType?: true
    accommodationName?: true
    position?: true
    positionOther?: true
    addressNumber?: true
    villageNumber?: true
    alley?: true
    road?: true
    province?: true
    district?: true
    subDistrict?: true
    postalCode?: true
    latitude?: true
    longitude?: true
    houseRegistrationUrl?: true
    houseRegistrationPath?: true
    ocrProcessed?: true
    ocrProcessedAt?: true
    ocrConfidence?: true
    status?: true
    tm30Id?: true
    submittedAt?: true
    approvedAt?: true
    rejectedAt?: true
    rejectionReason?: true
    errorMessage?: true
    propertyId?: true
    propertyOwnerId?: true
    whatsappPhone?: true
    whatsappSessionId?: true
    createdBy?: true
    updatedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tm30AccommodationRequestMaxAggregateInputType = {
    id?: true
    ownerSameAsRegistrant?: true
    ownerNationalType?: true
    ownerNationalId?: true
    ownerPassportNumber?: true
    ownerFirstName?: true
    ownerMiddleName?: true
    ownerLastName?: true
    ownerTelephone?: true
    ownerGender?: true
    entityType?: true
    houseIdNumber?: true
    accommodationType?: true
    accommodationName?: true
    position?: true
    positionOther?: true
    addressNumber?: true
    villageNumber?: true
    alley?: true
    road?: true
    province?: true
    district?: true
    subDistrict?: true
    postalCode?: true
    latitude?: true
    longitude?: true
    houseRegistrationUrl?: true
    houseRegistrationPath?: true
    ocrProcessed?: true
    ocrProcessedAt?: true
    ocrConfidence?: true
    status?: true
    tm30Id?: true
    submittedAt?: true
    approvedAt?: true
    rejectedAt?: true
    rejectionReason?: true
    errorMessage?: true
    propertyId?: true
    propertyOwnerId?: true
    whatsappPhone?: true
    whatsappSessionId?: true
    createdBy?: true
    updatedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tm30AccommodationRequestCountAggregateInputType = {
    id?: true
    ownerSameAsRegistrant?: true
    ownerNationalType?: true
    ownerNationalId?: true
    ownerPassportNumber?: true
    ownerFirstName?: true
    ownerMiddleName?: true
    ownerLastName?: true
    ownerTelephone?: true
    ownerGender?: true
    entityType?: true
    houseIdNumber?: true
    accommodationType?: true
    accommodationName?: true
    position?: true
    positionOther?: true
    addressNumber?: true
    villageNumber?: true
    alley?: true
    road?: true
    province?: true
    district?: true
    subDistrict?: true
    postalCode?: true
    latitude?: true
    longitude?: true
    houseRegistrationUrl?: true
    houseRegistrationPath?: true
    ocrProcessed?: true
    ocrProcessedAt?: true
    ocrRawData?: true
    ocrConfidence?: true
    status?: true
    tm30Id?: true
    submittedAt?: true
    approvedAt?: true
    rejectedAt?: true
    rejectionReason?: true
    errorMessage?: true
    propertyId?: true
    propertyOwnerId?: true
    whatsappPhone?: true
    whatsappSessionId?: true
    createdBy?: true
    updatedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Tm30AccommodationRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tm30AccommodationRequest to aggregate.
     */
    where?: Tm30AccommodationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tm30AccommodationRequests to fetch.
     */
    orderBy?: Tm30AccommodationRequestOrderByWithRelationInput | Tm30AccommodationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Tm30AccommodationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tm30AccommodationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tm30AccommodationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tm30AccommodationRequests
    **/
    _count?: true | Tm30AccommodationRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tm30AccommodationRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tm30AccommodationRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tm30AccommodationRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tm30AccommodationRequestMaxAggregateInputType
  }

  export type GetTm30AccommodationRequestAggregateType<T extends Tm30AccommodationRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateTm30AccommodationRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTm30AccommodationRequest[P]>
      : GetScalarType<T[P], AggregateTm30AccommodationRequest[P]>
  }




  export type Tm30AccommodationRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tm30AccommodationRequestWhereInput
    orderBy?: Tm30AccommodationRequestOrderByWithAggregationInput | Tm30AccommodationRequestOrderByWithAggregationInput[]
    by: Tm30AccommodationRequestScalarFieldEnum[] | Tm30AccommodationRequestScalarFieldEnum
    having?: Tm30AccommodationRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tm30AccommodationRequestCountAggregateInputType | true
    _avg?: Tm30AccommodationRequestAvgAggregateInputType
    _sum?: Tm30AccommodationRequestSumAggregateInputType
    _min?: Tm30AccommodationRequestMinAggregateInputType
    _max?: Tm30AccommodationRequestMaxAggregateInputType
  }

  export type Tm30AccommodationRequestGroupByOutputType = {
    id: string
    ownerSameAsRegistrant: boolean
    ownerNationalType: string
    ownerNationalId: string | null
    ownerPassportNumber: string | null
    ownerFirstName: string
    ownerMiddleName: string | null
    ownerLastName: string
    ownerTelephone: string
    ownerGender: string | null
    entityType: string
    houseIdNumber: string | null
    accommodationType: string
    accommodationName: string
    position: string | null
    positionOther: string | null
    addressNumber: string
    villageNumber: string | null
    alley: string | null
    road: string | null
    province: string
    district: string
    subDistrict: string
    postalCode: string
    latitude: number | null
    longitude: number | null
    houseRegistrationUrl: string | null
    houseRegistrationPath: string | null
    ocrProcessed: boolean
    ocrProcessedAt: Date | null
    ocrRawData: JsonValue | null
    ocrConfidence: number | null
    status: $Enums.Tm30AccomRequestStatus
    tm30Id: string | null
    submittedAt: Date | null
    approvedAt: Date | null
    rejectedAt: Date | null
    rejectionReason: string | null
    errorMessage: string | null
    propertyId: string | null
    propertyOwnerId: string | null
    whatsappPhone: string | null
    whatsappSessionId: string | null
    createdBy: string | null
    updatedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: Tm30AccommodationRequestCountAggregateOutputType | null
    _avg: Tm30AccommodationRequestAvgAggregateOutputType | null
    _sum: Tm30AccommodationRequestSumAggregateOutputType | null
    _min: Tm30AccommodationRequestMinAggregateOutputType | null
    _max: Tm30AccommodationRequestMaxAggregateOutputType | null
  }

  type GetTm30AccommodationRequestGroupByPayload<T extends Tm30AccommodationRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tm30AccommodationRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tm30AccommodationRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tm30AccommodationRequestGroupByOutputType[P]>
            : GetScalarType<T[P], Tm30AccommodationRequestGroupByOutputType[P]>
        }
      >
    >


  export type Tm30AccommodationRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerSameAsRegistrant?: boolean
    ownerNationalType?: boolean
    ownerNationalId?: boolean
    ownerPassportNumber?: boolean
    ownerFirstName?: boolean
    ownerMiddleName?: boolean
    ownerLastName?: boolean
    ownerTelephone?: boolean
    ownerGender?: boolean
    entityType?: boolean
    houseIdNumber?: boolean
    accommodationType?: boolean
    accommodationName?: boolean
    position?: boolean
    positionOther?: boolean
    addressNumber?: boolean
    villageNumber?: boolean
    alley?: boolean
    road?: boolean
    province?: boolean
    district?: boolean
    subDistrict?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    houseRegistrationUrl?: boolean
    houseRegistrationPath?: boolean
    ocrProcessed?: boolean
    ocrProcessedAt?: boolean
    ocrRawData?: boolean
    ocrConfidence?: boolean
    status?: boolean
    tm30Id?: boolean
    submittedAt?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    rejectionReason?: boolean
    errorMessage?: boolean
    propertyId?: boolean
    propertyOwnerId?: boolean
    whatsappPhone?: boolean
    whatsappSessionId?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    propertyOwner?: boolean | Tm30AccommodationRequest$propertyOwnerArgs<ExtArgs>
  }, ExtArgs["result"]["tm30AccommodationRequest"]>

  export type Tm30AccommodationRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerSameAsRegistrant?: boolean
    ownerNationalType?: boolean
    ownerNationalId?: boolean
    ownerPassportNumber?: boolean
    ownerFirstName?: boolean
    ownerMiddleName?: boolean
    ownerLastName?: boolean
    ownerTelephone?: boolean
    ownerGender?: boolean
    entityType?: boolean
    houseIdNumber?: boolean
    accommodationType?: boolean
    accommodationName?: boolean
    position?: boolean
    positionOther?: boolean
    addressNumber?: boolean
    villageNumber?: boolean
    alley?: boolean
    road?: boolean
    province?: boolean
    district?: boolean
    subDistrict?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    houseRegistrationUrl?: boolean
    houseRegistrationPath?: boolean
    ocrProcessed?: boolean
    ocrProcessedAt?: boolean
    ocrRawData?: boolean
    ocrConfidence?: boolean
    status?: boolean
    tm30Id?: boolean
    submittedAt?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    rejectionReason?: boolean
    errorMessage?: boolean
    propertyId?: boolean
    propertyOwnerId?: boolean
    whatsappPhone?: boolean
    whatsappSessionId?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    propertyOwner?: boolean | Tm30AccommodationRequest$propertyOwnerArgs<ExtArgs>
  }, ExtArgs["result"]["tm30AccommodationRequest"]>

  export type Tm30AccommodationRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerSameAsRegistrant?: boolean
    ownerNationalType?: boolean
    ownerNationalId?: boolean
    ownerPassportNumber?: boolean
    ownerFirstName?: boolean
    ownerMiddleName?: boolean
    ownerLastName?: boolean
    ownerTelephone?: boolean
    ownerGender?: boolean
    entityType?: boolean
    houseIdNumber?: boolean
    accommodationType?: boolean
    accommodationName?: boolean
    position?: boolean
    positionOther?: boolean
    addressNumber?: boolean
    villageNumber?: boolean
    alley?: boolean
    road?: boolean
    province?: boolean
    district?: boolean
    subDistrict?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    houseRegistrationUrl?: boolean
    houseRegistrationPath?: boolean
    ocrProcessed?: boolean
    ocrProcessedAt?: boolean
    ocrRawData?: boolean
    ocrConfidence?: boolean
    status?: boolean
    tm30Id?: boolean
    submittedAt?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    rejectionReason?: boolean
    errorMessage?: boolean
    propertyId?: boolean
    propertyOwnerId?: boolean
    whatsappPhone?: boolean
    whatsappSessionId?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    propertyOwner?: boolean | Tm30AccommodationRequest$propertyOwnerArgs<ExtArgs>
  }, ExtArgs["result"]["tm30AccommodationRequest"]>

  export type Tm30AccommodationRequestSelectScalar = {
    id?: boolean
    ownerSameAsRegistrant?: boolean
    ownerNationalType?: boolean
    ownerNationalId?: boolean
    ownerPassportNumber?: boolean
    ownerFirstName?: boolean
    ownerMiddleName?: boolean
    ownerLastName?: boolean
    ownerTelephone?: boolean
    ownerGender?: boolean
    entityType?: boolean
    houseIdNumber?: boolean
    accommodationType?: boolean
    accommodationName?: boolean
    position?: boolean
    positionOther?: boolean
    addressNumber?: boolean
    villageNumber?: boolean
    alley?: boolean
    road?: boolean
    province?: boolean
    district?: boolean
    subDistrict?: boolean
    postalCode?: boolean
    latitude?: boolean
    longitude?: boolean
    houseRegistrationUrl?: boolean
    houseRegistrationPath?: boolean
    ocrProcessed?: boolean
    ocrProcessedAt?: boolean
    ocrRawData?: boolean
    ocrConfidence?: boolean
    status?: boolean
    tm30Id?: boolean
    submittedAt?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    rejectionReason?: boolean
    errorMessage?: boolean
    propertyId?: boolean
    propertyOwnerId?: boolean
    whatsappPhone?: boolean
    whatsappSessionId?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type Tm30AccommodationRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ownerSameAsRegistrant" | "ownerNationalType" | "ownerNationalId" | "ownerPassportNumber" | "ownerFirstName" | "ownerMiddleName" | "ownerLastName" | "ownerTelephone" | "ownerGender" | "entityType" | "houseIdNumber" | "accommodationType" | "accommodationName" | "position" | "positionOther" | "addressNumber" | "villageNumber" | "alley" | "road" | "province" | "district" | "subDistrict" | "postalCode" | "latitude" | "longitude" | "houseRegistrationUrl" | "houseRegistrationPath" | "ocrProcessed" | "ocrProcessedAt" | "ocrRawData" | "ocrConfidence" | "status" | "tm30Id" | "submittedAt" | "approvedAt" | "rejectedAt" | "rejectionReason" | "errorMessage" | "propertyId" | "propertyOwnerId" | "whatsappPhone" | "whatsappSessionId" | "createdBy" | "updatedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["tm30AccommodationRequest"]>
  export type Tm30AccommodationRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyOwner?: boolean | Tm30AccommodationRequest$propertyOwnerArgs<ExtArgs>
  }
  export type Tm30AccommodationRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyOwner?: boolean | Tm30AccommodationRequest$propertyOwnerArgs<ExtArgs>
  }
  export type Tm30AccommodationRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propertyOwner?: boolean | Tm30AccommodationRequest$propertyOwnerArgs<ExtArgs>
  }

  export type $Tm30AccommodationRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tm30AccommodationRequest"
    objects: {
      propertyOwner: Prisma.$PropertyOwnerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerSameAsRegistrant: boolean
      ownerNationalType: string
      ownerNationalId: string | null
      ownerPassportNumber: string | null
      ownerFirstName: string
      ownerMiddleName: string | null
      ownerLastName: string
      ownerTelephone: string
      ownerGender: string | null
      entityType: string
      houseIdNumber: string | null
      accommodationType: string
      accommodationName: string
      position: string | null
      positionOther: string | null
      addressNumber: string
      villageNumber: string | null
      alley: string | null
      road: string | null
      province: string
      district: string
      subDistrict: string
      postalCode: string
      latitude: number | null
      longitude: number | null
      houseRegistrationUrl: string | null
      houseRegistrationPath: string | null
      ocrProcessed: boolean
      ocrProcessedAt: Date | null
      ocrRawData: Prisma.JsonValue | null
      ocrConfidence: number | null
      status: $Enums.Tm30AccomRequestStatus
      tm30Id: string | null
      submittedAt: Date | null
      approvedAt: Date | null
      rejectedAt: Date | null
      rejectionReason: string | null
      errorMessage: string | null
      propertyId: string | null
      propertyOwnerId: string | null
      whatsappPhone: string | null
      whatsappSessionId: string | null
      createdBy: string | null
      updatedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tm30AccommodationRequest"]>
    composites: {}
  }

  type Tm30AccommodationRequestGetPayload<S extends boolean | null | undefined | Tm30AccommodationRequestDefaultArgs> = $Result.GetResult<Prisma.$Tm30AccommodationRequestPayload, S>

  type Tm30AccommodationRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Tm30AccommodationRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tm30AccommodationRequestCountAggregateInputType | true
    }

  export interface Tm30AccommodationRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tm30AccommodationRequest'], meta: { name: 'Tm30AccommodationRequest' } }
    /**
     * Find zero or one Tm30AccommodationRequest that matches the filter.
     * @param {Tm30AccommodationRequestFindUniqueArgs} args - Arguments to find a Tm30AccommodationRequest
     * @example
     * // Get one Tm30AccommodationRequest
     * const tm30AccommodationRequest = await prisma.tm30AccommodationRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Tm30AccommodationRequestFindUniqueArgs>(args: SelectSubset<T, Tm30AccommodationRequestFindUniqueArgs<ExtArgs>>): Prisma__Tm30AccommodationRequestClient<$Result.GetResult<Prisma.$Tm30AccommodationRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tm30AccommodationRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Tm30AccommodationRequestFindUniqueOrThrowArgs} args - Arguments to find a Tm30AccommodationRequest
     * @example
     * // Get one Tm30AccommodationRequest
     * const tm30AccommodationRequest = await prisma.tm30AccommodationRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Tm30AccommodationRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, Tm30AccommodationRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Tm30AccommodationRequestClient<$Result.GetResult<Prisma.$Tm30AccommodationRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tm30AccommodationRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tm30AccommodationRequestFindFirstArgs} args - Arguments to find a Tm30AccommodationRequest
     * @example
     * // Get one Tm30AccommodationRequest
     * const tm30AccommodationRequest = await prisma.tm30AccommodationRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Tm30AccommodationRequestFindFirstArgs>(args?: SelectSubset<T, Tm30AccommodationRequestFindFirstArgs<ExtArgs>>): Prisma__Tm30AccommodationRequestClient<$Result.GetResult<Prisma.$Tm30AccommodationRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tm30AccommodationRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tm30AccommodationRequestFindFirstOrThrowArgs} args - Arguments to find a Tm30AccommodationRequest
     * @example
     * // Get one Tm30AccommodationRequest
     * const tm30AccommodationRequest = await prisma.tm30AccommodationRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Tm30AccommodationRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, Tm30AccommodationRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__Tm30AccommodationRequestClient<$Result.GetResult<Prisma.$Tm30AccommodationRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tm30AccommodationRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tm30AccommodationRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tm30AccommodationRequests
     * const tm30AccommodationRequests = await prisma.tm30AccommodationRequest.findMany()
     * 
     * // Get first 10 Tm30AccommodationRequests
     * const tm30AccommodationRequests = await prisma.tm30AccommodationRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tm30AccommodationRequestWithIdOnly = await prisma.tm30AccommodationRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Tm30AccommodationRequestFindManyArgs>(args?: SelectSubset<T, Tm30AccommodationRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tm30AccommodationRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tm30AccommodationRequest.
     * @param {Tm30AccommodationRequestCreateArgs} args - Arguments to create a Tm30AccommodationRequest.
     * @example
     * // Create one Tm30AccommodationRequest
     * const Tm30AccommodationRequest = await prisma.tm30AccommodationRequest.create({
     *   data: {
     *     // ... data to create a Tm30AccommodationRequest
     *   }
     * })
     * 
     */
    create<T extends Tm30AccommodationRequestCreateArgs>(args: SelectSubset<T, Tm30AccommodationRequestCreateArgs<ExtArgs>>): Prisma__Tm30AccommodationRequestClient<$Result.GetResult<Prisma.$Tm30AccommodationRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tm30AccommodationRequests.
     * @param {Tm30AccommodationRequestCreateManyArgs} args - Arguments to create many Tm30AccommodationRequests.
     * @example
     * // Create many Tm30AccommodationRequests
     * const tm30AccommodationRequest = await prisma.tm30AccommodationRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Tm30AccommodationRequestCreateManyArgs>(args?: SelectSubset<T, Tm30AccommodationRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tm30AccommodationRequests and returns the data saved in the database.
     * @param {Tm30AccommodationRequestCreateManyAndReturnArgs} args - Arguments to create many Tm30AccommodationRequests.
     * @example
     * // Create many Tm30AccommodationRequests
     * const tm30AccommodationRequest = await prisma.tm30AccommodationRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tm30AccommodationRequests and only return the `id`
     * const tm30AccommodationRequestWithIdOnly = await prisma.tm30AccommodationRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Tm30AccommodationRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, Tm30AccommodationRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tm30AccommodationRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tm30AccommodationRequest.
     * @param {Tm30AccommodationRequestDeleteArgs} args - Arguments to delete one Tm30AccommodationRequest.
     * @example
     * // Delete one Tm30AccommodationRequest
     * const Tm30AccommodationRequest = await prisma.tm30AccommodationRequest.delete({
     *   where: {
     *     // ... filter to delete one Tm30AccommodationRequest
     *   }
     * })
     * 
     */
    delete<T extends Tm30AccommodationRequestDeleteArgs>(args: SelectSubset<T, Tm30AccommodationRequestDeleteArgs<ExtArgs>>): Prisma__Tm30AccommodationRequestClient<$Result.GetResult<Prisma.$Tm30AccommodationRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tm30AccommodationRequest.
     * @param {Tm30AccommodationRequestUpdateArgs} args - Arguments to update one Tm30AccommodationRequest.
     * @example
     * // Update one Tm30AccommodationRequest
     * const tm30AccommodationRequest = await prisma.tm30AccommodationRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Tm30AccommodationRequestUpdateArgs>(args: SelectSubset<T, Tm30AccommodationRequestUpdateArgs<ExtArgs>>): Prisma__Tm30AccommodationRequestClient<$Result.GetResult<Prisma.$Tm30AccommodationRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tm30AccommodationRequests.
     * @param {Tm30AccommodationRequestDeleteManyArgs} args - Arguments to filter Tm30AccommodationRequests to delete.
     * @example
     * // Delete a few Tm30AccommodationRequests
     * const { count } = await prisma.tm30AccommodationRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Tm30AccommodationRequestDeleteManyArgs>(args?: SelectSubset<T, Tm30AccommodationRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tm30AccommodationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tm30AccommodationRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tm30AccommodationRequests
     * const tm30AccommodationRequest = await prisma.tm30AccommodationRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Tm30AccommodationRequestUpdateManyArgs>(args: SelectSubset<T, Tm30AccommodationRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tm30AccommodationRequests and returns the data updated in the database.
     * @param {Tm30AccommodationRequestUpdateManyAndReturnArgs} args - Arguments to update many Tm30AccommodationRequests.
     * @example
     * // Update many Tm30AccommodationRequests
     * const tm30AccommodationRequest = await prisma.tm30AccommodationRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tm30AccommodationRequests and only return the `id`
     * const tm30AccommodationRequestWithIdOnly = await prisma.tm30AccommodationRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Tm30AccommodationRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, Tm30AccommodationRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tm30AccommodationRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tm30AccommodationRequest.
     * @param {Tm30AccommodationRequestUpsertArgs} args - Arguments to update or create a Tm30AccommodationRequest.
     * @example
     * // Update or create a Tm30AccommodationRequest
     * const tm30AccommodationRequest = await prisma.tm30AccommodationRequest.upsert({
     *   create: {
     *     // ... data to create a Tm30AccommodationRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tm30AccommodationRequest we want to update
     *   }
     * })
     */
    upsert<T extends Tm30AccommodationRequestUpsertArgs>(args: SelectSubset<T, Tm30AccommodationRequestUpsertArgs<ExtArgs>>): Prisma__Tm30AccommodationRequestClient<$Result.GetResult<Prisma.$Tm30AccommodationRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tm30AccommodationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tm30AccommodationRequestCountArgs} args - Arguments to filter Tm30AccommodationRequests to count.
     * @example
     * // Count the number of Tm30AccommodationRequests
     * const count = await prisma.tm30AccommodationRequest.count({
     *   where: {
     *     // ... the filter for the Tm30AccommodationRequests we want to count
     *   }
     * })
    **/
    count<T extends Tm30AccommodationRequestCountArgs>(
      args?: Subset<T, Tm30AccommodationRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tm30AccommodationRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tm30AccommodationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tm30AccommodationRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tm30AccommodationRequestAggregateArgs>(args: Subset<T, Tm30AccommodationRequestAggregateArgs>): Prisma.PrismaPromise<GetTm30AccommodationRequestAggregateType<T>>

    /**
     * Group by Tm30AccommodationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tm30AccommodationRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tm30AccommodationRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tm30AccommodationRequestGroupByArgs['orderBy'] }
        : { orderBy?: Tm30AccommodationRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tm30AccommodationRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTm30AccommodationRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tm30AccommodationRequest model
   */
  readonly fields: Tm30AccommodationRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tm30AccommodationRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Tm30AccommodationRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    propertyOwner<T extends Tm30AccommodationRequest$propertyOwnerArgs<ExtArgs> = {}>(args?: Subset<T, Tm30AccommodationRequest$propertyOwnerArgs<ExtArgs>>): Prisma__PropertyOwnerClient<$Result.GetResult<Prisma.$PropertyOwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tm30AccommodationRequest model
   */
  interface Tm30AccommodationRequestFieldRefs {
    readonly id: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly ownerSameAsRegistrant: FieldRef<"Tm30AccommodationRequest", 'Boolean'>
    readonly ownerNationalType: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly ownerNationalId: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly ownerPassportNumber: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly ownerFirstName: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly ownerMiddleName: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly ownerLastName: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly ownerTelephone: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly ownerGender: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly entityType: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly houseIdNumber: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly accommodationType: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly accommodationName: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly position: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly positionOther: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly addressNumber: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly villageNumber: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly alley: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly road: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly province: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly district: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly subDistrict: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly postalCode: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly latitude: FieldRef<"Tm30AccommodationRequest", 'Float'>
    readonly longitude: FieldRef<"Tm30AccommodationRequest", 'Float'>
    readonly houseRegistrationUrl: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly houseRegistrationPath: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly ocrProcessed: FieldRef<"Tm30AccommodationRequest", 'Boolean'>
    readonly ocrProcessedAt: FieldRef<"Tm30AccommodationRequest", 'DateTime'>
    readonly ocrRawData: FieldRef<"Tm30AccommodationRequest", 'Json'>
    readonly ocrConfidence: FieldRef<"Tm30AccommodationRequest", 'Float'>
    readonly status: FieldRef<"Tm30AccommodationRequest", 'Tm30AccomRequestStatus'>
    readonly tm30Id: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly submittedAt: FieldRef<"Tm30AccommodationRequest", 'DateTime'>
    readonly approvedAt: FieldRef<"Tm30AccommodationRequest", 'DateTime'>
    readonly rejectedAt: FieldRef<"Tm30AccommodationRequest", 'DateTime'>
    readonly rejectionReason: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly errorMessage: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly propertyId: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly propertyOwnerId: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly whatsappPhone: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly whatsappSessionId: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly createdBy: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly updatedBy: FieldRef<"Tm30AccommodationRequest", 'String'>
    readonly createdAt: FieldRef<"Tm30AccommodationRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"Tm30AccommodationRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tm30AccommodationRequest findUnique
   */
  export type Tm30AccommodationRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30AccommodationRequest
     */
    select?: Tm30AccommodationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30AccommodationRequest
     */
    omit?: Tm30AccommodationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationRequestInclude<ExtArgs> | null
    /**
     * Filter, which Tm30AccommodationRequest to fetch.
     */
    where: Tm30AccommodationRequestWhereUniqueInput
  }

  /**
   * Tm30AccommodationRequest findUniqueOrThrow
   */
  export type Tm30AccommodationRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30AccommodationRequest
     */
    select?: Tm30AccommodationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30AccommodationRequest
     */
    omit?: Tm30AccommodationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationRequestInclude<ExtArgs> | null
    /**
     * Filter, which Tm30AccommodationRequest to fetch.
     */
    where: Tm30AccommodationRequestWhereUniqueInput
  }

  /**
   * Tm30AccommodationRequest findFirst
   */
  export type Tm30AccommodationRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30AccommodationRequest
     */
    select?: Tm30AccommodationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30AccommodationRequest
     */
    omit?: Tm30AccommodationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationRequestInclude<ExtArgs> | null
    /**
     * Filter, which Tm30AccommodationRequest to fetch.
     */
    where?: Tm30AccommodationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tm30AccommodationRequests to fetch.
     */
    orderBy?: Tm30AccommodationRequestOrderByWithRelationInput | Tm30AccommodationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tm30AccommodationRequests.
     */
    cursor?: Tm30AccommodationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tm30AccommodationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tm30AccommodationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tm30AccommodationRequests.
     */
    distinct?: Tm30AccommodationRequestScalarFieldEnum | Tm30AccommodationRequestScalarFieldEnum[]
  }

  /**
   * Tm30AccommodationRequest findFirstOrThrow
   */
  export type Tm30AccommodationRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30AccommodationRequest
     */
    select?: Tm30AccommodationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30AccommodationRequest
     */
    omit?: Tm30AccommodationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationRequestInclude<ExtArgs> | null
    /**
     * Filter, which Tm30AccommodationRequest to fetch.
     */
    where?: Tm30AccommodationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tm30AccommodationRequests to fetch.
     */
    orderBy?: Tm30AccommodationRequestOrderByWithRelationInput | Tm30AccommodationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tm30AccommodationRequests.
     */
    cursor?: Tm30AccommodationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tm30AccommodationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tm30AccommodationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tm30AccommodationRequests.
     */
    distinct?: Tm30AccommodationRequestScalarFieldEnum | Tm30AccommodationRequestScalarFieldEnum[]
  }

  /**
   * Tm30AccommodationRequest findMany
   */
  export type Tm30AccommodationRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30AccommodationRequest
     */
    select?: Tm30AccommodationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30AccommodationRequest
     */
    omit?: Tm30AccommodationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationRequestInclude<ExtArgs> | null
    /**
     * Filter, which Tm30AccommodationRequests to fetch.
     */
    where?: Tm30AccommodationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tm30AccommodationRequests to fetch.
     */
    orderBy?: Tm30AccommodationRequestOrderByWithRelationInput | Tm30AccommodationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tm30AccommodationRequests.
     */
    cursor?: Tm30AccommodationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tm30AccommodationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tm30AccommodationRequests.
     */
    skip?: number
    distinct?: Tm30AccommodationRequestScalarFieldEnum | Tm30AccommodationRequestScalarFieldEnum[]
  }

  /**
   * Tm30AccommodationRequest create
   */
  export type Tm30AccommodationRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30AccommodationRequest
     */
    select?: Tm30AccommodationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30AccommodationRequest
     */
    omit?: Tm30AccommodationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a Tm30AccommodationRequest.
     */
    data: XOR<Tm30AccommodationRequestCreateInput, Tm30AccommodationRequestUncheckedCreateInput>
  }

  /**
   * Tm30AccommodationRequest createMany
   */
  export type Tm30AccommodationRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tm30AccommodationRequests.
     */
    data: Tm30AccommodationRequestCreateManyInput | Tm30AccommodationRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tm30AccommodationRequest createManyAndReturn
   */
  export type Tm30AccommodationRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30AccommodationRequest
     */
    select?: Tm30AccommodationRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30AccommodationRequest
     */
    omit?: Tm30AccommodationRequestOmit<ExtArgs> | null
    /**
     * The data used to create many Tm30AccommodationRequests.
     */
    data: Tm30AccommodationRequestCreateManyInput | Tm30AccommodationRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tm30AccommodationRequest update
   */
  export type Tm30AccommodationRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30AccommodationRequest
     */
    select?: Tm30AccommodationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30AccommodationRequest
     */
    omit?: Tm30AccommodationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a Tm30AccommodationRequest.
     */
    data: XOR<Tm30AccommodationRequestUpdateInput, Tm30AccommodationRequestUncheckedUpdateInput>
    /**
     * Choose, which Tm30AccommodationRequest to update.
     */
    where: Tm30AccommodationRequestWhereUniqueInput
  }

  /**
   * Tm30AccommodationRequest updateMany
   */
  export type Tm30AccommodationRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tm30AccommodationRequests.
     */
    data: XOR<Tm30AccommodationRequestUpdateManyMutationInput, Tm30AccommodationRequestUncheckedUpdateManyInput>
    /**
     * Filter which Tm30AccommodationRequests to update
     */
    where?: Tm30AccommodationRequestWhereInput
    /**
     * Limit how many Tm30AccommodationRequests to update.
     */
    limit?: number
  }

  /**
   * Tm30AccommodationRequest updateManyAndReturn
   */
  export type Tm30AccommodationRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30AccommodationRequest
     */
    select?: Tm30AccommodationRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30AccommodationRequest
     */
    omit?: Tm30AccommodationRequestOmit<ExtArgs> | null
    /**
     * The data used to update Tm30AccommodationRequests.
     */
    data: XOR<Tm30AccommodationRequestUpdateManyMutationInput, Tm30AccommodationRequestUncheckedUpdateManyInput>
    /**
     * Filter which Tm30AccommodationRequests to update
     */
    where?: Tm30AccommodationRequestWhereInput
    /**
     * Limit how many Tm30AccommodationRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tm30AccommodationRequest upsert
   */
  export type Tm30AccommodationRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30AccommodationRequest
     */
    select?: Tm30AccommodationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30AccommodationRequest
     */
    omit?: Tm30AccommodationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the Tm30AccommodationRequest to update in case it exists.
     */
    where: Tm30AccommodationRequestWhereUniqueInput
    /**
     * In case the Tm30AccommodationRequest found by the `where` argument doesn't exist, create a new Tm30AccommodationRequest with this data.
     */
    create: XOR<Tm30AccommodationRequestCreateInput, Tm30AccommodationRequestUncheckedCreateInput>
    /**
     * In case the Tm30AccommodationRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Tm30AccommodationRequestUpdateInput, Tm30AccommodationRequestUncheckedUpdateInput>
  }

  /**
   * Tm30AccommodationRequest delete
   */
  export type Tm30AccommodationRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30AccommodationRequest
     */
    select?: Tm30AccommodationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30AccommodationRequest
     */
    omit?: Tm30AccommodationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationRequestInclude<ExtArgs> | null
    /**
     * Filter which Tm30AccommodationRequest to delete.
     */
    where: Tm30AccommodationRequestWhereUniqueInput
  }

  /**
   * Tm30AccommodationRequest deleteMany
   */
  export type Tm30AccommodationRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tm30AccommodationRequests to delete
     */
    where?: Tm30AccommodationRequestWhereInput
    /**
     * Limit how many Tm30AccommodationRequests to delete.
     */
    limit?: number
  }

  /**
   * Tm30AccommodationRequest.propertyOwner
   */
  export type Tm30AccommodationRequest$propertyOwnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwner
     */
    select?: PropertyOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwner
     */
    omit?: PropertyOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerInclude<ExtArgs> | null
    where?: PropertyOwnerWhereInput
  }

  /**
   * Tm30AccommodationRequest without action
   */
  export type Tm30AccommodationRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30AccommodationRequest
     */
    select?: Tm30AccommodationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30AccommodationRequest
     */
    omit?: Tm30AccommodationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationRequestInclude<ExtArgs> | null
  }


  /**
   * Model PropertyOwner
   */

  export type AggregatePropertyOwner = {
    _count: PropertyOwnerCountAggregateOutputType | null
    _min: PropertyOwnerMinAggregateOutputType | null
    _max: PropertyOwnerMaxAggregateOutputType | null
  }

  export type PropertyOwnerMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    thaiIdNumber: string | null
    phone: string | null
    email: string | null
    gender: string | null
    idCardUrl: string | null
    idCardPath: string | null
    idCardVerified: boolean | null
    idCardUploadedAt: Date | null
    isActive: boolean | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyOwnerMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    thaiIdNumber: string | null
    phone: string | null
    email: string | null
    gender: string | null
    idCardUrl: string | null
    idCardPath: string | null
    idCardVerified: boolean | null
    idCardUploadedAt: Date | null
    isActive: boolean | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyOwnerCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    thaiIdNumber: number
    phone: number
    email: number
    gender: number
    idCardUrl: number
    idCardPath: number
    idCardOcrData: number
    idCardVerified: number
    idCardUploadedAt: number
    isActive: number
    isVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyOwnerMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    thaiIdNumber?: true
    phone?: true
    email?: true
    gender?: true
    idCardUrl?: true
    idCardPath?: true
    idCardVerified?: true
    idCardUploadedAt?: true
    isActive?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyOwnerMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    thaiIdNumber?: true
    phone?: true
    email?: true
    gender?: true
    idCardUrl?: true
    idCardPath?: true
    idCardVerified?: true
    idCardUploadedAt?: true
    isActive?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyOwnerCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    thaiIdNumber?: true
    phone?: true
    email?: true
    gender?: true
    idCardUrl?: true
    idCardPath?: true
    idCardOcrData?: true
    idCardVerified?: true
    idCardUploadedAt?: true
    isActive?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyOwnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyOwner to aggregate.
     */
    where?: PropertyOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyOwners to fetch.
     */
    orderBy?: PropertyOwnerOrderByWithRelationInput | PropertyOwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyOwners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyOwners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyOwners
    **/
    _count?: true | PropertyOwnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyOwnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyOwnerMaxAggregateInputType
  }

  export type GetPropertyOwnerAggregateType<T extends PropertyOwnerAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyOwner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyOwner[P]>
      : GetScalarType<T[P], AggregatePropertyOwner[P]>
  }




  export type PropertyOwnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyOwnerWhereInput
    orderBy?: PropertyOwnerOrderByWithAggregationInput | PropertyOwnerOrderByWithAggregationInput[]
    by: PropertyOwnerScalarFieldEnum[] | PropertyOwnerScalarFieldEnum
    having?: PropertyOwnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyOwnerCountAggregateInputType | true
    _min?: PropertyOwnerMinAggregateInputType
    _max?: PropertyOwnerMaxAggregateInputType
  }

  export type PropertyOwnerGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    thaiIdNumber: string | null
    phone: string
    email: string | null
    gender: string | null
    idCardUrl: string | null
    idCardPath: string | null
    idCardOcrData: JsonValue | null
    idCardVerified: boolean
    idCardUploadedAt: Date | null
    isActive: boolean
    isVerified: boolean
    createdAt: Date
    updatedAt: Date
    _count: PropertyOwnerCountAggregateOutputType | null
    _min: PropertyOwnerMinAggregateOutputType | null
    _max: PropertyOwnerMaxAggregateOutputType | null
  }

  type GetPropertyOwnerGroupByPayload<T extends PropertyOwnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyOwnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyOwnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyOwnerGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyOwnerGroupByOutputType[P]>
        }
      >
    >


  export type PropertyOwnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    thaiIdNumber?: boolean
    phone?: boolean
    email?: boolean
    gender?: boolean
    idCardUrl?: boolean
    idCardPath?: boolean
    idCardOcrData?: boolean
    idCardVerified?: boolean
    idCardUploadedAt?: boolean
    isActive?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    documents?: boolean | PropertyOwner$documentsArgs<ExtArgs>
    properties?: boolean | PropertyOwner$propertiesArgs<ExtArgs>
    tm30Requests?: boolean | PropertyOwner$tm30RequestsArgs<ExtArgs>
    _count?: boolean | PropertyOwnerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyOwner"]>

  export type PropertyOwnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    thaiIdNumber?: boolean
    phone?: boolean
    email?: boolean
    gender?: boolean
    idCardUrl?: boolean
    idCardPath?: boolean
    idCardOcrData?: boolean
    idCardVerified?: boolean
    idCardUploadedAt?: boolean
    isActive?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["propertyOwner"]>

  export type PropertyOwnerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    thaiIdNumber?: boolean
    phone?: boolean
    email?: boolean
    gender?: boolean
    idCardUrl?: boolean
    idCardPath?: boolean
    idCardOcrData?: boolean
    idCardVerified?: boolean
    idCardUploadedAt?: boolean
    isActive?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["propertyOwner"]>

  export type PropertyOwnerSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    thaiIdNumber?: boolean
    phone?: boolean
    email?: boolean
    gender?: boolean
    idCardUrl?: boolean
    idCardPath?: boolean
    idCardOcrData?: boolean
    idCardVerified?: boolean
    idCardUploadedAt?: boolean
    isActive?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyOwnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "thaiIdNumber" | "phone" | "email" | "gender" | "idCardUrl" | "idCardPath" | "idCardOcrData" | "idCardVerified" | "idCardUploadedAt" | "isActive" | "isVerified" | "createdAt" | "updatedAt", ExtArgs["result"]["propertyOwner"]>
  export type PropertyOwnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | PropertyOwner$documentsArgs<ExtArgs>
    properties?: boolean | PropertyOwner$propertiesArgs<ExtArgs>
    tm30Requests?: boolean | PropertyOwner$tm30RequestsArgs<ExtArgs>
    _count?: boolean | PropertyOwnerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyOwnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PropertyOwnerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PropertyOwnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyOwner"
    objects: {
      documents: Prisma.$OwnerDocumentPayload<ExtArgs>[]
      properties: Prisma.$PropertyPayload<ExtArgs>[]
      tm30Requests: Prisma.$Tm30AccommodationRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      thaiIdNumber: string | null
      phone: string
      email: string | null
      gender: string | null
      idCardUrl: string | null
      idCardPath: string | null
      idCardOcrData: Prisma.JsonValue | null
      idCardVerified: boolean
      idCardUploadedAt: Date | null
      isActive: boolean
      isVerified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["propertyOwner"]>
    composites: {}
  }

  type PropertyOwnerGetPayload<S extends boolean | null | undefined | PropertyOwnerDefaultArgs> = $Result.GetResult<Prisma.$PropertyOwnerPayload, S>

  type PropertyOwnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyOwnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyOwnerCountAggregateInputType | true
    }

  export interface PropertyOwnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyOwner'], meta: { name: 'PropertyOwner' } }
    /**
     * Find zero or one PropertyOwner that matches the filter.
     * @param {PropertyOwnerFindUniqueArgs} args - Arguments to find a PropertyOwner
     * @example
     * // Get one PropertyOwner
     * const propertyOwner = await prisma.propertyOwner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyOwnerFindUniqueArgs>(args: SelectSubset<T, PropertyOwnerFindUniqueArgs<ExtArgs>>): Prisma__PropertyOwnerClient<$Result.GetResult<Prisma.$PropertyOwnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyOwner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyOwnerFindUniqueOrThrowArgs} args - Arguments to find a PropertyOwner
     * @example
     * // Get one PropertyOwner
     * const propertyOwner = await prisma.propertyOwner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyOwnerFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyOwnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyOwnerClient<$Result.GetResult<Prisma.$PropertyOwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyOwner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyOwnerFindFirstArgs} args - Arguments to find a PropertyOwner
     * @example
     * // Get one PropertyOwner
     * const propertyOwner = await prisma.propertyOwner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyOwnerFindFirstArgs>(args?: SelectSubset<T, PropertyOwnerFindFirstArgs<ExtArgs>>): Prisma__PropertyOwnerClient<$Result.GetResult<Prisma.$PropertyOwnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyOwner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyOwnerFindFirstOrThrowArgs} args - Arguments to find a PropertyOwner
     * @example
     * // Get one PropertyOwner
     * const propertyOwner = await prisma.propertyOwner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyOwnerFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyOwnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyOwnerClient<$Result.GetResult<Prisma.$PropertyOwnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyOwners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyOwnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyOwners
     * const propertyOwners = await prisma.propertyOwner.findMany()
     * 
     * // Get first 10 PropertyOwners
     * const propertyOwners = await prisma.propertyOwner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyOwnerWithIdOnly = await prisma.propertyOwner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyOwnerFindManyArgs>(args?: SelectSubset<T, PropertyOwnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyOwnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyOwner.
     * @param {PropertyOwnerCreateArgs} args - Arguments to create a PropertyOwner.
     * @example
     * // Create one PropertyOwner
     * const PropertyOwner = await prisma.propertyOwner.create({
     *   data: {
     *     // ... data to create a PropertyOwner
     *   }
     * })
     * 
     */
    create<T extends PropertyOwnerCreateArgs>(args: SelectSubset<T, PropertyOwnerCreateArgs<ExtArgs>>): Prisma__PropertyOwnerClient<$Result.GetResult<Prisma.$PropertyOwnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyOwners.
     * @param {PropertyOwnerCreateManyArgs} args - Arguments to create many PropertyOwners.
     * @example
     * // Create many PropertyOwners
     * const propertyOwner = await prisma.propertyOwner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyOwnerCreateManyArgs>(args?: SelectSubset<T, PropertyOwnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyOwners and returns the data saved in the database.
     * @param {PropertyOwnerCreateManyAndReturnArgs} args - Arguments to create many PropertyOwners.
     * @example
     * // Create many PropertyOwners
     * const propertyOwner = await prisma.propertyOwner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyOwners and only return the `id`
     * const propertyOwnerWithIdOnly = await prisma.propertyOwner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyOwnerCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyOwnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyOwnerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyOwner.
     * @param {PropertyOwnerDeleteArgs} args - Arguments to delete one PropertyOwner.
     * @example
     * // Delete one PropertyOwner
     * const PropertyOwner = await prisma.propertyOwner.delete({
     *   where: {
     *     // ... filter to delete one PropertyOwner
     *   }
     * })
     * 
     */
    delete<T extends PropertyOwnerDeleteArgs>(args: SelectSubset<T, PropertyOwnerDeleteArgs<ExtArgs>>): Prisma__PropertyOwnerClient<$Result.GetResult<Prisma.$PropertyOwnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyOwner.
     * @param {PropertyOwnerUpdateArgs} args - Arguments to update one PropertyOwner.
     * @example
     * // Update one PropertyOwner
     * const propertyOwner = await prisma.propertyOwner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyOwnerUpdateArgs>(args: SelectSubset<T, PropertyOwnerUpdateArgs<ExtArgs>>): Prisma__PropertyOwnerClient<$Result.GetResult<Prisma.$PropertyOwnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyOwners.
     * @param {PropertyOwnerDeleteManyArgs} args - Arguments to filter PropertyOwners to delete.
     * @example
     * // Delete a few PropertyOwners
     * const { count } = await prisma.propertyOwner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyOwnerDeleteManyArgs>(args?: SelectSubset<T, PropertyOwnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyOwners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyOwnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyOwners
     * const propertyOwner = await prisma.propertyOwner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyOwnerUpdateManyArgs>(args: SelectSubset<T, PropertyOwnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyOwners and returns the data updated in the database.
     * @param {PropertyOwnerUpdateManyAndReturnArgs} args - Arguments to update many PropertyOwners.
     * @example
     * // Update many PropertyOwners
     * const propertyOwner = await prisma.propertyOwner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyOwners and only return the `id`
     * const propertyOwnerWithIdOnly = await prisma.propertyOwner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyOwnerUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyOwnerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyOwnerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyOwner.
     * @param {PropertyOwnerUpsertArgs} args - Arguments to update or create a PropertyOwner.
     * @example
     * // Update or create a PropertyOwner
     * const propertyOwner = await prisma.propertyOwner.upsert({
     *   create: {
     *     // ... data to create a PropertyOwner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyOwner we want to update
     *   }
     * })
     */
    upsert<T extends PropertyOwnerUpsertArgs>(args: SelectSubset<T, PropertyOwnerUpsertArgs<ExtArgs>>): Prisma__PropertyOwnerClient<$Result.GetResult<Prisma.$PropertyOwnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyOwners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyOwnerCountArgs} args - Arguments to filter PropertyOwners to count.
     * @example
     * // Count the number of PropertyOwners
     * const count = await prisma.propertyOwner.count({
     *   where: {
     *     // ... the filter for the PropertyOwners we want to count
     *   }
     * })
    **/
    count<T extends PropertyOwnerCountArgs>(
      args?: Subset<T, PropertyOwnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyOwnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyOwner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyOwnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyOwnerAggregateArgs>(args: Subset<T, PropertyOwnerAggregateArgs>): Prisma.PrismaPromise<GetPropertyOwnerAggregateType<T>>

    /**
     * Group by PropertyOwner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyOwnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyOwnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyOwnerGroupByArgs['orderBy'] }
        : { orderBy?: PropertyOwnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyOwnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyOwnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyOwner model
   */
  readonly fields: PropertyOwnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyOwner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyOwnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documents<T extends PropertyOwner$documentsArgs<ExtArgs> = {}>(args?: Subset<T, PropertyOwner$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    properties<T extends PropertyOwner$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, PropertyOwner$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tm30Requests<T extends PropertyOwner$tm30RequestsArgs<ExtArgs> = {}>(args?: Subset<T, PropertyOwner$tm30RequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tm30AccommodationRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyOwner model
   */
  interface PropertyOwnerFieldRefs {
    readonly id: FieldRef<"PropertyOwner", 'String'>
    readonly firstName: FieldRef<"PropertyOwner", 'String'>
    readonly lastName: FieldRef<"PropertyOwner", 'String'>
    readonly thaiIdNumber: FieldRef<"PropertyOwner", 'String'>
    readonly phone: FieldRef<"PropertyOwner", 'String'>
    readonly email: FieldRef<"PropertyOwner", 'String'>
    readonly gender: FieldRef<"PropertyOwner", 'String'>
    readonly idCardUrl: FieldRef<"PropertyOwner", 'String'>
    readonly idCardPath: FieldRef<"PropertyOwner", 'String'>
    readonly idCardOcrData: FieldRef<"PropertyOwner", 'Json'>
    readonly idCardVerified: FieldRef<"PropertyOwner", 'Boolean'>
    readonly idCardUploadedAt: FieldRef<"PropertyOwner", 'DateTime'>
    readonly isActive: FieldRef<"PropertyOwner", 'Boolean'>
    readonly isVerified: FieldRef<"PropertyOwner", 'Boolean'>
    readonly createdAt: FieldRef<"PropertyOwner", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertyOwner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyOwner findUnique
   */
  export type PropertyOwnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwner
     */
    select?: PropertyOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwner
     */
    omit?: PropertyOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerInclude<ExtArgs> | null
    /**
     * Filter, which PropertyOwner to fetch.
     */
    where: PropertyOwnerWhereUniqueInput
  }

  /**
   * PropertyOwner findUniqueOrThrow
   */
  export type PropertyOwnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwner
     */
    select?: PropertyOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwner
     */
    omit?: PropertyOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerInclude<ExtArgs> | null
    /**
     * Filter, which PropertyOwner to fetch.
     */
    where: PropertyOwnerWhereUniqueInput
  }

  /**
   * PropertyOwner findFirst
   */
  export type PropertyOwnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwner
     */
    select?: PropertyOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwner
     */
    omit?: PropertyOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerInclude<ExtArgs> | null
    /**
     * Filter, which PropertyOwner to fetch.
     */
    where?: PropertyOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyOwners to fetch.
     */
    orderBy?: PropertyOwnerOrderByWithRelationInput | PropertyOwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyOwners.
     */
    cursor?: PropertyOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyOwners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyOwners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyOwners.
     */
    distinct?: PropertyOwnerScalarFieldEnum | PropertyOwnerScalarFieldEnum[]
  }

  /**
   * PropertyOwner findFirstOrThrow
   */
  export type PropertyOwnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwner
     */
    select?: PropertyOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwner
     */
    omit?: PropertyOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerInclude<ExtArgs> | null
    /**
     * Filter, which PropertyOwner to fetch.
     */
    where?: PropertyOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyOwners to fetch.
     */
    orderBy?: PropertyOwnerOrderByWithRelationInput | PropertyOwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyOwners.
     */
    cursor?: PropertyOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyOwners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyOwners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyOwners.
     */
    distinct?: PropertyOwnerScalarFieldEnum | PropertyOwnerScalarFieldEnum[]
  }

  /**
   * PropertyOwner findMany
   */
  export type PropertyOwnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwner
     */
    select?: PropertyOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwner
     */
    omit?: PropertyOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerInclude<ExtArgs> | null
    /**
     * Filter, which PropertyOwners to fetch.
     */
    where?: PropertyOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyOwners to fetch.
     */
    orderBy?: PropertyOwnerOrderByWithRelationInput | PropertyOwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyOwners.
     */
    cursor?: PropertyOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyOwners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyOwners.
     */
    skip?: number
    distinct?: PropertyOwnerScalarFieldEnum | PropertyOwnerScalarFieldEnum[]
  }

  /**
   * PropertyOwner create
   */
  export type PropertyOwnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwner
     */
    select?: PropertyOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwner
     */
    omit?: PropertyOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyOwner.
     */
    data: XOR<PropertyOwnerCreateInput, PropertyOwnerUncheckedCreateInput>
  }

  /**
   * PropertyOwner createMany
   */
  export type PropertyOwnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyOwners.
     */
    data: PropertyOwnerCreateManyInput | PropertyOwnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyOwner createManyAndReturn
   */
  export type PropertyOwnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwner
     */
    select?: PropertyOwnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwner
     */
    omit?: PropertyOwnerOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyOwners.
     */
    data: PropertyOwnerCreateManyInput | PropertyOwnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PropertyOwner update
   */
  export type PropertyOwnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwner
     */
    select?: PropertyOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwner
     */
    omit?: PropertyOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyOwner.
     */
    data: XOR<PropertyOwnerUpdateInput, PropertyOwnerUncheckedUpdateInput>
    /**
     * Choose, which PropertyOwner to update.
     */
    where: PropertyOwnerWhereUniqueInput
  }

  /**
   * PropertyOwner updateMany
   */
  export type PropertyOwnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyOwners.
     */
    data: XOR<PropertyOwnerUpdateManyMutationInput, PropertyOwnerUncheckedUpdateManyInput>
    /**
     * Filter which PropertyOwners to update
     */
    where?: PropertyOwnerWhereInput
    /**
     * Limit how many PropertyOwners to update.
     */
    limit?: number
  }

  /**
   * PropertyOwner updateManyAndReturn
   */
  export type PropertyOwnerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwner
     */
    select?: PropertyOwnerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwner
     */
    omit?: PropertyOwnerOmit<ExtArgs> | null
    /**
     * The data used to update PropertyOwners.
     */
    data: XOR<PropertyOwnerUpdateManyMutationInput, PropertyOwnerUncheckedUpdateManyInput>
    /**
     * Filter which PropertyOwners to update
     */
    where?: PropertyOwnerWhereInput
    /**
     * Limit how many PropertyOwners to update.
     */
    limit?: number
  }

  /**
   * PropertyOwner upsert
   */
  export type PropertyOwnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwner
     */
    select?: PropertyOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwner
     */
    omit?: PropertyOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyOwner to update in case it exists.
     */
    where: PropertyOwnerWhereUniqueInput
    /**
     * In case the PropertyOwner found by the `where` argument doesn't exist, create a new PropertyOwner with this data.
     */
    create: XOR<PropertyOwnerCreateInput, PropertyOwnerUncheckedCreateInput>
    /**
     * In case the PropertyOwner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyOwnerUpdateInput, PropertyOwnerUncheckedUpdateInput>
  }

  /**
   * PropertyOwner delete
   */
  export type PropertyOwnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwner
     */
    select?: PropertyOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwner
     */
    omit?: PropertyOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerInclude<ExtArgs> | null
    /**
     * Filter which PropertyOwner to delete.
     */
    where: PropertyOwnerWhereUniqueInput
  }

  /**
   * PropertyOwner deleteMany
   */
  export type PropertyOwnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyOwners to delete
     */
    where?: PropertyOwnerWhereInput
    /**
     * Limit how many PropertyOwners to delete.
     */
    limit?: number
  }

  /**
   * PropertyOwner.documents
   */
  export type PropertyOwner$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDocument
     */
    select?: OwnerDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDocument
     */
    omit?: OwnerDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDocumentInclude<ExtArgs> | null
    where?: OwnerDocumentWhereInput
    orderBy?: OwnerDocumentOrderByWithRelationInput | OwnerDocumentOrderByWithRelationInput[]
    cursor?: OwnerDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OwnerDocumentScalarFieldEnum | OwnerDocumentScalarFieldEnum[]
  }

  /**
   * PropertyOwner.properties
   */
  export type PropertyOwner$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * PropertyOwner.tm30Requests
   */
  export type PropertyOwner$tm30RequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tm30AccommodationRequest
     */
    select?: Tm30AccommodationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tm30AccommodationRequest
     */
    omit?: Tm30AccommodationRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Tm30AccommodationRequestInclude<ExtArgs> | null
    where?: Tm30AccommodationRequestWhereInput
    orderBy?: Tm30AccommodationRequestOrderByWithRelationInput | Tm30AccommodationRequestOrderByWithRelationInput[]
    cursor?: Tm30AccommodationRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tm30AccommodationRequestScalarFieldEnum | Tm30AccommodationRequestScalarFieldEnum[]
  }

  /**
   * PropertyOwner without action
   */
  export type PropertyOwnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyOwner
     */
    select?: PropertyOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyOwner
     */
    omit?: PropertyOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyOwnerInclude<ExtArgs> | null
  }


  /**
   * Model OwnerDocument
   */

  export type AggregateOwnerDocument = {
    _count: OwnerDocumentCountAggregateOutputType | null
    _avg: OwnerDocumentAvgAggregateOutputType | null
    _sum: OwnerDocumentSumAggregateOutputType | null
    _min: OwnerDocumentMinAggregateOutputType | null
    _max: OwnerDocumentMaxAggregateOutputType | null
  }

  export type OwnerDocumentAvgAggregateOutputType = {
    ocrConfidence: number | null
  }

  export type OwnerDocumentSumAggregateOutputType = {
    ocrConfidence: number | null
  }

  export type OwnerDocumentMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    documentType: $Enums.OwnerDocumentType | null
    imageUrl: string | null
    imagePath: string | null
    fileName: string | null
    ocrProcessedAt: Date | null
    ocrConfidence: number | null
    propertyId: string | null
    houseId: string | null
    extractedAddress: string | null
    isVerified: boolean | null
    verifiedBy: string | null
    verifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OwnerDocumentMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    documentType: $Enums.OwnerDocumentType | null
    imageUrl: string | null
    imagePath: string | null
    fileName: string | null
    ocrProcessedAt: Date | null
    ocrConfidence: number | null
    propertyId: string | null
    houseId: string | null
    extractedAddress: string | null
    isVerified: boolean | null
    verifiedBy: string | null
    verifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OwnerDocumentCountAggregateOutputType = {
    id: number
    ownerId: number
    documentType: number
    imageUrl: number
    imagePath: number
    fileName: number
    ocrData: number
    ocrProcessedAt: number
    ocrConfidence: number
    propertyId: number
    houseId: number
    extractedAddress: number
    isVerified: number
    verifiedBy: number
    verifiedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OwnerDocumentAvgAggregateInputType = {
    ocrConfidence?: true
  }

  export type OwnerDocumentSumAggregateInputType = {
    ocrConfidence?: true
  }

  export type OwnerDocumentMinAggregateInputType = {
    id?: true
    ownerId?: true
    documentType?: true
    imageUrl?: true
    imagePath?: true
    fileName?: true
    ocrProcessedAt?: true
    ocrConfidence?: true
    propertyId?: true
    houseId?: true
    extractedAddress?: true
    isVerified?: true
    verifiedBy?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OwnerDocumentMaxAggregateInputType = {
    id?: true
    ownerId?: true
    documentType?: true
    imageUrl?: true
    imagePath?: true
    fileName?: true
    ocrProcessedAt?: true
    ocrConfidence?: true
    propertyId?: true
    houseId?: true
    extractedAddress?: true
    isVerified?: true
    verifiedBy?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OwnerDocumentCountAggregateInputType = {
    id?: true
    ownerId?: true
    documentType?: true
    imageUrl?: true
    imagePath?: true
    fileName?: true
    ocrData?: true
    ocrProcessedAt?: true
    ocrConfidence?: true
    propertyId?: true
    houseId?: true
    extractedAddress?: true
    isVerified?: true
    verifiedBy?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OwnerDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnerDocument to aggregate.
     */
    where?: OwnerDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerDocuments to fetch.
     */
    orderBy?: OwnerDocumentOrderByWithRelationInput | OwnerDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OwnerDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OwnerDocuments
    **/
    _count?: true | OwnerDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OwnerDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OwnerDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OwnerDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OwnerDocumentMaxAggregateInputType
  }

  export type GetOwnerDocumentAggregateType<T extends OwnerDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateOwnerDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwnerDocument[P]>
      : GetScalarType<T[P], AggregateOwnerDocument[P]>
  }




  export type OwnerDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerDocumentWhereInput
    orderBy?: OwnerDocumentOrderByWithAggregationInput | OwnerDocumentOrderByWithAggregationInput[]
    by: OwnerDocumentScalarFieldEnum[] | OwnerDocumentScalarFieldEnum
    having?: OwnerDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OwnerDocumentCountAggregateInputType | true
    _avg?: OwnerDocumentAvgAggregateInputType
    _sum?: OwnerDocumentSumAggregateInputType
    _min?: OwnerDocumentMinAggregateInputType
    _max?: OwnerDocumentMaxAggregateInputType
  }

  export type OwnerDocumentGroupByOutputType = {
    id: string
    ownerId: string
    documentType: $Enums.OwnerDocumentType
    imageUrl: string
    imagePath: string
    fileName: string | null
    ocrData: JsonValue | null
    ocrProcessedAt: Date | null
    ocrConfidence: number | null
    propertyId: string | null
    houseId: string | null
    extractedAddress: string | null
    isVerified: boolean
    verifiedBy: string | null
    verifiedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: OwnerDocumentCountAggregateOutputType | null
    _avg: OwnerDocumentAvgAggregateOutputType | null
    _sum: OwnerDocumentSumAggregateOutputType | null
    _min: OwnerDocumentMinAggregateOutputType | null
    _max: OwnerDocumentMaxAggregateOutputType | null
  }

  type GetOwnerDocumentGroupByPayload<T extends OwnerDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OwnerDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OwnerDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OwnerDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], OwnerDocumentGroupByOutputType[P]>
        }
      >
    >


  export type OwnerDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    documentType?: boolean
    imageUrl?: boolean
    imagePath?: boolean
    fileName?: boolean
    ocrData?: boolean
    ocrProcessedAt?: boolean
    ocrConfidence?: boolean
    propertyId?: boolean
    houseId?: boolean
    extractedAddress?: boolean
    isVerified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | PropertyOwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownerDocument"]>

  export type OwnerDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    documentType?: boolean
    imageUrl?: boolean
    imagePath?: boolean
    fileName?: boolean
    ocrData?: boolean
    ocrProcessedAt?: boolean
    ocrConfidence?: boolean
    propertyId?: boolean
    houseId?: boolean
    extractedAddress?: boolean
    isVerified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | PropertyOwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownerDocument"]>

  export type OwnerDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    documentType?: boolean
    imageUrl?: boolean
    imagePath?: boolean
    fileName?: boolean
    ocrData?: boolean
    ocrProcessedAt?: boolean
    ocrConfidence?: boolean
    propertyId?: boolean
    houseId?: boolean
    extractedAddress?: boolean
    isVerified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | PropertyOwnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownerDocument"]>

  export type OwnerDocumentSelectScalar = {
    id?: boolean
    ownerId?: boolean
    documentType?: boolean
    imageUrl?: boolean
    imagePath?: boolean
    fileName?: boolean
    ocrData?: boolean
    ocrProcessedAt?: boolean
    ocrConfidence?: boolean
    propertyId?: boolean
    houseId?: boolean
    extractedAddress?: boolean
    isVerified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OwnerDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ownerId" | "documentType" | "imageUrl" | "imagePath" | "fileName" | "ocrData" | "ocrProcessedAt" | "ocrConfidence" | "propertyId" | "houseId" | "extractedAddress" | "isVerified" | "verifiedBy" | "verifiedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["ownerDocument"]>
  export type OwnerDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | PropertyOwnerDefaultArgs<ExtArgs>
  }
  export type OwnerDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | PropertyOwnerDefaultArgs<ExtArgs>
  }
  export type OwnerDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | PropertyOwnerDefaultArgs<ExtArgs>
  }

  export type $OwnerDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OwnerDocument"
    objects: {
      owner: Prisma.$PropertyOwnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerId: string
      documentType: $Enums.OwnerDocumentType
      imageUrl: string
      imagePath: string
      fileName: string | null
      ocrData: Prisma.JsonValue | null
      ocrProcessedAt: Date | null
      ocrConfidence: number | null
      propertyId: string | null
      houseId: string | null
      extractedAddress: string | null
      isVerified: boolean
      verifiedBy: string | null
      verifiedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ownerDocument"]>
    composites: {}
  }

  type OwnerDocumentGetPayload<S extends boolean | null | undefined | OwnerDocumentDefaultArgs> = $Result.GetResult<Prisma.$OwnerDocumentPayload, S>

  type OwnerDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OwnerDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OwnerDocumentCountAggregateInputType | true
    }

  export interface OwnerDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OwnerDocument'], meta: { name: 'OwnerDocument' } }
    /**
     * Find zero or one OwnerDocument that matches the filter.
     * @param {OwnerDocumentFindUniqueArgs} args - Arguments to find a OwnerDocument
     * @example
     * // Get one OwnerDocument
     * const ownerDocument = await prisma.ownerDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OwnerDocumentFindUniqueArgs>(args: SelectSubset<T, OwnerDocumentFindUniqueArgs<ExtArgs>>): Prisma__OwnerDocumentClient<$Result.GetResult<Prisma.$OwnerDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OwnerDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OwnerDocumentFindUniqueOrThrowArgs} args - Arguments to find a OwnerDocument
     * @example
     * // Get one OwnerDocument
     * const ownerDocument = await prisma.ownerDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OwnerDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, OwnerDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OwnerDocumentClient<$Result.GetResult<Prisma.$OwnerDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OwnerDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDocumentFindFirstArgs} args - Arguments to find a OwnerDocument
     * @example
     * // Get one OwnerDocument
     * const ownerDocument = await prisma.ownerDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OwnerDocumentFindFirstArgs>(args?: SelectSubset<T, OwnerDocumentFindFirstArgs<ExtArgs>>): Prisma__OwnerDocumentClient<$Result.GetResult<Prisma.$OwnerDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OwnerDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDocumentFindFirstOrThrowArgs} args - Arguments to find a OwnerDocument
     * @example
     * // Get one OwnerDocument
     * const ownerDocument = await prisma.ownerDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OwnerDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, OwnerDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__OwnerDocumentClient<$Result.GetResult<Prisma.$OwnerDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OwnerDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OwnerDocuments
     * const ownerDocuments = await prisma.ownerDocument.findMany()
     * 
     * // Get first 10 OwnerDocuments
     * const ownerDocuments = await prisma.ownerDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ownerDocumentWithIdOnly = await prisma.ownerDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OwnerDocumentFindManyArgs>(args?: SelectSubset<T, OwnerDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OwnerDocument.
     * @param {OwnerDocumentCreateArgs} args - Arguments to create a OwnerDocument.
     * @example
     * // Create one OwnerDocument
     * const OwnerDocument = await prisma.ownerDocument.create({
     *   data: {
     *     // ... data to create a OwnerDocument
     *   }
     * })
     * 
     */
    create<T extends OwnerDocumentCreateArgs>(args: SelectSubset<T, OwnerDocumentCreateArgs<ExtArgs>>): Prisma__OwnerDocumentClient<$Result.GetResult<Prisma.$OwnerDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OwnerDocuments.
     * @param {OwnerDocumentCreateManyArgs} args - Arguments to create many OwnerDocuments.
     * @example
     * // Create many OwnerDocuments
     * const ownerDocument = await prisma.ownerDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OwnerDocumentCreateManyArgs>(args?: SelectSubset<T, OwnerDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OwnerDocuments and returns the data saved in the database.
     * @param {OwnerDocumentCreateManyAndReturnArgs} args - Arguments to create many OwnerDocuments.
     * @example
     * // Create many OwnerDocuments
     * const ownerDocument = await prisma.ownerDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OwnerDocuments and only return the `id`
     * const ownerDocumentWithIdOnly = await prisma.ownerDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OwnerDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, OwnerDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OwnerDocument.
     * @param {OwnerDocumentDeleteArgs} args - Arguments to delete one OwnerDocument.
     * @example
     * // Delete one OwnerDocument
     * const OwnerDocument = await prisma.ownerDocument.delete({
     *   where: {
     *     // ... filter to delete one OwnerDocument
     *   }
     * })
     * 
     */
    delete<T extends OwnerDocumentDeleteArgs>(args: SelectSubset<T, OwnerDocumentDeleteArgs<ExtArgs>>): Prisma__OwnerDocumentClient<$Result.GetResult<Prisma.$OwnerDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OwnerDocument.
     * @param {OwnerDocumentUpdateArgs} args - Arguments to update one OwnerDocument.
     * @example
     * // Update one OwnerDocument
     * const ownerDocument = await prisma.ownerDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OwnerDocumentUpdateArgs>(args: SelectSubset<T, OwnerDocumentUpdateArgs<ExtArgs>>): Prisma__OwnerDocumentClient<$Result.GetResult<Prisma.$OwnerDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OwnerDocuments.
     * @param {OwnerDocumentDeleteManyArgs} args - Arguments to filter OwnerDocuments to delete.
     * @example
     * // Delete a few OwnerDocuments
     * const { count } = await prisma.ownerDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OwnerDocumentDeleteManyArgs>(args?: SelectSubset<T, OwnerDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OwnerDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OwnerDocuments
     * const ownerDocument = await prisma.ownerDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OwnerDocumentUpdateManyArgs>(args: SelectSubset<T, OwnerDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OwnerDocuments and returns the data updated in the database.
     * @param {OwnerDocumentUpdateManyAndReturnArgs} args - Arguments to update many OwnerDocuments.
     * @example
     * // Update many OwnerDocuments
     * const ownerDocument = await prisma.ownerDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OwnerDocuments and only return the `id`
     * const ownerDocumentWithIdOnly = await prisma.ownerDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OwnerDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, OwnerDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OwnerDocument.
     * @param {OwnerDocumentUpsertArgs} args - Arguments to update or create a OwnerDocument.
     * @example
     * // Update or create a OwnerDocument
     * const ownerDocument = await prisma.ownerDocument.upsert({
     *   create: {
     *     // ... data to create a OwnerDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OwnerDocument we want to update
     *   }
     * })
     */
    upsert<T extends OwnerDocumentUpsertArgs>(args: SelectSubset<T, OwnerDocumentUpsertArgs<ExtArgs>>): Prisma__OwnerDocumentClient<$Result.GetResult<Prisma.$OwnerDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OwnerDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDocumentCountArgs} args - Arguments to filter OwnerDocuments to count.
     * @example
     * // Count the number of OwnerDocuments
     * const count = await prisma.ownerDocument.count({
     *   where: {
     *     // ... the filter for the OwnerDocuments we want to count
     *   }
     * })
    **/
    count<T extends OwnerDocumentCountArgs>(
      args?: Subset<T, OwnerDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OwnerDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OwnerDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OwnerDocumentAggregateArgs>(args: Subset<T, OwnerDocumentAggregateArgs>): Prisma.PrismaPromise<GetOwnerDocumentAggregateType<T>>

    /**
     * Group by OwnerDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OwnerDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OwnerDocumentGroupByArgs['orderBy'] }
        : { orderBy?: OwnerDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OwnerDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOwnerDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OwnerDocument model
   */
  readonly fields: OwnerDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OwnerDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OwnerDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends PropertyOwnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyOwnerDefaultArgs<ExtArgs>>): Prisma__PropertyOwnerClient<$Result.GetResult<Prisma.$PropertyOwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OwnerDocument model
   */
  interface OwnerDocumentFieldRefs {
    readonly id: FieldRef<"OwnerDocument", 'String'>
    readonly ownerId: FieldRef<"OwnerDocument", 'String'>
    readonly documentType: FieldRef<"OwnerDocument", 'OwnerDocumentType'>
    readonly imageUrl: FieldRef<"OwnerDocument", 'String'>
    readonly imagePath: FieldRef<"OwnerDocument", 'String'>
    readonly fileName: FieldRef<"OwnerDocument", 'String'>
    readonly ocrData: FieldRef<"OwnerDocument", 'Json'>
    readonly ocrProcessedAt: FieldRef<"OwnerDocument", 'DateTime'>
    readonly ocrConfidence: FieldRef<"OwnerDocument", 'Float'>
    readonly propertyId: FieldRef<"OwnerDocument", 'String'>
    readonly houseId: FieldRef<"OwnerDocument", 'String'>
    readonly extractedAddress: FieldRef<"OwnerDocument", 'String'>
    readonly isVerified: FieldRef<"OwnerDocument", 'Boolean'>
    readonly verifiedBy: FieldRef<"OwnerDocument", 'String'>
    readonly verifiedAt: FieldRef<"OwnerDocument", 'DateTime'>
    readonly createdAt: FieldRef<"OwnerDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"OwnerDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OwnerDocument findUnique
   */
  export type OwnerDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDocument
     */
    select?: OwnerDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDocument
     */
    omit?: OwnerDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDocumentInclude<ExtArgs> | null
    /**
     * Filter, which OwnerDocument to fetch.
     */
    where: OwnerDocumentWhereUniqueInput
  }

  /**
   * OwnerDocument findUniqueOrThrow
   */
  export type OwnerDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDocument
     */
    select?: OwnerDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDocument
     */
    omit?: OwnerDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDocumentInclude<ExtArgs> | null
    /**
     * Filter, which OwnerDocument to fetch.
     */
    where: OwnerDocumentWhereUniqueInput
  }

  /**
   * OwnerDocument findFirst
   */
  export type OwnerDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDocument
     */
    select?: OwnerDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDocument
     */
    omit?: OwnerDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDocumentInclude<ExtArgs> | null
    /**
     * Filter, which OwnerDocument to fetch.
     */
    where?: OwnerDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerDocuments to fetch.
     */
    orderBy?: OwnerDocumentOrderByWithRelationInput | OwnerDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnerDocuments.
     */
    cursor?: OwnerDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnerDocuments.
     */
    distinct?: OwnerDocumentScalarFieldEnum | OwnerDocumentScalarFieldEnum[]
  }

  /**
   * OwnerDocument findFirstOrThrow
   */
  export type OwnerDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDocument
     */
    select?: OwnerDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDocument
     */
    omit?: OwnerDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDocumentInclude<ExtArgs> | null
    /**
     * Filter, which OwnerDocument to fetch.
     */
    where?: OwnerDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerDocuments to fetch.
     */
    orderBy?: OwnerDocumentOrderByWithRelationInput | OwnerDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnerDocuments.
     */
    cursor?: OwnerDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnerDocuments.
     */
    distinct?: OwnerDocumentScalarFieldEnum | OwnerDocumentScalarFieldEnum[]
  }

  /**
   * OwnerDocument findMany
   */
  export type OwnerDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDocument
     */
    select?: OwnerDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDocument
     */
    omit?: OwnerDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDocumentInclude<ExtArgs> | null
    /**
     * Filter, which OwnerDocuments to fetch.
     */
    where?: OwnerDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnerDocuments to fetch.
     */
    orderBy?: OwnerDocumentOrderByWithRelationInput | OwnerDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OwnerDocuments.
     */
    cursor?: OwnerDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnerDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnerDocuments.
     */
    skip?: number
    distinct?: OwnerDocumentScalarFieldEnum | OwnerDocumentScalarFieldEnum[]
  }

  /**
   * OwnerDocument create
   */
  export type OwnerDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDocument
     */
    select?: OwnerDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDocument
     */
    omit?: OwnerDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a OwnerDocument.
     */
    data: XOR<OwnerDocumentCreateInput, OwnerDocumentUncheckedCreateInput>
  }

  /**
   * OwnerDocument createMany
   */
  export type OwnerDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OwnerDocuments.
     */
    data: OwnerDocumentCreateManyInput | OwnerDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OwnerDocument createManyAndReturn
   */
  export type OwnerDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDocument
     */
    select?: OwnerDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDocument
     */
    omit?: OwnerDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many OwnerDocuments.
     */
    data: OwnerDocumentCreateManyInput | OwnerDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OwnerDocument update
   */
  export type OwnerDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDocument
     */
    select?: OwnerDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDocument
     */
    omit?: OwnerDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a OwnerDocument.
     */
    data: XOR<OwnerDocumentUpdateInput, OwnerDocumentUncheckedUpdateInput>
    /**
     * Choose, which OwnerDocument to update.
     */
    where: OwnerDocumentWhereUniqueInput
  }

  /**
   * OwnerDocument updateMany
   */
  export type OwnerDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OwnerDocuments.
     */
    data: XOR<OwnerDocumentUpdateManyMutationInput, OwnerDocumentUncheckedUpdateManyInput>
    /**
     * Filter which OwnerDocuments to update
     */
    where?: OwnerDocumentWhereInput
    /**
     * Limit how many OwnerDocuments to update.
     */
    limit?: number
  }

  /**
   * OwnerDocument updateManyAndReturn
   */
  export type OwnerDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDocument
     */
    select?: OwnerDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDocument
     */
    omit?: OwnerDocumentOmit<ExtArgs> | null
    /**
     * The data used to update OwnerDocuments.
     */
    data: XOR<OwnerDocumentUpdateManyMutationInput, OwnerDocumentUncheckedUpdateManyInput>
    /**
     * Filter which OwnerDocuments to update
     */
    where?: OwnerDocumentWhereInput
    /**
     * Limit how many OwnerDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OwnerDocument upsert
   */
  export type OwnerDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDocument
     */
    select?: OwnerDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDocument
     */
    omit?: OwnerDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the OwnerDocument to update in case it exists.
     */
    where: OwnerDocumentWhereUniqueInput
    /**
     * In case the OwnerDocument found by the `where` argument doesn't exist, create a new OwnerDocument with this data.
     */
    create: XOR<OwnerDocumentCreateInput, OwnerDocumentUncheckedCreateInput>
    /**
     * In case the OwnerDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OwnerDocumentUpdateInput, OwnerDocumentUncheckedUpdateInput>
  }

  /**
   * OwnerDocument delete
   */
  export type OwnerDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDocument
     */
    select?: OwnerDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDocument
     */
    omit?: OwnerDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDocumentInclude<ExtArgs> | null
    /**
     * Filter which OwnerDocument to delete.
     */
    where: OwnerDocumentWhereUniqueInput
  }

  /**
   * OwnerDocument deleteMany
   */
  export type OwnerDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnerDocuments to delete
     */
    where?: OwnerDocumentWhereInput
    /**
     * Limit how many OwnerDocuments to delete.
     */
    limit?: number
  }

  /**
   * OwnerDocument without action
   */
  export type OwnerDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerDocument
     */
    select?: OwnerDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnerDocument
     */
    omit?: OwnerDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerDocumentInclude<ExtArgs> | null
  }


  /**
   * Model WhatsappListingSession
   */

  export type AggregateWhatsappListingSession = {
    _count: WhatsappListingSessionCountAggregateOutputType | null
    _min: WhatsappListingSessionMinAggregateOutputType | null
    _max: WhatsappListingSessionMaxAggregateOutputType | null
  }

  export type WhatsappListingSessionMinAggregateOutputType = {
    id: string | null
    phone: string | null
    status: string | null
    currentAction: string | null
    ownerId: string | null
    currentPropertyId: string | null
    tm30RequestId: string | null
    tm30OwnerFirstName: string | null
    tm30OwnerLastName: string | null
    tm30OwnerGender: string | null
    tm30OwnerPhone: string | null
    tm30ThaiIdNumber: string | null
    tm30IdCardUrl: string | null
    tm30BluebookUrl: string | null
    tm30HouseId: string | null
    tm30Province: string | null
    tm30District: string | null
    tm30SubDistrict: string | null
    tm30AddressNumber: string | null
    tm30PostalCode: string | null
    tm30AccommodationName: string | null
    lastMessageAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsappListingSessionMaxAggregateOutputType = {
    id: string | null
    phone: string | null
    status: string | null
    currentAction: string | null
    ownerId: string | null
    currentPropertyId: string | null
    tm30RequestId: string | null
    tm30OwnerFirstName: string | null
    tm30OwnerLastName: string | null
    tm30OwnerGender: string | null
    tm30OwnerPhone: string | null
    tm30ThaiIdNumber: string | null
    tm30IdCardUrl: string | null
    tm30BluebookUrl: string | null
    tm30HouseId: string | null
    tm30Province: string | null
    tm30District: string | null
    tm30SubDistrict: string | null
    tm30AddressNumber: string | null
    tm30PostalCode: string | null
    tm30AccommodationName: string | null
    lastMessageAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsappListingSessionCountAggregateOutputType = {
    id: number
    phone: number
    status: number
    currentAction: number
    ownerId: number
    currentPropertyId: number
    tm30RequestId: number
    tm30OwnerFirstName: number
    tm30OwnerLastName: number
    tm30OwnerGender: number
    tm30OwnerPhone: number
    tm30ThaiIdNumber: number
    tm30IdCardUrl: number
    tm30BluebookUrl: number
    tm30HouseId: number
    tm30Province: number
    tm30District: number
    tm30SubDistrict: number
    tm30AddressNumber: number
    tm30PostalCode: number
    tm30AccommodationName: number
    pendingData: number
    lastMessageAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WhatsappListingSessionMinAggregateInputType = {
    id?: true
    phone?: true
    status?: true
    currentAction?: true
    ownerId?: true
    currentPropertyId?: true
    tm30RequestId?: true
    tm30OwnerFirstName?: true
    tm30OwnerLastName?: true
    tm30OwnerGender?: true
    tm30OwnerPhone?: true
    tm30ThaiIdNumber?: true
    tm30IdCardUrl?: true
    tm30BluebookUrl?: true
    tm30HouseId?: true
    tm30Province?: true
    tm30District?: true
    tm30SubDistrict?: true
    tm30AddressNumber?: true
    tm30PostalCode?: true
    tm30AccommodationName?: true
    lastMessageAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsappListingSessionMaxAggregateInputType = {
    id?: true
    phone?: true
    status?: true
    currentAction?: true
    ownerId?: true
    currentPropertyId?: true
    tm30RequestId?: true
    tm30OwnerFirstName?: true
    tm30OwnerLastName?: true
    tm30OwnerGender?: true
    tm30OwnerPhone?: true
    tm30ThaiIdNumber?: true
    tm30IdCardUrl?: true
    tm30BluebookUrl?: true
    tm30HouseId?: true
    tm30Province?: true
    tm30District?: true
    tm30SubDistrict?: true
    tm30AddressNumber?: true
    tm30PostalCode?: true
    tm30AccommodationName?: true
    lastMessageAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsappListingSessionCountAggregateInputType = {
    id?: true
    phone?: true
    status?: true
    currentAction?: true
    ownerId?: true
    currentPropertyId?: true
    tm30RequestId?: true
    tm30OwnerFirstName?: true
    tm30OwnerLastName?: true
    tm30OwnerGender?: true
    tm30OwnerPhone?: true
    tm30ThaiIdNumber?: true
    tm30IdCardUrl?: true
    tm30BluebookUrl?: true
    tm30HouseId?: true
    tm30Province?: true
    tm30District?: true
    tm30SubDistrict?: true
    tm30AddressNumber?: true
    tm30PostalCode?: true
    tm30AccommodationName?: true
    pendingData?: true
    lastMessageAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WhatsappListingSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsappListingSession to aggregate.
     */
    where?: WhatsappListingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappListingSessions to fetch.
     */
    orderBy?: WhatsappListingSessionOrderByWithRelationInput | WhatsappListingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsappListingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappListingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappListingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsappListingSessions
    **/
    _count?: true | WhatsappListingSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsappListingSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsappListingSessionMaxAggregateInputType
  }

  export type GetWhatsappListingSessionAggregateType<T extends WhatsappListingSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsappListingSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsappListingSession[P]>
      : GetScalarType<T[P], AggregateWhatsappListingSession[P]>
  }




  export type WhatsappListingSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsappListingSessionWhereInput
    orderBy?: WhatsappListingSessionOrderByWithAggregationInput | WhatsappListingSessionOrderByWithAggregationInput[]
    by: WhatsappListingSessionScalarFieldEnum[] | WhatsappListingSessionScalarFieldEnum
    having?: WhatsappListingSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsappListingSessionCountAggregateInputType | true
    _min?: WhatsappListingSessionMinAggregateInputType
    _max?: WhatsappListingSessionMaxAggregateInputType
  }

  export type WhatsappListingSessionGroupByOutputType = {
    id: string
    phone: string
    status: string
    currentAction: string | null
    ownerId: string | null
    currentPropertyId: string | null
    tm30RequestId: string | null
    tm30OwnerFirstName: string | null
    tm30OwnerLastName: string | null
    tm30OwnerGender: string | null
    tm30OwnerPhone: string | null
    tm30ThaiIdNumber: string | null
    tm30IdCardUrl: string | null
    tm30BluebookUrl: string | null
    tm30HouseId: string | null
    tm30Province: string | null
    tm30District: string | null
    tm30SubDistrict: string | null
    tm30AddressNumber: string | null
    tm30PostalCode: string | null
    tm30AccommodationName: string | null
    pendingData: JsonValue | null
    lastMessageAt: Date
    createdAt: Date
    updatedAt: Date
    _count: WhatsappListingSessionCountAggregateOutputType | null
    _min: WhatsappListingSessionMinAggregateOutputType | null
    _max: WhatsappListingSessionMaxAggregateOutputType | null
  }

  type GetWhatsappListingSessionGroupByPayload<T extends WhatsappListingSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsappListingSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsappListingSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsappListingSessionGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsappListingSessionGroupByOutputType[P]>
        }
      >
    >


  export type WhatsappListingSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    status?: boolean
    currentAction?: boolean
    ownerId?: boolean
    currentPropertyId?: boolean
    tm30RequestId?: boolean
    tm30OwnerFirstName?: boolean
    tm30OwnerLastName?: boolean
    tm30OwnerGender?: boolean
    tm30OwnerPhone?: boolean
    tm30ThaiIdNumber?: boolean
    tm30IdCardUrl?: boolean
    tm30BluebookUrl?: boolean
    tm30HouseId?: boolean
    tm30Province?: boolean
    tm30District?: boolean
    tm30SubDistrict?: boolean
    tm30AddressNumber?: boolean
    tm30PostalCode?: boolean
    tm30AccommodationName?: boolean
    pendingData?: boolean
    lastMessageAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["whatsappListingSession"]>

  export type WhatsappListingSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    status?: boolean
    currentAction?: boolean
    ownerId?: boolean
    currentPropertyId?: boolean
    tm30RequestId?: boolean
    tm30OwnerFirstName?: boolean
    tm30OwnerLastName?: boolean
    tm30OwnerGender?: boolean
    tm30OwnerPhone?: boolean
    tm30ThaiIdNumber?: boolean
    tm30IdCardUrl?: boolean
    tm30BluebookUrl?: boolean
    tm30HouseId?: boolean
    tm30Province?: boolean
    tm30District?: boolean
    tm30SubDistrict?: boolean
    tm30AddressNumber?: boolean
    tm30PostalCode?: boolean
    tm30AccommodationName?: boolean
    pendingData?: boolean
    lastMessageAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["whatsappListingSession"]>

  export type WhatsappListingSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    status?: boolean
    currentAction?: boolean
    ownerId?: boolean
    currentPropertyId?: boolean
    tm30RequestId?: boolean
    tm30OwnerFirstName?: boolean
    tm30OwnerLastName?: boolean
    tm30OwnerGender?: boolean
    tm30OwnerPhone?: boolean
    tm30ThaiIdNumber?: boolean
    tm30IdCardUrl?: boolean
    tm30BluebookUrl?: boolean
    tm30HouseId?: boolean
    tm30Province?: boolean
    tm30District?: boolean
    tm30SubDistrict?: boolean
    tm30AddressNumber?: boolean
    tm30PostalCode?: boolean
    tm30AccommodationName?: boolean
    pendingData?: boolean
    lastMessageAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["whatsappListingSession"]>

  export type WhatsappListingSessionSelectScalar = {
    id?: boolean
    phone?: boolean
    status?: boolean
    currentAction?: boolean
    ownerId?: boolean
    currentPropertyId?: boolean
    tm30RequestId?: boolean
    tm30OwnerFirstName?: boolean
    tm30OwnerLastName?: boolean
    tm30OwnerGender?: boolean
    tm30OwnerPhone?: boolean
    tm30ThaiIdNumber?: boolean
    tm30IdCardUrl?: boolean
    tm30BluebookUrl?: boolean
    tm30HouseId?: boolean
    tm30Province?: boolean
    tm30District?: boolean
    tm30SubDistrict?: boolean
    tm30AddressNumber?: boolean
    tm30PostalCode?: boolean
    tm30AccommodationName?: boolean
    pendingData?: boolean
    lastMessageAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WhatsappListingSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phone" | "status" | "currentAction" | "ownerId" | "currentPropertyId" | "tm30RequestId" | "tm30OwnerFirstName" | "tm30OwnerLastName" | "tm30OwnerGender" | "tm30OwnerPhone" | "tm30ThaiIdNumber" | "tm30IdCardUrl" | "tm30BluebookUrl" | "tm30HouseId" | "tm30Province" | "tm30District" | "tm30SubDistrict" | "tm30AddressNumber" | "tm30PostalCode" | "tm30AccommodationName" | "pendingData" | "lastMessageAt" | "createdAt" | "updatedAt", ExtArgs["result"]["whatsappListingSession"]>

  export type $WhatsappListingSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsappListingSession"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phone: string
      status: string
      currentAction: string | null
      ownerId: string | null
      currentPropertyId: string | null
      tm30RequestId: string | null
      tm30OwnerFirstName: string | null
      tm30OwnerLastName: string | null
      tm30OwnerGender: string | null
      tm30OwnerPhone: string | null
      tm30ThaiIdNumber: string | null
      tm30IdCardUrl: string | null
      tm30BluebookUrl: string | null
      tm30HouseId: string | null
      tm30Province: string | null
      tm30District: string | null
      tm30SubDistrict: string | null
      tm30AddressNumber: string | null
      tm30PostalCode: string | null
      tm30AccommodationName: string | null
      pendingData: Prisma.JsonValue | null
      lastMessageAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["whatsappListingSession"]>
    composites: {}
  }

  type WhatsappListingSessionGetPayload<S extends boolean | null | undefined | WhatsappListingSessionDefaultArgs> = $Result.GetResult<Prisma.$WhatsappListingSessionPayload, S>

  type WhatsappListingSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsappListingSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsappListingSessionCountAggregateInputType | true
    }

  export interface WhatsappListingSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsappListingSession'], meta: { name: 'WhatsappListingSession' } }
    /**
     * Find zero or one WhatsappListingSession that matches the filter.
     * @param {WhatsappListingSessionFindUniqueArgs} args - Arguments to find a WhatsappListingSession
     * @example
     * // Get one WhatsappListingSession
     * const whatsappListingSession = await prisma.whatsappListingSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsappListingSessionFindUniqueArgs>(args: SelectSubset<T, WhatsappListingSessionFindUniqueArgs<ExtArgs>>): Prisma__WhatsappListingSessionClient<$Result.GetResult<Prisma.$WhatsappListingSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsappListingSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsappListingSessionFindUniqueOrThrowArgs} args - Arguments to find a WhatsappListingSession
     * @example
     * // Get one WhatsappListingSession
     * const whatsappListingSession = await prisma.whatsappListingSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsappListingSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsappListingSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsappListingSessionClient<$Result.GetResult<Prisma.$WhatsappListingSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsappListingSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappListingSessionFindFirstArgs} args - Arguments to find a WhatsappListingSession
     * @example
     * // Get one WhatsappListingSession
     * const whatsappListingSession = await prisma.whatsappListingSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsappListingSessionFindFirstArgs>(args?: SelectSubset<T, WhatsappListingSessionFindFirstArgs<ExtArgs>>): Prisma__WhatsappListingSessionClient<$Result.GetResult<Prisma.$WhatsappListingSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsappListingSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappListingSessionFindFirstOrThrowArgs} args - Arguments to find a WhatsappListingSession
     * @example
     * // Get one WhatsappListingSession
     * const whatsappListingSession = await prisma.whatsappListingSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsappListingSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsappListingSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsappListingSessionClient<$Result.GetResult<Prisma.$WhatsappListingSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsappListingSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappListingSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsappListingSessions
     * const whatsappListingSessions = await prisma.whatsappListingSession.findMany()
     * 
     * // Get first 10 WhatsappListingSessions
     * const whatsappListingSessions = await prisma.whatsappListingSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsappListingSessionWithIdOnly = await prisma.whatsappListingSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsappListingSessionFindManyArgs>(args?: SelectSubset<T, WhatsappListingSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappListingSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsappListingSession.
     * @param {WhatsappListingSessionCreateArgs} args - Arguments to create a WhatsappListingSession.
     * @example
     * // Create one WhatsappListingSession
     * const WhatsappListingSession = await prisma.whatsappListingSession.create({
     *   data: {
     *     // ... data to create a WhatsappListingSession
     *   }
     * })
     * 
     */
    create<T extends WhatsappListingSessionCreateArgs>(args: SelectSubset<T, WhatsappListingSessionCreateArgs<ExtArgs>>): Prisma__WhatsappListingSessionClient<$Result.GetResult<Prisma.$WhatsappListingSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsappListingSessions.
     * @param {WhatsappListingSessionCreateManyArgs} args - Arguments to create many WhatsappListingSessions.
     * @example
     * // Create many WhatsappListingSessions
     * const whatsappListingSession = await prisma.whatsappListingSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsappListingSessionCreateManyArgs>(args?: SelectSubset<T, WhatsappListingSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsappListingSessions and returns the data saved in the database.
     * @param {WhatsappListingSessionCreateManyAndReturnArgs} args - Arguments to create many WhatsappListingSessions.
     * @example
     * // Create many WhatsappListingSessions
     * const whatsappListingSession = await prisma.whatsappListingSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsappListingSessions and only return the `id`
     * const whatsappListingSessionWithIdOnly = await prisma.whatsappListingSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsappListingSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsappListingSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappListingSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsappListingSession.
     * @param {WhatsappListingSessionDeleteArgs} args - Arguments to delete one WhatsappListingSession.
     * @example
     * // Delete one WhatsappListingSession
     * const WhatsappListingSession = await prisma.whatsappListingSession.delete({
     *   where: {
     *     // ... filter to delete one WhatsappListingSession
     *   }
     * })
     * 
     */
    delete<T extends WhatsappListingSessionDeleteArgs>(args: SelectSubset<T, WhatsappListingSessionDeleteArgs<ExtArgs>>): Prisma__WhatsappListingSessionClient<$Result.GetResult<Prisma.$WhatsappListingSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsappListingSession.
     * @param {WhatsappListingSessionUpdateArgs} args - Arguments to update one WhatsappListingSession.
     * @example
     * // Update one WhatsappListingSession
     * const whatsappListingSession = await prisma.whatsappListingSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsappListingSessionUpdateArgs>(args: SelectSubset<T, WhatsappListingSessionUpdateArgs<ExtArgs>>): Prisma__WhatsappListingSessionClient<$Result.GetResult<Prisma.$WhatsappListingSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsappListingSessions.
     * @param {WhatsappListingSessionDeleteManyArgs} args - Arguments to filter WhatsappListingSessions to delete.
     * @example
     * // Delete a few WhatsappListingSessions
     * const { count } = await prisma.whatsappListingSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsappListingSessionDeleteManyArgs>(args?: SelectSubset<T, WhatsappListingSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsappListingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappListingSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsappListingSessions
     * const whatsappListingSession = await prisma.whatsappListingSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsappListingSessionUpdateManyArgs>(args: SelectSubset<T, WhatsappListingSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsappListingSessions and returns the data updated in the database.
     * @param {WhatsappListingSessionUpdateManyAndReturnArgs} args - Arguments to update many WhatsappListingSessions.
     * @example
     * // Update many WhatsappListingSessions
     * const whatsappListingSession = await prisma.whatsappListingSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsappListingSessions and only return the `id`
     * const whatsappListingSessionWithIdOnly = await prisma.whatsappListingSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsappListingSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsappListingSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappListingSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsappListingSession.
     * @param {WhatsappListingSessionUpsertArgs} args - Arguments to update or create a WhatsappListingSession.
     * @example
     * // Update or create a WhatsappListingSession
     * const whatsappListingSession = await prisma.whatsappListingSession.upsert({
     *   create: {
     *     // ... data to create a WhatsappListingSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsappListingSession we want to update
     *   }
     * })
     */
    upsert<T extends WhatsappListingSessionUpsertArgs>(args: SelectSubset<T, WhatsappListingSessionUpsertArgs<ExtArgs>>): Prisma__WhatsappListingSessionClient<$Result.GetResult<Prisma.$WhatsappListingSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsappListingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappListingSessionCountArgs} args - Arguments to filter WhatsappListingSessions to count.
     * @example
     * // Count the number of WhatsappListingSessions
     * const count = await prisma.whatsappListingSession.count({
     *   where: {
     *     // ... the filter for the WhatsappListingSessions we want to count
     *   }
     * })
    **/
    count<T extends WhatsappListingSessionCountArgs>(
      args?: Subset<T, WhatsappListingSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsappListingSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsappListingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappListingSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsappListingSessionAggregateArgs>(args: Subset<T, WhatsappListingSessionAggregateArgs>): Prisma.PrismaPromise<GetWhatsappListingSessionAggregateType<T>>

    /**
     * Group by WhatsappListingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappListingSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsappListingSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsappListingSessionGroupByArgs['orderBy'] }
        : { orderBy?: WhatsappListingSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsappListingSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsappListingSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsappListingSession model
   */
  readonly fields: WhatsappListingSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsappListingSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsappListingSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsappListingSession model
   */
  interface WhatsappListingSessionFieldRefs {
    readonly id: FieldRef<"WhatsappListingSession", 'String'>
    readonly phone: FieldRef<"WhatsappListingSession", 'String'>
    readonly status: FieldRef<"WhatsappListingSession", 'String'>
    readonly currentAction: FieldRef<"WhatsappListingSession", 'String'>
    readonly ownerId: FieldRef<"WhatsappListingSession", 'String'>
    readonly currentPropertyId: FieldRef<"WhatsappListingSession", 'String'>
    readonly tm30RequestId: FieldRef<"WhatsappListingSession", 'String'>
    readonly tm30OwnerFirstName: FieldRef<"WhatsappListingSession", 'String'>
    readonly tm30OwnerLastName: FieldRef<"WhatsappListingSession", 'String'>
    readonly tm30OwnerGender: FieldRef<"WhatsappListingSession", 'String'>
    readonly tm30OwnerPhone: FieldRef<"WhatsappListingSession", 'String'>
    readonly tm30ThaiIdNumber: FieldRef<"WhatsappListingSession", 'String'>
    readonly tm30IdCardUrl: FieldRef<"WhatsappListingSession", 'String'>
    readonly tm30BluebookUrl: FieldRef<"WhatsappListingSession", 'String'>
    readonly tm30HouseId: FieldRef<"WhatsappListingSession", 'String'>
    readonly tm30Province: FieldRef<"WhatsappListingSession", 'String'>
    readonly tm30District: FieldRef<"WhatsappListingSession", 'String'>
    readonly tm30SubDistrict: FieldRef<"WhatsappListingSession", 'String'>
    readonly tm30AddressNumber: FieldRef<"WhatsappListingSession", 'String'>
    readonly tm30PostalCode: FieldRef<"WhatsappListingSession", 'String'>
    readonly tm30AccommodationName: FieldRef<"WhatsappListingSession", 'String'>
    readonly pendingData: FieldRef<"WhatsappListingSession", 'Json'>
    readonly lastMessageAt: FieldRef<"WhatsappListingSession", 'DateTime'>
    readonly createdAt: FieldRef<"WhatsappListingSession", 'DateTime'>
    readonly updatedAt: FieldRef<"WhatsappListingSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WhatsappListingSession findUnique
   */
  export type WhatsappListingSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappListingSession
     */
    select?: WhatsappListingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappListingSession
     */
    omit?: WhatsappListingSessionOmit<ExtArgs> | null
    /**
     * Filter, which WhatsappListingSession to fetch.
     */
    where: WhatsappListingSessionWhereUniqueInput
  }

  /**
   * WhatsappListingSession findUniqueOrThrow
   */
  export type WhatsappListingSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappListingSession
     */
    select?: WhatsappListingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappListingSession
     */
    omit?: WhatsappListingSessionOmit<ExtArgs> | null
    /**
     * Filter, which WhatsappListingSession to fetch.
     */
    where: WhatsappListingSessionWhereUniqueInput
  }

  /**
   * WhatsappListingSession findFirst
   */
  export type WhatsappListingSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappListingSession
     */
    select?: WhatsappListingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappListingSession
     */
    omit?: WhatsappListingSessionOmit<ExtArgs> | null
    /**
     * Filter, which WhatsappListingSession to fetch.
     */
    where?: WhatsappListingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappListingSessions to fetch.
     */
    orderBy?: WhatsappListingSessionOrderByWithRelationInput | WhatsappListingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsappListingSessions.
     */
    cursor?: WhatsappListingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappListingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappListingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsappListingSessions.
     */
    distinct?: WhatsappListingSessionScalarFieldEnum | WhatsappListingSessionScalarFieldEnum[]
  }

  /**
   * WhatsappListingSession findFirstOrThrow
   */
  export type WhatsappListingSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappListingSession
     */
    select?: WhatsappListingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappListingSession
     */
    omit?: WhatsappListingSessionOmit<ExtArgs> | null
    /**
     * Filter, which WhatsappListingSession to fetch.
     */
    where?: WhatsappListingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappListingSessions to fetch.
     */
    orderBy?: WhatsappListingSessionOrderByWithRelationInput | WhatsappListingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsappListingSessions.
     */
    cursor?: WhatsappListingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappListingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappListingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsappListingSessions.
     */
    distinct?: WhatsappListingSessionScalarFieldEnum | WhatsappListingSessionScalarFieldEnum[]
  }

  /**
   * WhatsappListingSession findMany
   */
  export type WhatsappListingSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappListingSession
     */
    select?: WhatsappListingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappListingSession
     */
    omit?: WhatsappListingSessionOmit<ExtArgs> | null
    /**
     * Filter, which WhatsappListingSessions to fetch.
     */
    where?: WhatsappListingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappListingSessions to fetch.
     */
    orderBy?: WhatsappListingSessionOrderByWithRelationInput | WhatsappListingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsappListingSessions.
     */
    cursor?: WhatsappListingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappListingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappListingSessions.
     */
    skip?: number
    distinct?: WhatsappListingSessionScalarFieldEnum | WhatsappListingSessionScalarFieldEnum[]
  }

  /**
   * WhatsappListingSession create
   */
  export type WhatsappListingSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappListingSession
     */
    select?: WhatsappListingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappListingSession
     */
    omit?: WhatsappListingSessionOmit<ExtArgs> | null
    /**
     * The data needed to create a WhatsappListingSession.
     */
    data: XOR<WhatsappListingSessionCreateInput, WhatsappListingSessionUncheckedCreateInput>
  }

  /**
   * WhatsappListingSession createMany
   */
  export type WhatsappListingSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsappListingSessions.
     */
    data: WhatsappListingSessionCreateManyInput | WhatsappListingSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsappListingSession createManyAndReturn
   */
  export type WhatsappListingSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappListingSession
     */
    select?: WhatsappListingSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappListingSession
     */
    omit?: WhatsappListingSessionOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsappListingSessions.
     */
    data: WhatsappListingSessionCreateManyInput | WhatsappListingSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsappListingSession update
   */
  export type WhatsappListingSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappListingSession
     */
    select?: WhatsappListingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappListingSession
     */
    omit?: WhatsappListingSessionOmit<ExtArgs> | null
    /**
     * The data needed to update a WhatsappListingSession.
     */
    data: XOR<WhatsappListingSessionUpdateInput, WhatsappListingSessionUncheckedUpdateInput>
    /**
     * Choose, which WhatsappListingSession to update.
     */
    where: WhatsappListingSessionWhereUniqueInput
  }

  /**
   * WhatsappListingSession updateMany
   */
  export type WhatsappListingSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsappListingSessions.
     */
    data: XOR<WhatsappListingSessionUpdateManyMutationInput, WhatsappListingSessionUncheckedUpdateManyInput>
    /**
     * Filter which WhatsappListingSessions to update
     */
    where?: WhatsappListingSessionWhereInput
    /**
     * Limit how many WhatsappListingSessions to update.
     */
    limit?: number
  }

  /**
   * WhatsappListingSession updateManyAndReturn
   */
  export type WhatsappListingSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappListingSession
     */
    select?: WhatsappListingSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappListingSession
     */
    omit?: WhatsappListingSessionOmit<ExtArgs> | null
    /**
     * The data used to update WhatsappListingSessions.
     */
    data: XOR<WhatsappListingSessionUpdateManyMutationInput, WhatsappListingSessionUncheckedUpdateManyInput>
    /**
     * Filter which WhatsappListingSessions to update
     */
    where?: WhatsappListingSessionWhereInput
    /**
     * Limit how many WhatsappListingSessions to update.
     */
    limit?: number
  }

  /**
   * WhatsappListingSession upsert
   */
  export type WhatsappListingSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappListingSession
     */
    select?: WhatsappListingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappListingSession
     */
    omit?: WhatsappListingSessionOmit<ExtArgs> | null
    /**
     * The filter to search for the WhatsappListingSession to update in case it exists.
     */
    where: WhatsappListingSessionWhereUniqueInput
    /**
     * In case the WhatsappListingSession found by the `where` argument doesn't exist, create a new WhatsappListingSession with this data.
     */
    create: XOR<WhatsappListingSessionCreateInput, WhatsappListingSessionUncheckedCreateInput>
    /**
     * In case the WhatsappListingSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsappListingSessionUpdateInput, WhatsappListingSessionUncheckedUpdateInput>
  }

  /**
   * WhatsappListingSession delete
   */
  export type WhatsappListingSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappListingSession
     */
    select?: WhatsappListingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappListingSession
     */
    omit?: WhatsappListingSessionOmit<ExtArgs> | null
    /**
     * Filter which WhatsappListingSession to delete.
     */
    where: WhatsappListingSessionWhereUniqueInput
  }

  /**
   * WhatsappListingSession deleteMany
   */
  export type WhatsappListingSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsappListingSessions to delete
     */
    where?: WhatsappListingSessionWhereInput
    /**
     * Limit how many WhatsappListingSessions to delete.
     */
    limit?: number
  }

  /**
   * WhatsappListingSession without action
   */
  export type WhatsappListingSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappListingSession
     */
    select?: WhatsappListingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappListingSession
     */
    omit?: WhatsappListingSessionOmit<ExtArgs> | null
  }


  /**
   * Model AIAgentConfig
   */

  export type AggregateAIAgentConfig = {
    _count: AIAgentConfigCountAggregateOutputType | null
    _avg: AIAgentConfigAvgAggregateOutputType | null
    _sum: AIAgentConfigSumAggregateOutputType | null
    _min: AIAgentConfigMinAggregateOutputType | null
    _max: AIAgentConfigMaxAggregateOutputType | null
  }

  export type AIAgentConfigAvgAggregateOutputType = {
    minConfidenceThreshold: number | null
    dailyDecisionLimit: number | null
    dailyAutoExecuteLimit: number | null
    feedbackLoopDays: number | null
  }

  export type AIAgentConfigSumAggregateOutputType = {
    minConfidenceThreshold: number | null
    dailyDecisionLimit: number | null
    dailyAutoExecuteLimit: number | null
    feedbackLoopDays: number | null
  }

  export type AIAgentConfigMinAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    autonomousMode: boolean | null
    minConfidenceThreshold: number | null
    dailyDecisionLimit: number | null
    dailyAutoExecuteLimit: number | null
    notifyOnDecision: boolean | null
    notifyOnAutoExecute: boolean | null
    notifyEmail: string | null
    allowedAutonomousTypes: string | null
    forbiddenPatterns: string | null
    learningEnabled: boolean | null
    feedbackLoopDays: number | null
    killSwitch: boolean | null
    pausedUntil: Date | null
    pauseReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIAgentConfigMaxAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    autonomousMode: boolean | null
    minConfidenceThreshold: number | null
    dailyDecisionLimit: number | null
    dailyAutoExecuteLimit: number | null
    notifyOnDecision: boolean | null
    notifyOnAutoExecute: boolean | null
    notifyEmail: string | null
    allowedAutonomousTypes: string | null
    forbiddenPatterns: string | null
    learningEnabled: boolean | null
    feedbackLoopDays: number | null
    killSwitch: boolean | null
    pausedUntil: Date | null
    pauseReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIAgentConfigCountAggregateOutputType = {
    id: number
    enabled: number
    autonomousMode: number
    minConfidenceThreshold: number
    dailyDecisionLimit: number
    dailyAutoExecuteLimit: number
    notifyOnDecision: number
    notifyOnAutoExecute: number
    notifyEmail: number
    allowedAutonomousTypes: number
    forbiddenPatterns: number
    learningEnabled: number
    feedbackLoopDays: number
    killSwitch: number
    pausedUntil: number
    pauseReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AIAgentConfigAvgAggregateInputType = {
    minConfidenceThreshold?: true
    dailyDecisionLimit?: true
    dailyAutoExecuteLimit?: true
    feedbackLoopDays?: true
  }

  export type AIAgentConfigSumAggregateInputType = {
    minConfidenceThreshold?: true
    dailyDecisionLimit?: true
    dailyAutoExecuteLimit?: true
    feedbackLoopDays?: true
  }

  export type AIAgentConfigMinAggregateInputType = {
    id?: true
    enabled?: true
    autonomousMode?: true
    minConfidenceThreshold?: true
    dailyDecisionLimit?: true
    dailyAutoExecuteLimit?: true
    notifyOnDecision?: true
    notifyOnAutoExecute?: true
    notifyEmail?: true
    allowedAutonomousTypes?: true
    forbiddenPatterns?: true
    learningEnabled?: true
    feedbackLoopDays?: true
    killSwitch?: true
    pausedUntil?: true
    pauseReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIAgentConfigMaxAggregateInputType = {
    id?: true
    enabled?: true
    autonomousMode?: true
    minConfidenceThreshold?: true
    dailyDecisionLimit?: true
    dailyAutoExecuteLimit?: true
    notifyOnDecision?: true
    notifyOnAutoExecute?: true
    notifyEmail?: true
    allowedAutonomousTypes?: true
    forbiddenPatterns?: true
    learningEnabled?: true
    feedbackLoopDays?: true
    killSwitch?: true
    pausedUntil?: true
    pauseReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIAgentConfigCountAggregateInputType = {
    id?: true
    enabled?: true
    autonomousMode?: true
    minConfidenceThreshold?: true
    dailyDecisionLimit?: true
    dailyAutoExecuteLimit?: true
    notifyOnDecision?: true
    notifyOnAutoExecute?: true
    notifyEmail?: true
    allowedAutonomousTypes?: true
    forbiddenPatterns?: true
    learningEnabled?: true
    feedbackLoopDays?: true
    killSwitch?: true
    pausedUntil?: true
    pauseReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AIAgentConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIAgentConfig to aggregate.
     */
    where?: AIAgentConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIAgentConfigs to fetch.
     */
    orderBy?: AIAgentConfigOrderByWithRelationInput | AIAgentConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIAgentConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIAgentConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIAgentConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIAgentConfigs
    **/
    _count?: true | AIAgentConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIAgentConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIAgentConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIAgentConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIAgentConfigMaxAggregateInputType
  }

  export type GetAIAgentConfigAggregateType<T extends AIAgentConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateAIAgentConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIAgentConfig[P]>
      : GetScalarType<T[P], AggregateAIAgentConfig[P]>
  }




  export type AIAgentConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIAgentConfigWhereInput
    orderBy?: AIAgentConfigOrderByWithAggregationInput | AIAgentConfigOrderByWithAggregationInput[]
    by: AIAgentConfigScalarFieldEnum[] | AIAgentConfigScalarFieldEnum
    having?: AIAgentConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIAgentConfigCountAggregateInputType | true
    _avg?: AIAgentConfigAvgAggregateInputType
    _sum?: AIAgentConfigSumAggregateInputType
    _min?: AIAgentConfigMinAggregateInputType
    _max?: AIAgentConfigMaxAggregateInputType
  }

  export type AIAgentConfigGroupByOutputType = {
    id: string
    enabled: boolean
    autonomousMode: boolean
    minConfidenceThreshold: number
    dailyDecisionLimit: number
    dailyAutoExecuteLimit: number
    notifyOnDecision: boolean
    notifyOnAutoExecute: boolean
    notifyEmail: string | null
    allowedAutonomousTypes: string
    forbiddenPatterns: string
    learningEnabled: boolean
    feedbackLoopDays: number
    killSwitch: boolean
    pausedUntil: Date | null
    pauseReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: AIAgentConfigCountAggregateOutputType | null
    _avg: AIAgentConfigAvgAggregateOutputType | null
    _sum: AIAgentConfigSumAggregateOutputType | null
    _min: AIAgentConfigMinAggregateOutputType | null
    _max: AIAgentConfigMaxAggregateOutputType | null
  }

  type GetAIAgentConfigGroupByPayload<T extends AIAgentConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIAgentConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIAgentConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIAgentConfigGroupByOutputType[P]>
            : GetScalarType<T[P], AIAgentConfigGroupByOutputType[P]>
        }
      >
    >


  export type AIAgentConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    autonomousMode?: boolean
    minConfidenceThreshold?: boolean
    dailyDecisionLimit?: boolean
    dailyAutoExecuteLimit?: boolean
    notifyOnDecision?: boolean
    notifyOnAutoExecute?: boolean
    notifyEmail?: boolean
    allowedAutonomousTypes?: boolean
    forbiddenPatterns?: boolean
    learningEnabled?: boolean
    feedbackLoopDays?: boolean
    killSwitch?: boolean
    pausedUntil?: boolean
    pauseReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIAgentConfig"]>

  export type AIAgentConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    autonomousMode?: boolean
    minConfidenceThreshold?: boolean
    dailyDecisionLimit?: boolean
    dailyAutoExecuteLimit?: boolean
    notifyOnDecision?: boolean
    notifyOnAutoExecute?: boolean
    notifyEmail?: boolean
    allowedAutonomousTypes?: boolean
    forbiddenPatterns?: boolean
    learningEnabled?: boolean
    feedbackLoopDays?: boolean
    killSwitch?: boolean
    pausedUntil?: boolean
    pauseReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIAgentConfig"]>

  export type AIAgentConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    autonomousMode?: boolean
    minConfidenceThreshold?: boolean
    dailyDecisionLimit?: boolean
    dailyAutoExecuteLimit?: boolean
    notifyOnDecision?: boolean
    notifyOnAutoExecute?: boolean
    notifyEmail?: boolean
    allowedAutonomousTypes?: boolean
    forbiddenPatterns?: boolean
    learningEnabled?: boolean
    feedbackLoopDays?: boolean
    killSwitch?: boolean
    pausedUntil?: boolean
    pauseReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIAgentConfig"]>

  export type AIAgentConfigSelectScalar = {
    id?: boolean
    enabled?: boolean
    autonomousMode?: boolean
    minConfidenceThreshold?: boolean
    dailyDecisionLimit?: boolean
    dailyAutoExecuteLimit?: boolean
    notifyOnDecision?: boolean
    notifyOnAutoExecute?: boolean
    notifyEmail?: boolean
    allowedAutonomousTypes?: boolean
    forbiddenPatterns?: boolean
    learningEnabled?: boolean
    feedbackLoopDays?: boolean
    killSwitch?: boolean
    pausedUntil?: boolean
    pauseReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AIAgentConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enabled" | "autonomousMode" | "minConfidenceThreshold" | "dailyDecisionLimit" | "dailyAutoExecuteLimit" | "notifyOnDecision" | "notifyOnAutoExecute" | "notifyEmail" | "allowedAutonomousTypes" | "forbiddenPatterns" | "learningEnabled" | "feedbackLoopDays" | "killSwitch" | "pausedUntil" | "pauseReason" | "createdAt" | "updatedAt", ExtArgs["result"]["aIAgentConfig"]>

  export type $AIAgentConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIAgentConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      enabled: boolean
      autonomousMode: boolean
      minConfidenceThreshold: number
      dailyDecisionLimit: number
      dailyAutoExecuteLimit: number
      notifyOnDecision: boolean
      notifyOnAutoExecute: boolean
      notifyEmail: string | null
      allowedAutonomousTypes: string
      forbiddenPatterns: string
      learningEnabled: boolean
      feedbackLoopDays: number
      killSwitch: boolean
      pausedUntil: Date | null
      pauseReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aIAgentConfig"]>
    composites: {}
  }

  type AIAgentConfigGetPayload<S extends boolean | null | undefined | AIAgentConfigDefaultArgs> = $Result.GetResult<Prisma.$AIAgentConfigPayload, S>

  type AIAgentConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIAgentConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIAgentConfigCountAggregateInputType | true
    }

  export interface AIAgentConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIAgentConfig'], meta: { name: 'AIAgentConfig' } }
    /**
     * Find zero or one AIAgentConfig that matches the filter.
     * @param {AIAgentConfigFindUniqueArgs} args - Arguments to find a AIAgentConfig
     * @example
     * // Get one AIAgentConfig
     * const aIAgentConfig = await prisma.aIAgentConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIAgentConfigFindUniqueArgs>(args: SelectSubset<T, AIAgentConfigFindUniqueArgs<ExtArgs>>): Prisma__AIAgentConfigClient<$Result.GetResult<Prisma.$AIAgentConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIAgentConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIAgentConfigFindUniqueOrThrowArgs} args - Arguments to find a AIAgentConfig
     * @example
     * // Get one AIAgentConfig
     * const aIAgentConfig = await prisma.aIAgentConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIAgentConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, AIAgentConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIAgentConfigClient<$Result.GetResult<Prisma.$AIAgentConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIAgentConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentConfigFindFirstArgs} args - Arguments to find a AIAgentConfig
     * @example
     * // Get one AIAgentConfig
     * const aIAgentConfig = await prisma.aIAgentConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIAgentConfigFindFirstArgs>(args?: SelectSubset<T, AIAgentConfigFindFirstArgs<ExtArgs>>): Prisma__AIAgentConfigClient<$Result.GetResult<Prisma.$AIAgentConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIAgentConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentConfigFindFirstOrThrowArgs} args - Arguments to find a AIAgentConfig
     * @example
     * // Get one AIAgentConfig
     * const aIAgentConfig = await prisma.aIAgentConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIAgentConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, AIAgentConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIAgentConfigClient<$Result.GetResult<Prisma.$AIAgentConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIAgentConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIAgentConfigs
     * const aIAgentConfigs = await prisma.aIAgentConfig.findMany()
     * 
     * // Get first 10 AIAgentConfigs
     * const aIAgentConfigs = await prisma.aIAgentConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIAgentConfigWithIdOnly = await prisma.aIAgentConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIAgentConfigFindManyArgs>(args?: SelectSubset<T, AIAgentConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIAgentConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIAgentConfig.
     * @param {AIAgentConfigCreateArgs} args - Arguments to create a AIAgentConfig.
     * @example
     * // Create one AIAgentConfig
     * const AIAgentConfig = await prisma.aIAgentConfig.create({
     *   data: {
     *     // ... data to create a AIAgentConfig
     *   }
     * })
     * 
     */
    create<T extends AIAgentConfigCreateArgs>(args: SelectSubset<T, AIAgentConfigCreateArgs<ExtArgs>>): Prisma__AIAgentConfigClient<$Result.GetResult<Prisma.$AIAgentConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIAgentConfigs.
     * @param {AIAgentConfigCreateManyArgs} args - Arguments to create many AIAgentConfigs.
     * @example
     * // Create many AIAgentConfigs
     * const aIAgentConfig = await prisma.aIAgentConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIAgentConfigCreateManyArgs>(args?: SelectSubset<T, AIAgentConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIAgentConfigs and returns the data saved in the database.
     * @param {AIAgentConfigCreateManyAndReturnArgs} args - Arguments to create many AIAgentConfigs.
     * @example
     * // Create many AIAgentConfigs
     * const aIAgentConfig = await prisma.aIAgentConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIAgentConfigs and only return the `id`
     * const aIAgentConfigWithIdOnly = await prisma.aIAgentConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIAgentConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, AIAgentConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIAgentConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIAgentConfig.
     * @param {AIAgentConfigDeleteArgs} args - Arguments to delete one AIAgentConfig.
     * @example
     * // Delete one AIAgentConfig
     * const AIAgentConfig = await prisma.aIAgentConfig.delete({
     *   where: {
     *     // ... filter to delete one AIAgentConfig
     *   }
     * })
     * 
     */
    delete<T extends AIAgentConfigDeleteArgs>(args: SelectSubset<T, AIAgentConfigDeleteArgs<ExtArgs>>): Prisma__AIAgentConfigClient<$Result.GetResult<Prisma.$AIAgentConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIAgentConfig.
     * @param {AIAgentConfigUpdateArgs} args - Arguments to update one AIAgentConfig.
     * @example
     * // Update one AIAgentConfig
     * const aIAgentConfig = await prisma.aIAgentConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIAgentConfigUpdateArgs>(args: SelectSubset<T, AIAgentConfigUpdateArgs<ExtArgs>>): Prisma__AIAgentConfigClient<$Result.GetResult<Prisma.$AIAgentConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIAgentConfigs.
     * @param {AIAgentConfigDeleteManyArgs} args - Arguments to filter AIAgentConfigs to delete.
     * @example
     * // Delete a few AIAgentConfigs
     * const { count } = await prisma.aIAgentConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIAgentConfigDeleteManyArgs>(args?: SelectSubset<T, AIAgentConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIAgentConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIAgentConfigs
     * const aIAgentConfig = await prisma.aIAgentConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIAgentConfigUpdateManyArgs>(args: SelectSubset<T, AIAgentConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIAgentConfigs and returns the data updated in the database.
     * @param {AIAgentConfigUpdateManyAndReturnArgs} args - Arguments to update many AIAgentConfigs.
     * @example
     * // Update many AIAgentConfigs
     * const aIAgentConfig = await prisma.aIAgentConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIAgentConfigs and only return the `id`
     * const aIAgentConfigWithIdOnly = await prisma.aIAgentConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIAgentConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, AIAgentConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIAgentConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIAgentConfig.
     * @param {AIAgentConfigUpsertArgs} args - Arguments to update or create a AIAgentConfig.
     * @example
     * // Update or create a AIAgentConfig
     * const aIAgentConfig = await prisma.aIAgentConfig.upsert({
     *   create: {
     *     // ... data to create a AIAgentConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIAgentConfig we want to update
     *   }
     * })
     */
    upsert<T extends AIAgentConfigUpsertArgs>(args: SelectSubset<T, AIAgentConfigUpsertArgs<ExtArgs>>): Prisma__AIAgentConfigClient<$Result.GetResult<Prisma.$AIAgentConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIAgentConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentConfigCountArgs} args - Arguments to filter AIAgentConfigs to count.
     * @example
     * // Count the number of AIAgentConfigs
     * const count = await prisma.aIAgentConfig.count({
     *   where: {
     *     // ... the filter for the AIAgentConfigs we want to count
     *   }
     * })
    **/
    count<T extends AIAgentConfigCountArgs>(
      args?: Subset<T, AIAgentConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIAgentConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIAgentConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIAgentConfigAggregateArgs>(args: Subset<T, AIAgentConfigAggregateArgs>): Prisma.PrismaPromise<GetAIAgentConfigAggregateType<T>>

    /**
     * Group by AIAgentConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIAgentConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIAgentConfigGroupByArgs['orderBy'] }
        : { orderBy?: AIAgentConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIAgentConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIAgentConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIAgentConfig model
   */
  readonly fields: AIAgentConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIAgentConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIAgentConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIAgentConfig model
   */
  interface AIAgentConfigFieldRefs {
    readonly id: FieldRef<"AIAgentConfig", 'String'>
    readonly enabled: FieldRef<"AIAgentConfig", 'Boolean'>
    readonly autonomousMode: FieldRef<"AIAgentConfig", 'Boolean'>
    readonly minConfidenceThreshold: FieldRef<"AIAgentConfig", 'Float'>
    readonly dailyDecisionLimit: FieldRef<"AIAgentConfig", 'Int'>
    readonly dailyAutoExecuteLimit: FieldRef<"AIAgentConfig", 'Int'>
    readonly notifyOnDecision: FieldRef<"AIAgentConfig", 'Boolean'>
    readonly notifyOnAutoExecute: FieldRef<"AIAgentConfig", 'Boolean'>
    readonly notifyEmail: FieldRef<"AIAgentConfig", 'String'>
    readonly allowedAutonomousTypes: FieldRef<"AIAgentConfig", 'String'>
    readonly forbiddenPatterns: FieldRef<"AIAgentConfig", 'String'>
    readonly learningEnabled: FieldRef<"AIAgentConfig", 'Boolean'>
    readonly feedbackLoopDays: FieldRef<"AIAgentConfig", 'Int'>
    readonly killSwitch: FieldRef<"AIAgentConfig", 'Boolean'>
    readonly pausedUntil: FieldRef<"AIAgentConfig", 'DateTime'>
    readonly pauseReason: FieldRef<"AIAgentConfig", 'String'>
    readonly createdAt: FieldRef<"AIAgentConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"AIAgentConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIAgentConfig findUnique
   */
  export type AIAgentConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentConfig
     */
    select?: AIAgentConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentConfig
     */
    omit?: AIAgentConfigOmit<ExtArgs> | null
    /**
     * Filter, which AIAgentConfig to fetch.
     */
    where: AIAgentConfigWhereUniqueInput
  }

  /**
   * AIAgentConfig findUniqueOrThrow
   */
  export type AIAgentConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentConfig
     */
    select?: AIAgentConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentConfig
     */
    omit?: AIAgentConfigOmit<ExtArgs> | null
    /**
     * Filter, which AIAgentConfig to fetch.
     */
    where: AIAgentConfigWhereUniqueInput
  }

  /**
   * AIAgentConfig findFirst
   */
  export type AIAgentConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentConfig
     */
    select?: AIAgentConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentConfig
     */
    omit?: AIAgentConfigOmit<ExtArgs> | null
    /**
     * Filter, which AIAgentConfig to fetch.
     */
    where?: AIAgentConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIAgentConfigs to fetch.
     */
    orderBy?: AIAgentConfigOrderByWithRelationInput | AIAgentConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIAgentConfigs.
     */
    cursor?: AIAgentConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIAgentConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIAgentConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIAgentConfigs.
     */
    distinct?: AIAgentConfigScalarFieldEnum | AIAgentConfigScalarFieldEnum[]
  }

  /**
   * AIAgentConfig findFirstOrThrow
   */
  export type AIAgentConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentConfig
     */
    select?: AIAgentConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentConfig
     */
    omit?: AIAgentConfigOmit<ExtArgs> | null
    /**
     * Filter, which AIAgentConfig to fetch.
     */
    where?: AIAgentConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIAgentConfigs to fetch.
     */
    orderBy?: AIAgentConfigOrderByWithRelationInput | AIAgentConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIAgentConfigs.
     */
    cursor?: AIAgentConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIAgentConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIAgentConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIAgentConfigs.
     */
    distinct?: AIAgentConfigScalarFieldEnum | AIAgentConfigScalarFieldEnum[]
  }

  /**
   * AIAgentConfig findMany
   */
  export type AIAgentConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentConfig
     */
    select?: AIAgentConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentConfig
     */
    omit?: AIAgentConfigOmit<ExtArgs> | null
    /**
     * Filter, which AIAgentConfigs to fetch.
     */
    where?: AIAgentConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIAgentConfigs to fetch.
     */
    orderBy?: AIAgentConfigOrderByWithRelationInput | AIAgentConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIAgentConfigs.
     */
    cursor?: AIAgentConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIAgentConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIAgentConfigs.
     */
    skip?: number
    distinct?: AIAgentConfigScalarFieldEnum | AIAgentConfigScalarFieldEnum[]
  }

  /**
   * AIAgentConfig create
   */
  export type AIAgentConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentConfig
     */
    select?: AIAgentConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentConfig
     */
    omit?: AIAgentConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a AIAgentConfig.
     */
    data: XOR<AIAgentConfigCreateInput, AIAgentConfigUncheckedCreateInput>
  }

  /**
   * AIAgentConfig createMany
   */
  export type AIAgentConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIAgentConfigs.
     */
    data: AIAgentConfigCreateManyInput | AIAgentConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIAgentConfig createManyAndReturn
   */
  export type AIAgentConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentConfig
     */
    select?: AIAgentConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentConfig
     */
    omit?: AIAgentConfigOmit<ExtArgs> | null
    /**
     * The data used to create many AIAgentConfigs.
     */
    data: AIAgentConfigCreateManyInput | AIAgentConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIAgentConfig update
   */
  export type AIAgentConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentConfig
     */
    select?: AIAgentConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentConfig
     */
    omit?: AIAgentConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a AIAgentConfig.
     */
    data: XOR<AIAgentConfigUpdateInput, AIAgentConfigUncheckedUpdateInput>
    /**
     * Choose, which AIAgentConfig to update.
     */
    where: AIAgentConfigWhereUniqueInput
  }

  /**
   * AIAgentConfig updateMany
   */
  export type AIAgentConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIAgentConfigs.
     */
    data: XOR<AIAgentConfigUpdateManyMutationInput, AIAgentConfigUncheckedUpdateManyInput>
    /**
     * Filter which AIAgentConfigs to update
     */
    where?: AIAgentConfigWhereInput
    /**
     * Limit how many AIAgentConfigs to update.
     */
    limit?: number
  }

  /**
   * AIAgentConfig updateManyAndReturn
   */
  export type AIAgentConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentConfig
     */
    select?: AIAgentConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentConfig
     */
    omit?: AIAgentConfigOmit<ExtArgs> | null
    /**
     * The data used to update AIAgentConfigs.
     */
    data: XOR<AIAgentConfigUpdateManyMutationInput, AIAgentConfigUncheckedUpdateManyInput>
    /**
     * Filter which AIAgentConfigs to update
     */
    where?: AIAgentConfigWhereInput
    /**
     * Limit how many AIAgentConfigs to update.
     */
    limit?: number
  }

  /**
   * AIAgentConfig upsert
   */
  export type AIAgentConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentConfig
     */
    select?: AIAgentConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentConfig
     */
    omit?: AIAgentConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the AIAgentConfig to update in case it exists.
     */
    where: AIAgentConfigWhereUniqueInput
    /**
     * In case the AIAgentConfig found by the `where` argument doesn't exist, create a new AIAgentConfig with this data.
     */
    create: XOR<AIAgentConfigCreateInput, AIAgentConfigUncheckedCreateInput>
    /**
     * In case the AIAgentConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIAgentConfigUpdateInput, AIAgentConfigUncheckedUpdateInput>
  }

  /**
   * AIAgentConfig delete
   */
  export type AIAgentConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentConfig
     */
    select?: AIAgentConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentConfig
     */
    omit?: AIAgentConfigOmit<ExtArgs> | null
    /**
     * Filter which AIAgentConfig to delete.
     */
    where: AIAgentConfigWhereUniqueInput
  }

  /**
   * AIAgentConfig deleteMany
   */
  export type AIAgentConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIAgentConfigs to delete
     */
    where?: AIAgentConfigWhereInput
    /**
     * Limit how many AIAgentConfigs to delete.
     */
    limit?: number
  }

  /**
   * AIAgentConfig without action
   */
  export type AIAgentConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentConfig
     */
    select?: AIAgentConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentConfig
     */
    omit?: AIAgentConfigOmit<ExtArgs> | null
  }


  /**
   * Model AIDecision
   */

  export type AggregateAIDecision = {
    _count: AIDecisionCountAggregateOutputType | null
    _avg: AIDecisionAvgAggregateOutputType | null
    _sum: AIDecisionSumAggregateOutputType | null
    _min: AIDecisionMinAggregateOutputType | null
    _max: AIDecisionMaxAggregateOutputType | null
  }

  export type AIDecisionAvgAggregateOutputType = {
    confidence: number | null
    executionDuration: number | null
    successScore: number | null
  }

  export type AIDecisionSumAggregateOutputType = {
    confidence: number | null
    executionDuration: number | null
    successScore: number | null
  }

  export type AIDecisionMinAggregateOutputType = {
    id: string | null
    type: string | null
    subType: string | null
    priority: string | null
    confidence: number | null
    reasoning: string | null
    actionType: string | null
    estimatedImpact: string | null
    rollbackPlan: string | null
    requiresApproval: boolean | null
    autoApproved: boolean | null
    status: $Enums.AIDecisionStatus | null
    approvedBy: string | null
    approvedByName: string | null
    approvedAt: Date | null
    rejectedBy: string | null
    rejectedByName: string | null
    rejectedAt: Date | null
    rejectionReason: string | null
    executedAt: Date | null
    executionError: string | null
    executionDuration: number | null
    rolledBackAt: Date | null
    rolledBackBy: string | null
    rollbackReason: string | null
    feedbackDueAt: Date | null
    wasSuccessful: boolean | null
    successScore: number | null
    feedbackNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIDecisionMaxAggregateOutputType = {
    id: string | null
    type: string | null
    subType: string | null
    priority: string | null
    confidence: number | null
    reasoning: string | null
    actionType: string | null
    estimatedImpact: string | null
    rollbackPlan: string | null
    requiresApproval: boolean | null
    autoApproved: boolean | null
    status: $Enums.AIDecisionStatus | null
    approvedBy: string | null
    approvedByName: string | null
    approvedAt: Date | null
    rejectedBy: string | null
    rejectedByName: string | null
    rejectedAt: Date | null
    rejectionReason: string | null
    executedAt: Date | null
    executionError: string | null
    executionDuration: number | null
    rolledBackAt: Date | null
    rolledBackBy: string | null
    rollbackReason: string | null
    feedbackDueAt: Date | null
    wasSuccessful: boolean | null
    successScore: number | null
    feedbackNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIDecisionCountAggregateOutputType = {
    id: number
    type: number
    subType: number
    priority: number
    confidence: number
    reasoning: number
    dataSnapshot: number
    actionType: number
    actionPayload: number
    estimatedImpact: number
    rollbackPlan: number
    requiresApproval: number
    autoApproved: number
    status: number
    approvedBy: number
    approvedByName: number
    approvedAt: number
    rejectedBy: number
    rejectedByName: number
    rejectedAt: number
    rejectionReason: number
    executedAt: number
    executionResult: number
    executionError: number
    executionDuration: number
    rolledBackAt: number
    rolledBackBy: number
    rollbackReason: number
    feedbackDueAt: number
    actualImpact: number
    wasSuccessful: number
    successScore: number
    feedbackNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AIDecisionAvgAggregateInputType = {
    confidence?: true
    executionDuration?: true
    successScore?: true
  }

  export type AIDecisionSumAggregateInputType = {
    confidence?: true
    executionDuration?: true
    successScore?: true
  }

  export type AIDecisionMinAggregateInputType = {
    id?: true
    type?: true
    subType?: true
    priority?: true
    confidence?: true
    reasoning?: true
    actionType?: true
    estimatedImpact?: true
    rollbackPlan?: true
    requiresApproval?: true
    autoApproved?: true
    status?: true
    approvedBy?: true
    approvedByName?: true
    approvedAt?: true
    rejectedBy?: true
    rejectedByName?: true
    rejectedAt?: true
    rejectionReason?: true
    executedAt?: true
    executionError?: true
    executionDuration?: true
    rolledBackAt?: true
    rolledBackBy?: true
    rollbackReason?: true
    feedbackDueAt?: true
    wasSuccessful?: true
    successScore?: true
    feedbackNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIDecisionMaxAggregateInputType = {
    id?: true
    type?: true
    subType?: true
    priority?: true
    confidence?: true
    reasoning?: true
    actionType?: true
    estimatedImpact?: true
    rollbackPlan?: true
    requiresApproval?: true
    autoApproved?: true
    status?: true
    approvedBy?: true
    approvedByName?: true
    approvedAt?: true
    rejectedBy?: true
    rejectedByName?: true
    rejectedAt?: true
    rejectionReason?: true
    executedAt?: true
    executionError?: true
    executionDuration?: true
    rolledBackAt?: true
    rolledBackBy?: true
    rollbackReason?: true
    feedbackDueAt?: true
    wasSuccessful?: true
    successScore?: true
    feedbackNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIDecisionCountAggregateInputType = {
    id?: true
    type?: true
    subType?: true
    priority?: true
    confidence?: true
    reasoning?: true
    dataSnapshot?: true
    actionType?: true
    actionPayload?: true
    estimatedImpact?: true
    rollbackPlan?: true
    requiresApproval?: true
    autoApproved?: true
    status?: true
    approvedBy?: true
    approvedByName?: true
    approvedAt?: true
    rejectedBy?: true
    rejectedByName?: true
    rejectedAt?: true
    rejectionReason?: true
    executedAt?: true
    executionResult?: true
    executionError?: true
    executionDuration?: true
    rolledBackAt?: true
    rolledBackBy?: true
    rollbackReason?: true
    feedbackDueAt?: true
    actualImpact?: true
    wasSuccessful?: true
    successScore?: true
    feedbackNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AIDecisionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIDecision to aggregate.
     */
    where?: AIDecisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIDecisions to fetch.
     */
    orderBy?: AIDecisionOrderByWithRelationInput | AIDecisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIDecisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIDecisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIDecisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIDecisions
    **/
    _count?: true | AIDecisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIDecisionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIDecisionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIDecisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIDecisionMaxAggregateInputType
  }

  export type GetAIDecisionAggregateType<T extends AIDecisionAggregateArgs> = {
        [P in keyof T & keyof AggregateAIDecision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIDecision[P]>
      : GetScalarType<T[P], AggregateAIDecision[P]>
  }




  export type AIDecisionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIDecisionWhereInput
    orderBy?: AIDecisionOrderByWithAggregationInput | AIDecisionOrderByWithAggregationInput[]
    by: AIDecisionScalarFieldEnum[] | AIDecisionScalarFieldEnum
    having?: AIDecisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIDecisionCountAggregateInputType | true
    _avg?: AIDecisionAvgAggregateInputType
    _sum?: AIDecisionSumAggregateInputType
    _min?: AIDecisionMinAggregateInputType
    _max?: AIDecisionMaxAggregateInputType
  }

  export type AIDecisionGroupByOutputType = {
    id: string
    type: string
    subType: string | null
    priority: string
    confidence: number
    reasoning: string
    dataSnapshot: JsonValue | null
    actionType: string
    actionPayload: JsonValue
    estimatedImpact: string | null
    rollbackPlan: string | null
    requiresApproval: boolean
    autoApproved: boolean
    status: $Enums.AIDecisionStatus
    approvedBy: string | null
    approvedByName: string | null
    approvedAt: Date | null
    rejectedBy: string | null
    rejectedByName: string | null
    rejectedAt: Date | null
    rejectionReason: string | null
    executedAt: Date | null
    executionResult: JsonValue | null
    executionError: string | null
    executionDuration: number | null
    rolledBackAt: Date | null
    rolledBackBy: string | null
    rollbackReason: string | null
    feedbackDueAt: Date | null
    actualImpact: JsonValue | null
    wasSuccessful: boolean | null
    successScore: number | null
    feedbackNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: AIDecisionCountAggregateOutputType | null
    _avg: AIDecisionAvgAggregateOutputType | null
    _sum: AIDecisionSumAggregateOutputType | null
    _min: AIDecisionMinAggregateOutputType | null
    _max: AIDecisionMaxAggregateOutputType | null
  }

  type GetAIDecisionGroupByPayload<T extends AIDecisionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIDecisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIDecisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIDecisionGroupByOutputType[P]>
            : GetScalarType<T[P], AIDecisionGroupByOutputType[P]>
        }
      >
    >


  export type AIDecisionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    subType?: boolean
    priority?: boolean
    confidence?: boolean
    reasoning?: boolean
    dataSnapshot?: boolean
    actionType?: boolean
    actionPayload?: boolean
    estimatedImpact?: boolean
    rollbackPlan?: boolean
    requiresApproval?: boolean
    autoApproved?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedByName?: boolean
    approvedAt?: boolean
    rejectedBy?: boolean
    rejectedByName?: boolean
    rejectedAt?: boolean
    rejectionReason?: boolean
    executedAt?: boolean
    executionResult?: boolean
    executionError?: boolean
    executionDuration?: boolean
    rolledBackAt?: boolean
    rolledBackBy?: boolean
    rollbackReason?: boolean
    feedbackDueAt?: boolean
    actualImpact?: boolean
    wasSuccessful?: boolean
    successScore?: boolean
    feedbackNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    codeChanges?: boolean | AIDecision$codeChangesArgs<ExtArgs>
    logs?: boolean | AIDecision$logsArgs<ExtArgs>
    _count?: boolean | AIDecisionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIDecision"]>

  export type AIDecisionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    subType?: boolean
    priority?: boolean
    confidence?: boolean
    reasoning?: boolean
    dataSnapshot?: boolean
    actionType?: boolean
    actionPayload?: boolean
    estimatedImpact?: boolean
    rollbackPlan?: boolean
    requiresApproval?: boolean
    autoApproved?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedByName?: boolean
    approvedAt?: boolean
    rejectedBy?: boolean
    rejectedByName?: boolean
    rejectedAt?: boolean
    rejectionReason?: boolean
    executedAt?: boolean
    executionResult?: boolean
    executionError?: boolean
    executionDuration?: boolean
    rolledBackAt?: boolean
    rolledBackBy?: boolean
    rollbackReason?: boolean
    feedbackDueAt?: boolean
    actualImpact?: boolean
    wasSuccessful?: boolean
    successScore?: boolean
    feedbackNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIDecision"]>

  export type AIDecisionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    subType?: boolean
    priority?: boolean
    confidence?: boolean
    reasoning?: boolean
    dataSnapshot?: boolean
    actionType?: boolean
    actionPayload?: boolean
    estimatedImpact?: boolean
    rollbackPlan?: boolean
    requiresApproval?: boolean
    autoApproved?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedByName?: boolean
    approvedAt?: boolean
    rejectedBy?: boolean
    rejectedByName?: boolean
    rejectedAt?: boolean
    rejectionReason?: boolean
    executedAt?: boolean
    executionResult?: boolean
    executionError?: boolean
    executionDuration?: boolean
    rolledBackAt?: boolean
    rolledBackBy?: boolean
    rollbackReason?: boolean
    feedbackDueAt?: boolean
    actualImpact?: boolean
    wasSuccessful?: boolean
    successScore?: boolean
    feedbackNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIDecision"]>

  export type AIDecisionSelectScalar = {
    id?: boolean
    type?: boolean
    subType?: boolean
    priority?: boolean
    confidence?: boolean
    reasoning?: boolean
    dataSnapshot?: boolean
    actionType?: boolean
    actionPayload?: boolean
    estimatedImpact?: boolean
    rollbackPlan?: boolean
    requiresApproval?: boolean
    autoApproved?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedByName?: boolean
    approvedAt?: boolean
    rejectedBy?: boolean
    rejectedByName?: boolean
    rejectedAt?: boolean
    rejectionReason?: boolean
    executedAt?: boolean
    executionResult?: boolean
    executionError?: boolean
    executionDuration?: boolean
    rolledBackAt?: boolean
    rolledBackBy?: boolean
    rollbackReason?: boolean
    feedbackDueAt?: boolean
    actualImpact?: boolean
    wasSuccessful?: boolean
    successScore?: boolean
    feedbackNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AIDecisionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "subType" | "priority" | "confidence" | "reasoning" | "dataSnapshot" | "actionType" | "actionPayload" | "estimatedImpact" | "rollbackPlan" | "requiresApproval" | "autoApproved" | "status" | "approvedBy" | "approvedByName" | "approvedAt" | "rejectedBy" | "rejectedByName" | "rejectedAt" | "rejectionReason" | "executedAt" | "executionResult" | "executionError" | "executionDuration" | "rolledBackAt" | "rolledBackBy" | "rollbackReason" | "feedbackDueAt" | "actualImpact" | "wasSuccessful" | "successScore" | "feedbackNotes" | "createdAt" | "updatedAt", ExtArgs["result"]["aIDecision"]>
  export type AIDecisionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    codeChanges?: boolean | AIDecision$codeChangesArgs<ExtArgs>
    logs?: boolean | AIDecision$logsArgs<ExtArgs>
    _count?: boolean | AIDecisionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AIDecisionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AIDecisionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AIDecisionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIDecision"
    objects: {
      codeChanges: Prisma.$AICodeChangePayload<ExtArgs>[]
      logs: Prisma.$AIAgentLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      subType: string | null
      priority: string
      confidence: number
      reasoning: string
      dataSnapshot: Prisma.JsonValue | null
      actionType: string
      actionPayload: Prisma.JsonValue
      estimatedImpact: string | null
      rollbackPlan: string | null
      requiresApproval: boolean
      autoApproved: boolean
      status: $Enums.AIDecisionStatus
      approvedBy: string | null
      approvedByName: string | null
      approvedAt: Date | null
      rejectedBy: string | null
      rejectedByName: string | null
      rejectedAt: Date | null
      rejectionReason: string | null
      executedAt: Date | null
      executionResult: Prisma.JsonValue | null
      executionError: string | null
      executionDuration: number | null
      rolledBackAt: Date | null
      rolledBackBy: string | null
      rollbackReason: string | null
      feedbackDueAt: Date | null
      actualImpact: Prisma.JsonValue | null
      wasSuccessful: boolean | null
      successScore: number | null
      feedbackNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aIDecision"]>
    composites: {}
  }

  type AIDecisionGetPayload<S extends boolean | null | undefined | AIDecisionDefaultArgs> = $Result.GetResult<Prisma.$AIDecisionPayload, S>

  type AIDecisionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIDecisionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIDecisionCountAggregateInputType | true
    }

  export interface AIDecisionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIDecision'], meta: { name: 'AIDecision' } }
    /**
     * Find zero or one AIDecision that matches the filter.
     * @param {AIDecisionFindUniqueArgs} args - Arguments to find a AIDecision
     * @example
     * // Get one AIDecision
     * const aIDecision = await prisma.aIDecision.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIDecisionFindUniqueArgs>(args: SelectSubset<T, AIDecisionFindUniqueArgs<ExtArgs>>): Prisma__AIDecisionClient<$Result.GetResult<Prisma.$AIDecisionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIDecision that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIDecisionFindUniqueOrThrowArgs} args - Arguments to find a AIDecision
     * @example
     * // Get one AIDecision
     * const aIDecision = await prisma.aIDecision.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIDecisionFindUniqueOrThrowArgs>(args: SelectSubset<T, AIDecisionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIDecisionClient<$Result.GetResult<Prisma.$AIDecisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIDecision that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDecisionFindFirstArgs} args - Arguments to find a AIDecision
     * @example
     * // Get one AIDecision
     * const aIDecision = await prisma.aIDecision.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIDecisionFindFirstArgs>(args?: SelectSubset<T, AIDecisionFindFirstArgs<ExtArgs>>): Prisma__AIDecisionClient<$Result.GetResult<Prisma.$AIDecisionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIDecision that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDecisionFindFirstOrThrowArgs} args - Arguments to find a AIDecision
     * @example
     * // Get one AIDecision
     * const aIDecision = await prisma.aIDecision.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIDecisionFindFirstOrThrowArgs>(args?: SelectSubset<T, AIDecisionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIDecisionClient<$Result.GetResult<Prisma.$AIDecisionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIDecisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDecisionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIDecisions
     * const aIDecisions = await prisma.aIDecision.findMany()
     * 
     * // Get first 10 AIDecisions
     * const aIDecisions = await prisma.aIDecision.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIDecisionWithIdOnly = await prisma.aIDecision.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIDecisionFindManyArgs>(args?: SelectSubset<T, AIDecisionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIDecisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIDecision.
     * @param {AIDecisionCreateArgs} args - Arguments to create a AIDecision.
     * @example
     * // Create one AIDecision
     * const AIDecision = await prisma.aIDecision.create({
     *   data: {
     *     // ... data to create a AIDecision
     *   }
     * })
     * 
     */
    create<T extends AIDecisionCreateArgs>(args: SelectSubset<T, AIDecisionCreateArgs<ExtArgs>>): Prisma__AIDecisionClient<$Result.GetResult<Prisma.$AIDecisionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIDecisions.
     * @param {AIDecisionCreateManyArgs} args - Arguments to create many AIDecisions.
     * @example
     * // Create many AIDecisions
     * const aIDecision = await prisma.aIDecision.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIDecisionCreateManyArgs>(args?: SelectSubset<T, AIDecisionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIDecisions and returns the data saved in the database.
     * @param {AIDecisionCreateManyAndReturnArgs} args - Arguments to create many AIDecisions.
     * @example
     * // Create many AIDecisions
     * const aIDecision = await prisma.aIDecision.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIDecisions and only return the `id`
     * const aIDecisionWithIdOnly = await prisma.aIDecision.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIDecisionCreateManyAndReturnArgs>(args?: SelectSubset<T, AIDecisionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIDecisionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIDecision.
     * @param {AIDecisionDeleteArgs} args - Arguments to delete one AIDecision.
     * @example
     * // Delete one AIDecision
     * const AIDecision = await prisma.aIDecision.delete({
     *   where: {
     *     // ... filter to delete one AIDecision
     *   }
     * })
     * 
     */
    delete<T extends AIDecisionDeleteArgs>(args: SelectSubset<T, AIDecisionDeleteArgs<ExtArgs>>): Prisma__AIDecisionClient<$Result.GetResult<Prisma.$AIDecisionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIDecision.
     * @param {AIDecisionUpdateArgs} args - Arguments to update one AIDecision.
     * @example
     * // Update one AIDecision
     * const aIDecision = await prisma.aIDecision.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIDecisionUpdateArgs>(args: SelectSubset<T, AIDecisionUpdateArgs<ExtArgs>>): Prisma__AIDecisionClient<$Result.GetResult<Prisma.$AIDecisionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIDecisions.
     * @param {AIDecisionDeleteManyArgs} args - Arguments to filter AIDecisions to delete.
     * @example
     * // Delete a few AIDecisions
     * const { count } = await prisma.aIDecision.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIDecisionDeleteManyArgs>(args?: SelectSubset<T, AIDecisionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIDecisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDecisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIDecisions
     * const aIDecision = await prisma.aIDecision.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIDecisionUpdateManyArgs>(args: SelectSubset<T, AIDecisionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIDecisions and returns the data updated in the database.
     * @param {AIDecisionUpdateManyAndReturnArgs} args - Arguments to update many AIDecisions.
     * @example
     * // Update many AIDecisions
     * const aIDecision = await prisma.aIDecision.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIDecisions and only return the `id`
     * const aIDecisionWithIdOnly = await prisma.aIDecision.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIDecisionUpdateManyAndReturnArgs>(args: SelectSubset<T, AIDecisionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIDecisionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIDecision.
     * @param {AIDecisionUpsertArgs} args - Arguments to update or create a AIDecision.
     * @example
     * // Update or create a AIDecision
     * const aIDecision = await prisma.aIDecision.upsert({
     *   create: {
     *     // ... data to create a AIDecision
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIDecision we want to update
     *   }
     * })
     */
    upsert<T extends AIDecisionUpsertArgs>(args: SelectSubset<T, AIDecisionUpsertArgs<ExtArgs>>): Prisma__AIDecisionClient<$Result.GetResult<Prisma.$AIDecisionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIDecisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDecisionCountArgs} args - Arguments to filter AIDecisions to count.
     * @example
     * // Count the number of AIDecisions
     * const count = await prisma.aIDecision.count({
     *   where: {
     *     // ... the filter for the AIDecisions we want to count
     *   }
     * })
    **/
    count<T extends AIDecisionCountArgs>(
      args?: Subset<T, AIDecisionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIDecisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIDecision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDecisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIDecisionAggregateArgs>(args: Subset<T, AIDecisionAggregateArgs>): Prisma.PrismaPromise<GetAIDecisionAggregateType<T>>

    /**
     * Group by AIDecision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDecisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIDecisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIDecisionGroupByArgs['orderBy'] }
        : { orderBy?: AIDecisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIDecisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIDecisionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIDecision model
   */
  readonly fields: AIDecisionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIDecision.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIDecisionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    codeChanges<T extends AIDecision$codeChangesArgs<ExtArgs> = {}>(args?: Subset<T, AIDecision$codeChangesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AICodeChangePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    logs<T extends AIDecision$logsArgs<ExtArgs> = {}>(args?: Subset<T, AIDecision$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIAgentLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIDecision model
   */
  interface AIDecisionFieldRefs {
    readonly id: FieldRef<"AIDecision", 'String'>
    readonly type: FieldRef<"AIDecision", 'String'>
    readonly subType: FieldRef<"AIDecision", 'String'>
    readonly priority: FieldRef<"AIDecision", 'String'>
    readonly confidence: FieldRef<"AIDecision", 'Float'>
    readonly reasoning: FieldRef<"AIDecision", 'String'>
    readonly dataSnapshot: FieldRef<"AIDecision", 'Json'>
    readonly actionType: FieldRef<"AIDecision", 'String'>
    readonly actionPayload: FieldRef<"AIDecision", 'Json'>
    readonly estimatedImpact: FieldRef<"AIDecision", 'String'>
    readonly rollbackPlan: FieldRef<"AIDecision", 'String'>
    readonly requiresApproval: FieldRef<"AIDecision", 'Boolean'>
    readonly autoApproved: FieldRef<"AIDecision", 'Boolean'>
    readonly status: FieldRef<"AIDecision", 'AIDecisionStatus'>
    readonly approvedBy: FieldRef<"AIDecision", 'String'>
    readonly approvedByName: FieldRef<"AIDecision", 'String'>
    readonly approvedAt: FieldRef<"AIDecision", 'DateTime'>
    readonly rejectedBy: FieldRef<"AIDecision", 'String'>
    readonly rejectedByName: FieldRef<"AIDecision", 'String'>
    readonly rejectedAt: FieldRef<"AIDecision", 'DateTime'>
    readonly rejectionReason: FieldRef<"AIDecision", 'String'>
    readonly executedAt: FieldRef<"AIDecision", 'DateTime'>
    readonly executionResult: FieldRef<"AIDecision", 'Json'>
    readonly executionError: FieldRef<"AIDecision", 'String'>
    readonly executionDuration: FieldRef<"AIDecision", 'Int'>
    readonly rolledBackAt: FieldRef<"AIDecision", 'DateTime'>
    readonly rolledBackBy: FieldRef<"AIDecision", 'String'>
    readonly rollbackReason: FieldRef<"AIDecision", 'String'>
    readonly feedbackDueAt: FieldRef<"AIDecision", 'DateTime'>
    readonly actualImpact: FieldRef<"AIDecision", 'Json'>
    readonly wasSuccessful: FieldRef<"AIDecision", 'Boolean'>
    readonly successScore: FieldRef<"AIDecision", 'Float'>
    readonly feedbackNotes: FieldRef<"AIDecision", 'String'>
    readonly createdAt: FieldRef<"AIDecision", 'DateTime'>
    readonly updatedAt: FieldRef<"AIDecision", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIDecision findUnique
   */
  export type AIDecisionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDecision
     */
    omit?: AIDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDecisionInclude<ExtArgs> | null
    /**
     * Filter, which AIDecision to fetch.
     */
    where: AIDecisionWhereUniqueInput
  }

  /**
   * AIDecision findUniqueOrThrow
   */
  export type AIDecisionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDecision
     */
    omit?: AIDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDecisionInclude<ExtArgs> | null
    /**
     * Filter, which AIDecision to fetch.
     */
    where: AIDecisionWhereUniqueInput
  }

  /**
   * AIDecision findFirst
   */
  export type AIDecisionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDecision
     */
    omit?: AIDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDecisionInclude<ExtArgs> | null
    /**
     * Filter, which AIDecision to fetch.
     */
    where?: AIDecisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIDecisions to fetch.
     */
    orderBy?: AIDecisionOrderByWithRelationInput | AIDecisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIDecisions.
     */
    cursor?: AIDecisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIDecisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIDecisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIDecisions.
     */
    distinct?: AIDecisionScalarFieldEnum | AIDecisionScalarFieldEnum[]
  }

  /**
   * AIDecision findFirstOrThrow
   */
  export type AIDecisionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDecision
     */
    omit?: AIDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDecisionInclude<ExtArgs> | null
    /**
     * Filter, which AIDecision to fetch.
     */
    where?: AIDecisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIDecisions to fetch.
     */
    orderBy?: AIDecisionOrderByWithRelationInput | AIDecisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIDecisions.
     */
    cursor?: AIDecisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIDecisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIDecisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIDecisions.
     */
    distinct?: AIDecisionScalarFieldEnum | AIDecisionScalarFieldEnum[]
  }

  /**
   * AIDecision findMany
   */
  export type AIDecisionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDecision
     */
    omit?: AIDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDecisionInclude<ExtArgs> | null
    /**
     * Filter, which AIDecisions to fetch.
     */
    where?: AIDecisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIDecisions to fetch.
     */
    orderBy?: AIDecisionOrderByWithRelationInput | AIDecisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIDecisions.
     */
    cursor?: AIDecisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIDecisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIDecisions.
     */
    skip?: number
    distinct?: AIDecisionScalarFieldEnum | AIDecisionScalarFieldEnum[]
  }

  /**
   * AIDecision create
   */
  export type AIDecisionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDecision
     */
    omit?: AIDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDecisionInclude<ExtArgs> | null
    /**
     * The data needed to create a AIDecision.
     */
    data: XOR<AIDecisionCreateInput, AIDecisionUncheckedCreateInput>
  }

  /**
   * AIDecision createMany
   */
  export type AIDecisionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIDecisions.
     */
    data: AIDecisionCreateManyInput | AIDecisionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIDecision createManyAndReturn
   */
  export type AIDecisionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIDecision
     */
    omit?: AIDecisionOmit<ExtArgs> | null
    /**
     * The data used to create many AIDecisions.
     */
    data: AIDecisionCreateManyInput | AIDecisionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIDecision update
   */
  export type AIDecisionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDecision
     */
    omit?: AIDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDecisionInclude<ExtArgs> | null
    /**
     * The data needed to update a AIDecision.
     */
    data: XOR<AIDecisionUpdateInput, AIDecisionUncheckedUpdateInput>
    /**
     * Choose, which AIDecision to update.
     */
    where: AIDecisionWhereUniqueInput
  }

  /**
   * AIDecision updateMany
   */
  export type AIDecisionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIDecisions.
     */
    data: XOR<AIDecisionUpdateManyMutationInput, AIDecisionUncheckedUpdateManyInput>
    /**
     * Filter which AIDecisions to update
     */
    where?: AIDecisionWhereInput
    /**
     * Limit how many AIDecisions to update.
     */
    limit?: number
  }

  /**
   * AIDecision updateManyAndReturn
   */
  export type AIDecisionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIDecision
     */
    omit?: AIDecisionOmit<ExtArgs> | null
    /**
     * The data used to update AIDecisions.
     */
    data: XOR<AIDecisionUpdateManyMutationInput, AIDecisionUncheckedUpdateManyInput>
    /**
     * Filter which AIDecisions to update
     */
    where?: AIDecisionWhereInput
    /**
     * Limit how many AIDecisions to update.
     */
    limit?: number
  }

  /**
   * AIDecision upsert
   */
  export type AIDecisionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDecision
     */
    omit?: AIDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDecisionInclude<ExtArgs> | null
    /**
     * The filter to search for the AIDecision to update in case it exists.
     */
    where: AIDecisionWhereUniqueInput
    /**
     * In case the AIDecision found by the `where` argument doesn't exist, create a new AIDecision with this data.
     */
    create: XOR<AIDecisionCreateInput, AIDecisionUncheckedCreateInput>
    /**
     * In case the AIDecision was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIDecisionUpdateInput, AIDecisionUncheckedUpdateInput>
  }

  /**
   * AIDecision delete
   */
  export type AIDecisionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDecision
     */
    omit?: AIDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDecisionInclude<ExtArgs> | null
    /**
     * Filter which AIDecision to delete.
     */
    where: AIDecisionWhereUniqueInput
  }

  /**
   * AIDecision deleteMany
   */
  export type AIDecisionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIDecisions to delete
     */
    where?: AIDecisionWhereInput
    /**
     * Limit how many AIDecisions to delete.
     */
    limit?: number
  }

  /**
   * AIDecision.codeChanges
   */
  export type AIDecision$codeChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICodeChange
     */
    select?: AICodeChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICodeChange
     */
    omit?: AICodeChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AICodeChangeInclude<ExtArgs> | null
    where?: AICodeChangeWhereInput
    orderBy?: AICodeChangeOrderByWithRelationInput | AICodeChangeOrderByWithRelationInput[]
    cursor?: AICodeChangeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AICodeChangeScalarFieldEnum | AICodeChangeScalarFieldEnum[]
  }

  /**
   * AIDecision.logs
   */
  export type AIDecision$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentLog
     */
    select?: AIAgentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentLog
     */
    omit?: AIAgentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentLogInclude<ExtArgs> | null
    where?: AIAgentLogWhereInput
    orderBy?: AIAgentLogOrderByWithRelationInput | AIAgentLogOrderByWithRelationInput[]
    cursor?: AIAgentLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIAgentLogScalarFieldEnum | AIAgentLogScalarFieldEnum[]
  }

  /**
   * AIDecision without action
   */
  export type AIDecisionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDecision
     */
    omit?: AIDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDecisionInclude<ExtArgs> | null
  }


  /**
   * Model AICodeChange
   */

  export type AggregateAICodeChange = {
    _count: AICodeChangeCountAggregateOutputType | null
    _min: AICodeChangeMinAggregateOutputType | null
    _max: AICodeChangeMaxAggregateOutputType | null
  }

  export type AICodeChangeMinAggregateOutputType = {
    id: string | null
    decisionId: string | null
    filePath: string | null
    action: $Enums.AICodeAction | null
    originalContent: string | null
    newContent: string | null
    diff: string | null
    syntaxValid: boolean | null
    typesValid: boolean | null
    lintPassed: boolean | null
    testsPassed: boolean | null
    appliedAt: Date | null
    rolledBackAt: Date | null
    createdAt: Date | null
  }

  export type AICodeChangeMaxAggregateOutputType = {
    id: string | null
    decisionId: string | null
    filePath: string | null
    action: $Enums.AICodeAction | null
    originalContent: string | null
    newContent: string | null
    diff: string | null
    syntaxValid: boolean | null
    typesValid: boolean | null
    lintPassed: boolean | null
    testsPassed: boolean | null
    appliedAt: Date | null
    rolledBackAt: Date | null
    createdAt: Date | null
  }

  export type AICodeChangeCountAggregateOutputType = {
    id: number
    decisionId: number
    filePath: number
    action: number
    originalContent: number
    newContent: number
    diff: number
    syntaxValid: number
    typesValid: number
    lintPassed: number
    testsPassed: number
    appliedAt: number
    rolledBackAt: number
    createdAt: number
    _all: number
  }


  export type AICodeChangeMinAggregateInputType = {
    id?: true
    decisionId?: true
    filePath?: true
    action?: true
    originalContent?: true
    newContent?: true
    diff?: true
    syntaxValid?: true
    typesValid?: true
    lintPassed?: true
    testsPassed?: true
    appliedAt?: true
    rolledBackAt?: true
    createdAt?: true
  }

  export type AICodeChangeMaxAggregateInputType = {
    id?: true
    decisionId?: true
    filePath?: true
    action?: true
    originalContent?: true
    newContent?: true
    diff?: true
    syntaxValid?: true
    typesValid?: true
    lintPassed?: true
    testsPassed?: true
    appliedAt?: true
    rolledBackAt?: true
    createdAt?: true
  }

  export type AICodeChangeCountAggregateInputType = {
    id?: true
    decisionId?: true
    filePath?: true
    action?: true
    originalContent?: true
    newContent?: true
    diff?: true
    syntaxValid?: true
    typesValid?: true
    lintPassed?: true
    testsPassed?: true
    appliedAt?: true
    rolledBackAt?: true
    createdAt?: true
    _all?: true
  }

  export type AICodeChangeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AICodeChange to aggregate.
     */
    where?: AICodeChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AICodeChanges to fetch.
     */
    orderBy?: AICodeChangeOrderByWithRelationInput | AICodeChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AICodeChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AICodeChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AICodeChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AICodeChanges
    **/
    _count?: true | AICodeChangeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AICodeChangeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AICodeChangeMaxAggregateInputType
  }

  export type GetAICodeChangeAggregateType<T extends AICodeChangeAggregateArgs> = {
        [P in keyof T & keyof AggregateAICodeChange]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAICodeChange[P]>
      : GetScalarType<T[P], AggregateAICodeChange[P]>
  }




  export type AICodeChangeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AICodeChangeWhereInput
    orderBy?: AICodeChangeOrderByWithAggregationInput | AICodeChangeOrderByWithAggregationInput[]
    by: AICodeChangeScalarFieldEnum[] | AICodeChangeScalarFieldEnum
    having?: AICodeChangeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AICodeChangeCountAggregateInputType | true
    _min?: AICodeChangeMinAggregateInputType
    _max?: AICodeChangeMaxAggregateInputType
  }

  export type AICodeChangeGroupByOutputType = {
    id: string
    decisionId: string
    filePath: string
    action: $Enums.AICodeAction
    originalContent: string | null
    newContent: string | null
    diff: string | null
    syntaxValid: boolean
    typesValid: boolean
    lintPassed: boolean
    testsPassed: boolean | null
    appliedAt: Date | null
    rolledBackAt: Date | null
    createdAt: Date
    _count: AICodeChangeCountAggregateOutputType | null
    _min: AICodeChangeMinAggregateOutputType | null
    _max: AICodeChangeMaxAggregateOutputType | null
  }

  type GetAICodeChangeGroupByPayload<T extends AICodeChangeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AICodeChangeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AICodeChangeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AICodeChangeGroupByOutputType[P]>
            : GetScalarType<T[P], AICodeChangeGroupByOutputType[P]>
        }
      >
    >


  export type AICodeChangeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    decisionId?: boolean
    filePath?: boolean
    action?: boolean
    originalContent?: boolean
    newContent?: boolean
    diff?: boolean
    syntaxValid?: boolean
    typesValid?: boolean
    lintPassed?: boolean
    testsPassed?: boolean
    appliedAt?: boolean
    rolledBackAt?: boolean
    createdAt?: boolean
    decision?: boolean | AIDecisionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aICodeChange"]>

  export type AICodeChangeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    decisionId?: boolean
    filePath?: boolean
    action?: boolean
    originalContent?: boolean
    newContent?: boolean
    diff?: boolean
    syntaxValid?: boolean
    typesValid?: boolean
    lintPassed?: boolean
    testsPassed?: boolean
    appliedAt?: boolean
    rolledBackAt?: boolean
    createdAt?: boolean
    decision?: boolean | AIDecisionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aICodeChange"]>

  export type AICodeChangeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    decisionId?: boolean
    filePath?: boolean
    action?: boolean
    originalContent?: boolean
    newContent?: boolean
    diff?: boolean
    syntaxValid?: boolean
    typesValid?: boolean
    lintPassed?: boolean
    testsPassed?: boolean
    appliedAt?: boolean
    rolledBackAt?: boolean
    createdAt?: boolean
    decision?: boolean | AIDecisionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aICodeChange"]>

  export type AICodeChangeSelectScalar = {
    id?: boolean
    decisionId?: boolean
    filePath?: boolean
    action?: boolean
    originalContent?: boolean
    newContent?: boolean
    diff?: boolean
    syntaxValid?: boolean
    typesValid?: boolean
    lintPassed?: boolean
    testsPassed?: boolean
    appliedAt?: boolean
    rolledBackAt?: boolean
    createdAt?: boolean
  }

  export type AICodeChangeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "decisionId" | "filePath" | "action" | "originalContent" | "newContent" | "diff" | "syntaxValid" | "typesValid" | "lintPassed" | "testsPassed" | "appliedAt" | "rolledBackAt" | "createdAt", ExtArgs["result"]["aICodeChange"]>
  export type AICodeChangeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    decision?: boolean | AIDecisionDefaultArgs<ExtArgs>
  }
  export type AICodeChangeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    decision?: boolean | AIDecisionDefaultArgs<ExtArgs>
  }
  export type AICodeChangeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    decision?: boolean | AIDecisionDefaultArgs<ExtArgs>
  }

  export type $AICodeChangePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AICodeChange"
    objects: {
      decision: Prisma.$AIDecisionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      decisionId: string
      filePath: string
      action: $Enums.AICodeAction
      originalContent: string | null
      newContent: string | null
      diff: string | null
      syntaxValid: boolean
      typesValid: boolean
      lintPassed: boolean
      testsPassed: boolean | null
      appliedAt: Date | null
      rolledBackAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["aICodeChange"]>
    composites: {}
  }

  type AICodeChangeGetPayload<S extends boolean | null | undefined | AICodeChangeDefaultArgs> = $Result.GetResult<Prisma.$AICodeChangePayload, S>

  type AICodeChangeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AICodeChangeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AICodeChangeCountAggregateInputType | true
    }

  export interface AICodeChangeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AICodeChange'], meta: { name: 'AICodeChange' } }
    /**
     * Find zero or one AICodeChange that matches the filter.
     * @param {AICodeChangeFindUniqueArgs} args - Arguments to find a AICodeChange
     * @example
     * // Get one AICodeChange
     * const aICodeChange = await prisma.aICodeChange.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AICodeChangeFindUniqueArgs>(args: SelectSubset<T, AICodeChangeFindUniqueArgs<ExtArgs>>): Prisma__AICodeChangeClient<$Result.GetResult<Prisma.$AICodeChangePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AICodeChange that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AICodeChangeFindUniqueOrThrowArgs} args - Arguments to find a AICodeChange
     * @example
     * // Get one AICodeChange
     * const aICodeChange = await prisma.aICodeChange.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AICodeChangeFindUniqueOrThrowArgs>(args: SelectSubset<T, AICodeChangeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AICodeChangeClient<$Result.GetResult<Prisma.$AICodeChangePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AICodeChange that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AICodeChangeFindFirstArgs} args - Arguments to find a AICodeChange
     * @example
     * // Get one AICodeChange
     * const aICodeChange = await prisma.aICodeChange.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AICodeChangeFindFirstArgs>(args?: SelectSubset<T, AICodeChangeFindFirstArgs<ExtArgs>>): Prisma__AICodeChangeClient<$Result.GetResult<Prisma.$AICodeChangePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AICodeChange that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AICodeChangeFindFirstOrThrowArgs} args - Arguments to find a AICodeChange
     * @example
     * // Get one AICodeChange
     * const aICodeChange = await prisma.aICodeChange.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AICodeChangeFindFirstOrThrowArgs>(args?: SelectSubset<T, AICodeChangeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AICodeChangeClient<$Result.GetResult<Prisma.$AICodeChangePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AICodeChanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AICodeChangeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AICodeChanges
     * const aICodeChanges = await prisma.aICodeChange.findMany()
     * 
     * // Get first 10 AICodeChanges
     * const aICodeChanges = await prisma.aICodeChange.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aICodeChangeWithIdOnly = await prisma.aICodeChange.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AICodeChangeFindManyArgs>(args?: SelectSubset<T, AICodeChangeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AICodeChangePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AICodeChange.
     * @param {AICodeChangeCreateArgs} args - Arguments to create a AICodeChange.
     * @example
     * // Create one AICodeChange
     * const AICodeChange = await prisma.aICodeChange.create({
     *   data: {
     *     // ... data to create a AICodeChange
     *   }
     * })
     * 
     */
    create<T extends AICodeChangeCreateArgs>(args: SelectSubset<T, AICodeChangeCreateArgs<ExtArgs>>): Prisma__AICodeChangeClient<$Result.GetResult<Prisma.$AICodeChangePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AICodeChanges.
     * @param {AICodeChangeCreateManyArgs} args - Arguments to create many AICodeChanges.
     * @example
     * // Create many AICodeChanges
     * const aICodeChange = await prisma.aICodeChange.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AICodeChangeCreateManyArgs>(args?: SelectSubset<T, AICodeChangeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AICodeChanges and returns the data saved in the database.
     * @param {AICodeChangeCreateManyAndReturnArgs} args - Arguments to create many AICodeChanges.
     * @example
     * // Create many AICodeChanges
     * const aICodeChange = await prisma.aICodeChange.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AICodeChanges and only return the `id`
     * const aICodeChangeWithIdOnly = await prisma.aICodeChange.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AICodeChangeCreateManyAndReturnArgs>(args?: SelectSubset<T, AICodeChangeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AICodeChangePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AICodeChange.
     * @param {AICodeChangeDeleteArgs} args - Arguments to delete one AICodeChange.
     * @example
     * // Delete one AICodeChange
     * const AICodeChange = await prisma.aICodeChange.delete({
     *   where: {
     *     // ... filter to delete one AICodeChange
     *   }
     * })
     * 
     */
    delete<T extends AICodeChangeDeleteArgs>(args: SelectSubset<T, AICodeChangeDeleteArgs<ExtArgs>>): Prisma__AICodeChangeClient<$Result.GetResult<Prisma.$AICodeChangePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AICodeChange.
     * @param {AICodeChangeUpdateArgs} args - Arguments to update one AICodeChange.
     * @example
     * // Update one AICodeChange
     * const aICodeChange = await prisma.aICodeChange.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AICodeChangeUpdateArgs>(args: SelectSubset<T, AICodeChangeUpdateArgs<ExtArgs>>): Prisma__AICodeChangeClient<$Result.GetResult<Prisma.$AICodeChangePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AICodeChanges.
     * @param {AICodeChangeDeleteManyArgs} args - Arguments to filter AICodeChanges to delete.
     * @example
     * // Delete a few AICodeChanges
     * const { count } = await prisma.aICodeChange.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AICodeChangeDeleteManyArgs>(args?: SelectSubset<T, AICodeChangeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AICodeChanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AICodeChangeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AICodeChanges
     * const aICodeChange = await prisma.aICodeChange.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AICodeChangeUpdateManyArgs>(args: SelectSubset<T, AICodeChangeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AICodeChanges and returns the data updated in the database.
     * @param {AICodeChangeUpdateManyAndReturnArgs} args - Arguments to update many AICodeChanges.
     * @example
     * // Update many AICodeChanges
     * const aICodeChange = await prisma.aICodeChange.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AICodeChanges and only return the `id`
     * const aICodeChangeWithIdOnly = await prisma.aICodeChange.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AICodeChangeUpdateManyAndReturnArgs>(args: SelectSubset<T, AICodeChangeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AICodeChangePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AICodeChange.
     * @param {AICodeChangeUpsertArgs} args - Arguments to update or create a AICodeChange.
     * @example
     * // Update or create a AICodeChange
     * const aICodeChange = await prisma.aICodeChange.upsert({
     *   create: {
     *     // ... data to create a AICodeChange
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AICodeChange we want to update
     *   }
     * })
     */
    upsert<T extends AICodeChangeUpsertArgs>(args: SelectSubset<T, AICodeChangeUpsertArgs<ExtArgs>>): Prisma__AICodeChangeClient<$Result.GetResult<Prisma.$AICodeChangePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AICodeChanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AICodeChangeCountArgs} args - Arguments to filter AICodeChanges to count.
     * @example
     * // Count the number of AICodeChanges
     * const count = await prisma.aICodeChange.count({
     *   where: {
     *     // ... the filter for the AICodeChanges we want to count
     *   }
     * })
    **/
    count<T extends AICodeChangeCountArgs>(
      args?: Subset<T, AICodeChangeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AICodeChangeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AICodeChange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AICodeChangeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AICodeChangeAggregateArgs>(args: Subset<T, AICodeChangeAggregateArgs>): Prisma.PrismaPromise<GetAICodeChangeAggregateType<T>>

    /**
     * Group by AICodeChange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AICodeChangeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AICodeChangeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AICodeChangeGroupByArgs['orderBy'] }
        : { orderBy?: AICodeChangeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AICodeChangeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAICodeChangeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AICodeChange model
   */
  readonly fields: AICodeChangeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AICodeChange.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AICodeChangeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    decision<T extends AIDecisionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AIDecisionDefaultArgs<ExtArgs>>): Prisma__AIDecisionClient<$Result.GetResult<Prisma.$AIDecisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AICodeChange model
   */
  interface AICodeChangeFieldRefs {
    readonly id: FieldRef<"AICodeChange", 'String'>
    readonly decisionId: FieldRef<"AICodeChange", 'String'>
    readonly filePath: FieldRef<"AICodeChange", 'String'>
    readonly action: FieldRef<"AICodeChange", 'AICodeAction'>
    readonly originalContent: FieldRef<"AICodeChange", 'String'>
    readonly newContent: FieldRef<"AICodeChange", 'String'>
    readonly diff: FieldRef<"AICodeChange", 'String'>
    readonly syntaxValid: FieldRef<"AICodeChange", 'Boolean'>
    readonly typesValid: FieldRef<"AICodeChange", 'Boolean'>
    readonly lintPassed: FieldRef<"AICodeChange", 'Boolean'>
    readonly testsPassed: FieldRef<"AICodeChange", 'Boolean'>
    readonly appliedAt: FieldRef<"AICodeChange", 'DateTime'>
    readonly rolledBackAt: FieldRef<"AICodeChange", 'DateTime'>
    readonly createdAt: FieldRef<"AICodeChange", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AICodeChange findUnique
   */
  export type AICodeChangeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICodeChange
     */
    select?: AICodeChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICodeChange
     */
    omit?: AICodeChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AICodeChangeInclude<ExtArgs> | null
    /**
     * Filter, which AICodeChange to fetch.
     */
    where: AICodeChangeWhereUniqueInput
  }

  /**
   * AICodeChange findUniqueOrThrow
   */
  export type AICodeChangeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICodeChange
     */
    select?: AICodeChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICodeChange
     */
    omit?: AICodeChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AICodeChangeInclude<ExtArgs> | null
    /**
     * Filter, which AICodeChange to fetch.
     */
    where: AICodeChangeWhereUniqueInput
  }

  /**
   * AICodeChange findFirst
   */
  export type AICodeChangeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICodeChange
     */
    select?: AICodeChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICodeChange
     */
    omit?: AICodeChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AICodeChangeInclude<ExtArgs> | null
    /**
     * Filter, which AICodeChange to fetch.
     */
    where?: AICodeChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AICodeChanges to fetch.
     */
    orderBy?: AICodeChangeOrderByWithRelationInput | AICodeChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AICodeChanges.
     */
    cursor?: AICodeChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AICodeChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AICodeChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AICodeChanges.
     */
    distinct?: AICodeChangeScalarFieldEnum | AICodeChangeScalarFieldEnum[]
  }

  /**
   * AICodeChange findFirstOrThrow
   */
  export type AICodeChangeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICodeChange
     */
    select?: AICodeChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICodeChange
     */
    omit?: AICodeChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AICodeChangeInclude<ExtArgs> | null
    /**
     * Filter, which AICodeChange to fetch.
     */
    where?: AICodeChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AICodeChanges to fetch.
     */
    orderBy?: AICodeChangeOrderByWithRelationInput | AICodeChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AICodeChanges.
     */
    cursor?: AICodeChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AICodeChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AICodeChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AICodeChanges.
     */
    distinct?: AICodeChangeScalarFieldEnum | AICodeChangeScalarFieldEnum[]
  }

  /**
   * AICodeChange findMany
   */
  export type AICodeChangeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICodeChange
     */
    select?: AICodeChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICodeChange
     */
    omit?: AICodeChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AICodeChangeInclude<ExtArgs> | null
    /**
     * Filter, which AICodeChanges to fetch.
     */
    where?: AICodeChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AICodeChanges to fetch.
     */
    orderBy?: AICodeChangeOrderByWithRelationInput | AICodeChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AICodeChanges.
     */
    cursor?: AICodeChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AICodeChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AICodeChanges.
     */
    skip?: number
    distinct?: AICodeChangeScalarFieldEnum | AICodeChangeScalarFieldEnum[]
  }

  /**
   * AICodeChange create
   */
  export type AICodeChangeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICodeChange
     */
    select?: AICodeChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICodeChange
     */
    omit?: AICodeChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AICodeChangeInclude<ExtArgs> | null
    /**
     * The data needed to create a AICodeChange.
     */
    data: XOR<AICodeChangeCreateInput, AICodeChangeUncheckedCreateInput>
  }

  /**
   * AICodeChange createMany
   */
  export type AICodeChangeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AICodeChanges.
     */
    data: AICodeChangeCreateManyInput | AICodeChangeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AICodeChange createManyAndReturn
   */
  export type AICodeChangeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICodeChange
     */
    select?: AICodeChangeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AICodeChange
     */
    omit?: AICodeChangeOmit<ExtArgs> | null
    /**
     * The data used to create many AICodeChanges.
     */
    data: AICodeChangeCreateManyInput | AICodeChangeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AICodeChangeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AICodeChange update
   */
  export type AICodeChangeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICodeChange
     */
    select?: AICodeChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICodeChange
     */
    omit?: AICodeChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AICodeChangeInclude<ExtArgs> | null
    /**
     * The data needed to update a AICodeChange.
     */
    data: XOR<AICodeChangeUpdateInput, AICodeChangeUncheckedUpdateInput>
    /**
     * Choose, which AICodeChange to update.
     */
    where: AICodeChangeWhereUniqueInput
  }

  /**
   * AICodeChange updateMany
   */
  export type AICodeChangeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AICodeChanges.
     */
    data: XOR<AICodeChangeUpdateManyMutationInput, AICodeChangeUncheckedUpdateManyInput>
    /**
     * Filter which AICodeChanges to update
     */
    where?: AICodeChangeWhereInput
    /**
     * Limit how many AICodeChanges to update.
     */
    limit?: number
  }

  /**
   * AICodeChange updateManyAndReturn
   */
  export type AICodeChangeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICodeChange
     */
    select?: AICodeChangeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AICodeChange
     */
    omit?: AICodeChangeOmit<ExtArgs> | null
    /**
     * The data used to update AICodeChanges.
     */
    data: XOR<AICodeChangeUpdateManyMutationInput, AICodeChangeUncheckedUpdateManyInput>
    /**
     * Filter which AICodeChanges to update
     */
    where?: AICodeChangeWhereInput
    /**
     * Limit how many AICodeChanges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AICodeChangeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AICodeChange upsert
   */
  export type AICodeChangeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICodeChange
     */
    select?: AICodeChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICodeChange
     */
    omit?: AICodeChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AICodeChangeInclude<ExtArgs> | null
    /**
     * The filter to search for the AICodeChange to update in case it exists.
     */
    where: AICodeChangeWhereUniqueInput
    /**
     * In case the AICodeChange found by the `where` argument doesn't exist, create a new AICodeChange with this data.
     */
    create: XOR<AICodeChangeCreateInput, AICodeChangeUncheckedCreateInput>
    /**
     * In case the AICodeChange was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AICodeChangeUpdateInput, AICodeChangeUncheckedUpdateInput>
  }

  /**
   * AICodeChange delete
   */
  export type AICodeChangeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICodeChange
     */
    select?: AICodeChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICodeChange
     */
    omit?: AICodeChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AICodeChangeInclude<ExtArgs> | null
    /**
     * Filter which AICodeChange to delete.
     */
    where: AICodeChangeWhereUniqueInput
  }

  /**
   * AICodeChange deleteMany
   */
  export type AICodeChangeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AICodeChanges to delete
     */
    where?: AICodeChangeWhereInput
    /**
     * Limit how many AICodeChanges to delete.
     */
    limit?: number
  }

  /**
   * AICodeChange without action
   */
  export type AICodeChangeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AICodeChange
     */
    select?: AICodeChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AICodeChange
     */
    omit?: AICodeChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AICodeChangeInclude<ExtArgs> | null
  }


  /**
   * Model AIAgentLog
   */

  export type AggregateAIAgentLog = {
    _count: AIAgentLogCountAggregateOutputType | null
    _avg: AIAgentLogAvgAggregateOutputType | null
    _sum: AIAgentLogSumAggregateOutputType | null
    _min: AIAgentLogMinAggregateOutputType | null
    _max: AIAgentLogMaxAggregateOutputType | null
  }

  export type AIAgentLogAvgAggregateOutputType = {
    durationMs: number | null
  }

  export type AIAgentLogSumAggregateOutputType = {
    durationMs: number | null
  }

  export type AIAgentLogMinAggregateOutputType = {
    id: string | null
    level: $Enums.AILogLevel | null
    category: string | null
    message: string | null
    decisionId: string | null
    errorCode: string | null
    errorStack: string | null
    durationMs: number | null
    createdAt: Date | null
  }

  export type AIAgentLogMaxAggregateOutputType = {
    id: string | null
    level: $Enums.AILogLevel | null
    category: string | null
    message: string | null
    decisionId: string | null
    errorCode: string | null
    errorStack: string | null
    durationMs: number | null
    createdAt: Date | null
  }

  export type AIAgentLogCountAggregateOutputType = {
    id: number
    level: number
    category: number
    message: number
    data: number
    decisionId: number
    errorCode: number
    errorStack: number
    durationMs: number
    createdAt: number
    _all: number
  }


  export type AIAgentLogAvgAggregateInputType = {
    durationMs?: true
  }

  export type AIAgentLogSumAggregateInputType = {
    durationMs?: true
  }

  export type AIAgentLogMinAggregateInputType = {
    id?: true
    level?: true
    category?: true
    message?: true
    decisionId?: true
    errorCode?: true
    errorStack?: true
    durationMs?: true
    createdAt?: true
  }

  export type AIAgentLogMaxAggregateInputType = {
    id?: true
    level?: true
    category?: true
    message?: true
    decisionId?: true
    errorCode?: true
    errorStack?: true
    durationMs?: true
    createdAt?: true
  }

  export type AIAgentLogCountAggregateInputType = {
    id?: true
    level?: true
    category?: true
    message?: true
    data?: true
    decisionId?: true
    errorCode?: true
    errorStack?: true
    durationMs?: true
    createdAt?: true
    _all?: true
  }

  export type AIAgentLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIAgentLog to aggregate.
     */
    where?: AIAgentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIAgentLogs to fetch.
     */
    orderBy?: AIAgentLogOrderByWithRelationInput | AIAgentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIAgentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIAgentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIAgentLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIAgentLogs
    **/
    _count?: true | AIAgentLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIAgentLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIAgentLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIAgentLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIAgentLogMaxAggregateInputType
  }

  export type GetAIAgentLogAggregateType<T extends AIAgentLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAIAgentLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIAgentLog[P]>
      : GetScalarType<T[P], AggregateAIAgentLog[P]>
  }




  export type AIAgentLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIAgentLogWhereInput
    orderBy?: AIAgentLogOrderByWithAggregationInput | AIAgentLogOrderByWithAggregationInput[]
    by: AIAgentLogScalarFieldEnum[] | AIAgentLogScalarFieldEnum
    having?: AIAgentLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIAgentLogCountAggregateInputType | true
    _avg?: AIAgentLogAvgAggregateInputType
    _sum?: AIAgentLogSumAggregateInputType
    _min?: AIAgentLogMinAggregateInputType
    _max?: AIAgentLogMaxAggregateInputType
  }

  export type AIAgentLogGroupByOutputType = {
    id: string
    level: $Enums.AILogLevel
    category: string
    message: string
    data: JsonValue | null
    decisionId: string | null
    errorCode: string | null
    errorStack: string | null
    durationMs: number | null
    createdAt: Date
    _count: AIAgentLogCountAggregateOutputType | null
    _avg: AIAgentLogAvgAggregateOutputType | null
    _sum: AIAgentLogSumAggregateOutputType | null
    _min: AIAgentLogMinAggregateOutputType | null
    _max: AIAgentLogMaxAggregateOutputType | null
  }

  type GetAIAgentLogGroupByPayload<T extends AIAgentLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIAgentLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIAgentLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIAgentLogGroupByOutputType[P]>
            : GetScalarType<T[P], AIAgentLogGroupByOutputType[P]>
        }
      >
    >


  export type AIAgentLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    category?: boolean
    message?: boolean
    data?: boolean
    decisionId?: boolean
    errorCode?: boolean
    errorStack?: boolean
    durationMs?: boolean
    createdAt?: boolean
    decision?: boolean | AIAgentLog$decisionArgs<ExtArgs>
  }, ExtArgs["result"]["aIAgentLog"]>

  export type AIAgentLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    category?: boolean
    message?: boolean
    data?: boolean
    decisionId?: boolean
    errorCode?: boolean
    errorStack?: boolean
    durationMs?: boolean
    createdAt?: boolean
    decision?: boolean | AIAgentLog$decisionArgs<ExtArgs>
  }, ExtArgs["result"]["aIAgentLog"]>

  export type AIAgentLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    category?: boolean
    message?: boolean
    data?: boolean
    decisionId?: boolean
    errorCode?: boolean
    errorStack?: boolean
    durationMs?: boolean
    createdAt?: boolean
    decision?: boolean | AIAgentLog$decisionArgs<ExtArgs>
  }, ExtArgs["result"]["aIAgentLog"]>

  export type AIAgentLogSelectScalar = {
    id?: boolean
    level?: boolean
    category?: boolean
    message?: boolean
    data?: boolean
    decisionId?: boolean
    errorCode?: boolean
    errorStack?: boolean
    durationMs?: boolean
    createdAt?: boolean
  }

  export type AIAgentLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "level" | "category" | "message" | "data" | "decisionId" | "errorCode" | "errorStack" | "durationMs" | "createdAt", ExtArgs["result"]["aIAgentLog"]>
  export type AIAgentLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    decision?: boolean | AIAgentLog$decisionArgs<ExtArgs>
  }
  export type AIAgentLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    decision?: boolean | AIAgentLog$decisionArgs<ExtArgs>
  }
  export type AIAgentLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    decision?: boolean | AIAgentLog$decisionArgs<ExtArgs>
  }

  export type $AIAgentLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIAgentLog"
    objects: {
      decision: Prisma.$AIDecisionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      level: $Enums.AILogLevel
      category: string
      message: string
      data: Prisma.JsonValue | null
      decisionId: string | null
      errorCode: string | null
      errorStack: string | null
      durationMs: number | null
      createdAt: Date
    }, ExtArgs["result"]["aIAgentLog"]>
    composites: {}
  }

  type AIAgentLogGetPayload<S extends boolean | null | undefined | AIAgentLogDefaultArgs> = $Result.GetResult<Prisma.$AIAgentLogPayload, S>

  type AIAgentLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIAgentLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIAgentLogCountAggregateInputType | true
    }

  export interface AIAgentLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIAgentLog'], meta: { name: 'AIAgentLog' } }
    /**
     * Find zero or one AIAgentLog that matches the filter.
     * @param {AIAgentLogFindUniqueArgs} args - Arguments to find a AIAgentLog
     * @example
     * // Get one AIAgentLog
     * const aIAgentLog = await prisma.aIAgentLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIAgentLogFindUniqueArgs>(args: SelectSubset<T, AIAgentLogFindUniqueArgs<ExtArgs>>): Prisma__AIAgentLogClient<$Result.GetResult<Prisma.$AIAgentLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIAgentLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIAgentLogFindUniqueOrThrowArgs} args - Arguments to find a AIAgentLog
     * @example
     * // Get one AIAgentLog
     * const aIAgentLog = await prisma.aIAgentLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIAgentLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AIAgentLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIAgentLogClient<$Result.GetResult<Prisma.$AIAgentLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIAgentLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentLogFindFirstArgs} args - Arguments to find a AIAgentLog
     * @example
     * // Get one AIAgentLog
     * const aIAgentLog = await prisma.aIAgentLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIAgentLogFindFirstArgs>(args?: SelectSubset<T, AIAgentLogFindFirstArgs<ExtArgs>>): Prisma__AIAgentLogClient<$Result.GetResult<Prisma.$AIAgentLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIAgentLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentLogFindFirstOrThrowArgs} args - Arguments to find a AIAgentLog
     * @example
     * // Get one AIAgentLog
     * const aIAgentLog = await prisma.aIAgentLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIAgentLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AIAgentLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIAgentLogClient<$Result.GetResult<Prisma.$AIAgentLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIAgentLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIAgentLogs
     * const aIAgentLogs = await prisma.aIAgentLog.findMany()
     * 
     * // Get first 10 AIAgentLogs
     * const aIAgentLogs = await prisma.aIAgentLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIAgentLogWithIdOnly = await prisma.aIAgentLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIAgentLogFindManyArgs>(args?: SelectSubset<T, AIAgentLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIAgentLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIAgentLog.
     * @param {AIAgentLogCreateArgs} args - Arguments to create a AIAgentLog.
     * @example
     * // Create one AIAgentLog
     * const AIAgentLog = await prisma.aIAgentLog.create({
     *   data: {
     *     // ... data to create a AIAgentLog
     *   }
     * })
     * 
     */
    create<T extends AIAgentLogCreateArgs>(args: SelectSubset<T, AIAgentLogCreateArgs<ExtArgs>>): Prisma__AIAgentLogClient<$Result.GetResult<Prisma.$AIAgentLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIAgentLogs.
     * @param {AIAgentLogCreateManyArgs} args - Arguments to create many AIAgentLogs.
     * @example
     * // Create many AIAgentLogs
     * const aIAgentLog = await prisma.aIAgentLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIAgentLogCreateManyArgs>(args?: SelectSubset<T, AIAgentLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIAgentLogs and returns the data saved in the database.
     * @param {AIAgentLogCreateManyAndReturnArgs} args - Arguments to create many AIAgentLogs.
     * @example
     * // Create many AIAgentLogs
     * const aIAgentLog = await prisma.aIAgentLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIAgentLogs and only return the `id`
     * const aIAgentLogWithIdOnly = await prisma.aIAgentLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIAgentLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AIAgentLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIAgentLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIAgentLog.
     * @param {AIAgentLogDeleteArgs} args - Arguments to delete one AIAgentLog.
     * @example
     * // Delete one AIAgentLog
     * const AIAgentLog = await prisma.aIAgentLog.delete({
     *   where: {
     *     // ... filter to delete one AIAgentLog
     *   }
     * })
     * 
     */
    delete<T extends AIAgentLogDeleteArgs>(args: SelectSubset<T, AIAgentLogDeleteArgs<ExtArgs>>): Prisma__AIAgentLogClient<$Result.GetResult<Prisma.$AIAgentLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIAgentLog.
     * @param {AIAgentLogUpdateArgs} args - Arguments to update one AIAgentLog.
     * @example
     * // Update one AIAgentLog
     * const aIAgentLog = await prisma.aIAgentLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIAgentLogUpdateArgs>(args: SelectSubset<T, AIAgentLogUpdateArgs<ExtArgs>>): Prisma__AIAgentLogClient<$Result.GetResult<Prisma.$AIAgentLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIAgentLogs.
     * @param {AIAgentLogDeleteManyArgs} args - Arguments to filter AIAgentLogs to delete.
     * @example
     * // Delete a few AIAgentLogs
     * const { count } = await prisma.aIAgentLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIAgentLogDeleteManyArgs>(args?: SelectSubset<T, AIAgentLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIAgentLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIAgentLogs
     * const aIAgentLog = await prisma.aIAgentLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIAgentLogUpdateManyArgs>(args: SelectSubset<T, AIAgentLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIAgentLogs and returns the data updated in the database.
     * @param {AIAgentLogUpdateManyAndReturnArgs} args - Arguments to update many AIAgentLogs.
     * @example
     * // Update many AIAgentLogs
     * const aIAgentLog = await prisma.aIAgentLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIAgentLogs and only return the `id`
     * const aIAgentLogWithIdOnly = await prisma.aIAgentLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIAgentLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AIAgentLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIAgentLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIAgentLog.
     * @param {AIAgentLogUpsertArgs} args - Arguments to update or create a AIAgentLog.
     * @example
     * // Update or create a AIAgentLog
     * const aIAgentLog = await prisma.aIAgentLog.upsert({
     *   create: {
     *     // ... data to create a AIAgentLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIAgentLog we want to update
     *   }
     * })
     */
    upsert<T extends AIAgentLogUpsertArgs>(args: SelectSubset<T, AIAgentLogUpsertArgs<ExtArgs>>): Prisma__AIAgentLogClient<$Result.GetResult<Prisma.$AIAgentLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIAgentLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentLogCountArgs} args - Arguments to filter AIAgentLogs to count.
     * @example
     * // Count the number of AIAgentLogs
     * const count = await prisma.aIAgentLog.count({
     *   where: {
     *     // ... the filter for the AIAgentLogs we want to count
     *   }
     * })
    **/
    count<T extends AIAgentLogCountArgs>(
      args?: Subset<T, AIAgentLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIAgentLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIAgentLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIAgentLogAggregateArgs>(args: Subset<T, AIAgentLogAggregateArgs>): Prisma.PrismaPromise<GetAIAgentLogAggregateType<T>>

    /**
     * Group by AIAgentLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIAgentLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIAgentLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIAgentLogGroupByArgs['orderBy'] }
        : { orderBy?: AIAgentLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIAgentLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIAgentLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIAgentLog model
   */
  readonly fields: AIAgentLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIAgentLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIAgentLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    decision<T extends AIAgentLog$decisionArgs<ExtArgs> = {}>(args?: Subset<T, AIAgentLog$decisionArgs<ExtArgs>>): Prisma__AIDecisionClient<$Result.GetResult<Prisma.$AIDecisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIAgentLog model
   */
  interface AIAgentLogFieldRefs {
    readonly id: FieldRef<"AIAgentLog", 'String'>
    readonly level: FieldRef<"AIAgentLog", 'AILogLevel'>
    readonly category: FieldRef<"AIAgentLog", 'String'>
    readonly message: FieldRef<"AIAgentLog", 'String'>
    readonly data: FieldRef<"AIAgentLog", 'Json'>
    readonly decisionId: FieldRef<"AIAgentLog", 'String'>
    readonly errorCode: FieldRef<"AIAgentLog", 'String'>
    readonly errorStack: FieldRef<"AIAgentLog", 'String'>
    readonly durationMs: FieldRef<"AIAgentLog", 'Int'>
    readonly createdAt: FieldRef<"AIAgentLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIAgentLog findUnique
   */
  export type AIAgentLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentLog
     */
    select?: AIAgentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentLog
     */
    omit?: AIAgentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentLogInclude<ExtArgs> | null
    /**
     * Filter, which AIAgentLog to fetch.
     */
    where: AIAgentLogWhereUniqueInput
  }

  /**
   * AIAgentLog findUniqueOrThrow
   */
  export type AIAgentLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentLog
     */
    select?: AIAgentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentLog
     */
    omit?: AIAgentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentLogInclude<ExtArgs> | null
    /**
     * Filter, which AIAgentLog to fetch.
     */
    where: AIAgentLogWhereUniqueInput
  }

  /**
   * AIAgentLog findFirst
   */
  export type AIAgentLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentLog
     */
    select?: AIAgentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentLog
     */
    omit?: AIAgentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentLogInclude<ExtArgs> | null
    /**
     * Filter, which AIAgentLog to fetch.
     */
    where?: AIAgentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIAgentLogs to fetch.
     */
    orderBy?: AIAgentLogOrderByWithRelationInput | AIAgentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIAgentLogs.
     */
    cursor?: AIAgentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIAgentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIAgentLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIAgentLogs.
     */
    distinct?: AIAgentLogScalarFieldEnum | AIAgentLogScalarFieldEnum[]
  }

  /**
   * AIAgentLog findFirstOrThrow
   */
  export type AIAgentLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentLog
     */
    select?: AIAgentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentLog
     */
    omit?: AIAgentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentLogInclude<ExtArgs> | null
    /**
     * Filter, which AIAgentLog to fetch.
     */
    where?: AIAgentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIAgentLogs to fetch.
     */
    orderBy?: AIAgentLogOrderByWithRelationInput | AIAgentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIAgentLogs.
     */
    cursor?: AIAgentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIAgentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIAgentLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIAgentLogs.
     */
    distinct?: AIAgentLogScalarFieldEnum | AIAgentLogScalarFieldEnum[]
  }

  /**
   * AIAgentLog findMany
   */
  export type AIAgentLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentLog
     */
    select?: AIAgentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentLog
     */
    omit?: AIAgentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentLogInclude<ExtArgs> | null
    /**
     * Filter, which AIAgentLogs to fetch.
     */
    where?: AIAgentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIAgentLogs to fetch.
     */
    orderBy?: AIAgentLogOrderByWithRelationInput | AIAgentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIAgentLogs.
     */
    cursor?: AIAgentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIAgentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIAgentLogs.
     */
    skip?: number
    distinct?: AIAgentLogScalarFieldEnum | AIAgentLogScalarFieldEnum[]
  }

  /**
   * AIAgentLog create
   */
  export type AIAgentLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentLog
     */
    select?: AIAgentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentLog
     */
    omit?: AIAgentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AIAgentLog.
     */
    data: XOR<AIAgentLogCreateInput, AIAgentLogUncheckedCreateInput>
  }

  /**
   * AIAgentLog createMany
   */
  export type AIAgentLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIAgentLogs.
     */
    data: AIAgentLogCreateManyInput | AIAgentLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIAgentLog createManyAndReturn
   */
  export type AIAgentLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentLog
     */
    select?: AIAgentLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentLog
     */
    omit?: AIAgentLogOmit<ExtArgs> | null
    /**
     * The data used to create many AIAgentLogs.
     */
    data: AIAgentLogCreateManyInput | AIAgentLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIAgentLog update
   */
  export type AIAgentLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentLog
     */
    select?: AIAgentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentLog
     */
    omit?: AIAgentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AIAgentLog.
     */
    data: XOR<AIAgentLogUpdateInput, AIAgentLogUncheckedUpdateInput>
    /**
     * Choose, which AIAgentLog to update.
     */
    where: AIAgentLogWhereUniqueInput
  }

  /**
   * AIAgentLog updateMany
   */
  export type AIAgentLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIAgentLogs.
     */
    data: XOR<AIAgentLogUpdateManyMutationInput, AIAgentLogUncheckedUpdateManyInput>
    /**
     * Filter which AIAgentLogs to update
     */
    where?: AIAgentLogWhereInput
    /**
     * Limit how many AIAgentLogs to update.
     */
    limit?: number
  }

  /**
   * AIAgentLog updateManyAndReturn
   */
  export type AIAgentLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentLog
     */
    select?: AIAgentLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentLog
     */
    omit?: AIAgentLogOmit<ExtArgs> | null
    /**
     * The data used to update AIAgentLogs.
     */
    data: XOR<AIAgentLogUpdateManyMutationInput, AIAgentLogUncheckedUpdateManyInput>
    /**
     * Filter which AIAgentLogs to update
     */
    where?: AIAgentLogWhereInput
    /**
     * Limit how many AIAgentLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIAgentLog upsert
   */
  export type AIAgentLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentLog
     */
    select?: AIAgentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentLog
     */
    omit?: AIAgentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AIAgentLog to update in case it exists.
     */
    where: AIAgentLogWhereUniqueInput
    /**
     * In case the AIAgentLog found by the `where` argument doesn't exist, create a new AIAgentLog with this data.
     */
    create: XOR<AIAgentLogCreateInput, AIAgentLogUncheckedCreateInput>
    /**
     * In case the AIAgentLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIAgentLogUpdateInput, AIAgentLogUncheckedUpdateInput>
  }

  /**
   * AIAgentLog delete
   */
  export type AIAgentLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentLog
     */
    select?: AIAgentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentLog
     */
    omit?: AIAgentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentLogInclude<ExtArgs> | null
    /**
     * Filter which AIAgentLog to delete.
     */
    where: AIAgentLogWhereUniqueInput
  }

  /**
   * AIAgentLog deleteMany
   */
  export type AIAgentLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIAgentLogs to delete
     */
    where?: AIAgentLogWhereInput
    /**
     * Limit how many AIAgentLogs to delete.
     */
    limit?: number
  }

  /**
   * AIAgentLog.decision
   */
  export type AIAgentLog$decisionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDecision
     */
    select?: AIDecisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDecision
     */
    omit?: AIDecisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIDecisionInclude<ExtArgs> | null
    where?: AIDecisionWhereInput
  }

  /**
   * AIAgentLog without action
   */
  export type AIAgentLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIAgentLog
     */
    select?: AIAgentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIAgentLog
     */
    omit?: AIAgentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIAgentLogInclude<ExtArgs> | null
  }


  /**
   * Model AIDataSnapshot
   */

  export type AggregateAIDataSnapshot = {
    _count: AIDataSnapshotCountAggregateOutputType | null
    _avg: AIDataSnapshotAvgAggregateOutputType | null
    _sum: AIDataSnapshotSumAggregateOutputType | null
    _min: AIDataSnapshotMinAggregateOutputType | null
    _max: AIDataSnapshotMaxAggregateOutputType | null
  }

  export type AIDataSnapshotAvgAggregateOutputType = {
    totalViews: number | null
    uniqueVisitors: number | null
    bounceRate: number | null
    avgSessionDuration: number | null
    totalInquiries: number | null
    viewingRequests: number | null
    investorLeads: number | null
    rentalLeads: number | null
    conversionRate: number | null
    totalProperties: number | null
    activeListings: number | null
    newListings: number | null
    avgPropertyViews: number | null
    totalBlogs: number | null
    publishedBlogs: number | null
    avgBlogViews: number | null
    organicTraffic: number | null
    avgPosition: number | null
    estimatedLeadValue: number | null
    errorCount: number | null
    brokenLinks: number | null
  }

  export type AIDataSnapshotSumAggregateOutputType = {
    totalViews: number | null
    uniqueVisitors: number | null
    bounceRate: number | null
    avgSessionDuration: number | null
    totalInquiries: number | null
    viewingRequests: number | null
    investorLeads: number | null
    rentalLeads: number | null
    conversionRate: number | null
    totalProperties: number | null
    activeListings: number | null
    newListings: number | null
    avgPropertyViews: number | null
    totalBlogs: number | null
    publishedBlogs: number | null
    avgBlogViews: number | null
    organicTraffic: number | null
    avgPosition: number | null
    estimatedLeadValue: number | null
    errorCount: number | null
    brokenLinks: number | null
  }

  export type AIDataSnapshotMinAggregateOutputType = {
    id: string | null
    snapshotType: string | null
    totalViews: number | null
    uniqueVisitors: number | null
    bounceRate: number | null
    avgSessionDuration: number | null
    totalInquiries: number | null
    viewingRequests: number | null
    investorLeads: number | null
    rentalLeads: number | null
    conversionRate: number | null
    totalProperties: number | null
    activeListings: number | null
    newListings: number | null
    avgPropertyViews: number | null
    totalBlogs: number | null
    publishedBlogs: number | null
    avgBlogViews: number | null
    organicTraffic: number | null
    avgPosition: number | null
    estimatedLeadValue: number | null
    errorCount: number | null
    brokenLinks: number | null
    periodStart: Date | null
    periodEnd: Date | null
    createdAt: Date | null
  }

  export type AIDataSnapshotMaxAggregateOutputType = {
    id: string | null
    snapshotType: string | null
    totalViews: number | null
    uniqueVisitors: number | null
    bounceRate: number | null
    avgSessionDuration: number | null
    totalInquiries: number | null
    viewingRequests: number | null
    investorLeads: number | null
    rentalLeads: number | null
    conversionRate: number | null
    totalProperties: number | null
    activeListings: number | null
    newListings: number | null
    avgPropertyViews: number | null
    totalBlogs: number | null
    publishedBlogs: number | null
    avgBlogViews: number | null
    organicTraffic: number | null
    avgPosition: number | null
    estimatedLeadValue: number | null
    errorCount: number | null
    brokenLinks: number | null
    periodStart: Date | null
    periodEnd: Date | null
    createdAt: Date | null
  }

  export type AIDataSnapshotCountAggregateOutputType = {
    id: number
    snapshotType: number
    totalViews: number
    uniqueVisitors: number
    bounceRate: number
    avgSessionDuration: number
    totalInquiries: number
    viewingRequests: number
    investorLeads: number
    rentalLeads: number
    conversionRate: number
    totalProperties: number
    activeListings: number
    newListings: number
    avgPropertyViews: number
    totalBlogs: number
    publishedBlogs: number
    avgBlogViews: number
    organicTraffic: number
    topKeywords: number
    avgPosition: number
    estimatedLeadValue: number
    errorCount: number
    slowPages: number
    brokenLinks: number
    rawData: number
    periodStart: number
    periodEnd: number
    createdAt: number
    _all: number
  }


  export type AIDataSnapshotAvgAggregateInputType = {
    totalViews?: true
    uniqueVisitors?: true
    bounceRate?: true
    avgSessionDuration?: true
    totalInquiries?: true
    viewingRequests?: true
    investorLeads?: true
    rentalLeads?: true
    conversionRate?: true
    totalProperties?: true
    activeListings?: true
    newListings?: true
    avgPropertyViews?: true
    totalBlogs?: true
    publishedBlogs?: true
    avgBlogViews?: true
    organicTraffic?: true
    avgPosition?: true
    estimatedLeadValue?: true
    errorCount?: true
    brokenLinks?: true
  }

  export type AIDataSnapshotSumAggregateInputType = {
    totalViews?: true
    uniqueVisitors?: true
    bounceRate?: true
    avgSessionDuration?: true
    totalInquiries?: true
    viewingRequests?: true
    investorLeads?: true
    rentalLeads?: true
    conversionRate?: true
    totalProperties?: true
    activeListings?: true
    newListings?: true
    avgPropertyViews?: true
    totalBlogs?: true
    publishedBlogs?: true
    avgBlogViews?: true
    organicTraffic?: true
    avgPosition?: true
    estimatedLeadValue?: true
    errorCount?: true
    brokenLinks?: true
  }

  export type AIDataSnapshotMinAggregateInputType = {
    id?: true
    snapshotType?: true
    totalViews?: true
    uniqueVisitors?: true
    bounceRate?: true
    avgSessionDuration?: true
    totalInquiries?: true
    viewingRequests?: true
    investorLeads?: true
    rentalLeads?: true
    conversionRate?: true
    totalProperties?: true
    activeListings?: true
    newListings?: true
    avgPropertyViews?: true
    totalBlogs?: true
    publishedBlogs?: true
    avgBlogViews?: true
    organicTraffic?: true
    avgPosition?: true
    estimatedLeadValue?: true
    errorCount?: true
    brokenLinks?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
  }

  export type AIDataSnapshotMaxAggregateInputType = {
    id?: true
    snapshotType?: true
    totalViews?: true
    uniqueVisitors?: true
    bounceRate?: true
    avgSessionDuration?: true
    totalInquiries?: true
    viewingRequests?: true
    investorLeads?: true
    rentalLeads?: true
    conversionRate?: true
    totalProperties?: true
    activeListings?: true
    newListings?: true
    avgPropertyViews?: true
    totalBlogs?: true
    publishedBlogs?: true
    avgBlogViews?: true
    organicTraffic?: true
    avgPosition?: true
    estimatedLeadValue?: true
    errorCount?: true
    brokenLinks?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
  }

  export type AIDataSnapshotCountAggregateInputType = {
    id?: true
    snapshotType?: true
    totalViews?: true
    uniqueVisitors?: true
    bounceRate?: true
    avgSessionDuration?: true
    totalInquiries?: true
    viewingRequests?: true
    investorLeads?: true
    rentalLeads?: true
    conversionRate?: true
    totalProperties?: true
    activeListings?: true
    newListings?: true
    avgPropertyViews?: true
    totalBlogs?: true
    publishedBlogs?: true
    avgBlogViews?: true
    organicTraffic?: true
    topKeywords?: true
    avgPosition?: true
    estimatedLeadValue?: true
    errorCount?: true
    slowPages?: true
    brokenLinks?: true
    rawData?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
    _all?: true
  }

  export type AIDataSnapshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIDataSnapshot to aggregate.
     */
    where?: AIDataSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIDataSnapshots to fetch.
     */
    orderBy?: AIDataSnapshotOrderByWithRelationInput | AIDataSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIDataSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIDataSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIDataSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIDataSnapshots
    **/
    _count?: true | AIDataSnapshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIDataSnapshotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIDataSnapshotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIDataSnapshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIDataSnapshotMaxAggregateInputType
  }

  export type GetAIDataSnapshotAggregateType<T extends AIDataSnapshotAggregateArgs> = {
        [P in keyof T & keyof AggregateAIDataSnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIDataSnapshot[P]>
      : GetScalarType<T[P], AggregateAIDataSnapshot[P]>
  }




  export type AIDataSnapshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIDataSnapshotWhereInput
    orderBy?: AIDataSnapshotOrderByWithAggregationInput | AIDataSnapshotOrderByWithAggregationInput[]
    by: AIDataSnapshotScalarFieldEnum[] | AIDataSnapshotScalarFieldEnum
    having?: AIDataSnapshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIDataSnapshotCountAggregateInputType | true
    _avg?: AIDataSnapshotAvgAggregateInputType
    _sum?: AIDataSnapshotSumAggregateInputType
    _min?: AIDataSnapshotMinAggregateInputType
    _max?: AIDataSnapshotMaxAggregateInputType
  }

  export type AIDataSnapshotGroupByOutputType = {
    id: string
    snapshotType: string
    totalViews: number
    uniqueVisitors: number
    bounceRate: number | null
    avgSessionDuration: number | null
    totalInquiries: number
    viewingRequests: number
    investorLeads: number
    rentalLeads: number
    conversionRate: number | null
    totalProperties: number
    activeListings: number
    newListings: number
    avgPropertyViews: number | null
    totalBlogs: number
    publishedBlogs: number
    avgBlogViews: number | null
    organicTraffic: number | null
    topKeywords: JsonValue | null
    avgPosition: number | null
    estimatedLeadValue: number | null
    errorCount: number
    slowPages: JsonValue | null
    brokenLinks: number
    rawData: JsonValue | null
    periodStart: Date
    periodEnd: Date
    createdAt: Date
    _count: AIDataSnapshotCountAggregateOutputType | null
    _avg: AIDataSnapshotAvgAggregateOutputType | null
    _sum: AIDataSnapshotSumAggregateOutputType | null
    _min: AIDataSnapshotMinAggregateOutputType | null
    _max: AIDataSnapshotMaxAggregateOutputType | null
  }

  type GetAIDataSnapshotGroupByPayload<T extends AIDataSnapshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIDataSnapshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIDataSnapshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIDataSnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], AIDataSnapshotGroupByOutputType[P]>
        }
      >
    >


  export type AIDataSnapshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    snapshotType?: boolean
    totalViews?: boolean
    uniqueVisitors?: boolean
    bounceRate?: boolean
    avgSessionDuration?: boolean
    totalInquiries?: boolean
    viewingRequests?: boolean
    investorLeads?: boolean
    rentalLeads?: boolean
    conversionRate?: boolean
    totalProperties?: boolean
    activeListings?: boolean
    newListings?: boolean
    avgPropertyViews?: boolean
    totalBlogs?: boolean
    publishedBlogs?: boolean
    avgBlogViews?: boolean
    organicTraffic?: boolean
    topKeywords?: boolean
    avgPosition?: boolean
    estimatedLeadValue?: boolean
    errorCount?: boolean
    slowPages?: boolean
    brokenLinks?: boolean
    rawData?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aIDataSnapshot"]>

  export type AIDataSnapshotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    snapshotType?: boolean
    totalViews?: boolean
    uniqueVisitors?: boolean
    bounceRate?: boolean
    avgSessionDuration?: boolean
    totalInquiries?: boolean
    viewingRequests?: boolean
    investorLeads?: boolean
    rentalLeads?: boolean
    conversionRate?: boolean
    totalProperties?: boolean
    activeListings?: boolean
    newListings?: boolean
    avgPropertyViews?: boolean
    totalBlogs?: boolean
    publishedBlogs?: boolean
    avgBlogViews?: boolean
    organicTraffic?: boolean
    topKeywords?: boolean
    avgPosition?: boolean
    estimatedLeadValue?: boolean
    errorCount?: boolean
    slowPages?: boolean
    brokenLinks?: boolean
    rawData?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aIDataSnapshot"]>

  export type AIDataSnapshotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    snapshotType?: boolean
    totalViews?: boolean
    uniqueVisitors?: boolean
    bounceRate?: boolean
    avgSessionDuration?: boolean
    totalInquiries?: boolean
    viewingRequests?: boolean
    investorLeads?: boolean
    rentalLeads?: boolean
    conversionRate?: boolean
    totalProperties?: boolean
    activeListings?: boolean
    newListings?: boolean
    avgPropertyViews?: boolean
    totalBlogs?: boolean
    publishedBlogs?: boolean
    avgBlogViews?: boolean
    organicTraffic?: boolean
    topKeywords?: boolean
    avgPosition?: boolean
    estimatedLeadValue?: boolean
    errorCount?: boolean
    slowPages?: boolean
    brokenLinks?: boolean
    rawData?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aIDataSnapshot"]>

  export type AIDataSnapshotSelectScalar = {
    id?: boolean
    snapshotType?: boolean
    totalViews?: boolean
    uniqueVisitors?: boolean
    bounceRate?: boolean
    avgSessionDuration?: boolean
    totalInquiries?: boolean
    viewingRequests?: boolean
    investorLeads?: boolean
    rentalLeads?: boolean
    conversionRate?: boolean
    totalProperties?: boolean
    activeListings?: boolean
    newListings?: boolean
    avgPropertyViews?: boolean
    totalBlogs?: boolean
    publishedBlogs?: boolean
    avgBlogViews?: boolean
    organicTraffic?: boolean
    topKeywords?: boolean
    avgPosition?: boolean
    estimatedLeadValue?: boolean
    errorCount?: boolean
    slowPages?: boolean
    brokenLinks?: boolean
    rawData?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    createdAt?: boolean
  }

  export type AIDataSnapshotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "snapshotType" | "totalViews" | "uniqueVisitors" | "bounceRate" | "avgSessionDuration" | "totalInquiries" | "viewingRequests" | "investorLeads" | "rentalLeads" | "conversionRate" | "totalProperties" | "activeListings" | "newListings" | "avgPropertyViews" | "totalBlogs" | "publishedBlogs" | "avgBlogViews" | "organicTraffic" | "topKeywords" | "avgPosition" | "estimatedLeadValue" | "errorCount" | "slowPages" | "brokenLinks" | "rawData" | "periodStart" | "periodEnd" | "createdAt", ExtArgs["result"]["aIDataSnapshot"]>

  export type $AIDataSnapshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIDataSnapshot"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      snapshotType: string
      totalViews: number
      uniqueVisitors: number
      bounceRate: number | null
      avgSessionDuration: number | null
      totalInquiries: number
      viewingRequests: number
      investorLeads: number
      rentalLeads: number
      conversionRate: number | null
      totalProperties: number
      activeListings: number
      newListings: number
      avgPropertyViews: number | null
      totalBlogs: number
      publishedBlogs: number
      avgBlogViews: number | null
      organicTraffic: number | null
      topKeywords: Prisma.JsonValue | null
      avgPosition: number | null
      estimatedLeadValue: number | null
      errorCount: number
      slowPages: Prisma.JsonValue | null
      brokenLinks: number
      rawData: Prisma.JsonValue | null
      periodStart: Date
      periodEnd: Date
      createdAt: Date
    }, ExtArgs["result"]["aIDataSnapshot"]>
    composites: {}
  }

  type AIDataSnapshotGetPayload<S extends boolean | null | undefined | AIDataSnapshotDefaultArgs> = $Result.GetResult<Prisma.$AIDataSnapshotPayload, S>

  type AIDataSnapshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIDataSnapshotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIDataSnapshotCountAggregateInputType | true
    }

  export interface AIDataSnapshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIDataSnapshot'], meta: { name: 'AIDataSnapshot' } }
    /**
     * Find zero or one AIDataSnapshot that matches the filter.
     * @param {AIDataSnapshotFindUniqueArgs} args - Arguments to find a AIDataSnapshot
     * @example
     * // Get one AIDataSnapshot
     * const aIDataSnapshot = await prisma.aIDataSnapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIDataSnapshotFindUniqueArgs>(args: SelectSubset<T, AIDataSnapshotFindUniqueArgs<ExtArgs>>): Prisma__AIDataSnapshotClient<$Result.GetResult<Prisma.$AIDataSnapshotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIDataSnapshot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIDataSnapshotFindUniqueOrThrowArgs} args - Arguments to find a AIDataSnapshot
     * @example
     * // Get one AIDataSnapshot
     * const aIDataSnapshot = await prisma.aIDataSnapshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIDataSnapshotFindUniqueOrThrowArgs>(args: SelectSubset<T, AIDataSnapshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIDataSnapshotClient<$Result.GetResult<Prisma.$AIDataSnapshotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIDataSnapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDataSnapshotFindFirstArgs} args - Arguments to find a AIDataSnapshot
     * @example
     * // Get one AIDataSnapshot
     * const aIDataSnapshot = await prisma.aIDataSnapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIDataSnapshotFindFirstArgs>(args?: SelectSubset<T, AIDataSnapshotFindFirstArgs<ExtArgs>>): Prisma__AIDataSnapshotClient<$Result.GetResult<Prisma.$AIDataSnapshotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIDataSnapshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDataSnapshotFindFirstOrThrowArgs} args - Arguments to find a AIDataSnapshot
     * @example
     * // Get one AIDataSnapshot
     * const aIDataSnapshot = await prisma.aIDataSnapshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIDataSnapshotFindFirstOrThrowArgs>(args?: SelectSubset<T, AIDataSnapshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIDataSnapshotClient<$Result.GetResult<Prisma.$AIDataSnapshotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIDataSnapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDataSnapshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIDataSnapshots
     * const aIDataSnapshots = await prisma.aIDataSnapshot.findMany()
     * 
     * // Get first 10 AIDataSnapshots
     * const aIDataSnapshots = await prisma.aIDataSnapshot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIDataSnapshotWithIdOnly = await prisma.aIDataSnapshot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIDataSnapshotFindManyArgs>(args?: SelectSubset<T, AIDataSnapshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIDataSnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIDataSnapshot.
     * @param {AIDataSnapshotCreateArgs} args - Arguments to create a AIDataSnapshot.
     * @example
     * // Create one AIDataSnapshot
     * const AIDataSnapshot = await prisma.aIDataSnapshot.create({
     *   data: {
     *     // ... data to create a AIDataSnapshot
     *   }
     * })
     * 
     */
    create<T extends AIDataSnapshotCreateArgs>(args: SelectSubset<T, AIDataSnapshotCreateArgs<ExtArgs>>): Prisma__AIDataSnapshotClient<$Result.GetResult<Prisma.$AIDataSnapshotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIDataSnapshots.
     * @param {AIDataSnapshotCreateManyArgs} args - Arguments to create many AIDataSnapshots.
     * @example
     * // Create many AIDataSnapshots
     * const aIDataSnapshot = await prisma.aIDataSnapshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIDataSnapshotCreateManyArgs>(args?: SelectSubset<T, AIDataSnapshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIDataSnapshots and returns the data saved in the database.
     * @param {AIDataSnapshotCreateManyAndReturnArgs} args - Arguments to create many AIDataSnapshots.
     * @example
     * // Create many AIDataSnapshots
     * const aIDataSnapshot = await prisma.aIDataSnapshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIDataSnapshots and only return the `id`
     * const aIDataSnapshotWithIdOnly = await prisma.aIDataSnapshot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIDataSnapshotCreateManyAndReturnArgs>(args?: SelectSubset<T, AIDataSnapshotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIDataSnapshotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIDataSnapshot.
     * @param {AIDataSnapshotDeleteArgs} args - Arguments to delete one AIDataSnapshot.
     * @example
     * // Delete one AIDataSnapshot
     * const AIDataSnapshot = await prisma.aIDataSnapshot.delete({
     *   where: {
     *     // ... filter to delete one AIDataSnapshot
     *   }
     * })
     * 
     */
    delete<T extends AIDataSnapshotDeleteArgs>(args: SelectSubset<T, AIDataSnapshotDeleteArgs<ExtArgs>>): Prisma__AIDataSnapshotClient<$Result.GetResult<Prisma.$AIDataSnapshotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIDataSnapshot.
     * @param {AIDataSnapshotUpdateArgs} args - Arguments to update one AIDataSnapshot.
     * @example
     * // Update one AIDataSnapshot
     * const aIDataSnapshot = await prisma.aIDataSnapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIDataSnapshotUpdateArgs>(args: SelectSubset<T, AIDataSnapshotUpdateArgs<ExtArgs>>): Prisma__AIDataSnapshotClient<$Result.GetResult<Prisma.$AIDataSnapshotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIDataSnapshots.
     * @param {AIDataSnapshotDeleteManyArgs} args - Arguments to filter AIDataSnapshots to delete.
     * @example
     * // Delete a few AIDataSnapshots
     * const { count } = await prisma.aIDataSnapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIDataSnapshotDeleteManyArgs>(args?: SelectSubset<T, AIDataSnapshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIDataSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDataSnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIDataSnapshots
     * const aIDataSnapshot = await prisma.aIDataSnapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIDataSnapshotUpdateManyArgs>(args: SelectSubset<T, AIDataSnapshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIDataSnapshots and returns the data updated in the database.
     * @param {AIDataSnapshotUpdateManyAndReturnArgs} args - Arguments to update many AIDataSnapshots.
     * @example
     * // Update many AIDataSnapshots
     * const aIDataSnapshot = await prisma.aIDataSnapshot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIDataSnapshots and only return the `id`
     * const aIDataSnapshotWithIdOnly = await prisma.aIDataSnapshot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIDataSnapshotUpdateManyAndReturnArgs>(args: SelectSubset<T, AIDataSnapshotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIDataSnapshotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIDataSnapshot.
     * @param {AIDataSnapshotUpsertArgs} args - Arguments to update or create a AIDataSnapshot.
     * @example
     * // Update or create a AIDataSnapshot
     * const aIDataSnapshot = await prisma.aIDataSnapshot.upsert({
     *   create: {
     *     // ... data to create a AIDataSnapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIDataSnapshot we want to update
     *   }
     * })
     */
    upsert<T extends AIDataSnapshotUpsertArgs>(args: SelectSubset<T, AIDataSnapshotUpsertArgs<ExtArgs>>): Prisma__AIDataSnapshotClient<$Result.GetResult<Prisma.$AIDataSnapshotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIDataSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDataSnapshotCountArgs} args - Arguments to filter AIDataSnapshots to count.
     * @example
     * // Count the number of AIDataSnapshots
     * const count = await prisma.aIDataSnapshot.count({
     *   where: {
     *     // ... the filter for the AIDataSnapshots we want to count
     *   }
     * })
    **/
    count<T extends AIDataSnapshotCountArgs>(
      args?: Subset<T, AIDataSnapshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIDataSnapshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIDataSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDataSnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIDataSnapshotAggregateArgs>(args: Subset<T, AIDataSnapshotAggregateArgs>): Prisma.PrismaPromise<GetAIDataSnapshotAggregateType<T>>

    /**
     * Group by AIDataSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIDataSnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIDataSnapshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIDataSnapshotGroupByArgs['orderBy'] }
        : { orderBy?: AIDataSnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIDataSnapshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIDataSnapshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIDataSnapshot model
   */
  readonly fields: AIDataSnapshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIDataSnapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIDataSnapshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIDataSnapshot model
   */
  interface AIDataSnapshotFieldRefs {
    readonly id: FieldRef<"AIDataSnapshot", 'String'>
    readonly snapshotType: FieldRef<"AIDataSnapshot", 'String'>
    readonly totalViews: FieldRef<"AIDataSnapshot", 'Int'>
    readonly uniqueVisitors: FieldRef<"AIDataSnapshot", 'Int'>
    readonly bounceRate: FieldRef<"AIDataSnapshot", 'Float'>
    readonly avgSessionDuration: FieldRef<"AIDataSnapshot", 'Float'>
    readonly totalInquiries: FieldRef<"AIDataSnapshot", 'Int'>
    readonly viewingRequests: FieldRef<"AIDataSnapshot", 'Int'>
    readonly investorLeads: FieldRef<"AIDataSnapshot", 'Int'>
    readonly rentalLeads: FieldRef<"AIDataSnapshot", 'Int'>
    readonly conversionRate: FieldRef<"AIDataSnapshot", 'Float'>
    readonly totalProperties: FieldRef<"AIDataSnapshot", 'Int'>
    readonly activeListings: FieldRef<"AIDataSnapshot", 'Int'>
    readonly newListings: FieldRef<"AIDataSnapshot", 'Int'>
    readonly avgPropertyViews: FieldRef<"AIDataSnapshot", 'Float'>
    readonly totalBlogs: FieldRef<"AIDataSnapshot", 'Int'>
    readonly publishedBlogs: FieldRef<"AIDataSnapshot", 'Int'>
    readonly avgBlogViews: FieldRef<"AIDataSnapshot", 'Float'>
    readonly organicTraffic: FieldRef<"AIDataSnapshot", 'Int'>
    readonly topKeywords: FieldRef<"AIDataSnapshot", 'Json'>
    readonly avgPosition: FieldRef<"AIDataSnapshot", 'Float'>
    readonly estimatedLeadValue: FieldRef<"AIDataSnapshot", 'Float'>
    readonly errorCount: FieldRef<"AIDataSnapshot", 'Int'>
    readonly slowPages: FieldRef<"AIDataSnapshot", 'Json'>
    readonly brokenLinks: FieldRef<"AIDataSnapshot", 'Int'>
    readonly rawData: FieldRef<"AIDataSnapshot", 'Json'>
    readonly periodStart: FieldRef<"AIDataSnapshot", 'DateTime'>
    readonly periodEnd: FieldRef<"AIDataSnapshot", 'DateTime'>
    readonly createdAt: FieldRef<"AIDataSnapshot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIDataSnapshot findUnique
   */
  export type AIDataSnapshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDataSnapshot
     */
    select?: AIDataSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDataSnapshot
     */
    omit?: AIDataSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which AIDataSnapshot to fetch.
     */
    where: AIDataSnapshotWhereUniqueInput
  }

  /**
   * AIDataSnapshot findUniqueOrThrow
   */
  export type AIDataSnapshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDataSnapshot
     */
    select?: AIDataSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDataSnapshot
     */
    omit?: AIDataSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which AIDataSnapshot to fetch.
     */
    where: AIDataSnapshotWhereUniqueInput
  }

  /**
   * AIDataSnapshot findFirst
   */
  export type AIDataSnapshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDataSnapshot
     */
    select?: AIDataSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDataSnapshot
     */
    omit?: AIDataSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which AIDataSnapshot to fetch.
     */
    where?: AIDataSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIDataSnapshots to fetch.
     */
    orderBy?: AIDataSnapshotOrderByWithRelationInput | AIDataSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIDataSnapshots.
     */
    cursor?: AIDataSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIDataSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIDataSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIDataSnapshots.
     */
    distinct?: AIDataSnapshotScalarFieldEnum | AIDataSnapshotScalarFieldEnum[]
  }

  /**
   * AIDataSnapshot findFirstOrThrow
   */
  export type AIDataSnapshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDataSnapshot
     */
    select?: AIDataSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDataSnapshot
     */
    omit?: AIDataSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which AIDataSnapshot to fetch.
     */
    where?: AIDataSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIDataSnapshots to fetch.
     */
    orderBy?: AIDataSnapshotOrderByWithRelationInput | AIDataSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIDataSnapshots.
     */
    cursor?: AIDataSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIDataSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIDataSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIDataSnapshots.
     */
    distinct?: AIDataSnapshotScalarFieldEnum | AIDataSnapshotScalarFieldEnum[]
  }

  /**
   * AIDataSnapshot findMany
   */
  export type AIDataSnapshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDataSnapshot
     */
    select?: AIDataSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDataSnapshot
     */
    omit?: AIDataSnapshotOmit<ExtArgs> | null
    /**
     * Filter, which AIDataSnapshots to fetch.
     */
    where?: AIDataSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIDataSnapshots to fetch.
     */
    orderBy?: AIDataSnapshotOrderByWithRelationInput | AIDataSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIDataSnapshots.
     */
    cursor?: AIDataSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIDataSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIDataSnapshots.
     */
    skip?: number
    distinct?: AIDataSnapshotScalarFieldEnum | AIDataSnapshotScalarFieldEnum[]
  }

  /**
   * AIDataSnapshot create
   */
  export type AIDataSnapshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDataSnapshot
     */
    select?: AIDataSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDataSnapshot
     */
    omit?: AIDataSnapshotOmit<ExtArgs> | null
    /**
     * The data needed to create a AIDataSnapshot.
     */
    data: XOR<AIDataSnapshotCreateInput, AIDataSnapshotUncheckedCreateInput>
  }

  /**
   * AIDataSnapshot createMany
   */
  export type AIDataSnapshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIDataSnapshots.
     */
    data: AIDataSnapshotCreateManyInput | AIDataSnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIDataSnapshot createManyAndReturn
   */
  export type AIDataSnapshotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDataSnapshot
     */
    select?: AIDataSnapshotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIDataSnapshot
     */
    omit?: AIDataSnapshotOmit<ExtArgs> | null
    /**
     * The data used to create many AIDataSnapshots.
     */
    data: AIDataSnapshotCreateManyInput | AIDataSnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIDataSnapshot update
   */
  export type AIDataSnapshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDataSnapshot
     */
    select?: AIDataSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDataSnapshot
     */
    omit?: AIDataSnapshotOmit<ExtArgs> | null
    /**
     * The data needed to update a AIDataSnapshot.
     */
    data: XOR<AIDataSnapshotUpdateInput, AIDataSnapshotUncheckedUpdateInput>
    /**
     * Choose, which AIDataSnapshot to update.
     */
    where: AIDataSnapshotWhereUniqueInput
  }

  /**
   * AIDataSnapshot updateMany
   */
  export type AIDataSnapshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIDataSnapshots.
     */
    data: XOR<AIDataSnapshotUpdateManyMutationInput, AIDataSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which AIDataSnapshots to update
     */
    where?: AIDataSnapshotWhereInput
    /**
     * Limit how many AIDataSnapshots to update.
     */
    limit?: number
  }

  /**
   * AIDataSnapshot updateManyAndReturn
   */
  export type AIDataSnapshotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDataSnapshot
     */
    select?: AIDataSnapshotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIDataSnapshot
     */
    omit?: AIDataSnapshotOmit<ExtArgs> | null
    /**
     * The data used to update AIDataSnapshots.
     */
    data: XOR<AIDataSnapshotUpdateManyMutationInput, AIDataSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which AIDataSnapshots to update
     */
    where?: AIDataSnapshotWhereInput
    /**
     * Limit how many AIDataSnapshots to update.
     */
    limit?: number
  }

  /**
   * AIDataSnapshot upsert
   */
  export type AIDataSnapshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDataSnapshot
     */
    select?: AIDataSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDataSnapshot
     */
    omit?: AIDataSnapshotOmit<ExtArgs> | null
    /**
     * The filter to search for the AIDataSnapshot to update in case it exists.
     */
    where: AIDataSnapshotWhereUniqueInput
    /**
     * In case the AIDataSnapshot found by the `where` argument doesn't exist, create a new AIDataSnapshot with this data.
     */
    create: XOR<AIDataSnapshotCreateInput, AIDataSnapshotUncheckedCreateInput>
    /**
     * In case the AIDataSnapshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIDataSnapshotUpdateInput, AIDataSnapshotUncheckedUpdateInput>
  }

  /**
   * AIDataSnapshot delete
   */
  export type AIDataSnapshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDataSnapshot
     */
    select?: AIDataSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDataSnapshot
     */
    omit?: AIDataSnapshotOmit<ExtArgs> | null
    /**
     * Filter which AIDataSnapshot to delete.
     */
    where: AIDataSnapshotWhereUniqueInput
  }

  /**
   * AIDataSnapshot deleteMany
   */
  export type AIDataSnapshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIDataSnapshots to delete
     */
    where?: AIDataSnapshotWhereInput
    /**
     * Limit how many AIDataSnapshots to delete.
     */
    limit?: number
  }

  /**
   * AIDataSnapshot without action
   */
  export type AIDataSnapshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIDataSnapshot
     */
    select?: AIDataSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIDataSnapshot
     */
    omit?: AIDataSnapshotOmit<ExtArgs> | null
  }


  /**
   * Model AIOpportunity
   */

  export type AggregateAIOpportunity = {
    _count: AIOpportunityCountAggregateOutputType | null
    _avg: AIOpportunityAvgAggregateOutputType | null
    _sum: AIOpportunitySumAggregateOutputType | null
    _min: AIOpportunityMinAggregateOutputType | null
    _max: AIOpportunityMaxAggregateOutputType | null
  }

  export type AIOpportunityAvgAggregateOutputType = {
    priority: number | null
    potentialRevenue: number | null
    potentialLeads: number | null
  }

  export type AIOpportunitySumAggregateOutputType = {
    priority: number | null
    potentialRevenue: number | null
    potentialLeads: number | null
  }

  export type AIOpportunityMinAggregateOutputType = {
    id: string | null
    type: string | null
    subType: string | null
    title: string | null
    description: string | null
    trigger: string | null
    priority: number | null
    estimatedEffort: string | null
    estimatedImpact: string | null
    potentialRevenue: number | null
    potentialLeads: number | null
    status: $Enums.AIOpportunityStatus | null
    decisionId: string | null
    identifiedAt: Date | null
    addressedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIOpportunityMaxAggregateOutputType = {
    id: string | null
    type: string | null
    subType: string | null
    title: string | null
    description: string | null
    trigger: string | null
    priority: number | null
    estimatedEffort: string | null
    estimatedImpact: string | null
    potentialRevenue: number | null
    potentialLeads: number | null
    status: $Enums.AIOpportunityStatus | null
    decisionId: string | null
    identifiedAt: Date | null
    addressedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIOpportunityCountAggregateOutputType = {
    id: number
    type: number
    subType: number
    title: number
    description: number
    trigger: number
    priority: number
    estimatedEffort: number
    estimatedImpact: number
    potentialRevenue: number
    potentialLeads: number
    status: number
    decisionId: number
    identifiedAt: number
    addressedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AIOpportunityAvgAggregateInputType = {
    priority?: true
    potentialRevenue?: true
    potentialLeads?: true
  }

  export type AIOpportunitySumAggregateInputType = {
    priority?: true
    potentialRevenue?: true
    potentialLeads?: true
  }

  export type AIOpportunityMinAggregateInputType = {
    id?: true
    type?: true
    subType?: true
    title?: true
    description?: true
    trigger?: true
    priority?: true
    estimatedEffort?: true
    estimatedImpact?: true
    potentialRevenue?: true
    potentialLeads?: true
    status?: true
    decisionId?: true
    identifiedAt?: true
    addressedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIOpportunityMaxAggregateInputType = {
    id?: true
    type?: true
    subType?: true
    title?: true
    description?: true
    trigger?: true
    priority?: true
    estimatedEffort?: true
    estimatedImpact?: true
    potentialRevenue?: true
    potentialLeads?: true
    status?: true
    decisionId?: true
    identifiedAt?: true
    addressedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIOpportunityCountAggregateInputType = {
    id?: true
    type?: true
    subType?: true
    title?: true
    description?: true
    trigger?: true
    priority?: true
    estimatedEffort?: true
    estimatedImpact?: true
    potentialRevenue?: true
    potentialLeads?: true
    status?: true
    decisionId?: true
    identifiedAt?: true
    addressedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AIOpportunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIOpportunity to aggregate.
     */
    where?: AIOpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIOpportunities to fetch.
     */
    orderBy?: AIOpportunityOrderByWithRelationInput | AIOpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIOpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIOpportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIOpportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIOpportunities
    **/
    _count?: true | AIOpportunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIOpportunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIOpportunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIOpportunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIOpportunityMaxAggregateInputType
  }

  export type GetAIOpportunityAggregateType<T extends AIOpportunityAggregateArgs> = {
        [P in keyof T & keyof AggregateAIOpportunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIOpportunity[P]>
      : GetScalarType<T[P], AggregateAIOpportunity[P]>
  }




  export type AIOpportunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIOpportunityWhereInput
    orderBy?: AIOpportunityOrderByWithAggregationInput | AIOpportunityOrderByWithAggregationInput[]
    by: AIOpportunityScalarFieldEnum[] | AIOpportunityScalarFieldEnum
    having?: AIOpportunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIOpportunityCountAggregateInputType | true
    _avg?: AIOpportunityAvgAggregateInputType
    _sum?: AIOpportunitySumAggregateInputType
    _min?: AIOpportunityMinAggregateInputType
    _max?: AIOpportunityMaxAggregateInputType
  }

  export type AIOpportunityGroupByOutputType = {
    id: string
    type: string
    subType: string | null
    title: string
    description: string
    trigger: string
    priority: number
    estimatedEffort: string
    estimatedImpact: string
    potentialRevenue: number | null
    potentialLeads: number | null
    status: $Enums.AIOpportunityStatus
    decisionId: string | null
    identifiedAt: Date
    addressedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AIOpportunityCountAggregateOutputType | null
    _avg: AIOpportunityAvgAggregateOutputType | null
    _sum: AIOpportunitySumAggregateOutputType | null
    _min: AIOpportunityMinAggregateOutputType | null
    _max: AIOpportunityMaxAggregateOutputType | null
  }

  type GetAIOpportunityGroupByPayload<T extends AIOpportunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIOpportunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIOpportunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIOpportunityGroupByOutputType[P]>
            : GetScalarType<T[P], AIOpportunityGroupByOutputType[P]>
        }
      >
    >


  export type AIOpportunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    subType?: boolean
    title?: boolean
    description?: boolean
    trigger?: boolean
    priority?: boolean
    estimatedEffort?: boolean
    estimatedImpact?: boolean
    potentialRevenue?: boolean
    potentialLeads?: boolean
    status?: boolean
    decisionId?: boolean
    identifiedAt?: boolean
    addressedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIOpportunity"]>

  export type AIOpportunitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    subType?: boolean
    title?: boolean
    description?: boolean
    trigger?: boolean
    priority?: boolean
    estimatedEffort?: boolean
    estimatedImpact?: boolean
    potentialRevenue?: boolean
    potentialLeads?: boolean
    status?: boolean
    decisionId?: boolean
    identifiedAt?: boolean
    addressedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIOpportunity"]>

  export type AIOpportunitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    subType?: boolean
    title?: boolean
    description?: boolean
    trigger?: boolean
    priority?: boolean
    estimatedEffort?: boolean
    estimatedImpact?: boolean
    potentialRevenue?: boolean
    potentialLeads?: boolean
    status?: boolean
    decisionId?: boolean
    identifiedAt?: boolean
    addressedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIOpportunity"]>

  export type AIOpportunitySelectScalar = {
    id?: boolean
    type?: boolean
    subType?: boolean
    title?: boolean
    description?: boolean
    trigger?: boolean
    priority?: boolean
    estimatedEffort?: boolean
    estimatedImpact?: boolean
    potentialRevenue?: boolean
    potentialLeads?: boolean
    status?: boolean
    decisionId?: boolean
    identifiedAt?: boolean
    addressedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AIOpportunityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "subType" | "title" | "description" | "trigger" | "priority" | "estimatedEffort" | "estimatedImpact" | "potentialRevenue" | "potentialLeads" | "status" | "decisionId" | "identifiedAt" | "addressedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["aIOpportunity"]>

  export type $AIOpportunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIOpportunity"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      subType: string | null
      title: string
      description: string
      trigger: string
      priority: number
      estimatedEffort: string
      estimatedImpact: string
      potentialRevenue: number | null
      potentialLeads: number | null
      status: $Enums.AIOpportunityStatus
      decisionId: string | null
      identifiedAt: Date
      addressedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aIOpportunity"]>
    composites: {}
  }

  type AIOpportunityGetPayload<S extends boolean | null | undefined | AIOpportunityDefaultArgs> = $Result.GetResult<Prisma.$AIOpportunityPayload, S>

  type AIOpportunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIOpportunityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIOpportunityCountAggregateInputType | true
    }

  export interface AIOpportunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIOpportunity'], meta: { name: 'AIOpportunity' } }
    /**
     * Find zero or one AIOpportunity that matches the filter.
     * @param {AIOpportunityFindUniqueArgs} args - Arguments to find a AIOpportunity
     * @example
     * // Get one AIOpportunity
     * const aIOpportunity = await prisma.aIOpportunity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIOpportunityFindUniqueArgs>(args: SelectSubset<T, AIOpportunityFindUniqueArgs<ExtArgs>>): Prisma__AIOpportunityClient<$Result.GetResult<Prisma.$AIOpportunityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIOpportunity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIOpportunityFindUniqueOrThrowArgs} args - Arguments to find a AIOpportunity
     * @example
     * // Get one AIOpportunity
     * const aIOpportunity = await prisma.aIOpportunity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIOpportunityFindUniqueOrThrowArgs>(args: SelectSubset<T, AIOpportunityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIOpportunityClient<$Result.GetResult<Prisma.$AIOpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIOpportunity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOpportunityFindFirstArgs} args - Arguments to find a AIOpportunity
     * @example
     * // Get one AIOpportunity
     * const aIOpportunity = await prisma.aIOpportunity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIOpportunityFindFirstArgs>(args?: SelectSubset<T, AIOpportunityFindFirstArgs<ExtArgs>>): Prisma__AIOpportunityClient<$Result.GetResult<Prisma.$AIOpportunityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIOpportunity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOpportunityFindFirstOrThrowArgs} args - Arguments to find a AIOpportunity
     * @example
     * // Get one AIOpportunity
     * const aIOpportunity = await prisma.aIOpportunity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIOpportunityFindFirstOrThrowArgs>(args?: SelectSubset<T, AIOpportunityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIOpportunityClient<$Result.GetResult<Prisma.$AIOpportunityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIOpportunities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOpportunityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIOpportunities
     * const aIOpportunities = await prisma.aIOpportunity.findMany()
     * 
     * // Get first 10 AIOpportunities
     * const aIOpportunities = await prisma.aIOpportunity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIOpportunityWithIdOnly = await prisma.aIOpportunity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIOpportunityFindManyArgs>(args?: SelectSubset<T, AIOpportunityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIOpportunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIOpportunity.
     * @param {AIOpportunityCreateArgs} args - Arguments to create a AIOpportunity.
     * @example
     * // Create one AIOpportunity
     * const AIOpportunity = await prisma.aIOpportunity.create({
     *   data: {
     *     // ... data to create a AIOpportunity
     *   }
     * })
     * 
     */
    create<T extends AIOpportunityCreateArgs>(args: SelectSubset<T, AIOpportunityCreateArgs<ExtArgs>>): Prisma__AIOpportunityClient<$Result.GetResult<Prisma.$AIOpportunityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIOpportunities.
     * @param {AIOpportunityCreateManyArgs} args - Arguments to create many AIOpportunities.
     * @example
     * // Create many AIOpportunities
     * const aIOpportunity = await prisma.aIOpportunity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIOpportunityCreateManyArgs>(args?: SelectSubset<T, AIOpportunityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIOpportunities and returns the data saved in the database.
     * @param {AIOpportunityCreateManyAndReturnArgs} args - Arguments to create many AIOpportunities.
     * @example
     * // Create many AIOpportunities
     * const aIOpportunity = await prisma.aIOpportunity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIOpportunities and only return the `id`
     * const aIOpportunityWithIdOnly = await prisma.aIOpportunity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIOpportunityCreateManyAndReturnArgs>(args?: SelectSubset<T, AIOpportunityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIOpportunityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIOpportunity.
     * @param {AIOpportunityDeleteArgs} args - Arguments to delete one AIOpportunity.
     * @example
     * // Delete one AIOpportunity
     * const AIOpportunity = await prisma.aIOpportunity.delete({
     *   where: {
     *     // ... filter to delete one AIOpportunity
     *   }
     * })
     * 
     */
    delete<T extends AIOpportunityDeleteArgs>(args: SelectSubset<T, AIOpportunityDeleteArgs<ExtArgs>>): Prisma__AIOpportunityClient<$Result.GetResult<Prisma.$AIOpportunityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIOpportunity.
     * @param {AIOpportunityUpdateArgs} args - Arguments to update one AIOpportunity.
     * @example
     * // Update one AIOpportunity
     * const aIOpportunity = await prisma.aIOpportunity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIOpportunityUpdateArgs>(args: SelectSubset<T, AIOpportunityUpdateArgs<ExtArgs>>): Prisma__AIOpportunityClient<$Result.GetResult<Prisma.$AIOpportunityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIOpportunities.
     * @param {AIOpportunityDeleteManyArgs} args - Arguments to filter AIOpportunities to delete.
     * @example
     * // Delete a few AIOpportunities
     * const { count } = await prisma.aIOpportunity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIOpportunityDeleteManyArgs>(args?: SelectSubset<T, AIOpportunityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIOpportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOpportunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIOpportunities
     * const aIOpportunity = await prisma.aIOpportunity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIOpportunityUpdateManyArgs>(args: SelectSubset<T, AIOpportunityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIOpportunities and returns the data updated in the database.
     * @param {AIOpportunityUpdateManyAndReturnArgs} args - Arguments to update many AIOpportunities.
     * @example
     * // Update many AIOpportunities
     * const aIOpportunity = await prisma.aIOpportunity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIOpportunities and only return the `id`
     * const aIOpportunityWithIdOnly = await prisma.aIOpportunity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIOpportunityUpdateManyAndReturnArgs>(args: SelectSubset<T, AIOpportunityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIOpportunityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIOpportunity.
     * @param {AIOpportunityUpsertArgs} args - Arguments to update or create a AIOpportunity.
     * @example
     * // Update or create a AIOpportunity
     * const aIOpportunity = await prisma.aIOpportunity.upsert({
     *   create: {
     *     // ... data to create a AIOpportunity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIOpportunity we want to update
     *   }
     * })
     */
    upsert<T extends AIOpportunityUpsertArgs>(args: SelectSubset<T, AIOpportunityUpsertArgs<ExtArgs>>): Prisma__AIOpportunityClient<$Result.GetResult<Prisma.$AIOpportunityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIOpportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOpportunityCountArgs} args - Arguments to filter AIOpportunities to count.
     * @example
     * // Count the number of AIOpportunities
     * const count = await prisma.aIOpportunity.count({
     *   where: {
     *     // ... the filter for the AIOpportunities we want to count
     *   }
     * })
    **/
    count<T extends AIOpportunityCountArgs>(
      args?: Subset<T, AIOpportunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIOpportunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIOpportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOpportunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIOpportunityAggregateArgs>(args: Subset<T, AIOpportunityAggregateArgs>): Prisma.PrismaPromise<GetAIOpportunityAggregateType<T>>

    /**
     * Group by AIOpportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIOpportunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIOpportunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIOpportunityGroupByArgs['orderBy'] }
        : { orderBy?: AIOpportunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIOpportunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIOpportunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIOpportunity model
   */
  readonly fields: AIOpportunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIOpportunity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIOpportunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIOpportunity model
   */
  interface AIOpportunityFieldRefs {
    readonly id: FieldRef<"AIOpportunity", 'String'>
    readonly type: FieldRef<"AIOpportunity", 'String'>
    readonly subType: FieldRef<"AIOpportunity", 'String'>
    readonly title: FieldRef<"AIOpportunity", 'String'>
    readonly description: FieldRef<"AIOpportunity", 'String'>
    readonly trigger: FieldRef<"AIOpportunity", 'String'>
    readonly priority: FieldRef<"AIOpportunity", 'Int'>
    readonly estimatedEffort: FieldRef<"AIOpportunity", 'String'>
    readonly estimatedImpact: FieldRef<"AIOpportunity", 'String'>
    readonly potentialRevenue: FieldRef<"AIOpportunity", 'Float'>
    readonly potentialLeads: FieldRef<"AIOpportunity", 'Int'>
    readonly status: FieldRef<"AIOpportunity", 'AIOpportunityStatus'>
    readonly decisionId: FieldRef<"AIOpportunity", 'String'>
    readonly identifiedAt: FieldRef<"AIOpportunity", 'DateTime'>
    readonly addressedAt: FieldRef<"AIOpportunity", 'DateTime'>
    readonly createdAt: FieldRef<"AIOpportunity", 'DateTime'>
    readonly updatedAt: FieldRef<"AIOpportunity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIOpportunity findUnique
   */
  export type AIOpportunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOpportunity
     */
    select?: AIOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOpportunity
     */
    omit?: AIOpportunityOmit<ExtArgs> | null
    /**
     * Filter, which AIOpportunity to fetch.
     */
    where: AIOpportunityWhereUniqueInput
  }

  /**
   * AIOpportunity findUniqueOrThrow
   */
  export type AIOpportunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOpportunity
     */
    select?: AIOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOpportunity
     */
    omit?: AIOpportunityOmit<ExtArgs> | null
    /**
     * Filter, which AIOpportunity to fetch.
     */
    where: AIOpportunityWhereUniqueInput
  }

  /**
   * AIOpportunity findFirst
   */
  export type AIOpportunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOpportunity
     */
    select?: AIOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOpportunity
     */
    omit?: AIOpportunityOmit<ExtArgs> | null
    /**
     * Filter, which AIOpportunity to fetch.
     */
    where?: AIOpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIOpportunities to fetch.
     */
    orderBy?: AIOpportunityOrderByWithRelationInput | AIOpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIOpportunities.
     */
    cursor?: AIOpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIOpportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIOpportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIOpportunities.
     */
    distinct?: AIOpportunityScalarFieldEnum | AIOpportunityScalarFieldEnum[]
  }

  /**
   * AIOpportunity findFirstOrThrow
   */
  export type AIOpportunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOpportunity
     */
    select?: AIOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOpportunity
     */
    omit?: AIOpportunityOmit<ExtArgs> | null
    /**
     * Filter, which AIOpportunity to fetch.
     */
    where?: AIOpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIOpportunities to fetch.
     */
    orderBy?: AIOpportunityOrderByWithRelationInput | AIOpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIOpportunities.
     */
    cursor?: AIOpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIOpportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIOpportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIOpportunities.
     */
    distinct?: AIOpportunityScalarFieldEnum | AIOpportunityScalarFieldEnum[]
  }

  /**
   * AIOpportunity findMany
   */
  export type AIOpportunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOpportunity
     */
    select?: AIOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOpportunity
     */
    omit?: AIOpportunityOmit<ExtArgs> | null
    /**
     * Filter, which AIOpportunities to fetch.
     */
    where?: AIOpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIOpportunities to fetch.
     */
    orderBy?: AIOpportunityOrderByWithRelationInput | AIOpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIOpportunities.
     */
    cursor?: AIOpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIOpportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIOpportunities.
     */
    skip?: number
    distinct?: AIOpportunityScalarFieldEnum | AIOpportunityScalarFieldEnum[]
  }

  /**
   * AIOpportunity create
   */
  export type AIOpportunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOpportunity
     */
    select?: AIOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOpportunity
     */
    omit?: AIOpportunityOmit<ExtArgs> | null
    /**
     * The data needed to create a AIOpportunity.
     */
    data: XOR<AIOpportunityCreateInput, AIOpportunityUncheckedCreateInput>
  }

  /**
   * AIOpportunity createMany
   */
  export type AIOpportunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIOpportunities.
     */
    data: AIOpportunityCreateManyInput | AIOpportunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIOpportunity createManyAndReturn
   */
  export type AIOpportunityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOpportunity
     */
    select?: AIOpportunitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIOpportunity
     */
    omit?: AIOpportunityOmit<ExtArgs> | null
    /**
     * The data used to create many AIOpportunities.
     */
    data: AIOpportunityCreateManyInput | AIOpportunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIOpportunity update
   */
  export type AIOpportunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOpportunity
     */
    select?: AIOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOpportunity
     */
    omit?: AIOpportunityOmit<ExtArgs> | null
    /**
     * The data needed to update a AIOpportunity.
     */
    data: XOR<AIOpportunityUpdateInput, AIOpportunityUncheckedUpdateInput>
    /**
     * Choose, which AIOpportunity to update.
     */
    where: AIOpportunityWhereUniqueInput
  }

  /**
   * AIOpportunity updateMany
   */
  export type AIOpportunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIOpportunities.
     */
    data: XOR<AIOpportunityUpdateManyMutationInput, AIOpportunityUncheckedUpdateManyInput>
    /**
     * Filter which AIOpportunities to update
     */
    where?: AIOpportunityWhereInput
    /**
     * Limit how many AIOpportunities to update.
     */
    limit?: number
  }

  /**
   * AIOpportunity updateManyAndReturn
   */
  export type AIOpportunityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOpportunity
     */
    select?: AIOpportunitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIOpportunity
     */
    omit?: AIOpportunityOmit<ExtArgs> | null
    /**
     * The data used to update AIOpportunities.
     */
    data: XOR<AIOpportunityUpdateManyMutationInput, AIOpportunityUncheckedUpdateManyInput>
    /**
     * Filter which AIOpportunities to update
     */
    where?: AIOpportunityWhereInput
    /**
     * Limit how many AIOpportunities to update.
     */
    limit?: number
  }

  /**
   * AIOpportunity upsert
   */
  export type AIOpportunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOpportunity
     */
    select?: AIOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOpportunity
     */
    omit?: AIOpportunityOmit<ExtArgs> | null
    /**
     * The filter to search for the AIOpportunity to update in case it exists.
     */
    where: AIOpportunityWhereUniqueInput
    /**
     * In case the AIOpportunity found by the `where` argument doesn't exist, create a new AIOpportunity with this data.
     */
    create: XOR<AIOpportunityCreateInput, AIOpportunityUncheckedCreateInput>
    /**
     * In case the AIOpportunity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIOpportunityUpdateInput, AIOpportunityUncheckedUpdateInput>
  }

  /**
   * AIOpportunity delete
   */
  export type AIOpportunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOpportunity
     */
    select?: AIOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOpportunity
     */
    omit?: AIOpportunityOmit<ExtArgs> | null
    /**
     * Filter which AIOpportunity to delete.
     */
    where: AIOpportunityWhereUniqueInput
  }

  /**
   * AIOpportunity deleteMany
   */
  export type AIOpportunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIOpportunities to delete
     */
    where?: AIOpportunityWhereInput
    /**
     * Limit how many AIOpportunities to delete.
     */
    limit?: number
  }

  /**
   * AIOpportunity without action
   */
  export type AIOpportunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIOpportunity
     */
    select?: AIOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIOpportunity
     */
    omit?: AIOpportunityOmit<ExtArgs> | null
  }


  /**
   * Model AILearning
   */

  export type AggregateAILearning = {
    _count: AILearningCountAggregateOutputType | null
    _avg: AILearningAvgAggregateOutputType | null
    _sum: AILearningSumAggregateOutputType | null
    _min: AILearningMinAggregateOutputType | null
    _max: AILearningMaxAggregateOutputType | null
  }

  export type AILearningAvgAggregateOutputType = {
    confidence: number | null
  }

  export type AILearningSumAggregateOutputType = {
    confidence: number | null
  }

  export type AILearningMinAggregateOutputType = {
    id: string | null
    category: string | null
    insight: string | null
    sourceDecisionId: string | null
    confidence: number | null
    impactArea: string | null
    adjustment: string | null
    validatedBy: string | null
    validatedAt: Date | null
    isValid: boolean | null
    createdAt: Date | null
  }

  export type AILearningMaxAggregateOutputType = {
    id: string | null
    category: string | null
    insight: string | null
    sourceDecisionId: string | null
    confidence: number | null
    impactArea: string | null
    adjustment: string | null
    validatedBy: string | null
    validatedAt: Date | null
    isValid: boolean | null
    createdAt: Date | null
  }

  export type AILearningCountAggregateOutputType = {
    id: number
    category: number
    insight: number
    sourceDecisionId: number
    confidence: number
    impactArea: number
    adjustment: number
    validatedBy: number
    validatedAt: number
    isValid: number
    createdAt: number
    _all: number
  }


  export type AILearningAvgAggregateInputType = {
    confidence?: true
  }

  export type AILearningSumAggregateInputType = {
    confidence?: true
  }

  export type AILearningMinAggregateInputType = {
    id?: true
    category?: true
    insight?: true
    sourceDecisionId?: true
    confidence?: true
    impactArea?: true
    adjustment?: true
    validatedBy?: true
    validatedAt?: true
    isValid?: true
    createdAt?: true
  }

  export type AILearningMaxAggregateInputType = {
    id?: true
    category?: true
    insight?: true
    sourceDecisionId?: true
    confidence?: true
    impactArea?: true
    adjustment?: true
    validatedBy?: true
    validatedAt?: true
    isValid?: true
    createdAt?: true
  }

  export type AILearningCountAggregateInputType = {
    id?: true
    category?: true
    insight?: true
    sourceDecisionId?: true
    confidence?: true
    impactArea?: true
    adjustment?: true
    validatedBy?: true
    validatedAt?: true
    isValid?: true
    createdAt?: true
    _all?: true
  }

  export type AILearningAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AILearning to aggregate.
     */
    where?: AILearningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AILearnings to fetch.
     */
    orderBy?: AILearningOrderByWithRelationInput | AILearningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AILearningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AILearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AILearnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AILearnings
    **/
    _count?: true | AILearningCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AILearningAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AILearningSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AILearningMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AILearningMaxAggregateInputType
  }

  export type GetAILearningAggregateType<T extends AILearningAggregateArgs> = {
        [P in keyof T & keyof AggregateAILearning]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAILearning[P]>
      : GetScalarType<T[P], AggregateAILearning[P]>
  }




  export type AILearningGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AILearningWhereInput
    orderBy?: AILearningOrderByWithAggregationInput | AILearningOrderByWithAggregationInput[]
    by: AILearningScalarFieldEnum[] | AILearningScalarFieldEnum
    having?: AILearningScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AILearningCountAggregateInputType | true
    _avg?: AILearningAvgAggregateInputType
    _sum?: AILearningSumAggregateInputType
    _min?: AILearningMinAggregateInputType
    _max?: AILearningMaxAggregateInputType
  }

  export type AILearningGroupByOutputType = {
    id: string
    category: string
    insight: string
    sourceDecisionId: string | null
    confidence: number
    impactArea: string
    adjustment: string
    validatedBy: string | null
    validatedAt: Date | null
    isValid: boolean
    createdAt: Date
    _count: AILearningCountAggregateOutputType | null
    _avg: AILearningAvgAggregateOutputType | null
    _sum: AILearningSumAggregateOutputType | null
    _min: AILearningMinAggregateOutputType | null
    _max: AILearningMaxAggregateOutputType | null
  }

  type GetAILearningGroupByPayload<T extends AILearningGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AILearningGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AILearningGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AILearningGroupByOutputType[P]>
            : GetScalarType<T[P], AILearningGroupByOutputType[P]>
        }
      >
    >


  export type AILearningSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    insight?: boolean
    sourceDecisionId?: boolean
    confidence?: boolean
    impactArea?: boolean
    adjustment?: boolean
    validatedBy?: boolean
    validatedAt?: boolean
    isValid?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aILearning"]>

  export type AILearningSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    insight?: boolean
    sourceDecisionId?: boolean
    confidence?: boolean
    impactArea?: boolean
    adjustment?: boolean
    validatedBy?: boolean
    validatedAt?: boolean
    isValid?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aILearning"]>

  export type AILearningSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    insight?: boolean
    sourceDecisionId?: boolean
    confidence?: boolean
    impactArea?: boolean
    adjustment?: boolean
    validatedBy?: boolean
    validatedAt?: boolean
    isValid?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aILearning"]>

  export type AILearningSelectScalar = {
    id?: boolean
    category?: boolean
    insight?: boolean
    sourceDecisionId?: boolean
    confidence?: boolean
    impactArea?: boolean
    adjustment?: boolean
    validatedBy?: boolean
    validatedAt?: boolean
    isValid?: boolean
    createdAt?: boolean
  }

  export type AILearningOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category" | "insight" | "sourceDecisionId" | "confidence" | "impactArea" | "adjustment" | "validatedBy" | "validatedAt" | "isValid" | "createdAt", ExtArgs["result"]["aILearning"]>

  export type $AILearningPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AILearning"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      insight: string
      sourceDecisionId: string | null
      confidence: number
      impactArea: string
      adjustment: string
      validatedBy: string | null
      validatedAt: Date | null
      isValid: boolean
      createdAt: Date
    }, ExtArgs["result"]["aILearning"]>
    composites: {}
  }

  type AILearningGetPayload<S extends boolean | null | undefined | AILearningDefaultArgs> = $Result.GetResult<Prisma.$AILearningPayload, S>

  type AILearningCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AILearningFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AILearningCountAggregateInputType | true
    }

  export interface AILearningDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AILearning'], meta: { name: 'AILearning' } }
    /**
     * Find zero or one AILearning that matches the filter.
     * @param {AILearningFindUniqueArgs} args - Arguments to find a AILearning
     * @example
     * // Get one AILearning
     * const aILearning = await prisma.aILearning.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AILearningFindUniqueArgs>(args: SelectSubset<T, AILearningFindUniqueArgs<ExtArgs>>): Prisma__AILearningClient<$Result.GetResult<Prisma.$AILearningPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AILearning that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AILearningFindUniqueOrThrowArgs} args - Arguments to find a AILearning
     * @example
     * // Get one AILearning
     * const aILearning = await prisma.aILearning.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AILearningFindUniqueOrThrowArgs>(args: SelectSubset<T, AILearningFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AILearningClient<$Result.GetResult<Prisma.$AILearningPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AILearning that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AILearningFindFirstArgs} args - Arguments to find a AILearning
     * @example
     * // Get one AILearning
     * const aILearning = await prisma.aILearning.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AILearningFindFirstArgs>(args?: SelectSubset<T, AILearningFindFirstArgs<ExtArgs>>): Prisma__AILearningClient<$Result.GetResult<Prisma.$AILearningPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AILearning that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AILearningFindFirstOrThrowArgs} args - Arguments to find a AILearning
     * @example
     * // Get one AILearning
     * const aILearning = await prisma.aILearning.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AILearningFindFirstOrThrowArgs>(args?: SelectSubset<T, AILearningFindFirstOrThrowArgs<ExtArgs>>): Prisma__AILearningClient<$Result.GetResult<Prisma.$AILearningPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AILearnings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AILearningFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AILearnings
     * const aILearnings = await prisma.aILearning.findMany()
     * 
     * // Get first 10 AILearnings
     * const aILearnings = await prisma.aILearning.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aILearningWithIdOnly = await prisma.aILearning.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AILearningFindManyArgs>(args?: SelectSubset<T, AILearningFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AILearningPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AILearning.
     * @param {AILearningCreateArgs} args - Arguments to create a AILearning.
     * @example
     * // Create one AILearning
     * const AILearning = await prisma.aILearning.create({
     *   data: {
     *     // ... data to create a AILearning
     *   }
     * })
     * 
     */
    create<T extends AILearningCreateArgs>(args: SelectSubset<T, AILearningCreateArgs<ExtArgs>>): Prisma__AILearningClient<$Result.GetResult<Prisma.$AILearningPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AILearnings.
     * @param {AILearningCreateManyArgs} args - Arguments to create many AILearnings.
     * @example
     * // Create many AILearnings
     * const aILearning = await prisma.aILearning.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AILearningCreateManyArgs>(args?: SelectSubset<T, AILearningCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AILearnings and returns the data saved in the database.
     * @param {AILearningCreateManyAndReturnArgs} args - Arguments to create many AILearnings.
     * @example
     * // Create many AILearnings
     * const aILearning = await prisma.aILearning.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AILearnings and only return the `id`
     * const aILearningWithIdOnly = await prisma.aILearning.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AILearningCreateManyAndReturnArgs>(args?: SelectSubset<T, AILearningCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AILearningPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AILearning.
     * @param {AILearningDeleteArgs} args - Arguments to delete one AILearning.
     * @example
     * // Delete one AILearning
     * const AILearning = await prisma.aILearning.delete({
     *   where: {
     *     // ... filter to delete one AILearning
     *   }
     * })
     * 
     */
    delete<T extends AILearningDeleteArgs>(args: SelectSubset<T, AILearningDeleteArgs<ExtArgs>>): Prisma__AILearningClient<$Result.GetResult<Prisma.$AILearningPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AILearning.
     * @param {AILearningUpdateArgs} args - Arguments to update one AILearning.
     * @example
     * // Update one AILearning
     * const aILearning = await prisma.aILearning.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AILearningUpdateArgs>(args: SelectSubset<T, AILearningUpdateArgs<ExtArgs>>): Prisma__AILearningClient<$Result.GetResult<Prisma.$AILearningPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AILearnings.
     * @param {AILearningDeleteManyArgs} args - Arguments to filter AILearnings to delete.
     * @example
     * // Delete a few AILearnings
     * const { count } = await prisma.aILearning.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AILearningDeleteManyArgs>(args?: SelectSubset<T, AILearningDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AILearnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AILearningUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AILearnings
     * const aILearning = await prisma.aILearning.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AILearningUpdateManyArgs>(args: SelectSubset<T, AILearningUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AILearnings and returns the data updated in the database.
     * @param {AILearningUpdateManyAndReturnArgs} args - Arguments to update many AILearnings.
     * @example
     * // Update many AILearnings
     * const aILearning = await prisma.aILearning.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AILearnings and only return the `id`
     * const aILearningWithIdOnly = await prisma.aILearning.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AILearningUpdateManyAndReturnArgs>(args: SelectSubset<T, AILearningUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AILearningPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AILearning.
     * @param {AILearningUpsertArgs} args - Arguments to update or create a AILearning.
     * @example
     * // Update or create a AILearning
     * const aILearning = await prisma.aILearning.upsert({
     *   create: {
     *     // ... data to create a AILearning
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AILearning we want to update
     *   }
     * })
     */
    upsert<T extends AILearningUpsertArgs>(args: SelectSubset<T, AILearningUpsertArgs<ExtArgs>>): Prisma__AILearningClient<$Result.GetResult<Prisma.$AILearningPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AILearnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AILearningCountArgs} args - Arguments to filter AILearnings to count.
     * @example
     * // Count the number of AILearnings
     * const count = await prisma.aILearning.count({
     *   where: {
     *     // ... the filter for the AILearnings we want to count
     *   }
     * })
    **/
    count<T extends AILearningCountArgs>(
      args?: Subset<T, AILearningCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AILearningCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AILearning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AILearningAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AILearningAggregateArgs>(args: Subset<T, AILearningAggregateArgs>): Prisma.PrismaPromise<GetAILearningAggregateType<T>>

    /**
     * Group by AILearning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AILearningGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AILearningGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AILearningGroupByArgs['orderBy'] }
        : { orderBy?: AILearningGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AILearningGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAILearningGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AILearning model
   */
  readonly fields: AILearningFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AILearning.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AILearningClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AILearning model
   */
  interface AILearningFieldRefs {
    readonly id: FieldRef<"AILearning", 'String'>
    readonly category: FieldRef<"AILearning", 'String'>
    readonly insight: FieldRef<"AILearning", 'String'>
    readonly sourceDecisionId: FieldRef<"AILearning", 'String'>
    readonly confidence: FieldRef<"AILearning", 'Float'>
    readonly impactArea: FieldRef<"AILearning", 'String'>
    readonly adjustment: FieldRef<"AILearning", 'String'>
    readonly validatedBy: FieldRef<"AILearning", 'String'>
    readonly validatedAt: FieldRef<"AILearning", 'DateTime'>
    readonly isValid: FieldRef<"AILearning", 'Boolean'>
    readonly createdAt: FieldRef<"AILearning", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AILearning findUnique
   */
  export type AILearningFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILearning
     */
    select?: AILearningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILearning
     */
    omit?: AILearningOmit<ExtArgs> | null
    /**
     * Filter, which AILearning to fetch.
     */
    where: AILearningWhereUniqueInput
  }

  /**
   * AILearning findUniqueOrThrow
   */
  export type AILearningFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILearning
     */
    select?: AILearningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILearning
     */
    omit?: AILearningOmit<ExtArgs> | null
    /**
     * Filter, which AILearning to fetch.
     */
    where: AILearningWhereUniqueInput
  }

  /**
   * AILearning findFirst
   */
  export type AILearningFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILearning
     */
    select?: AILearningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILearning
     */
    omit?: AILearningOmit<ExtArgs> | null
    /**
     * Filter, which AILearning to fetch.
     */
    where?: AILearningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AILearnings to fetch.
     */
    orderBy?: AILearningOrderByWithRelationInput | AILearningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AILearnings.
     */
    cursor?: AILearningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AILearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AILearnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AILearnings.
     */
    distinct?: AILearningScalarFieldEnum | AILearningScalarFieldEnum[]
  }

  /**
   * AILearning findFirstOrThrow
   */
  export type AILearningFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILearning
     */
    select?: AILearningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILearning
     */
    omit?: AILearningOmit<ExtArgs> | null
    /**
     * Filter, which AILearning to fetch.
     */
    where?: AILearningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AILearnings to fetch.
     */
    orderBy?: AILearningOrderByWithRelationInput | AILearningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AILearnings.
     */
    cursor?: AILearningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AILearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AILearnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AILearnings.
     */
    distinct?: AILearningScalarFieldEnum | AILearningScalarFieldEnum[]
  }

  /**
   * AILearning findMany
   */
  export type AILearningFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILearning
     */
    select?: AILearningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILearning
     */
    omit?: AILearningOmit<ExtArgs> | null
    /**
     * Filter, which AILearnings to fetch.
     */
    where?: AILearningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AILearnings to fetch.
     */
    orderBy?: AILearningOrderByWithRelationInput | AILearningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AILearnings.
     */
    cursor?: AILearningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AILearnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AILearnings.
     */
    skip?: number
    distinct?: AILearningScalarFieldEnum | AILearningScalarFieldEnum[]
  }

  /**
   * AILearning create
   */
  export type AILearningCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILearning
     */
    select?: AILearningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILearning
     */
    omit?: AILearningOmit<ExtArgs> | null
    /**
     * The data needed to create a AILearning.
     */
    data: XOR<AILearningCreateInput, AILearningUncheckedCreateInput>
  }

  /**
   * AILearning createMany
   */
  export type AILearningCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AILearnings.
     */
    data: AILearningCreateManyInput | AILearningCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AILearning createManyAndReturn
   */
  export type AILearningCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILearning
     */
    select?: AILearningSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AILearning
     */
    omit?: AILearningOmit<ExtArgs> | null
    /**
     * The data used to create many AILearnings.
     */
    data: AILearningCreateManyInput | AILearningCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AILearning update
   */
  export type AILearningUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILearning
     */
    select?: AILearningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILearning
     */
    omit?: AILearningOmit<ExtArgs> | null
    /**
     * The data needed to update a AILearning.
     */
    data: XOR<AILearningUpdateInput, AILearningUncheckedUpdateInput>
    /**
     * Choose, which AILearning to update.
     */
    where: AILearningWhereUniqueInput
  }

  /**
   * AILearning updateMany
   */
  export type AILearningUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AILearnings.
     */
    data: XOR<AILearningUpdateManyMutationInput, AILearningUncheckedUpdateManyInput>
    /**
     * Filter which AILearnings to update
     */
    where?: AILearningWhereInput
    /**
     * Limit how many AILearnings to update.
     */
    limit?: number
  }

  /**
   * AILearning updateManyAndReturn
   */
  export type AILearningUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILearning
     */
    select?: AILearningSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AILearning
     */
    omit?: AILearningOmit<ExtArgs> | null
    /**
     * The data used to update AILearnings.
     */
    data: XOR<AILearningUpdateManyMutationInput, AILearningUncheckedUpdateManyInput>
    /**
     * Filter which AILearnings to update
     */
    where?: AILearningWhereInput
    /**
     * Limit how many AILearnings to update.
     */
    limit?: number
  }

  /**
   * AILearning upsert
   */
  export type AILearningUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILearning
     */
    select?: AILearningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILearning
     */
    omit?: AILearningOmit<ExtArgs> | null
    /**
     * The filter to search for the AILearning to update in case it exists.
     */
    where: AILearningWhereUniqueInput
    /**
     * In case the AILearning found by the `where` argument doesn't exist, create a new AILearning with this data.
     */
    create: XOR<AILearningCreateInput, AILearningUncheckedCreateInput>
    /**
     * In case the AILearning was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AILearningUpdateInput, AILearningUncheckedUpdateInput>
  }

  /**
   * AILearning delete
   */
  export type AILearningDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILearning
     */
    select?: AILearningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILearning
     */
    omit?: AILearningOmit<ExtArgs> | null
    /**
     * Filter which AILearning to delete.
     */
    where: AILearningWhereUniqueInput
  }

  /**
   * AILearning deleteMany
   */
  export type AILearningDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AILearnings to delete
     */
    where?: AILearningWhereInput
    /**
     * Limit how many AILearnings to delete.
     */
    limit?: number
  }

  /**
   * AILearning without action
   */
  export type AILearningDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AILearning
     */
    select?: AILearningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AILearning
     */
    omit?: AILearningOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    expiresAt: 'expiresAt',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId',
    impersonatedBy: 'impersonatedBy'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    role: 'role',
    banned: 'banned',
    banReason: 'banReason',
    banExpires: 'banExpires'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const AgentInviteScalarFieldEnum: {
    id: 'id',
    code: 'code',
    email: 'email',
    role: 'role',
    maxUses: 'maxUses',
    usedCount: 'usedCount',
    usedBy: 'usedBy',
    usedAt: 'usedAt',
    expiresAt: 'expiresAt',
    isActive: 'isActive',
    createdBy: 'createdBy',
    note: 'note',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentInviteScalarFieldEnum = (typeof AgentInviteScalarFieldEnum)[keyof typeof AgentInviteScalarFieldEnum]


  export const PropertyScalarFieldEnum: {
    id: 'id',
    listingNumber: 'listingNumber',
    title: 'title',
    slug: 'slug',
    location: 'location',
    price: 'price',
    beds: 'beds',
    baths: 'baths',
    sqft: 'sqft',
    plotSize: 'plotSize',
    type: 'type',
    category: 'category',
    tag: 'tag',
    status: 'status',
    isHighlighted: 'isHighlighted',
    ownershipType: 'ownershipType',
    isResale: 'isResale',
    image: 'image',
    shortDescription: 'shortDescription',
    descriptionParagraphs: 'descriptionParagraphs',
    propertyFeatures: 'propertyFeatures',
    amenities: 'amenities',
    amenitiesWithIcons: 'amenitiesWithIcons',
    content: 'content',
    yearBuilt: 'yearBuilt',
    mapUrl: 'mapUrl',
    monthlyRentalPrice: 'monthlyRentalPrice',
    allowPets: 'allowPets',
    enableDailyRental: 'enableDailyRental',
    maxGuests: 'maxGuests',
    provinceSlug: 'provinceSlug',
    areaSlug: 'areaSlug',
    ownerName: 'ownerName',
    ownerEmail: 'ownerEmail',
    ownerPhone: 'ownerPhone',
    ownerCountryCode: 'ownerCountryCode',
    ownerCompany: 'ownerCompany',
    ownerNotes: 'ownerNotes',
    propertyOwnerId: 'propertyOwnerId',
    bluebookUrl: 'bluebookUrl',
    bluebookHouseId: 'bluebookHouseId',
    commissionRate: 'commissionRate',
    tm30AccommodationId: 'tm30AccommodationId',
    tm30AccommodationName: 'tm30AccommodationName',
    defaultCheckInTime: 'defaultCheckInTime',
    defaultCheckOutTime: 'defaultCheckOutTime',
    defaultPropertyAddress: 'defaultPropertyAddress',
    defaultWifiName: 'defaultWifiName',
    defaultWifiPassword: 'defaultWifiPassword',
    defaultAccessCode: 'defaultAccessCode',
    defaultEmergencyContact: 'defaultEmergencyContact',
    defaultPropertyInstructions: 'defaultPropertyInstructions',
    defaultHouseRules: 'defaultHouseRules',
    latitude: 'latitude',
    longitude: 'longitude',
    beachScore: 'beachScore',
    familyScore: 'familyScore',
    convenienceScore: 'convenienceScore',
    quietnessScore: 'quietnessScore',
    hasSeaView: 'hasSeaView',
    seaViewDirection: 'seaViewDirection',
    seaDistance: 'seaDistance',
    district: 'district',
    poisLastCalculatedAt: 'poisLastCalculatedAt',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


  export const PropertyImageScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    url: 'url',
    position: 'position',
    alt: 'alt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyImageScalarFieldEnum = (typeof PropertyImageScalarFieldEnum)[keyof typeof PropertyImageScalarFieldEnum]


  export const PropertyViewScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    viewedAt: 'viewedAt',
    country: 'country',
    city: 'city',
    ipHash: 'ipHash',
    userAgent: 'userAgent',
    referrer: 'referrer',
    sessionId: 'sessionId'
  };

  export type PropertyViewScalarFieldEnum = (typeof PropertyViewScalarFieldEnum)[keyof typeof PropertyViewScalarFieldEnum]


  export const ViewingRequestScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    requestType: 'requestType',
    viewingDate: 'viewingDate',
    name: 'name',
    email: 'email',
    phone: 'phone',
    countryCode: 'countryCode',
    language: 'language',
    message: 'message',
    offerAmount: 'offerAmount',
    offerCurrency: 'offerCurrency',
    status: 'status',
    confirmedBy: 'confirmedBy',
    confirmedByName: 'confirmedByName',
    confirmedAt: 'confirmedAt',
    completedBy: 'completedBy',
    completedByName: 'completedByName',
    completedAt: 'completedAt',
    cancelledBy: 'cancelledBy',
    cancelledByName: 'cancelledByName',
    cancelledAt: 'cancelledAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ViewingRequestScalarFieldEnum = (typeof ViewingRequestScalarFieldEnum)[keyof typeof ViewingRequestScalarFieldEnum]


  export const InvestorLeadScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    countryCode: 'countryCode',
    currency: 'currency',
    investmentBudget: 'investmentBudget',
    investmentGoal: 'investmentGoal',
    timeline: 'timeline',
    preferredAreas: 'preferredAreas',
    propertyType: 'propertyType',
    experience: 'experience',
    financing: 'financing',
    message: 'message',
    newsletter: 'newsletter',
    status: 'status',
    assignedToId: 'assignedToId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    source: 'source',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvestorLeadScalarFieldEnum = (typeof InvestorLeadScalarFieldEnum)[keyof typeof InvestorLeadScalarFieldEnum]


  export const RentalLeadScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    countryCode: 'countryCode',
    propertyType: 'propertyType',
    bedrooms: 'bedrooms',
    budget: 'budget',
    rentalDuration: 'rentalDuration',
    preferredAreas: 'preferredAreas',
    moveInDate: 'moveInDate',
    furnished: 'furnished',
    pets: 'pets',
    message: 'message',
    newsletter: 'newsletter',
    status: 'status',
    assignedToId: 'assignedToId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    source: 'source',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RentalLeadScalarFieldEnum = (typeof RentalLeadScalarFieldEnum)[keyof typeof RentalLeadScalarFieldEnum]


  export const BlogScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    excerpt: 'excerpt',
    content: 'content',
    coverImage: 'coverImage',
    coverImageAlt: 'coverImageAlt',
    tag: 'tag',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    categoryId: 'categoryId',
    published: 'published',
    publishedAt: 'publishedAt',
    originalContent: 'originalContent',
    linkOptimizedAt: 'linkOptimizedAt',
    internalLinkCount: 'internalLinkCount',
    hasDynamicProperties: 'hasDynamicProperties',
    poiQueryParams: 'poiQueryParams',
    poiTemplateId: 'poiTemplateId',
    authorId: 'authorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogScalarFieldEnum = (typeof BlogScalarFieldEnum)[keyof typeof BlogScalarFieldEnum]


  export const BlogCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    parentId: 'parentId',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    icon: 'icon',
    color: 'color',
    order: 'order',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogCategoryScalarFieldEnum = (typeof BlogCategoryScalarFieldEnum)[keyof typeof BlogCategoryScalarFieldEnum]


  export const PropertySubmissionScalarFieldEnum: {
    id: 'id',
    ownerName: 'ownerName',
    ownerEmail: 'ownerEmail',
    ownerPhone: 'ownerPhone',
    ownerCountryCode: 'ownerCountryCode',
    accessToken: 'accessToken',
    propertyTitle: 'propertyTitle',
    propertyCategory: 'propertyCategory',
    propertyType: 'propertyType',
    location: 'location',
    askingPrice: 'askingPrice',
    beds: 'beds',
    baths: 'baths',
    sqft: 'sqft',
    description: 'description',
    images: 'images',
    exclusiveRights: 'exclusiveRights',
    commissionRate: 'commissionRate',
    agreementAccepted: 'agreementAccepted',
    status: 'status',
    reviewNotes: 'reviewNotes',
    reviewedBy: 'reviewedBy',
    reviewedByName: 'reviewedByName',
    reviewedAt: 'reviewedAt',
    imagesApprovedAt: 'imagesApprovedAt',
    imagesApprovedBy: 'imagesApprovedBy',
    publishedAt: 'publishedAt',
    publishedBy: 'publishedBy',
    convertedPropertyId: 'convertedPropertyId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    source: 'source',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertySubmissionScalarFieldEnum = (typeof PropertySubmissionScalarFieldEnum)[keyof typeof PropertySubmissionScalarFieldEnum]


  export const SiteSettingsScalarFieldEnum: {
    id: 'id',
    smtpHost: 'smtpHost',
    smtpPort: 'smtpPort',
    smtpSecure: 'smtpSecure',
    smtpUser: 'smtpUser',
    smtpPassword: 'smtpPassword',
    smtpFromName: 'smtpFromName',
    smtpFromEmail: 'smtpFromEmail',
    siteName: 'siteName',
    siteEmail: 'siteEmail',
    adminNotifyEmail: 'adminNotifyEmail',
    notifyOnSubmission: 'notifyOnSubmission',
    notifyOnImageUpload: 'notifyOnImageUpload',
    companyDescription: 'companyDescription',
    companyTone: 'companyTone',
    companyUSPs: 'companyUSPs',
    targetAudience: 'targetAudience',
    brandKeywords: 'brandKeywords',
    avoidTopics: 'avoidTopics',
    websiteUrl: 'websiteUrl',
    lastScannedAt: 'lastScannedAt',
    scannedPagesCount: 'scannedPagesCount',
    scanConfidence: 'scanConfidence',
    detectedThemes: 'detectedThemes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SiteSettingsScalarFieldEnum = (typeof SiteSettingsScalarFieldEnum)[keyof typeof SiteSettingsScalarFieldEnum]


  export const InternalLinkScalarFieldEnum: {
    id: 'id',
    url: 'url',
    title: 'title',
    description: 'description',
    category: 'category',
    subCategory: 'subCategory',
    keywords: 'keywords',
    anchorTexts: 'anchorTexts',
    priority: 'priority',
    isActive: 'isActive',
    usageCount: 'usageCount',
    pageExists: 'pageExists',
    lastChecked: 'lastChecked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InternalLinkScalarFieldEnum = (typeof InternalLinkScalarFieldEnum)[keyof typeof InternalLinkScalarFieldEnum]


  export const LinkUsageScalarFieldEnum: {
    id: 'id',
    linkId: 'linkId',
    blogId: 'blogId',
    anchorText: 'anchorText',
    context: 'context',
    position: 'position',
    wasAutoInserted: 'wasAutoInserted',
    insertedAt: 'insertedAt',
    createdAt: 'createdAt'
  };

  export type LinkUsageScalarFieldEnum = (typeof LinkUsageScalarFieldEnum)[keyof typeof LinkUsageScalarFieldEnum]


  export const LandingPageSuggestionScalarFieldEnum: {
    id: 'id',
    suggestedUrl: 'suggestedUrl',
    suggestedTitle: 'suggestedTitle',
    description: 'description',
    category: 'category',
    reason: 'reason',
    mentionCount: 'mentionCount',
    sourceBlogs: 'sourceBlogs',
    status: 'status',
    createdPageUrl: 'createdPageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LandingPageSuggestionScalarFieldEnum = (typeof LandingPageSuggestionScalarFieldEnum)[keyof typeof LandingPageSuggestionScalarFieldEnum]


  export const LandingPageScalarFieldEnum: {
    id: 'id',
    url: 'url',
    title: 'title',
    category: 'category',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    content: 'content',
    faq: 'faq',
    published: 'published',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LandingPageScalarFieldEnum = (typeof LandingPageScalarFieldEnum)[keyof typeof LandingPageScalarFieldEnum]


  export const CompanyProfileScalarFieldEnum: {
    id: 'id',
    companyName: 'companyName',
    tagline: 'tagline',
    description: 'description',
    tone: 'tone',
    writingStyle: 'writingStyle',
    targetAudience: 'targetAudience',
    targetLocations: 'targetLocations',
    usps: 'usps',
    expertise: 'expertise',
    contentThemes: 'contentThemes',
    brandKeywords: 'brandKeywords',
    avoidTopics: 'avoidTopics',
    competitors: 'competitors',
    websiteUrl: 'websiteUrl',
    lastAnalyzedAt: 'lastAnalyzedAt',
    analysisData: 'analysisData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyProfileScalarFieldEnum = (typeof CompanyProfileScalarFieldEnum)[keyof typeof CompanyProfileScalarFieldEnum]


  export const BlogScheduleSettingsScalarFieldEnum: {
    id: 'id',
    maxBlogsPerWeek: 'maxBlogsPerWeek',
    minDaysBetweenPosts: 'minDaysBetweenPosts',
    preferredPostTime: 'preferredPostTime',
    preferredPostDays: 'preferredPostDays',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogScheduleSettingsScalarFieldEnum = (typeof BlogScheduleSettingsScalarFieldEnum)[keyof typeof BlogScheduleSettingsScalarFieldEnum]


  export const TopicSuggestionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    category: 'category',
    priority: 'priority',
    difficulty: 'difficulty',
    estimatedImpact: 'estimatedImpact',
    language: 'language',
    status: 'status',
    usedAt: 'usedAt',
    generatedBlogId: 'generatedBlogId',
    batchId: 'batchId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TopicSuggestionScalarFieldEnum = (typeof TopicSuggestionScalarFieldEnum)[keyof typeof TopicSuggestionScalarFieldEnum]


  export const ScheduledBlogScalarFieldEnum: {
    id: 'id',
    topicId: 'topicId',
    topicTitle: 'topicTitle',
    language: 'language',
    length: 'length',
    tone: 'tone',
    includeResearch: 'includeResearch',
    scheduledFor: 'scheduledFor',
    scheduledBy: 'scheduledBy',
    status: 'status',
    generatedBlogId: 'generatedBlogId',
    processingStartedAt: 'processingStartedAt',
    processedAt: 'processedAt',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduledBlogScalarFieldEnum = (typeof ScheduledBlogScalarFieldEnum)[keyof typeof ScheduledBlogScalarFieldEnum]


  export const HeroImageScalarFieldEnum: {
    id: 'id',
    page: 'page',
    deviceType: 'deviceType',
    imageUrl: 'imageUrl',
    alt: 'alt',
    fileName: 'fileName',
    originalUrl: 'originalUrl',
    width: 'width',
    height: 'height',
    isAiGenerated: 'isAiGenerated',
    aiPrompt: 'aiPrompt',
    originalSize: 'originalSize',
    optimizedSize: 'optimizedSize',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HeroImageScalarFieldEnum = (typeof HeroImageScalarFieldEnum)[keyof typeof HeroImageScalarFieldEnum]


  export const PropertyAlertScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    phone: 'phone',
    countryCode: 'countryCode',
    userId: 'userId',
    propertyType: 'propertyType',
    category: 'category',
    locations: 'locations',
    minPrice: 'minPrice',
    maxPrice: 'maxPrice',
    minBeds: 'minBeds',
    maxBeds: 'maxBeds',
    minBaths: 'minBaths',
    maxBaths: 'maxBaths',
    minSqft: 'minSqft',
    maxSqft: 'maxSqft',
    notifyImmediately: 'notifyImmediately',
    notifyDigest: 'notifyDigest',
    digestDay: 'digestDay',
    isActive: 'isActive',
    lastNotifiedAt: 'lastNotifiedAt',
    matchCount: 'matchCount',
    notificationCount: 'notificationCount',
    verificationToken: 'verificationToken',
    isVerified: 'isVerified',
    verifiedAt: 'verifiedAt',
    unsubscribeToken: 'unsubscribeToken',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    source: 'source',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyAlertScalarFieldEnum = (typeof PropertyAlertScalarFieldEnum)[keyof typeof PropertyAlertScalarFieldEnum]


  export const PropertyAlertNotificationScalarFieldEnum: {
    id: 'id',
    alertId: 'alertId',
    propertyIds: 'propertyIds',
    propertyCount: 'propertyCount',
    emailSent: 'emailSent',
    emailSentAt: 'emailSentAt',
    emailError: 'emailError',
    opened: 'opened',
    openedAt: 'openedAt',
    clicked: 'clicked',
    clickedAt: 'clickedAt',
    createdAt: 'createdAt'
  };

  export type PropertyAlertNotificationScalarFieldEnum = (typeof PropertyAlertNotificationScalarFieldEnum)[keyof typeof PropertyAlertNotificationScalarFieldEnum]


  export const PoiScalarFieldEnum: {
    id: 'id',
    externalId: 'externalId',
    source: 'source',
    name: 'name',
    nameTh: 'nameTh',
    nameLocal: 'nameLocal',
    category: 'category',
    subCategory: 'subCategory',
    latitude: 'latitude',
    longitude: 'longitude',
    address: 'address',
    district: 'district',
    osmTags: 'osmTags',
    importance: 'importance',
    isVerified: 'isVerified',
    isActive: 'isActive',
    noiseLevel: 'noiseLevel',
    trafficLevel: 'trafficLevel',
    lastSyncedAt: 'lastSyncedAt',
    syncError: 'syncError',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PoiScalarFieldEnum = (typeof PoiScalarFieldEnum)[keyof typeof PoiScalarFieldEnum]


  export const PropertyPoiDistanceScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    poiId: 'poiId',
    distanceMeters: 'distanceMeters',
    walkingMinutes: 'walkingMinutes',
    drivingMinutes: 'drivingMinutes',
    isHighlight: 'isHighlight',
    calculatedAt: 'calculatedAt'
  };

  export type PropertyPoiDistanceScalarFieldEnum = (typeof PropertyPoiDistanceScalarFieldEnum)[keyof typeof PropertyPoiDistanceScalarFieldEnum]


  export const PoiSyncJobScalarFieldEnum: {
    id: 'id',
    jobType: 'jobType',
    status: 'status',
    category: 'category',
    district: 'district',
    poisFetched: 'poisFetched',
    poisCreated: 'poisCreated',
    poisUpdated: 'poisUpdated',
    poisSkipped: 'poisSkipped',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    errorMessage: 'errorMessage',
    errorStack: 'errorStack',
    createdAt: 'createdAt'
  };

  export type PoiSyncJobScalarFieldEnum = (typeof PoiSyncJobScalarFieldEnum)[keyof typeof PoiSyncJobScalarFieldEnum]


  export const RentalPricingConfigScalarFieldEnum: {
    id: 'id',
    peakSeasonMonths: 'peakSeasonMonths',
    peakSeasonSurcharges: 'peakSeasonSurcharges',
    lowSeasonSurcharges: 'lowSeasonSurcharges',
    minimumStayDays: 'minimumStayDays',
    maximumStayDays: 'maximumStayDays',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RentalPricingConfigScalarFieldEnum = (typeof RentalPricingConfigScalarFieldEnum)[keyof typeof RentalPricingConfigScalarFieldEnum]


  export const RentalBookingScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    userId: 'userId',
    checkIn: 'checkIn',
    checkOut: 'checkOut',
    nights: 'nights',
    adults: 'adults',
    children: 'children',
    babies: 'babies',
    pets: 'pets',
    basePrice: 'basePrice',
    season: 'season',
    discountPercent: 'discountPercent',
    totalPrice: 'totalPrice',
    guestName: 'guestName',
    guestEmail: 'guestEmail',
    guestPhone: 'guestPhone',
    guestCountryCode: 'guestCountryCode',
    guestMessage: 'guestMessage',
    status: 'status',
    paymentStatus: 'paymentStatus',
    cancellationPolicy: 'cancellationPolicy',
    cancelledAt: 'cancelledAt',
    cancellationReason: 'cancellationReason',
    internalNotes: 'internalNotes',
    checkInTime: 'checkInTime',
    checkOutTime: 'checkOutTime',
    propertyAddress: 'propertyAddress',
    propertyInstructions: 'propertyInstructions',
    wifiName: 'wifiName',
    wifiPassword: 'wifiPassword',
    accessCode: 'accessCode',
    emergencyContact: 'emergencyContact',
    houseRules: 'houseRules',
    confirmedAt: 'confirmedAt',
    agentId: 'agentId',
    tm30Status: 'tm30Status',
    tm30SubmittedAt: 'tm30SubmittedAt',
    tm30Reference: 'tm30Reference',
    tm30Error: 'tm30Error',
    passportsRequired: 'passportsRequired',
    passportsReceived: 'passportsReceived',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RentalBookingScalarFieldEnum = (typeof RentalBookingScalarFieldEnum)[keyof typeof RentalBookingScalarFieldEnum]


  export const BookingMessageScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    senderId: 'senderId',
    senderRole: 'senderRole',
    message: 'message',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingMessageScalarFieldEnum = (typeof BookingMessageScalarFieldEnum)[keyof typeof BookingMessageScalarFieldEnum]


  export const BookingGuestScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    guestType: 'guestType',
    guestNumber: 'guestNumber',
    firstName: 'firstName',
    lastName: 'lastName',
    fullName: 'fullName',
    dateOfBirth: 'dateOfBirth',
    nationality: 'nationality',
    gender: 'gender',
    passportNumber: 'passportNumber',
    passportExpiry: 'passportExpiry',
    passportIssueDate: 'passportIssueDate',
    passportCountry: 'passportCountry',
    passportImageUrl: 'passportImageUrl',
    passportImagePath: 'passportImagePath',
    ocrConfidence: 'ocrConfidence',
    ocrRawData: 'ocrRawData',
    ocrProcessedAt: 'ocrProcessedAt',
    passportVerified: 'passportVerified',
    verifiedBy: 'verifiedBy',
    verifiedAt: 'verifiedAt',
    tm30Status: 'tm30Status',
    tm30SubmittedAt: 'tm30SubmittedAt',
    tm30Error: 'tm30Error',
    whatsappMessageId: 'whatsappMessageId',
    whatsappReceivedAt: 'whatsappReceivedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingGuestScalarFieldEnum = (typeof BookingGuestScalarFieldEnum)[keyof typeof BookingGuestScalarFieldEnum]


  export const PropertyBlockedDateScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    startDate: 'startDate',
    endDate: 'endDate',
    reason: 'reason',
    blockedBy: 'blockedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyBlockedDateScalarFieldEnum = (typeof PropertyBlockedDateScalarFieldEnum)[keyof typeof PropertyBlockedDateScalarFieldEnum]


  export const Tm30AccommodationScalarFieldEnum: {
    id: 'id',
    tm30Id: 'tm30Id',
    name: 'name',
    address: 'address',
    status: 'status',
    propertyId: 'propertyId',
    matchScore: 'matchScore',
    matchedBy: 'matchedBy',
    matchedAt: 'matchedAt',
    lastSyncedAt: 'lastSyncedAt',
    syncSource: 'syncSource',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Tm30AccommodationScalarFieldEnum = (typeof Tm30AccommodationScalarFieldEnum)[keyof typeof Tm30AccommodationScalarFieldEnum]


  export const Tm30AccommodationRequestScalarFieldEnum: {
    id: 'id',
    ownerSameAsRegistrant: 'ownerSameAsRegistrant',
    ownerNationalType: 'ownerNationalType',
    ownerNationalId: 'ownerNationalId',
    ownerPassportNumber: 'ownerPassportNumber',
    ownerFirstName: 'ownerFirstName',
    ownerMiddleName: 'ownerMiddleName',
    ownerLastName: 'ownerLastName',
    ownerTelephone: 'ownerTelephone',
    ownerGender: 'ownerGender',
    entityType: 'entityType',
    houseIdNumber: 'houseIdNumber',
    accommodationType: 'accommodationType',
    accommodationName: 'accommodationName',
    position: 'position',
    positionOther: 'positionOther',
    addressNumber: 'addressNumber',
    villageNumber: 'villageNumber',
    alley: 'alley',
    road: 'road',
    province: 'province',
    district: 'district',
    subDistrict: 'subDistrict',
    postalCode: 'postalCode',
    latitude: 'latitude',
    longitude: 'longitude',
    houseRegistrationUrl: 'houseRegistrationUrl',
    houseRegistrationPath: 'houseRegistrationPath',
    ocrProcessed: 'ocrProcessed',
    ocrProcessedAt: 'ocrProcessedAt',
    ocrRawData: 'ocrRawData',
    ocrConfidence: 'ocrConfidence',
    status: 'status',
    tm30Id: 'tm30Id',
    submittedAt: 'submittedAt',
    approvedAt: 'approvedAt',
    rejectedAt: 'rejectedAt',
    rejectionReason: 'rejectionReason',
    errorMessage: 'errorMessage',
    propertyId: 'propertyId',
    propertyOwnerId: 'propertyOwnerId',
    whatsappPhone: 'whatsappPhone',
    whatsappSessionId: 'whatsappSessionId',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Tm30AccommodationRequestScalarFieldEnum = (typeof Tm30AccommodationRequestScalarFieldEnum)[keyof typeof Tm30AccommodationRequestScalarFieldEnum]


  export const PropertyOwnerScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    thaiIdNumber: 'thaiIdNumber',
    phone: 'phone',
    email: 'email',
    gender: 'gender',
    idCardUrl: 'idCardUrl',
    idCardPath: 'idCardPath',
    idCardOcrData: 'idCardOcrData',
    idCardVerified: 'idCardVerified',
    idCardUploadedAt: 'idCardUploadedAt',
    isActive: 'isActive',
    isVerified: 'isVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyOwnerScalarFieldEnum = (typeof PropertyOwnerScalarFieldEnum)[keyof typeof PropertyOwnerScalarFieldEnum]


  export const OwnerDocumentScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    documentType: 'documentType',
    imageUrl: 'imageUrl',
    imagePath: 'imagePath',
    fileName: 'fileName',
    ocrData: 'ocrData',
    ocrProcessedAt: 'ocrProcessedAt',
    ocrConfidence: 'ocrConfidence',
    propertyId: 'propertyId',
    houseId: 'houseId',
    extractedAddress: 'extractedAddress',
    isVerified: 'isVerified',
    verifiedBy: 'verifiedBy',
    verifiedAt: 'verifiedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OwnerDocumentScalarFieldEnum = (typeof OwnerDocumentScalarFieldEnum)[keyof typeof OwnerDocumentScalarFieldEnum]


  export const WhatsappListingSessionScalarFieldEnum: {
    id: 'id',
    phone: 'phone',
    status: 'status',
    currentAction: 'currentAction',
    ownerId: 'ownerId',
    currentPropertyId: 'currentPropertyId',
    tm30RequestId: 'tm30RequestId',
    tm30OwnerFirstName: 'tm30OwnerFirstName',
    tm30OwnerLastName: 'tm30OwnerLastName',
    tm30OwnerGender: 'tm30OwnerGender',
    tm30OwnerPhone: 'tm30OwnerPhone',
    tm30ThaiIdNumber: 'tm30ThaiIdNumber',
    tm30IdCardUrl: 'tm30IdCardUrl',
    tm30BluebookUrl: 'tm30BluebookUrl',
    tm30HouseId: 'tm30HouseId',
    tm30Province: 'tm30Province',
    tm30District: 'tm30District',
    tm30SubDistrict: 'tm30SubDistrict',
    tm30AddressNumber: 'tm30AddressNumber',
    tm30PostalCode: 'tm30PostalCode',
    tm30AccommodationName: 'tm30AccommodationName',
    pendingData: 'pendingData',
    lastMessageAt: 'lastMessageAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WhatsappListingSessionScalarFieldEnum = (typeof WhatsappListingSessionScalarFieldEnum)[keyof typeof WhatsappListingSessionScalarFieldEnum]


  export const AIAgentConfigScalarFieldEnum: {
    id: 'id',
    enabled: 'enabled',
    autonomousMode: 'autonomousMode',
    minConfidenceThreshold: 'minConfidenceThreshold',
    dailyDecisionLimit: 'dailyDecisionLimit',
    dailyAutoExecuteLimit: 'dailyAutoExecuteLimit',
    notifyOnDecision: 'notifyOnDecision',
    notifyOnAutoExecute: 'notifyOnAutoExecute',
    notifyEmail: 'notifyEmail',
    allowedAutonomousTypes: 'allowedAutonomousTypes',
    forbiddenPatterns: 'forbiddenPatterns',
    learningEnabled: 'learningEnabled',
    feedbackLoopDays: 'feedbackLoopDays',
    killSwitch: 'killSwitch',
    pausedUntil: 'pausedUntil',
    pauseReason: 'pauseReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AIAgentConfigScalarFieldEnum = (typeof AIAgentConfigScalarFieldEnum)[keyof typeof AIAgentConfigScalarFieldEnum]


  export const AIDecisionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    subType: 'subType',
    priority: 'priority',
    confidence: 'confidence',
    reasoning: 'reasoning',
    dataSnapshot: 'dataSnapshot',
    actionType: 'actionType',
    actionPayload: 'actionPayload',
    estimatedImpact: 'estimatedImpact',
    rollbackPlan: 'rollbackPlan',
    requiresApproval: 'requiresApproval',
    autoApproved: 'autoApproved',
    status: 'status',
    approvedBy: 'approvedBy',
    approvedByName: 'approvedByName',
    approvedAt: 'approvedAt',
    rejectedBy: 'rejectedBy',
    rejectedByName: 'rejectedByName',
    rejectedAt: 'rejectedAt',
    rejectionReason: 'rejectionReason',
    executedAt: 'executedAt',
    executionResult: 'executionResult',
    executionError: 'executionError',
    executionDuration: 'executionDuration',
    rolledBackAt: 'rolledBackAt',
    rolledBackBy: 'rolledBackBy',
    rollbackReason: 'rollbackReason',
    feedbackDueAt: 'feedbackDueAt',
    actualImpact: 'actualImpact',
    wasSuccessful: 'wasSuccessful',
    successScore: 'successScore',
    feedbackNotes: 'feedbackNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AIDecisionScalarFieldEnum = (typeof AIDecisionScalarFieldEnum)[keyof typeof AIDecisionScalarFieldEnum]


  export const AICodeChangeScalarFieldEnum: {
    id: 'id',
    decisionId: 'decisionId',
    filePath: 'filePath',
    action: 'action',
    originalContent: 'originalContent',
    newContent: 'newContent',
    diff: 'diff',
    syntaxValid: 'syntaxValid',
    typesValid: 'typesValid',
    lintPassed: 'lintPassed',
    testsPassed: 'testsPassed',
    appliedAt: 'appliedAt',
    rolledBackAt: 'rolledBackAt',
    createdAt: 'createdAt'
  };

  export type AICodeChangeScalarFieldEnum = (typeof AICodeChangeScalarFieldEnum)[keyof typeof AICodeChangeScalarFieldEnum]


  export const AIAgentLogScalarFieldEnum: {
    id: 'id',
    level: 'level',
    category: 'category',
    message: 'message',
    data: 'data',
    decisionId: 'decisionId',
    errorCode: 'errorCode',
    errorStack: 'errorStack',
    durationMs: 'durationMs',
    createdAt: 'createdAt'
  };

  export type AIAgentLogScalarFieldEnum = (typeof AIAgentLogScalarFieldEnum)[keyof typeof AIAgentLogScalarFieldEnum]


  export const AIDataSnapshotScalarFieldEnum: {
    id: 'id',
    snapshotType: 'snapshotType',
    totalViews: 'totalViews',
    uniqueVisitors: 'uniqueVisitors',
    bounceRate: 'bounceRate',
    avgSessionDuration: 'avgSessionDuration',
    totalInquiries: 'totalInquiries',
    viewingRequests: 'viewingRequests',
    investorLeads: 'investorLeads',
    rentalLeads: 'rentalLeads',
    conversionRate: 'conversionRate',
    totalProperties: 'totalProperties',
    activeListings: 'activeListings',
    newListings: 'newListings',
    avgPropertyViews: 'avgPropertyViews',
    totalBlogs: 'totalBlogs',
    publishedBlogs: 'publishedBlogs',
    avgBlogViews: 'avgBlogViews',
    organicTraffic: 'organicTraffic',
    topKeywords: 'topKeywords',
    avgPosition: 'avgPosition',
    estimatedLeadValue: 'estimatedLeadValue',
    errorCount: 'errorCount',
    slowPages: 'slowPages',
    brokenLinks: 'brokenLinks',
    rawData: 'rawData',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    createdAt: 'createdAt'
  };

  export type AIDataSnapshotScalarFieldEnum = (typeof AIDataSnapshotScalarFieldEnum)[keyof typeof AIDataSnapshotScalarFieldEnum]


  export const AIOpportunityScalarFieldEnum: {
    id: 'id',
    type: 'type',
    subType: 'subType',
    title: 'title',
    description: 'description',
    trigger: 'trigger',
    priority: 'priority',
    estimatedEffort: 'estimatedEffort',
    estimatedImpact: 'estimatedImpact',
    potentialRevenue: 'potentialRevenue',
    potentialLeads: 'potentialLeads',
    status: 'status',
    decisionId: 'decisionId',
    identifiedAt: 'identifiedAt',
    addressedAt: 'addressedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AIOpportunityScalarFieldEnum = (typeof AIOpportunityScalarFieldEnum)[keyof typeof AIOpportunityScalarFieldEnum]


  export const AILearningScalarFieldEnum: {
    id: 'id',
    category: 'category',
    insight: 'insight',
    sourceDecisionId: 'sourceDecisionId',
    confidence: 'confidence',
    impactArea: 'impactArea',
    adjustment: 'adjustment',
    validatedBy: 'validatedBy',
    validatedAt: 'validatedAt',
    isValid: 'isValid',
    createdAt: 'createdAt'
  };

  export type AILearningScalarFieldEnum = (typeof AILearningScalarFieldEnum)[keyof typeof AILearningScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'PropertyType'
   */
  export type EnumPropertyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyType'>
    


  /**
   * Reference to a field of type 'PropertyType[]'
   */
  export type ListEnumPropertyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyType[]'>
    


  /**
   * Reference to a field of type 'PropertyCategory'
   */
  export type EnumPropertyCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyCategory'>
    


  /**
   * Reference to a field of type 'PropertyCategory[]'
   */
  export type ListEnumPropertyCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyCategory[]'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'OwnershipType'
   */
  export type EnumOwnershipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OwnershipType'>
    


  /**
   * Reference to a field of type 'OwnershipType[]'
   */
  export type ListEnumOwnershipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OwnershipType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'RequestType'
   */
  export type EnumRequestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestType'>
    


  /**
   * Reference to a field of type 'RequestType[]'
   */
  export type ListEnumRequestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestType[]'>
    


  /**
   * Reference to a field of type 'RequestStatus'
   */
  export type EnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus'>
    


  /**
   * Reference to a field of type 'RequestStatus[]'
   */
  export type ListEnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus[]'>
    


  /**
   * Reference to a field of type 'LeadStatus'
   */
  export type EnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus'>
    


  /**
   * Reference to a field of type 'LeadStatus[]'
   */
  export type ListEnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus[]'>
    


  /**
   * Reference to a field of type 'RentalLeadStatus'
   */
  export type EnumRentalLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RentalLeadStatus'>
    


  /**
   * Reference to a field of type 'RentalLeadStatus[]'
   */
  export type ListEnumRentalLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RentalLeadStatus[]'>
    


  /**
   * Reference to a field of type 'SubmissionStatus'
   */
  export type EnumSubmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubmissionStatus'>
    


  /**
   * Reference to a field of type 'SubmissionStatus[]'
   */
  export type ListEnumSubmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubmissionStatus[]'>
    


  /**
   * Reference to a field of type 'LandingPageStatus'
   */
  export type EnumLandingPageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LandingPageStatus'>
    


  /**
   * Reference to a field of type 'LandingPageStatus[]'
   */
  export type ListEnumLandingPageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LandingPageStatus[]'>
    


  /**
   * Reference to a field of type 'TopicStatus'
   */
  export type EnumTopicStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TopicStatus'>
    


  /**
   * Reference to a field of type 'TopicStatus[]'
   */
  export type ListEnumTopicStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TopicStatus[]'>
    


  /**
   * Reference to a field of type 'ScheduledBlogStatus'
   */
  export type EnumScheduledBlogStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduledBlogStatus'>
    


  /**
   * Reference to a field of type 'ScheduledBlogStatus[]'
   */
  export type ListEnumScheduledBlogStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduledBlogStatus[]'>
    


  /**
   * Reference to a field of type 'HeroDeviceType'
   */
  export type EnumHeroDeviceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HeroDeviceType'>
    


  /**
   * Reference to a field of type 'HeroDeviceType[]'
   */
  export type ListEnumHeroDeviceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HeroDeviceType[]'>
    


  /**
   * Reference to a field of type 'PoiSource'
   */
  export type EnumPoiSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PoiSource'>
    


  /**
   * Reference to a field of type 'PoiSource[]'
   */
  export type ListEnumPoiSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PoiSource[]'>
    


  /**
   * Reference to a field of type 'PoiCategory'
   */
  export type EnumPoiCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PoiCategory'>
    


  /**
   * Reference to a field of type 'PoiCategory[]'
   */
  export type ListEnumPoiCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PoiCategory[]'>
    


  /**
   * Reference to a field of type 'NoiseLevel'
   */
  export type EnumNoiseLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoiseLevel'>
    


  /**
   * Reference to a field of type 'NoiseLevel[]'
   */
  export type ListEnumNoiseLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoiseLevel[]'>
    


  /**
   * Reference to a field of type 'TrafficLevel'
   */
  export type EnumTrafficLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrafficLevel'>
    


  /**
   * Reference to a field of type 'TrafficLevel[]'
   */
  export type ListEnumTrafficLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrafficLevel[]'>
    


  /**
   * Reference to a field of type 'PoiSyncJobType'
   */
  export type EnumPoiSyncJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PoiSyncJobType'>
    


  /**
   * Reference to a field of type 'PoiSyncJobType[]'
   */
  export type ListEnumPoiSyncJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PoiSyncJobType[]'>
    


  /**
   * Reference to a field of type 'PoiSyncJobStatus'
   */
  export type EnumPoiSyncJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PoiSyncJobStatus'>
    


  /**
   * Reference to a field of type 'PoiSyncJobStatus[]'
   */
  export type ListEnumPoiSyncJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PoiSyncJobStatus[]'>
    


  /**
   * Reference to a field of type 'RentalBookingStatus'
   */
  export type EnumRentalBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RentalBookingStatus'>
    


  /**
   * Reference to a field of type 'RentalBookingStatus[]'
   */
  export type ListEnumRentalBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RentalBookingStatus[]'>
    


  /**
   * Reference to a field of type 'TM30BookingStatus'
   */
  export type EnumTM30BookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TM30BookingStatus'>
    


  /**
   * Reference to a field of type 'TM30BookingStatus[]'
   */
  export type ListEnumTM30BookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TM30BookingStatus[]'>
    


  /**
   * Reference to a field of type 'TM30GuestStatus'
   */
  export type EnumTM30GuestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TM30GuestStatus'>
    


  /**
   * Reference to a field of type 'TM30GuestStatus[]'
   */
  export type ListEnumTM30GuestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TM30GuestStatus[]'>
    


  /**
   * Reference to a field of type 'Tm30AccomRequestStatus'
   */
  export type EnumTm30AccomRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Tm30AccomRequestStatus'>
    


  /**
   * Reference to a field of type 'Tm30AccomRequestStatus[]'
   */
  export type ListEnumTm30AccomRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Tm30AccomRequestStatus[]'>
    


  /**
   * Reference to a field of type 'OwnerDocumentType'
   */
  export type EnumOwnerDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OwnerDocumentType'>
    


  /**
   * Reference to a field of type 'OwnerDocumentType[]'
   */
  export type ListEnumOwnerDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OwnerDocumentType[]'>
    


  /**
   * Reference to a field of type 'AIDecisionStatus'
   */
  export type EnumAIDecisionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIDecisionStatus'>
    


  /**
   * Reference to a field of type 'AIDecisionStatus[]'
   */
  export type ListEnumAIDecisionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIDecisionStatus[]'>
    


  /**
   * Reference to a field of type 'AICodeAction'
   */
  export type EnumAICodeActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AICodeAction'>
    


  /**
   * Reference to a field of type 'AICodeAction[]'
   */
  export type ListEnumAICodeActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AICodeAction[]'>
    


  /**
   * Reference to a field of type 'AILogLevel'
   */
  export type EnumAILogLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AILogLevel'>
    


  /**
   * Reference to a field of type 'AILogLevel[]'
   */
  export type ListEnumAILogLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AILogLevel[]'>
    


  /**
   * Reference to a field of type 'AIOpportunityStatus'
   */
  export type EnumAIOpportunityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIOpportunityStatus'>
    


  /**
   * Reference to a field of type 'AIOpportunityStatus[]'
   */
  export type ListEnumAIOpportunityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIOpportunityStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    impersonatedBy?: StringNullableFilter<"Session"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    impersonatedBy?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    impersonatedBy?: StringNullableFilter<"Session"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    impersonatedBy?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    token?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userId?: StringWithAggregatesFilter<"Session"> | string
    impersonatedBy?: StringNullableWithAggregatesFilter<"Session"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: StringNullableFilter<"User"> | string | null
    banned?: BoolNullableFilter<"User"> | boolean | null
    banReason?: StringNullableFilter<"User"> | string | null
    banExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    properties?: PropertyListRelationFilter
    investorLeads?: InvestorLeadListRelationFilter
    rentalLeads?: RentalLeadListRelationFilter
    blogs?: BlogListRelationFilter
    rentalBookings?: RentalBookingListRelationFilter
    bookingsAsAgent?: RentalBookingListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrderInput | SortOrder
    banned?: SortOrderInput | SortOrder
    banReason?: SortOrderInput | SortOrder
    banExpires?: SortOrderInput | SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    properties?: PropertyOrderByRelationAggregateInput
    investorLeads?: InvestorLeadOrderByRelationAggregateInput
    rentalLeads?: RentalLeadOrderByRelationAggregateInput
    blogs?: BlogOrderByRelationAggregateInput
    rentalBookings?: RentalBookingOrderByRelationAggregateInput
    bookingsAsAgent?: RentalBookingOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: StringNullableFilter<"User"> | string | null
    banned?: BoolNullableFilter<"User"> | boolean | null
    banReason?: StringNullableFilter<"User"> | string | null
    banExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    properties?: PropertyListRelationFilter
    investorLeads?: InvestorLeadListRelationFilter
    rentalLeads?: RentalLeadListRelationFilter
    blogs?: BlogListRelationFilter
    rentalBookings?: RentalBookingListRelationFilter
    bookingsAsAgent?: RentalBookingListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrderInput | SortOrder
    banned?: SortOrderInput | SortOrder
    banReason?: SortOrderInput | SortOrder
    banExpires?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    role?: StringNullableWithAggregatesFilter<"User"> | string | null
    banned?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    banReason?: StringNullableWithAggregatesFilter<"User"> | string | null
    banExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
  }

  export type AgentInviteWhereInput = {
    AND?: AgentInviteWhereInput | AgentInviteWhereInput[]
    OR?: AgentInviteWhereInput[]
    NOT?: AgentInviteWhereInput | AgentInviteWhereInput[]
    id?: StringFilter<"AgentInvite"> | string
    code?: StringFilter<"AgentInvite"> | string
    email?: StringNullableFilter<"AgentInvite"> | string | null
    role?: StringFilter<"AgentInvite"> | string
    maxUses?: IntFilter<"AgentInvite"> | number
    usedCount?: IntFilter<"AgentInvite"> | number
    usedBy?: StringNullableFilter<"AgentInvite"> | string | null
    usedAt?: DateTimeNullableFilter<"AgentInvite"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"AgentInvite"> | Date | string | null
    isActive?: BoolFilter<"AgentInvite"> | boolean
    createdBy?: StringFilter<"AgentInvite"> | string
    note?: StringNullableFilter<"AgentInvite"> | string | null
    createdAt?: DateTimeFilter<"AgentInvite"> | Date | string
    updatedAt?: DateTimeFilter<"AgentInvite"> | Date | string
  }

  export type AgentInviteOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    usedBy?: SortOrderInput | SortOrder
    usedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentInviteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: AgentInviteWhereInput | AgentInviteWhereInput[]
    OR?: AgentInviteWhereInput[]
    NOT?: AgentInviteWhereInput | AgentInviteWhereInput[]
    email?: StringNullableFilter<"AgentInvite"> | string | null
    role?: StringFilter<"AgentInvite"> | string
    maxUses?: IntFilter<"AgentInvite"> | number
    usedCount?: IntFilter<"AgentInvite"> | number
    usedBy?: StringNullableFilter<"AgentInvite"> | string | null
    usedAt?: DateTimeNullableFilter<"AgentInvite"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"AgentInvite"> | Date | string | null
    isActive?: BoolFilter<"AgentInvite"> | boolean
    createdBy?: StringFilter<"AgentInvite"> | string
    note?: StringNullableFilter<"AgentInvite"> | string | null
    createdAt?: DateTimeFilter<"AgentInvite"> | Date | string
    updatedAt?: DateTimeFilter<"AgentInvite"> | Date | string
  }, "id" | "code">

  export type AgentInviteOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    usedBy?: SortOrderInput | SortOrder
    usedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentInviteCountOrderByAggregateInput
    _avg?: AgentInviteAvgOrderByAggregateInput
    _max?: AgentInviteMaxOrderByAggregateInput
    _min?: AgentInviteMinOrderByAggregateInput
    _sum?: AgentInviteSumOrderByAggregateInput
  }

  export type AgentInviteScalarWhereWithAggregatesInput = {
    AND?: AgentInviteScalarWhereWithAggregatesInput | AgentInviteScalarWhereWithAggregatesInput[]
    OR?: AgentInviteScalarWhereWithAggregatesInput[]
    NOT?: AgentInviteScalarWhereWithAggregatesInput | AgentInviteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentInvite"> | string
    code?: StringWithAggregatesFilter<"AgentInvite"> | string
    email?: StringNullableWithAggregatesFilter<"AgentInvite"> | string | null
    role?: StringWithAggregatesFilter<"AgentInvite"> | string
    maxUses?: IntWithAggregatesFilter<"AgentInvite"> | number
    usedCount?: IntWithAggregatesFilter<"AgentInvite"> | number
    usedBy?: StringNullableWithAggregatesFilter<"AgentInvite"> | string | null
    usedAt?: DateTimeNullableWithAggregatesFilter<"AgentInvite"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"AgentInvite"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"AgentInvite"> | boolean
    createdBy?: StringWithAggregatesFilter<"AgentInvite"> | string
    note?: StringNullableWithAggregatesFilter<"AgentInvite"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AgentInvite"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgentInvite"> | Date | string
  }

  export type PropertyWhereInput = {
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    id?: StringFilter<"Property"> | string
    listingNumber?: StringNullableFilter<"Property"> | string | null
    title?: StringFilter<"Property"> | string
    slug?: StringFilter<"Property"> | string
    location?: StringFilter<"Property"> | string
    price?: StringFilter<"Property"> | string
    beds?: IntFilter<"Property"> | number
    baths?: FloatFilter<"Property"> | number
    sqft?: IntFilter<"Property"> | number
    plotSize?: IntNullableFilter<"Property"> | number | null
    type?: EnumPropertyTypeFilter<"Property"> | $Enums.PropertyType
    category?: EnumPropertyCategoryFilter<"Property"> | $Enums.PropertyCategory
    tag?: StringNullableFilter<"Property"> | string | null
    status?: EnumStatusFilter<"Property"> | $Enums.Status
    isHighlighted?: BoolFilter<"Property"> | boolean
    ownershipType?: EnumOwnershipTypeNullableFilter<"Property"> | $Enums.OwnershipType | null
    isResale?: BoolNullableFilter<"Property"> | boolean | null
    image?: StringFilter<"Property"> | string
    shortDescription?: StringNullableFilter<"Property"> | string | null
    descriptionParagraphs?: JsonNullableFilter<"Property">
    propertyFeatures?: JsonNullableFilter<"Property">
    amenities?: StringNullableListFilter<"Property">
    amenitiesWithIcons?: JsonNullableFilter<"Property">
    content?: StringFilter<"Property"> | string
    yearBuilt?: IntNullableFilter<"Property"> | number | null
    mapUrl?: StringNullableFilter<"Property"> | string | null
    monthlyRentalPrice?: FloatNullableFilter<"Property"> | number | null
    allowPets?: BoolFilter<"Property"> | boolean
    enableDailyRental?: BoolFilter<"Property"> | boolean
    maxGuests?: IntNullableFilter<"Property"> | number | null
    provinceSlug?: StringNullableFilter<"Property"> | string | null
    areaSlug?: StringNullableFilter<"Property"> | string | null
    ownerName?: StringNullableFilter<"Property"> | string | null
    ownerEmail?: StringNullableFilter<"Property"> | string | null
    ownerPhone?: StringNullableFilter<"Property"> | string | null
    ownerCountryCode?: StringNullableFilter<"Property"> | string | null
    ownerCompany?: StringNullableFilter<"Property"> | string | null
    ownerNotes?: StringNullableFilter<"Property"> | string | null
    propertyOwnerId?: StringNullableFilter<"Property"> | string | null
    bluebookUrl?: StringNullableFilter<"Property"> | string | null
    bluebookHouseId?: StringNullableFilter<"Property"> | string | null
    commissionRate?: FloatNullableFilter<"Property"> | number | null
    tm30AccommodationId?: StringNullableFilter<"Property"> | string | null
    tm30AccommodationName?: StringNullableFilter<"Property"> | string | null
    defaultCheckInTime?: StringNullableFilter<"Property"> | string | null
    defaultCheckOutTime?: StringNullableFilter<"Property"> | string | null
    defaultPropertyAddress?: StringNullableFilter<"Property"> | string | null
    defaultWifiName?: StringNullableFilter<"Property"> | string | null
    defaultWifiPassword?: StringNullableFilter<"Property"> | string | null
    defaultAccessCode?: StringNullableFilter<"Property"> | string | null
    defaultEmergencyContact?: StringNullableFilter<"Property"> | string | null
    defaultPropertyInstructions?: StringNullableFilter<"Property"> | string | null
    defaultHouseRules?: StringNullableFilter<"Property"> | string | null
    latitude?: FloatNullableFilter<"Property"> | number | null
    longitude?: FloatNullableFilter<"Property"> | number | null
    beachScore?: IntNullableFilter<"Property"> | number | null
    familyScore?: IntNullableFilter<"Property"> | number | null
    convenienceScore?: IntNullableFilter<"Property"> | number | null
    quietnessScore?: IntNullableFilter<"Property"> | number | null
    hasSeaView?: BoolFilter<"Property"> | boolean
    seaViewDirection?: StringNullableFilter<"Property"> | string | null
    seaDistance?: IntNullableFilter<"Property"> | number | null
    district?: StringNullableFilter<"Property"> | string | null
    poisLastCalculatedAt?: DateTimeNullableFilter<"Property"> | Date | string | null
    userId?: StringFilter<"Property"> | string
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    images?: PropertyImageListRelationFilter
    views?: PropertyViewListRelationFilter
    propertyOwner?: XOR<PropertyOwnerNullableScalarRelationFilter, PropertyOwnerWhereInput> | null
    poiDistances?: PropertyPoiDistanceListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    viewingRequests?: ViewingRequestListRelationFilter
    rentalBookings?: RentalBookingListRelationFilter
    blockedDates?: PropertyBlockedDateListRelationFilter
    tm30Accommodation?: XOR<Tm30AccommodationNullableScalarRelationFilter, Tm30AccommodationWhereInput> | null
  }

  export type PropertyOrderByWithRelationInput = {
    id?: SortOrder
    listingNumber?: SortOrderInput | SortOrder
    title?: SortOrder
    slug?: SortOrder
    location?: SortOrder
    price?: SortOrder
    beds?: SortOrder
    baths?: SortOrder
    sqft?: SortOrder
    plotSize?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrder
    tag?: SortOrderInput | SortOrder
    status?: SortOrder
    isHighlighted?: SortOrder
    ownershipType?: SortOrderInput | SortOrder
    isResale?: SortOrderInput | SortOrder
    image?: SortOrder
    shortDescription?: SortOrderInput | SortOrder
    descriptionParagraphs?: SortOrderInput | SortOrder
    propertyFeatures?: SortOrderInput | SortOrder
    amenities?: SortOrder
    amenitiesWithIcons?: SortOrderInput | SortOrder
    content?: SortOrder
    yearBuilt?: SortOrderInput | SortOrder
    mapUrl?: SortOrderInput | SortOrder
    monthlyRentalPrice?: SortOrderInput | SortOrder
    allowPets?: SortOrder
    enableDailyRental?: SortOrder
    maxGuests?: SortOrderInput | SortOrder
    provinceSlug?: SortOrderInput | SortOrder
    areaSlug?: SortOrderInput | SortOrder
    ownerName?: SortOrderInput | SortOrder
    ownerEmail?: SortOrderInput | SortOrder
    ownerPhone?: SortOrderInput | SortOrder
    ownerCountryCode?: SortOrderInput | SortOrder
    ownerCompany?: SortOrderInput | SortOrder
    ownerNotes?: SortOrderInput | SortOrder
    propertyOwnerId?: SortOrderInput | SortOrder
    bluebookUrl?: SortOrderInput | SortOrder
    bluebookHouseId?: SortOrderInput | SortOrder
    commissionRate?: SortOrderInput | SortOrder
    tm30AccommodationId?: SortOrderInput | SortOrder
    tm30AccommodationName?: SortOrderInput | SortOrder
    defaultCheckInTime?: SortOrderInput | SortOrder
    defaultCheckOutTime?: SortOrderInput | SortOrder
    defaultPropertyAddress?: SortOrderInput | SortOrder
    defaultWifiName?: SortOrderInput | SortOrder
    defaultWifiPassword?: SortOrderInput | SortOrder
    defaultAccessCode?: SortOrderInput | SortOrder
    defaultEmergencyContact?: SortOrderInput | SortOrder
    defaultPropertyInstructions?: SortOrderInput | SortOrder
    defaultHouseRules?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    beachScore?: SortOrderInput | SortOrder
    familyScore?: SortOrderInput | SortOrder
    convenienceScore?: SortOrderInput | SortOrder
    quietnessScore?: SortOrderInput | SortOrder
    hasSeaView?: SortOrder
    seaViewDirection?: SortOrderInput | SortOrder
    seaDistance?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    poisLastCalculatedAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    images?: PropertyImageOrderByRelationAggregateInput
    views?: PropertyViewOrderByRelationAggregateInput
    propertyOwner?: PropertyOwnerOrderByWithRelationInput
    poiDistances?: PropertyPoiDistanceOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    viewingRequests?: ViewingRequestOrderByRelationAggregateInput
    rentalBookings?: RentalBookingOrderByRelationAggregateInput
    blockedDates?: PropertyBlockedDateOrderByRelationAggregateInput
    tm30Accommodation?: Tm30AccommodationOrderByWithRelationInput
  }

  export type PropertyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    listingNumber?: string
    slug?: string
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    title?: StringFilter<"Property"> | string
    location?: StringFilter<"Property"> | string
    price?: StringFilter<"Property"> | string
    beds?: IntFilter<"Property"> | number
    baths?: FloatFilter<"Property"> | number
    sqft?: IntFilter<"Property"> | number
    plotSize?: IntNullableFilter<"Property"> | number | null
    type?: EnumPropertyTypeFilter<"Property"> | $Enums.PropertyType
    category?: EnumPropertyCategoryFilter<"Property"> | $Enums.PropertyCategory
    tag?: StringNullableFilter<"Property"> | string | null
    status?: EnumStatusFilter<"Property"> | $Enums.Status
    isHighlighted?: BoolFilter<"Property"> | boolean
    ownershipType?: EnumOwnershipTypeNullableFilter<"Property"> | $Enums.OwnershipType | null
    isResale?: BoolNullableFilter<"Property"> | boolean | null
    image?: StringFilter<"Property"> | string
    shortDescription?: StringNullableFilter<"Property"> | string | null
    descriptionParagraphs?: JsonNullableFilter<"Property">
    propertyFeatures?: JsonNullableFilter<"Property">
    amenities?: StringNullableListFilter<"Property">
    amenitiesWithIcons?: JsonNullableFilter<"Property">
    content?: StringFilter<"Property"> | string
    yearBuilt?: IntNullableFilter<"Property"> | number | null
    mapUrl?: StringNullableFilter<"Property"> | string | null
    monthlyRentalPrice?: FloatNullableFilter<"Property"> | number | null
    allowPets?: BoolFilter<"Property"> | boolean
    enableDailyRental?: BoolFilter<"Property"> | boolean
    maxGuests?: IntNullableFilter<"Property"> | number | null
    provinceSlug?: StringNullableFilter<"Property"> | string | null
    areaSlug?: StringNullableFilter<"Property"> | string | null
    ownerName?: StringNullableFilter<"Property"> | string | null
    ownerEmail?: StringNullableFilter<"Property"> | string | null
    ownerPhone?: StringNullableFilter<"Property"> | string | null
    ownerCountryCode?: StringNullableFilter<"Property"> | string | null
    ownerCompany?: StringNullableFilter<"Property"> | string | null
    ownerNotes?: StringNullableFilter<"Property"> | string | null
    propertyOwnerId?: StringNullableFilter<"Property"> | string | null
    bluebookUrl?: StringNullableFilter<"Property"> | string | null
    bluebookHouseId?: StringNullableFilter<"Property"> | string | null
    commissionRate?: FloatNullableFilter<"Property"> | number | null
    tm30AccommodationId?: StringNullableFilter<"Property"> | string | null
    tm30AccommodationName?: StringNullableFilter<"Property"> | string | null
    defaultCheckInTime?: StringNullableFilter<"Property"> | string | null
    defaultCheckOutTime?: StringNullableFilter<"Property"> | string | null
    defaultPropertyAddress?: StringNullableFilter<"Property"> | string | null
    defaultWifiName?: StringNullableFilter<"Property"> | string | null
    defaultWifiPassword?: StringNullableFilter<"Property"> | string | null
    defaultAccessCode?: StringNullableFilter<"Property"> | string | null
    defaultEmergencyContact?: StringNullableFilter<"Property"> | string | null
    defaultPropertyInstructions?: StringNullableFilter<"Property"> | string | null
    defaultHouseRules?: StringNullableFilter<"Property"> | string | null
    latitude?: FloatNullableFilter<"Property"> | number | null
    longitude?: FloatNullableFilter<"Property"> | number | null
    beachScore?: IntNullableFilter<"Property"> | number | null
    familyScore?: IntNullableFilter<"Property"> | number | null
    convenienceScore?: IntNullableFilter<"Property"> | number | null
    quietnessScore?: IntNullableFilter<"Property"> | number | null
    hasSeaView?: BoolFilter<"Property"> | boolean
    seaViewDirection?: StringNullableFilter<"Property"> | string | null
    seaDistance?: IntNullableFilter<"Property"> | number | null
    district?: StringNullableFilter<"Property"> | string | null
    poisLastCalculatedAt?: DateTimeNullableFilter<"Property"> | Date | string | null
    userId?: StringFilter<"Property"> | string
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    images?: PropertyImageListRelationFilter
    views?: PropertyViewListRelationFilter
    propertyOwner?: XOR<PropertyOwnerNullableScalarRelationFilter, PropertyOwnerWhereInput> | null
    poiDistances?: PropertyPoiDistanceListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    viewingRequests?: ViewingRequestListRelationFilter
    rentalBookings?: RentalBookingListRelationFilter
    blockedDates?: PropertyBlockedDateListRelationFilter
    tm30Accommodation?: XOR<Tm30AccommodationNullableScalarRelationFilter, Tm30AccommodationWhereInput> | null
  }, "id" | "listingNumber" | "slug">

  export type PropertyOrderByWithAggregationInput = {
    id?: SortOrder
    listingNumber?: SortOrderInput | SortOrder
    title?: SortOrder
    slug?: SortOrder
    location?: SortOrder
    price?: SortOrder
    beds?: SortOrder
    baths?: SortOrder
    sqft?: SortOrder
    plotSize?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrder
    tag?: SortOrderInput | SortOrder
    status?: SortOrder
    isHighlighted?: SortOrder
    ownershipType?: SortOrderInput | SortOrder
    isResale?: SortOrderInput | SortOrder
    image?: SortOrder
    shortDescription?: SortOrderInput | SortOrder
    descriptionParagraphs?: SortOrderInput | SortOrder
    propertyFeatures?: SortOrderInput | SortOrder
    amenities?: SortOrder
    amenitiesWithIcons?: SortOrderInput | SortOrder
    content?: SortOrder
    yearBuilt?: SortOrderInput | SortOrder
    mapUrl?: SortOrderInput | SortOrder
    monthlyRentalPrice?: SortOrderInput | SortOrder
    allowPets?: SortOrder
    enableDailyRental?: SortOrder
    maxGuests?: SortOrderInput | SortOrder
    provinceSlug?: SortOrderInput | SortOrder
    areaSlug?: SortOrderInput | SortOrder
    ownerName?: SortOrderInput | SortOrder
    ownerEmail?: SortOrderInput | SortOrder
    ownerPhone?: SortOrderInput | SortOrder
    ownerCountryCode?: SortOrderInput | SortOrder
    ownerCompany?: SortOrderInput | SortOrder
    ownerNotes?: SortOrderInput | SortOrder
    propertyOwnerId?: SortOrderInput | SortOrder
    bluebookUrl?: SortOrderInput | SortOrder
    bluebookHouseId?: SortOrderInput | SortOrder
    commissionRate?: SortOrderInput | SortOrder
    tm30AccommodationId?: SortOrderInput | SortOrder
    tm30AccommodationName?: SortOrderInput | SortOrder
    defaultCheckInTime?: SortOrderInput | SortOrder
    defaultCheckOutTime?: SortOrderInput | SortOrder
    defaultPropertyAddress?: SortOrderInput | SortOrder
    defaultWifiName?: SortOrderInput | SortOrder
    defaultWifiPassword?: SortOrderInput | SortOrder
    defaultAccessCode?: SortOrderInput | SortOrder
    defaultEmergencyContact?: SortOrderInput | SortOrder
    defaultPropertyInstructions?: SortOrderInput | SortOrder
    defaultHouseRules?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    beachScore?: SortOrderInput | SortOrder
    familyScore?: SortOrderInput | SortOrder
    convenienceScore?: SortOrderInput | SortOrder
    quietnessScore?: SortOrderInput | SortOrder
    hasSeaView?: SortOrder
    seaViewDirection?: SortOrderInput | SortOrder
    seaDistance?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    poisLastCalculatedAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyCountOrderByAggregateInput
    _avg?: PropertyAvgOrderByAggregateInput
    _max?: PropertyMaxOrderByAggregateInput
    _min?: PropertyMinOrderByAggregateInput
    _sum?: PropertySumOrderByAggregateInput
  }

  export type PropertyScalarWhereWithAggregatesInput = {
    AND?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    OR?: PropertyScalarWhereWithAggregatesInput[]
    NOT?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Property"> | string
    listingNumber?: StringNullableWithAggregatesFilter<"Property"> | string | null
    title?: StringWithAggregatesFilter<"Property"> | string
    slug?: StringWithAggregatesFilter<"Property"> | string
    location?: StringWithAggregatesFilter<"Property"> | string
    price?: StringWithAggregatesFilter<"Property"> | string
    beds?: IntWithAggregatesFilter<"Property"> | number
    baths?: FloatWithAggregatesFilter<"Property"> | number
    sqft?: IntWithAggregatesFilter<"Property"> | number
    plotSize?: IntNullableWithAggregatesFilter<"Property"> | number | null
    type?: EnumPropertyTypeWithAggregatesFilter<"Property"> | $Enums.PropertyType
    category?: EnumPropertyCategoryWithAggregatesFilter<"Property"> | $Enums.PropertyCategory
    tag?: StringNullableWithAggregatesFilter<"Property"> | string | null
    status?: EnumStatusWithAggregatesFilter<"Property"> | $Enums.Status
    isHighlighted?: BoolWithAggregatesFilter<"Property"> | boolean
    ownershipType?: EnumOwnershipTypeNullableWithAggregatesFilter<"Property"> | $Enums.OwnershipType | null
    isResale?: BoolNullableWithAggregatesFilter<"Property"> | boolean | null
    image?: StringWithAggregatesFilter<"Property"> | string
    shortDescription?: StringNullableWithAggregatesFilter<"Property"> | string | null
    descriptionParagraphs?: JsonNullableWithAggregatesFilter<"Property">
    propertyFeatures?: JsonNullableWithAggregatesFilter<"Property">
    amenities?: StringNullableListFilter<"Property">
    amenitiesWithIcons?: JsonNullableWithAggregatesFilter<"Property">
    content?: StringWithAggregatesFilter<"Property"> | string
    yearBuilt?: IntNullableWithAggregatesFilter<"Property"> | number | null
    mapUrl?: StringNullableWithAggregatesFilter<"Property"> | string | null
    monthlyRentalPrice?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    allowPets?: BoolWithAggregatesFilter<"Property"> | boolean
    enableDailyRental?: BoolWithAggregatesFilter<"Property"> | boolean
    maxGuests?: IntNullableWithAggregatesFilter<"Property"> | number | null
    provinceSlug?: StringNullableWithAggregatesFilter<"Property"> | string | null
    areaSlug?: StringNullableWithAggregatesFilter<"Property"> | string | null
    ownerName?: StringNullableWithAggregatesFilter<"Property"> | string | null
    ownerEmail?: StringNullableWithAggregatesFilter<"Property"> | string | null
    ownerPhone?: StringNullableWithAggregatesFilter<"Property"> | string | null
    ownerCountryCode?: StringNullableWithAggregatesFilter<"Property"> | string | null
    ownerCompany?: StringNullableWithAggregatesFilter<"Property"> | string | null
    ownerNotes?: StringNullableWithAggregatesFilter<"Property"> | string | null
    propertyOwnerId?: StringNullableWithAggregatesFilter<"Property"> | string | null
    bluebookUrl?: StringNullableWithAggregatesFilter<"Property"> | string | null
    bluebookHouseId?: StringNullableWithAggregatesFilter<"Property"> | string | null
    commissionRate?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    tm30AccommodationId?: StringNullableWithAggregatesFilter<"Property"> | string | null
    tm30AccommodationName?: StringNullableWithAggregatesFilter<"Property"> | string | null
    defaultCheckInTime?: StringNullableWithAggregatesFilter<"Property"> | string | null
    defaultCheckOutTime?: StringNullableWithAggregatesFilter<"Property"> | string | null
    defaultPropertyAddress?: StringNullableWithAggregatesFilter<"Property"> | string | null
    defaultWifiName?: StringNullableWithAggregatesFilter<"Property"> | string | null
    defaultWifiPassword?: StringNullableWithAggregatesFilter<"Property"> | string | null
    defaultAccessCode?: StringNullableWithAggregatesFilter<"Property"> | string | null
    defaultEmergencyContact?: StringNullableWithAggregatesFilter<"Property"> | string | null
    defaultPropertyInstructions?: StringNullableWithAggregatesFilter<"Property"> | string | null
    defaultHouseRules?: StringNullableWithAggregatesFilter<"Property"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    beachScore?: IntNullableWithAggregatesFilter<"Property"> | number | null
    familyScore?: IntNullableWithAggregatesFilter<"Property"> | number | null
    convenienceScore?: IntNullableWithAggregatesFilter<"Property"> | number | null
    quietnessScore?: IntNullableWithAggregatesFilter<"Property"> | number | null
    hasSeaView?: BoolWithAggregatesFilter<"Property"> | boolean
    seaViewDirection?: StringNullableWithAggregatesFilter<"Property"> | string | null
    seaDistance?: IntNullableWithAggregatesFilter<"Property"> | number | null
    district?: StringNullableWithAggregatesFilter<"Property"> | string | null
    poisLastCalculatedAt?: DateTimeNullableWithAggregatesFilter<"Property"> | Date | string | null
    userId?: StringWithAggregatesFilter<"Property"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
  }

  export type PropertyImageWhereInput = {
    AND?: PropertyImageWhereInput | PropertyImageWhereInput[]
    OR?: PropertyImageWhereInput[]
    NOT?: PropertyImageWhereInput | PropertyImageWhereInput[]
    id?: StringFilter<"PropertyImage"> | string
    propertyId?: StringFilter<"PropertyImage"> | string
    url?: StringNullableFilter<"PropertyImage"> | string | null
    position?: IntFilter<"PropertyImage"> | number
    alt?: StringNullableFilter<"PropertyImage"> | string | null
    createdAt?: DateTimeFilter<"PropertyImage"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyImage"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PropertyImageOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    url?: SortOrderInput | SortOrder
    position?: SortOrder
    alt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type PropertyImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    propertyId_position?: PropertyImagePropertyIdPositionCompoundUniqueInput
    AND?: PropertyImageWhereInput | PropertyImageWhereInput[]
    OR?: PropertyImageWhereInput[]
    NOT?: PropertyImageWhereInput | PropertyImageWhereInput[]
    propertyId?: StringFilter<"PropertyImage"> | string
    url?: StringNullableFilter<"PropertyImage"> | string | null
    position?: IntFilter<"PropertyImage"> | number
    alt?: StringNullableFilter<"PropertyImage"> | string | null
    createdAt?: DateTimeFilter<"PropertyImage"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyImage"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id" | "propertyId_position">

  export type PropertyImageOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    url?: SortOrderInput | SortOrder
    position?: SortOrder
    alt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyImageCountOrderByAggregateInput
    _avg?: PropertyImageAvgOrderByAggregateInput
    _max?: PropertyImageMaxOrderByAggregateInput
    _min?: PropertyImageMinOrderByAggregateInput
    _sum?: PropertyImageSumOrderByAggregateInput
  }

  export type PropertyImageScalarWhereWithAggregatesInput = {
    AND?: PropertyImageScalarWhereWithAggregatesInput | PropertyImageScalarWhereWithAggregatesInput[]
    OR?: PropertyImageScalarWhereWithAggregatesInput[]
    NOT?: PropertyImageScalarWhereWithAggregatesInput | PropertyImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyImage"> | string
    propertyId?: StringWithAggregatesFilter<"PropertyImage"> | string
    url?: StringNullableWithAggregatesFilter<"PropertyImage"> | string | null
    position?: IntWithAggregatesFilter<"PropertyImage"> | number
    alt?: StringNullableWithAggregatesFilter<"PropertyImage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PropertyImage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertyImage"> | Date | string
  }

  export type PropertyViewWhereInput = {
    AND?: PropertyViewWhereInput | PropertyViewWhereInput[]
    OR?: PropertyViewWhereInput[]
    NOT?: PropertyViewWhereInput | PropertyViewWhereInput[]
    id?: StringFilter<"PropertyView"> | string
    propertyId?: StringFilter<"PropertyView"> | string
    viewedAt?: DateTimeFilter<"PropertyView"> | Date | string
    country?: StringNullableFilter<"PropertyView"> | string | null
    city?: StringNullableFilter<"PropertyView"> | string | null
    ipHash?: StringNullableFilter<"PropertyView"> | string | null
    userAgent?: StringNullableFilter<"PropertyView"> | string | null
    referrer?: StringNullableFilter<"PropertyView"> | string | null
    sessionId?: StringNullableFilter<"PropertyView"> | string | null
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PropertyViewOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    viewedAt?: SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    ipHash?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    referrer?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type PropertyViewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyViewWhereInput | PropertyViewWhereInput[]
    OR?: PropertyViewWhereInput[]
    NOT?: PropertyViewWhereInput | PropertyViewWhereInput[]
    propertyId?: StringFilter<"PropertyView"> | string
    viewedAt?: DateTimeFilter<"PropertyView"> | Date | string
    country?: StringNullableFilter<"PropertyView"> | string | null
    city?: StringNullableFilter<"PropertyView"> | string | null
    ipHash?: StringNullableFilter<"PropertyView"> | string | null
    userAgent?: StringNullableFilter<"PropertyView"> | string | null
    referrer?: StringNullableFilter<"PropertyView"> | string | null
    sessionId?: StringNullableFilter<"PropertyView"> | string | null
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type PropertyViewOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    viewedAt?: SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    ipHash?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    referrer?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    _count?: PropertyViewCountOrderByAggregateInput
    _max?: PropertyViewMaxOrderByAggregateInput
    _min?: PropertyViewMinOrderByAggregateInput
  }

  export type PropertyViewScalarWhereWithAggregatesInput = {
    AND?: PropertyViewScalarWhereWithAggregatesInput | PropertyViewScalarWhereWithAggregatesInput[]
    OR?: PropertyViewScalarWhereWithAggregatesInput[]
    NOT?: PropertyViewScalarWhereWithAggregatesInput | PropertyViewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyView"> | string
    propertyId?: StringWithAggregatesFilter<"PropertyView"> | string
    viewedAt?: DateTimeWithAggregatesFilter<"PropertyView"> | Date | string
    country?: StringNullableWithAggregatesFilter<"PropertyView"> | string | null
    city?: StringNullableWithAggregatesFilter<"PropertyView"> | string | null
    ipHash?: StringNullableWithAggregatesFilter<"PropertyView"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"PropertyView"> | string | null
    referrer?: StringNullableWithAggregatesFilter<"PropertyView"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"PropertyView"> | string | null
  }

  export type ViewingRequestWhereInput = {
    AND?: ViewingRequestWhereInput | ViewingRequestWhereInput[]
    OR?: ViewingRequestWhereInput[]
    NOT?: ViewingRequestWhereInput | ViewingRequestWhereInput[]
    id?: StringFilter<"ViewingRequest"> | string
    propertyId?: StringNullableFilter<"ViewingRequest"> | string | null
    requestType?: EnumRequestTypeFilter<"ViewingRequest"> | $Enums.RequestType
    viewingDate?: DateTimeNullableFilter<"ViewingRequest"> | Date | string | null
    name?: StringFilter<"ViewingRequest"> | string
    email?: StringFilter<"ViewingRequest"> | string
    phone?: StringFilter<"ViewingRequest"> | string
    countryCode?: StringFilter<"ViewingRequest"> | string
    language?: StringNullableFilter<"ViewingRequest"> | string | null
    message?: StringNullableFilter<"ViewingRequest"> | string | null
    offerAmount?: StringNullableFilter<"ViewingRequest"> | string | null
    offerCurrency?: StringNullableFilter<"ViewingRequest"> | string | null
    status?: EnumRequestStatusFilter<"ViewingRequest"> | $Enums.RequestStatus
    confirmedBy?: StringNullableFilter<"ViewingRequest"> | string | null
    confirmedByName?: StringNullableFilter<"ViewingRequest"> | string | null
    confirmedAt?: DateTimeNullableFilter<"ViewingRequest"> | Date | string | null
    completedBy?: StringNullableFilter<"ViewingRequest"> | string | null
    completedByName?: StringNullableFilter<"ViewingRequest"> | string | null
    completedAt?: DateTimeNullableFilter<"ViewingRequest"> | Date | string | null
    cancelledBy?: StringNullableFilter<"ViewingRequest"> | string | null
    cancelledByName?: StringNullableFilter<"ViewingRequest"> | string | null
    cancelledAt?: DateTimeNullableFilter<"ViewingRequest"> | Date | string | null
    ipAddress?: StringNullableFilter<"ViewingRequest"> | string | null
    userAgent?: StringNullableFilter<"ViewingRequest"> | string | null
    createdAt?: DateTimeFilter<"ViewingRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ViewingRequest"> | Date | string
    property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
  }

  export type ViewingRequestOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrderInput | SortOrder
    requestType?: SortOrder
    viewingDate?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    countryCode?: SortOrder
    language?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    offerAmount?: SortOrderInput | SortOrder
    offerCurrency?: SortOrderInput | SortOrder
    status?: SortOrder
    confirmedBy?: SortOrderInput | SortOrder
    confirmedByName?: SortOrderInput | SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    completedBy?: SortOrderInput | SortOrder
    completedByName?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    cancelledBy?: SortOrderInput | SortOrder
    cancelledByName?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type ViewingRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ViewingRequestWhereInput | ViewingRequestWhereInput[]
    OR?: ViewingRequestWhereInput[]
    NOT?: ViewingRequestWhereInput | ViewingRequestWhereInput[]
    propertyId?: StringNullableFilter<"ViewingRequest"> | string | null
    requestType?: EnumRequestTypeFilter<"ViewingRequest"> | $Enums.RequestType
    viewingDate?: DateTimeNullableFilter<"ViewingRequest"> | Date | string | null
    name?: StringFilter<"ViewingRequest"> | string
    email?: StringFilter<"ViewingRequest"> | string
    phone?: StringFilter<"ViewingRequest"> | string
    countryCode?: StringFilter<"ViewingRequest"> | string
    language?: StringNullableFilter<"ViewingRequest"> | string | null
    message?: StringNullableFilter<"ViewingRequest"> | string | null
    offerAmount?: StringNullableFilter<"ViewingRequest"> | string | null
    offerCurrency?: StringNullableFilter<"ViewingRequest"> | string | null
    status?: EnumRequestStatusFilter<"ViewingRequest"> | $Enums.RequestStatus
    confirmedBy?: StringNullableFilter<"ViewingRequest"> | string | null
    confirmedByName?: StringNullableFilter<"ViewingRequest"> | string | null
    confirmedAt?: DateTimeNullableFilter<"ViewingRequest"> | Date | string | null
    completedBy?: StringNullableFilter<"ViewingRequest"> | string | null
    completedByName?: StringNullableFilter<"ViewingRequest"> | string | null
    completedAt?: DateTimeNullableFilter<"ViewingRequest"> | Date | string | null
    cancelledBy?: StringNullableFilter<"ViewingRequest"> | string | null
    cancelledByName?: StringNullableFilter<"ViewingRequest"> | string | null
    cancelledAt?: DateTimeNullableFilter<"ViewingRequest"> | Date | string | null
    ipAddress?: StringNullableFilter<"ViewingRequest"> | string | null
    userAgent?: StringNullableFilter<"ViewingRequest"> | string | null
    createdAt?: DateTimeFilter<"ViewingRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ViewingRequest"> | Date | string
    property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
  }, "id">

  export type ViewingRequestOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrderInput | SortOrder
    requestType?: SortOrder
    viewingDate?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    countryCode?: SortOrder
    language?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    offerAmount?: SortOrderInput | SortOrder
    offerCurrency?: SortOrderInput | SortOrder
    status?: SortOrder
    confirmedBy?: SortOrderInput | SortOrder
    confirmedByName?: SortOrderInput | SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    completedBy?: SortOrderInput | SortOrder
    completedByName?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    cancelledBy?: SortOrderInput | SortOrder
    cancelledByName?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ViewingRequestCountOrderByAggregateInput
    _max?: ViewingRequestMaxOrderByAggregateInput
    _min?: ViewingRequestMinOrderByAggregateInput
  }

  export type ViewingRequestScalarWhereWithAggregatesInput = {
    AND?: ViewingRequestScalarWhereWithAggregatesInput | ViewingRequestScalarWhereWithAggregatesInput[]
    OR?: ViewingRequestScalarWhereWithAggregatesInput[]
    NOT?: ViewingRequestScalarWhereWithAggregatesInput | ViewingRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ViewingRequest"> | string
    propertyId?: StringNullableWithAggregatesFilter<"ViewingRequest"> | string | null
    requestType?: EnumRequestTypeWithAggregatesFilter<"ViewingRequest"> | $Enums.RequestType
    viewingDate?: DateTimeNullableWithAggregatesFilter<"ViewingRequest"> | Date | string | null
    name?: StringWithAggregatesFilter<"ViewingRequest"> | string
    email?: StringWithAggregatesFilter<"ViewingRequest"> | string
    phone?: StringWithAggregatesFilter<"ViewingRequest"> | string
    countryCode?: StringWithAggregatesFilter<"ViewingRequest"> | string
    language?: StringNullableWithAggregatesFilter<"ViewingRequest"> | string | null
    message?: StringNullableWithAggregatesFilter<"ViewingRequest"> | string | null
    offerAmount?: StringNullableWithAggregatesFilter<"ViewingRequest"> | string | null
    offerCurrency?: StringNullableWithAggregatesFilter<"ViewingRequest"> | string | null
    status?: EnumRequestStatusWithAggregatesFilter<"ViewingRequest"> | $Enums.RequestStatus
    confirmedBy?: StringNullableWithAggregatesFilter<"ViewingRequest"> | string | null
    confirmedByName?: StringNullableWithAggregatesFilter<"ViewingRequest"> | string | null
    confirmedAt?: DateTimeNullableWithAggregatesFilter<"ViewingRequest"> | Date | string | null
    completedBy?: StringNullableWithAggregatesFilter<"ViewingRequest"> | string | null
    completedByName?: StringNullableWithAggregatesFilter<"ViewingRequest"> | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"ViewingRequest"> | Date | string | null
    cancelledBy?: StringNullableWithAggregatesFilter<"ViewingRequest"> | string | null
    cancelledByName?: StringNullableWithAggregatesFilter<"ViewingRequest"> | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"ViewingRequest"> | Date | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"ViewingRequest"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"ViewingRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ViewingRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ViewingRequest"> | Date | string
  }

  export type InvestorLeadWhereInput = {
    AND?: InvestorLeadWhereInput | InvestorLeadWhereInput[]
    OR?: InvestorLeadWhereInput[]
    NOT?: InvestorLeadWhereInput | InvestorLeadWhereInput[]
    id?: StringFilter<"InvestorLead"> | string
    name?: StringFilter<"InvestorLead"> | string
    email?: StringFilter<"InvestorLead"> | string
    phone?: StringFilter<"InvestorLead"> | string
    countryCode?: StringFilter<"InvestorLead"> | string
    currency?: StringFilter<"InvestorLead"> | string
    investmentBudget?: StringFilter<"InvestorLead"> | string
    investmentGoal?: StringFilter<"InvestorLead"> | string
    timeline?: StringFilter<"InvestorLead"> | string
    preferredAreas?: StringNullableFilter<"InvestorLead"> | string | null
    propertyType?: StringNullableFilter<"InvestorLead"> | string | null
    experience?: StringNullableFilter<"InvestorLead"> | string | null
    financing?: StringNullableFilter<"InvestorLead"> | string | null
    message?: StringNullableFilter<"InvestorLead"> | string | null
    newsletter?: BoolFilter<"InvestorLead"> | boolean
    status?: EnumLeadStatusFilter<"InvestorLead"> | $Enums.LeadStatus
    assignedToId?: StringNullableFilter<"InvestorLead"> | string | null
    ipAddress?: StringNullableFilter<"InvestorLead"> | string | null
    userAgent?: StringNullableFilter<"InvestorLead"> | string | null
    source?: StringNullableFilter<"InvestorLead"> | string | null
    createdAt?: DateTimeFilter<"InvestorLead"> | Date | string
    updatedAt?: DateTimeFilter<"InvestorLead"> | Date | string
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type InvestorLeadOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    countryCode?: SortOrder
    currency?: SortOrder
    investmentBudget?: SortOrder
    investmentGoal?: SortOrder
    timeline?: SortOrder
    preferredAreas?: SortOrderInput | SortOrder
    propertyType?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    financing?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    newsletter?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedTo?: UserOrderByWithRelationInput
  }

  export type InvestorLeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvestorLeadWhereInput | InvestorLeadWhereInput[]
    OR?: InvestorLeadWhereInput[]
    NOT?: InvestorLeadWhereInput | InvestorLeadWhereInput[]
    name?: StringFilter<"InvestorLead"> | string
    email?: StringFilter<"InvestorLead"> | string
    phone?: StringFilter<"InvestorLead"> | string
    countryCode?: StringFilter<"InvestorLead"> | string
    currency?: StringFilter<"InvestorLead"> | string
    investmentBudget?: StringFilter<"InvestorLead"> | string
    investmentGoal?: StringFilter<"InvestorLead"> | string
    timeline?: StringFilter<"InvestorLead"> | string
    preferredAreas?: StringNullableFilter<"InvestorLead"> | string | null
    propertyType?: StringNullableFilter<"InvestorLead"> | string | null
    experience?: StringNullableFilter<"InvestorLead"> | string | null
    financing?: StringNullableFilter<"InvestorLead"> | string | null
    message?: StringNullableFilter<"InvestorLead"> | string | null
    newsletter?: BoolFilter<"InvestorLead"> | boolean
    status?: EnumLeadStatusFilter<"InvestorLead"> | $Enums.LeadStatus
    assignedToId?: StringNullableFilter<"InvestorLead"> | string | null
    ipAddress?: StringNullableFilter<"InvestorLead"> | string | null
    userAgent?: StringNullableFilter<"InvestorLead"> | string | null
    source?: StringNullableFilter<"InvestorLead"> | string | null
    createdAt?: DateTimeFilter<"InvestorLead"> | Date | string
    updatedAt?: DateTimeFilter<"InvestorLead"> | Date | string
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type InvestorLeadOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    countryCode?: SortOrder
    currency?: SortOrder
    investmentBudget?: SortOrder
    investmentGoal?: SortOrder
    timeline?: SortOrder
    preferredAreas?: SortOrderInput | SortOrder
    propertyType?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    financing?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    newsletter?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvestorLeadCountOrderByAggregateInput
    _max?: InvestorLeadMaxOrderByAggregateInput
    _min?: InvestorLeadMinOrderByAggregateInput
  }

  export type InvestorLeadScalarWhereWithAggregatesInput = {
    AND?: InvestorLeadScalarWhereWithAggregatesInput | InvestorLeadScalarWhereWithAggregatesInput[]
    OR?: InvestorLeadScalarWhereWithAggregatesInput[]
    NOT?: InvestorLeadScalarWhereWithAggregatesInput | InvestorLeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvestorLead"> | string
    name?: StringWithAggregatesFilter<"InvestorLead"> | string
    email?: StringWithAggregatesFilter<"InvestorLead"> | string
    phone?: StringWithAggregatesFilter<"InvestorLead"> | string
    countryCode?: StringWithAggregatesFilter<"InvestorLead"> | string
    currency?: StringWithAggregatesFilter<"InvestorLead"> | string
    investmentBudget?: StringWithAggregatesFilter<"InvestorLead"> | string
    investmentGoal?: StringWithAggregatesFilter<"InvestorLead"> | string
    timeline?: StringWithAggregatesFilter<"InvestorLead"> | string
    preferredAreas?: StringNullableWithAggregatesFilter<"InvestorLead"> | string | null
    propertyType?: StringNullableWithAggregatesFilter<"InvestorLead"> | string | null
    experience?: StringNullableWithAggregatesFilter<"InvestorLead"> | string | null
    financing?: StringNullableWithAggregatesFilter<"InvestorLead"> | string | null
    message?: StringNullableWithAggregatesFilter<"InvestorLead"> | string | null
    newsletter?: BoolWithAggregatesFilter<"InvestorLead"> | boolean
    status?: EnumLeadStatusWithAggregatesFilter<"InvestorLead"> | $Enums.LeadStatus
    assignedToId?: StringNullableWithAggregatesFilter<"InvestorLead"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"InvestorLead"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"InvestorLead"> | string | null
    source?: StringNullableWithAggregatesFilter<"InvestorLead"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InvestorLead"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InvestorLead"> | Date | string
  }

  export type RentalLeadWhereInput = {
    AND?: RentalLeadWhereInput | RentalLeadWhereInput[]
    OR?: RentalLeadWhereInput[]
    NOT?: RentalLeadWhereInput | RentalLeadWhereInput[]
    id?: StringFilter<"RentalLead"> | string
    name?: StringFilter<"RentalLead"> | string
    email?: StringFilter<"RentalLead"> | string
    phone?: StringFilter<"RentalLead"> | string
    countryCode?: StringFilter<"RentalLead"> | string
    propertyType?: StringFilter<"RentalLead"> | string
    bedrooms?: StringFilter<"RentalLead"> | string
    budget?: StringFilter<"RentalLead"> | string
    rentalDuration?: StringFilter<"RentalLead"> | string
    preferredAreas?: StringNullableFilter<"RentalLead"> | string | null
    moveInDate?: StringNullableFilter<"RentalLead"> | string | null
    furnished?: StringNullableFilter<"RentalLead"> | string | null
    pets?: StringNullableFilter<"RentalLead"> | string | null
    message?: StringNullableFilter<"RentalLead"> | string | null
    newsletter?: BoolFilter<"RentalLead"> | boolean
    status?: EnumRentalLeadStatusFilter<"RentalLead"> | $Enums.RentalLeadStatus
    assignedToId?: StringNullableFilter<"RentalLead"> | string | null
    ipAddress?: StringNullableFilter<"RentalLead"> | string | null
    userAgent?: StringNullableFilter<"RentalLead"> | string | null
    source?: StringNullableFilter<"RentalLead"> | string | null
    createdAt?: DateTimeFilter<"RentalLead"> | Date | string
    updatedAt?: DateTimeFilter<"RentalLead"> | Date | string
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type RentalLeadOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    countryCode?: SortOrder
    propertyType?: SortOrder
    bedrooms?: SortOrder
    budget?: SortOrder
    rentalDuration?: SortOrder
    preferredAreas?: SortOrderInput | SortOrder
    moveInDate?: SortOrderInput | SortOrder
    furnished?: SortOrderInput | SortOrder
    pets?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    newsletter?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedTo?: UserOrderByWithRelationInput
  }

  export type RentalLeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RentalLeadWhereInput | RentalLeadWhereInput[]
    OR?: RentalLeadWhereInput[]
    NOT?: RentalLeadWhereInput | RentalLeadWhereInput[]
    name?: StringFilter<"RentalLead"> | string
    email?: StringFilter<"RentalLead"> | string
    phone?: StringFilter<"RentalLead"> | string
    countryCode?: StringFilter<"RentalLead"> | string
    propertyType?: StringFilter<"RentalLead"> | string
    bedrooms?: StringFilter<"RentalLead"> | string
    budget?: StringFilter<"RentalLead"> | string
    rentalDuration?: StringFilter<"RentalLead"> | string
    preferredAreas?: StringNullableFilter<"RentalLead"> | string | null
    moveInDate?: StringNullableFilter<"RentalLead"> | string | null
    furnished?: StringNullableFilter<"RentalLead"> | string | null
    pets?: StringNullableFilter<"RentalLead"> | string | null
    message?: StringNullableFilter<"RentalLead"> | string | null
    newsletter?: BoolFilter<"RentalLead"> | boolean
    status?: EnumRentalLeadStatusFilter<"RentalLead"> | $Enums.RentalLeadStatus
    assignedToId?: StringNullableFilter<"RentalLead"> | string | null
    ipAddress?: StringNullableFilter<"RentalLead"> | string | null
    userAgent?: StringNullableFilter<"RentalLead"> | string | null
    source?: StringNullableFilter<"RentalLead"> | string | null
    createdAt?: DateTimeFilter<"RentalLead"> | Date | string
    updatedAt?: DateTimeFilter<"RentalLead"> | Date | string
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type RentalLeadOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    countryCode?: SortOrder
    propertyType?: SortOrder
    bedrooms?: SortOrder
    budget?: SortOrder
    rentalDuration?: SortOrder
    preferredAreas?: SortOrderInput | SortOrder
    moveInDate?: SortOrderInput | SortOrder
    furnished?: SortOrderInput | SortOrder
    pets?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    newsletter?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RentalLeadCountOrderByAggregateInput
    _max?: RentalLeadMaxOrderByAggregateInput
    _min?: RentalLeadMinOrderByAggregateInput
  }

  export type RentalLeadScalarWhereWithAggregatesInput = {
    AND?: RentalLeadScalarWhereWithAggregatesInput | RentalLeadScalarWhereWithAggregatesInput[]
    OR?: RentalLeadScalarWhereWithAggregatesInput[]
    NOT?: RentalLeadScalarWhereWithAggregatesInput | RentalLeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RentalLead"> | string
    name?: StringWithAggregatesFilter<"RentalLead"> | string
    email?: StringWithAggregatesFilter<"RentalLead"> | string
    phone?: StringWithAggregatesFilter<"RentalLead"> | string
    countryCode?: StringWithAggregatesFilter<"RentalLead"> | string
    propertyType?: StringWithAggregatesFilter<"RentalLead"> | string
    bedrooms?: StringWithAggregatesFilter<"RentalLead"> | string
    budget?: StringWithAggregatesFilter<"RentalLead"> | string
    rentalDuration?: StringWithAggregatesFilter<"RentalLead"> | string
    preferredAreas?: StringNullableWithAggregatesFilter<"RentalLead"> | string | null
    moveInDate?: StringNullableWithAggregatesFilter<"RentalLead"> | string | null
    furnished?: StringNullableWithAggregatesFilter<"RentalLead"> | string | null
    pets?: StringNullableWithAggregatesFilter<"RentalLead"> | string | null
    message?: StringNullableWithAggregatesFilter<"RentalLead"> | string | null
    newsletter?: BoolWithAggregatesFilter<"RentalLead"> | boolean
    status?: EnumRentalLeadStatusWithAggregatesFilter<"RentalLead"> | $Enums.RentalLeadStatus
    assignedToId?: StringNullableWithAggregatesFilter<"RentalLead"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"RentalLead"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"RentalLead"> | string | null
    source?: StringNullableWithAggregatesFilter<"RentalLead"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RentalLead"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RentalLead"> | Date | string
  }

  export type BlogWhereInput = {
    AND?: BlogWhereInput | BlogWhereInput[]
    OR?: BlogWhereInput[]
    NOT?: BlogWhereInput | BlogWhereInput[]
    id?: StringFilter<"Blog"> | string
    title?: StringFilter<"Blog"> | string
    slug?: StringFilter<"Blog"> | string
    excerpt?: StringFilter<"Blog"> | string
    content?: StringFilter<"Blog"> | string
    coverImage?: StringNullableFilter<"Blog"> | string | null
    coverImageAlt?: StringNullableFilter<"Blog"> | string | null
    tag?: StringNullableFilter<"Blog"> | string | null
    metaTitle?: StringNullableFilter<"Blog"> | string | null
    metaDescription?: StringNullableFilter<"Blog"> | string | null
    categoryId?: StringNullableFilter<"Blog"> | string | null
    published?: BoolFilter<"Blog"> | boolean
    publishedAt?: DateTimeNullableFilter<"Blog"> | Date | string | null
    originalContent?: StringNullableFilter<"Blog"> | string | null
    linkOptimizedAt?: DateTimeNullableFilter<"Blog"> | Date | string | null
    internalLinkCount?: IntFilter<"Blog"> | number
    hasDynamicProperties?: BoolFilter<"Blog"> | boolean
    poiQueryParams?: StringNullableFilter<"Blog"> | string | null
    poiTemplateId?: StringNullableFilter<"Blog"> | string | null
    authorId?: StringFilter<"Blog"> | string
    createdAt?: DateTimeFilter<"Blog"> | Date | string
    updatedAt?: DateTimeFilter<"Blog"> | Date | string
    category?: XOR<BlogCategoryNullableScalarRelationFilter, BlogCategoryWhereInput> | null
    linkUsages?: LinkUsageListRelationFilter
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BlogOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    coverImage?: SortOrderInput | SortOrder
    coverImageAlt?: SortOrderInput | SortOrder
    tag?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    published?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    originalContent?: SortOrderInput | SortOrder
    linkOptimizedAt?: SortOrderInput | SortOrder
    internalLinkCount?: SortOrder
    hasDynamicProperties?: SortOrder
    poiQueryParams?: SortOrderInput | SortOrder
    poiTemplateId?: SortOrderInput | SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: BlogCategoryOrderByWithRelationInput
    linkUsages?: LinkUsageOrderByRelationAggregateInput
    author?: UserOrderByWithRelationInput
  }

  export type BlogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BlogWhereInput | BlogWhereInput[]
    OR?: BlogWhereInput[]
    NOT?: BlogWhereInput | BlogWhereInput[]
    title?: StringFilter<"Blog"> | string
    excerpt?: StringFilter<"Blog"> | string
    content?: StringFilter<"Blog"> | string
    coverImage?: StringNullableFilter<"Blog"> | string | null
    coverImageAlt?: StringNullableFilter<"Blog"> | string | null
    tag?: StringNullableFilter<"Blog"> | string | null
    metaTitle?: StringNullableFilter<"Blog"> | string | null
    metaDescription?: StringNullableFilter<"Blog"> | string | null
    categoryId?: StringNullableFilter<"Blog"> | string | null
    published?: BoolFilter<"Blog"> | boolean
    publishedAt?: DateTimeNullableFilter<"Blog"> | Date | string | null
    originalContent?: StringNullableFilter<"Blog"> | string | null
    linkOptimizedAt?: DateTimeNullableFilter<"Blog"> | Date | string | null
    internalLinkCount?: IntFilter<"Blog"> | number
    hasDynamicProperties?: BoolFilter<"Blog"> | boolean
    poiQueryParams?: StringNullableFilter<"Blog"> | string | null
    poiTemplateId?: StringNullableFilter<"Blog"> | string | null
    authorId?: StringFilter<"Blog"> | string
    createdAt?: DateTimeFilter<"Blog"> | Date | string
    updatedAt?: DateTimeFilter<"Blog"> | Date | string
    category?: XOR<BlogCategoryNullableScalarRelationFilter, BlogCategoryWhereInput> | null
    linkUsages?: LinkUsageListRelationFilter
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "slug">

  export type BlogOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    coverImage?: SortOrderInput | SortOrder
    coverImageAlt?: SortOrderInput | SortOrder
    tag?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    published?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    originalContent?: SortOrderInput | SortOrder
    linkOptimizedAt?: SortOrderInput | SortOrder
    internalLinkCount?: SortOrder
    hasDynamicProperties?: SortOrder
    poiQueryParams?: SortOrderInput | SortOrder
    poiTemplateId?: SortOrderInput | SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlogCountOrderByAggregateInput
    _avg?: BlogAvgOrderByAggregateInput
    _max?: BlogMaxOrderByAggregateInput
    _min?: BlogMinOrderByAggregateInput
    _sum?: BlogSumOrderByAggregateInput
  }

  export type BlogScalarWhereWithAggregatesInput = {
    AND?: BlogScalarWhereWithAggregatesInput | BlogScalarWhereWithAggregatesInput[]
    OR?: BlogScalarWhereWithAggregatesInput[]
    NOT?: BlogScalarWhereWithAggregatesInput | BlogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Blog"> | string
    title?: StringWithAggregatesFilter<"Blog"> | string
    slug?: StringWithAggregatesFilter<"Blog"> | string
    excerpt?: StringWithAggregatesFilter<"Blog"> | string
    content?: StringWithAggregatesFilter<"Blog"> | string
    coverImage?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    coverImageAlt?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    tag?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    categoryId?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    published?: BoolWithAggregatesFilter<"Blog"> | boolean
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Blog"> | Date | string | null
    originalContent?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    linkOptimizedAt?: DateTimeNullableWithAggregatesFilter<"Blog"> | Date | string | null
    internalLinkCount?: IntWithAggregatesFilter<"Blog"> | number
    hasDynamicProperties?: BoolWithAggregatesFilter<"Blog"> | boolean
    poiQueryParams?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    poiTemplateId?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    authorId?: StringWithAggregatesFilter<"Blog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Blog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Blog"> | Date | string
  }

  export type BlogCategoryWhereInput = {
    AND?: BlogCategoryWhereInput | BlogCategoryWhereInput[]
    OR?: BlogCategoryWhereInput[]
    NOT?: BlogCategoryWhereInput | BlogCategoryWhereInput[]
    id?: StringFilter<"BlogCategory"> | string
    name?: StringFilter<"BlogCategory"> | string
    slug?: StringFilter<"BlogCategory"> | string
    description?: StringNullableFilter<"BlogCategory"> | string | null
    parentId?: StringNullableFilter<"BlogCategory"> | string | null
    metaTitle?: StringNullableFilter<"BlogCategory"> | string | null
    metaDescription?: StringNullableFilter<"BlogCategory"> | string | null
    icon?: StringNullableFilter<"BlogCategory"> | string | null
    color?: StringNullableFilter<"BlogCategory"> | string | null
    order?: IntFilter<"BlogCategory"> | number
    isActive?: BoolFilter<"BlogCategory"> | boolean
    createdAt?: DateTimeFilter<"BlogCategory"> | Date | string
    updatedAt?: DateTimeFilter<"BlogCategory"> | Date | string
    parent?: XOR<BlogCategoryNullableScalarRelationFilter, BlogCategoryWhereInput> | null
    children?: BlogCategoryListRelationFilter
    blogs?: BlogListRelationFilter
  }

  export type BlogCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: BlogCategoryOrderByWithRelationInput
    children?: BlogCategoryOrderByRelationAggregateInput
    blogs?: BlogOrderByRelationAggregateInput
  }

  export type BlogCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BlogCategoryWhereInput | BlogCategoryWhereInput[]
    OR?: BlogCategoryWhereInput[]
    NOT?: BlogCategoryWhereInput | BlogCategoryWhereInput[]
    name?: StringFilter<"BlogCategory"> | string
    description?: StringNullableFilter<"BlogCategory"> | string | null
    parentId?: StringNullableFilter<"BlogCategory"> | string | null
    metaTitle?: StringNullableFilter<"BlogCategory"> | string | null
    metaDescription?: StringNullableFilter<"BlogCategory"> | string | null
    icon?: StringNullableFilter<"BlogCategory"> | string | null
    color?: StringNullableFilter<"BlogCategory"> | string | null
    order?: IntFilter<"BlogCategory"> | number
    isActive?: BoolFilter<"BlogCategory"> | boolean
    createdAt?: DateTimeFilter<"BlogCategory"> | Date | string
    updatedAt?: DateTimeFilter<"BlogCategory"> | Date | string
    parent?: XOR<BlogCategoryNullableScalarRelationFilter, BlogCategoryWhereInput> | null
    children?: BlogCategoryListRelationFilter
    blogs?: BlogListRelationFilter
  }, "id" | "slug">

  export type BlogCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlogCategoryCountOrderByAggregateInput
    _avg?: BlogCategoryAvgOrderByAggregateInput
    _max?: BlogCategoryMaxOrderByAggregateInput
    _min?: BlogCategoryMinOrderByAggregateInput
    _sum?: BlogCategorySumOrderByAggregateInput
  }

  export type BlogCategoryScalarWhereWithAggregatesInput = {
    AND?: BlogCategoryScalarWhereWithAggregatesInput | BlogCategoryScalarWhereWithAggregatesInput[]
    OR?: BlogCategoryScalarWhereWithAggregatesInput[]
    NOT?: BlogCategoryScalarWhereWithAggregatesInput | BlogCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogCategory"> | string
    name?: StringWithAggregatesFilter<"BlogCategory"> | string
    slug?: StringWithAggregatesFilter<"BlogCategory"> | string
    description?: StringNullableWithAggregatesFilter<"BlogCategory"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"BlogCategory"> | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"BlogCategory"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"BlogCategory"> | string | null
    icon?: StringNullableWithAggregatesFilter<"BlogCategory"> | string | null
    color?: StringNullableWithAggregatesFilter<"BlogCategory"> | string | null
    order?: IntWithAggregatesFilter<"BlogCategory"> | number
    isActive?: BoolWithAggregatesFilter<"BlogCategory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BlogCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlogCategory"> | Date | string
  }

  export type PropertySubmissionWhereInput = {
    AND?: PropertySubmissionWhereInput | PropertySubmissionWhereInput[]
    OR?: PropertySubmissionWhereInput[]
    NOT?: PropertySubmissionWhereInput | PropertySubmissionWhereInput[]
    id?: StringFilter<"PropertySubmission"> | string
    ownerName?: StringFilter<"PropertySubmission"> | string
    ownerEmail?: StringFilter<"PropertySubmission"> | string
    ownerPhone?: StringFilter<"PropertySubmission"> | string
    ownerCountryCode?: StringFilter<"PropertySubmission"> | string
    accessToken?: StringFilter<"PropertySubmission"> | string
    propertyTitle?: StringFilter<"PropertySubmission"> | string
    propertyCategory?: EnumPropertyCategoryFilter<"PropertySubmission"> | $Enums.PropertyCategory
    propertyType?: EnumPropertyTypeFilter<"PropertySubmission"> | $Enums.PropertyType
    location?: StringFilter<"PropertySubmission"> | string
    askingPrice?: StringFilter<"PropertySubmission"> | string
    beds?: IntFilter<"PropertySubmission"> | number
    baths?: FloatFilter<"PropertySubmission"> | number
    sqft?: IntFilter<"PropertySubmission"> | number
    description?: StringFilter<"PropertySubmission"> | string
    images?: StringNullableListFilter<"PropertySubmission">
    exclusiveRights?: BoolFilter<"PropertySubmission"> | boolean
    commissionRate?: FloatFilter<"PropertySubmission"> | number
    agreementAccepted?: BoolFilter<"PropertySubmission"> | boolean
    status?: EnumSubmissionStatusFilter<"PropertySubmission"> | $Enums.SubmissionStatus
    reviewNotes?: StringNullableFilter<"PropertySubmission"> | string | null
    reviewedBy?: StringNullableFilter<"PropertySubmission"> | string | null
    reviewedByName?: StringNullableFilter<"PropertySubmission"> | string | null
    reviewedAt?: DateTimeNullableFilter<"PropertySubmission"> | Date | string | null
    imagesApprovedAt?: DateTimeNullableFilter<"PropertySubmission"> | Date | string | null
    imagesApprovedBy?: StringNullableFilter<"PropertySubmission"> | string | null
    publishedAt?: DateTimeNullableFilter<"PropertySubmission"> | Date | string | null
    publishedBy?: StringNullableFilter<"PropertySubmission"> | string | null
    convertedPropertyId?: StringNullableFilter<"PropertySubmission"> | string | null
    ipAddress?: StringNullableFilter<"PropertySubmission"> | string | null
    userAgent?: StringNullableFilter<"PropertySubmission"> | string | null
    source?: StringNullableFilter<"PropertySubmission"> | string | null
    createdAt?: DateTimeFilter<"PropertySubmission"> | Date | string
    updatedAt?: DateTimeFilter<"PropertySubmission"> | Date | string
  }

  export type PropertySubmissionOrderByWithRelationInput = {
    id?: SortOrder
    ownerName?: SortOrder
    ownerEmail?: SortOrder
    ownerPhone?: SortOrder
    ownerCountryCode?: SortOrder
    accessToken?: SortOrder
    propertyTitle?: SortOrder
    propertyCategory?: SortOrder
    propertyType?: SortOrder
    location?: SortOrder
    askingPrice?: SortOrder
    beds?: SortOrder
    baths?: SortOrder
    sqft?: SortOrder
    description?: SortOrder
    images?: SortOrder
    exclusiveRights?: SortOrder
    commissionRate?: SortOrder
    agreementAccepted?: SortOrder
    status?: SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedByName?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    imagesApprovedAt?: SortOrderInput | SortOrder
    imagesApprovedBy?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    publishedBy?: SortOrderInput | SortOrder
    convertedPropertyId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertySubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accessToken?: string
    AND?: PropertySubmissionWhereInput | PropertySubmissionWhereInput[]
    OR?: PropertySubmissionWhereInput[]
    NOT?: PropertySubmissionWhereInput | PropertySubmissionWhereInput[]
    ownerName?: StringFilter<"PropertySubmission"> | string
    ownerEmail?: StringFilter<"PropertySubmission"> | string
    ownerPhone?: StringFilter<"PropertySubmission"> | string
    ownerCountryCode?: StringFilter<"PropertySubmission"> | string
    propertyTitle?: StringFilter<"PropertySubmission"> | string
    propertyCategory?: EnumPropertyCategoryFilter<"PropertySubmission"> | $Enums.PropertyCategory
    propertyType?: EnumPropertyTypeFilter<"PropertySubmission"> | $Enums.PropertyType
    location?: StringFilter<"PropertySubmission"> | string
    askingPrice?: StringFilter<"PropertySubmission"> | string
    beds?: IntFilter<"PropertySubmission"> | number
    baths?: FloatFilter<"PropertySubmission"> | number
    sqft?: IntFilter<"PropertySubmission"> | number
    description?: StringFilter<"PropertySubmission"> | string
    images?: StringNullableListFilter<"PropertySubmission">
    exclusiveRights?: BoolFilter<"PropertySubmission"> | boolean
    commissionRate?: FloatFilter<"PropertySubmission"> | number
    agreementAccepted?: BoolFilter<"PropertySubmission"> | boolean
    status?: EnumSubmissionStatusFilter<"PropertySubmission"> | $Enums.SubmissionStatus
    reviewNotes?: StringNullableFilter<"PropertySubmission"> | string | null
    reviewedBy?: StringNullableFilter<"PropertySubmission"> | string | null
    reviewedByName?: StringNullableFilter<"PropertySubmission"> | string | null
    reviewedAt?: DateTimeNullableFilter<"PropertySubmission"> | Date | string | null
    imagesApprovedAt?: DateTimeNullableFilter<"PropertySubmission"> | Date | string | null
    imagesApprovedBy?: StringNullableFilter<"PropertySubmission"> | string | null
    publishedAt?: DateTimeNullableFilter<"PropertySubmission"> | Date | string | null
    publishedBy?: StringNullableFilter<"PropertySubmission"> | string | null
    convertedPropertyId?: StringNullableFilter<"PropertySubmission"> | string | null
    ipAddress?: StringNullableFilter<"PropertySubmission"> | string | null
    userAgent?: StringNullableFilter<"PropertySubmission"> | string | null
    source?: StringNullableFilter<"PropertySubmission"> | string | null
    createdAt?: DateTimeFilter<"PropertySubmission"> | Date | string
    updatedAt?: DateTimeFilter<"PropertySubmission"> | Date | string
  }, "id" | "accessToken">

  export type PropertySubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    ownerName?: SortOrder
    ownerEmail?: SortOrder
    ownerPhone?: SortOrder
    ownerCountryCode?: SortOrder
    accessToken?: SortOrder
    propertyTitle?: SortOrder
    propertyCategory?: SortOrder
    propertyType?: SortOrder
    location?: SortOrder
    askingPrice?: SortOrder
    beds?: SortOrder
    baths?: SortOrder
    sqft?: SortOrder
    description?: SortOrder
    images?: SortOrder
    exclusiveRights?: SortOrder
    commissionRate?: SortOrder
    agreementAccepted?: SortOrder
    status?: SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedByName?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    imagesApprovedAt?: SortOrderInput | SortOrder
    imagesApprovedBy?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    publishedBy?: SortOrderInput | SortOrder
    convertedPropertyId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertySubmissionCountOrderByAggregateInput
    _avg?: PropertySubmissionAvgOrderByAggregateInput
    _max?: PropertySubmissionMaxOrderByAggregateInput
    _min?: PropertySubmissionMinOrderByAggregateInput
    _sum?: PropertySubmissionSumOrderByAggregateInput
  }

  export type PropertySubmissionScalarWhereWithAggregatesInput = {
    AND?: PropertySubmissionScalarWhereWithAggregatesInput | PropertySubmissionScalarWhereWithAggregatesInput[]
    OR?: PropertySubmissionScalarWhereWithAggregatesInput[]
    NOT?: PropertySubmissionScalarWhereWithAggregatesInput | PropertySubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertySubmission"> | string
    ownerName?: StringWithAggregatesFilter<"PropertySubmission"> | string
    ownerEmail?: StringWithAggregatesFilter<"PropertySubmission"> | string
    ownerPhone?: StringWithAggregatesFilter<"PropertySubmission"> | string
    ownerCountryCode?: StringWithAggregatesFilter<"PropertySubmission"> | string
    accessToken?: StringWithAggregatesFilter<"PropertySubmission"> | string
    propertyTitle?: StringWithAggregatesFilter<"PropertySubmission"> | string
    propertyCategory?: EnumPropertyCategoryWithAggregatesFilter<"PropertySubmission"> | $Enums.PropertyCategory
    propertyType?: EnumPropertyTypeWithAggregatesFilter<"PropertySubmission"> | $Enums.PropertyType
    location?: StringWithAggregatesFilter<"PropertySubmission"> | string
    askingPrice?: StringWithAggregatesFilter<"PropertySubmission"> | string
    beds?: IntWithAggregatesFilter<"PropertySubmission"> | number
    baths?: FloatWithAggregatesFilter<"PropertySubmission"> | number
    sqft?: IntWithAggregatesFilter<"PropertySubmission"> | number
    description?: StringWithAggregatesFilter<"PropertySubmission"> | string
    images?: StringNullableListFilter<"PropertySubmission">
    exclusiveRights?: BoolWithAggregatesFilter<"PropertySubmission"> | boolean
    commissionRate?: FloatWithAggregatesFilter<"PropertySubmission"> | number
    agreementAccepted?: BoolWithAggregatesFilter<"PropertySubmission"> | boolean
    status?: EnumSubmissionStatusWithAggregatesFilter<"PropertySubmission"> | $Enums.SubmissionStatus
    reviewNotes?: StringNullableWithAggregatesFilter<"PropertySubmission"> | string | null
    reviewedBy?: StringNullableWithAggregatesFilter<"PropertySubmission"> | string | null
    reviewedByName?: StringNullableWithAggregatesFilter<"PropertySubmission"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"PropertySubmission"> | Date | string | null
    imagesApprovedAt?: DateTimeNullableWithAggregatesFilter<"PropertySubmission"> | Date | string | null
    imagesApprovedBy?: StringNullableWithAggregatesFilter<"PropertySubmission"> | string | null
    publishedAt?: DateTimeNullableWithAggregatesFilter<"PropertySubmission"> | Date | string | null
    publishedBy?: StringNullableWithAggregatesFilter<"PropertySubmission"> | string | null
    convertedPropertyId?: StringNullableWithAggregatesFilter<"PropertySubmission"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"PropertySubmission"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"PropertySubmission"> | string | null
    source?: StringNullableWithAggregatesFilter<"PropertySubmission"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PropertySubmission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertySubmission"> | Date | string
  }

  export type SiteSettingsWhereInput = {
    AND?: SiteSettingsWhereInput | SiteSettingsWhereInput[]
    OR?: SiteSettingsWhereInput[]
    NOT?: SiteSettingsWhereInput | SiteSettingsWhereInput[]
    id?: StringFilter<"SiteSettings"> | string
    smtpHost?: StringNullableFilter<"SiteSettings"> | string | null
    smtpPort?: IntNullableFilter<"SiteSettings"> | number | null
    smtpSecure?: BoolFilter<"SiteSettings"> | boolean
    smtpUser?: StringNullableFilter<"SiteSettings"> | string | null
    smtpPassword?: StringNullableFilter<"SiteSettings"> | string | null
    smtpFromName?: StringNullableFilter<"SiteSettings"> | string | null
    smtpFromEmail?: StringNullableFilter<"SiteSettings"> | string | null
    siteName?: StringNullableFilter<"SiteSettings"> | string | null
    siteEmail?: StringNullableFilter<"SiteSettings"> | string | null
    adminNotifyEmail?: StringNullableFilter<"SiteSettings"> | string | null
    notifyOnSubmission?: BoolFilter<"SiteSettings"> | boolean
    notifyOnImageUpload?: BoolFilter<"SiteSettings"> | boolean
    companyDescription?: StringNullableFilter<"SiteSettings"> | string | null
    companyTone?: StringNullableFilter<"SiteSettings"> | string | null
    companyUSPs?: StringNullableFilter<"SiteSettings"> | string | null
    targetAudience?: StringNullableFilter<"SiteSettings"> | string | null
    brandKeywords?: StringNullableFilter<"SiteSettings"> | string | null
    avoidTopics?: StringNullableFilter<"SiteSettings"> | string | null
    websiteUrl?: StringNullableFilter<"SiteSettings"> | string | null
    lastScannedAt?: DateTimeNullableFilter<"SiteSettings"> | Date | string | null
    scannedPagesCount?: IntNullableFilter<"SiteSettings"> | number | null
    scanConfidence?: FloatNullableFilter<"SiteSettings"> | number | null
    detectedThemes?: StringNullableFilter<"SiteSettings"> | string | null
    createdAt?: DateTimeFilter<"SiteSettings"> | Date | string
    updatedAt?: DateTimeFilter<"SiteSettings"> | Date | string
  }

  export type SiteSettingsOrderByWithRelationInput = {
    id?: SortOrder
    smtpHost?: SortOrderInput | SortOrder
    smtpPort?: SortOrderInput | SortOrder
    smtpSecure?: SortOrder
    smtpUser?: SortOrderInput | SortOrder
    smtpPassword?: SortOrderInput | SortOrder
    smtpFromName?: SortOrderInput | SortOrder
    smtpFromEmail?: SortOrderInput | SortOrder
    siteName?: SortOrderInput | SortOrder
    siteEmail?: SortOrderInput | SortOrder
    adminNotifyEmail?: SortOrderInput | SortOrder
    notifyOnSubmission?: SortOrder
    notifyOnImageUpload?: SortOrder
    companyDescription?: SortOrderInput | SortOrder
    companyTone?: SortOrderInput | SortOrder
    companyUSPs?: SortOrderInput | SortOrder
    targetAudience?: SortOrderInput | SortOrder
    brandKeywords?: SortOrderInput | SortOrder
    avoidTopics?: SortOrderInput | SortOrder
    websiteUrl?: SortOrderInput | SortOrder
    lastScannedAt?: SortOrderInput | SortOrder
    scannedPagesCount?: SortOrderInput | SortOrder
    scanConfidence?: SortOrderInput | SortOrder
    detectedThemes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SiteSettingsWhereInput | SiteSettingsWhereInput[]
    OR?: SiteSettingsWhereInput[]
    NOT?: SiteSettingsWhereInput | SiteSettingsWhereInput[]
    smtpHost?: StringNullableFilter<"SiteSettings"> | string | null
    smtpPort?: IntNullableFilter<"SiteSettings"> | number | null
    smtpSecure?: BoolFilter<"SiteSettings"> | boolean
    smtpUser?: StringNullableFilter<"SiteSettings"> | string | null
    smtpPassword?: StringNullableFilter<"SiteSettings"> | string | null
    smtpFromName?: StringNullableFilter<"SiteSettings"> | string | null
    smtpFromEmail?: StringNullableFilter<"SiteSettings"> | string | null
    siteName?: StringNullableFilter<"SiteSettings"> | string | null
    siteEmail?: StringNullableFilter<"SiteSettings"> | string | null
    adminNotifyEmail?: StringNullableFilter<"SiteSettings"> | string | null
    notifyOnSubmission?: BoolFilter<"SiteSettings"> | boolean
    notifyOnImageUpload?: BoolFilter<"SiteSettings"> | boolean
    companyDescription?: StringNullableFilter<"SiteSettings"> | string | null
    companyTone?: StringNullableFilter<"SiteSettings"> | string | null
    companyUSPs?: StringNullableFilter<"SiteSettings"> | string | null
    targetAudience?: StringNullableFilter<"SiteSettings"> | string | null
    brandKeywords?: StringNullableFilter<"SiteSettings"> | string | null
    avoidTopics?: StringNullableFilter<"SiteSettings"> | string | null
    websiteUrl?: StringNullableFilter<"SiteSettings"> | string | null
    lastScannedAt?: DateTimeNullableFilter<"SiteSettings"> | Date | string | null
    scannedPagesCount?: IntNullableFilter<"SiteSettings"> | number | null
    scanConfidence?: FloatNullableFilter<"SiteSettings"> | number | null
    detectedThemes?: StringNullableFilter<"SiteSettings"> | string | null
    createdAt?: DateTimeFilter<"SiteSettings"> | Date | string
    updatedAt?: DateTimeFilter<"SiteSettings"> | Date | string
  }, "id">

  export type SiteSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    smtpHost?: SortOrderInput | SortOrder
    smtpPort?: SortOrderInput | SortOrder
    smtpSecure?: SortOrder
    smtpUser?: SortOrderInput | SortOrder
    smtpPassword?: SortOrderInput | SortOrder
    smtpFromName?: SortOrderInput | SortOrder
    smtpFromEmail?: SortOrderInput | SortOrder
    siteName?: SortOrderInput | SortOrder
    siteEmail?: SortOrderInput | SortOrder
    adminNotifyEmail?: SortOrderInput | SortOrder
    notifyOnSubmission?: SortOrder
    notifyOnImageUpload?: SortOrder
    companyDescription?: SortOrderInput | SortOrder
    companyTone?: SortOrderInput | SortOrder
    companyUSPs?: SortOrderInput | SortOrder
    targetAudience?: SortOrderInput | SortOrder
    brandKeywords?: SortOrderInput | SortOrder
    avoidTopics?: SortOrderInput | SortOrder
    websiteUrl?: SortOrderInput | SortOrder
    lastScannedAt?: SortOrderInput | SortOrder
    scannedPagesCount?: SortOrderInput | SortOrder
    scanConfidence?: SortOrderInput | SortOrder
    detectedThemes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SiteSettingsCountOrderByAggregateInput
    _avg?: SiteSettingsAvgOrderByAggregateInput
    _max?: SiteSettingsMaxOrderByAggregateInput
    _min?: SiteSettingsMinOrderByAggregateInput
    _sum?: SiteSettingsSumOrderByAggregateInput
  }

  export type SiteSettingsScalarWhereWithAggregatesInput = {
    AND?: SiteSettingsScalarWhereWithAggregatesInput | SiteSettingsScalarWhereWithAggregatesInput[]
    OR?: SiteSettingsScalarWhereWithAggregatesInput[]
    NOT?: SiteSettingsScalarWhereWithAggregatesInput | SiteSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SiteSettings"> | string
    smtpHost?: StringNullableWithAggregatesFilter<"SiteSettings"> | string | null
    smtpPort?: IntNullableWithAggregatesFilter<"SiteSettings"> | number | null
    smtpSecure?: BoolWithAggregatesFilter<"SiteSettings"> | boolean
    smtpUser?: StringNullableWithAggregatesFilter<"SiteSettings"> | string | null
    smtpPassword?: StringNullableWithAggregatesFilter<"SiteSettings"> | string | null
    smtpFromName?: StringNullableWithAggregatesFilter<"SiteSettings"> | string | null
    smtpFromEmail?: StringNullableWithAggregatesFilter<"SiteSettings"> | string | null
    siteName?: StringNullableWithAggregatesFilter<"SiteSettings"> | string | null
    siteEmail?: StringNullableWithAggregatesFilter<"SiteSettings"> | string | null
    adminNotifyEmail?: StringNullableWithAggregatesFilter<"SiteSettings"> | string | null
    notifyOnSubmission?: BoolWithAggregatesFilter<"SiteSettings"> | boolean
    notifyOnImageUpload?: BoolWithAggregatesFilter<"SiteSettings"> | boolean
    companyDescription?: StringNullableWithAggregatesFilter<"SiteSettings"> | string | null
    companyTone?: StringNullableWithAggregatesFilter<"SiteSettings"> | string | null
    companyUSPs?: StringNullableWithAggregatesFilter<"SiteSettings"> | string | null
    targetAudience?: StringNullableWithAggregatesFilter<"SiteSettings"> | string | null
    brandKeywords?: StringNullableWithAggregatesFilter<"SiteSettings"> | string | null
    avoidTopics?: StringNullableWithAggregatesFilter<"SiteSettings"> | string | null
    websiteUrl?: StringNullableWithAggregatesFilter<"SiteSettings"> | string | null
    lastScannedAt?: DateTimeNullableWithAggregatesFilter<"SiteSettings"> | Date | string | null
    scannedPagesCount?: IntNullableWithAggregatesFilter<"SiteSettings"> | number | null
    scanConfidence?: FloatNullableWithAggregatesFilter<"SiteSettings"> | number | null
    detectedThemes?: StringNullableWithAggregatesFilter<"SiteSettings"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SiteSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SiteSettings"> | Date | string
  }

  export type InternalLinkWhereInput = {
    AND?: InternalLinkWhereInput | InternalLinkWhereInput[]
    OR?: InternalLinkWhereInput[]
    NOT?: InternalLinkWhereInput | InternalLinkWhereInput[]
    id?: StringFilter<"InternalLink"> | string
    url?: StringFilter<"InternalLink"> | string
    title?: StringFilter<"InternalLink"> | string
    description?: StringNullableFilter<"InternalLink"> | string | null
    category?: StringNullableFilter<"InternalLink"> | string | null
    subCategory?: StringNullableFilter<"InternalLink"> | string | null
    keywords?: StringNullableFilter<"InternalLink"> | string | null
    anchorTexts?: StringNullableFilter<"InternalLink"> | string | null
    priority?: IntFilter<"InternalLink"> | number
    isActive?: BoolFilter<"InternalLink"> | boolean
    usageCount?: IntFilter<"InternalLink"> | number
    pageExists?: BoolFilter<"InternalLink"> | boolean
    lastChecked?: DateTimeNullableFilter<"InternalLink"> | Date | string | null
    createdAt?: DateTimeFilter<"InternalLink"> | Date | string
    updatedAt?: DateTimeFilter<"InternalLink"> | Date | string
    usages?: LinkUsageListRelationFilter
  }

  export type InternalLinkOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    subCategory?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    anchorTexts?: SortOrderInput | SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    usageCount?: SortOrder
    pageExists?: SortOrder
    lastChecked?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usages?: LinkUsageOrderByRelationAggregateInput
  }

  export type InternalLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    url?: string
    AND?: InternalLinkWhereInput | InternalLinkWhereInput[]
    OR?: InternalLinkWhereInput[]
    NOT?: InternalLinkWhereInput | InternalLinkWhereInput[]
    title?: StringFilter<"InternalLink"> | string
    description?: StringNullableFilter<"InternalLink"> | string | null
    category?: StringNullableFilter<"InternalLink"> | string | null
    subCategory?: StringNullableFilter<"InternalLink"> | string | null
    keywords?: StringNullableFilter<"InternalLink"> | string | null
    anchorTexts?: StringNullableFilter<"InternalLink"> | string | null
    priority?: IntFilter<"InternalLink"> | number
    isActive?: BoolFilter<"InternalLink"> | boolean
    usageCount?: IntFilter<"InternalLink"> | number
    pageExists?: BoolFilter<"InternalLink"> | boolean
    lastChecked?: DateTimeNullableFilter<"InternalLink"> | Date | string | null
    createdAt?: DateTimeFilter<"InternalLink"> | Date | string
    updatedAt?: DateTimeFilter<"InternalLink"> | Date | string
    usages?: LinkUsageListRelationFilter
  }, "id" | "url">

  export type InternalLinkOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    subCategory?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    anchorTexts?: SortOrderInput | SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    usageCount?: SortOrder
    pageExists?: SortOrder
    lastChecked?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InternalLinkCountOrderByAggregateInput
    _avg?: InternalLinkAvgOrderByAggregateInput
    _max?: InternalLinkMaxOrderByAggregateInput
    _min?: InternalLinkMinOrderByAggregateInput
    _sum?: InternalLinkSumOrderByAggregateInput
  }

  export type InternalLinkScalarWhereWithAggregatesInput = {
    AND?: InternalLinkScalarWhereWithAggregatesInput | InternalLinkScalarWhereWithAggregatesInput[]
    OR?: InternalLinkScalarWhereWithAggregatesInput[]
    NOT?: InternalLinkScalarWhereWithAggregatesInput | InternalLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InternalLink"> | string
    url?: StringWithAggregatesFilter<"InternalLink"> | string
    title?: StringWithAggregatesFilter<"InternalLink"> | string
    description?: StringNullableWithAggregatesFilter<"InternalLink"> | string | null
    category?: StringNullableWithAggregatesFilter<"InternalLink"> | string | null
    subCategory?: StringNullableWithAggregatesFilter<"InternalLink"> | string | null
    keywords?: StringNullableWithAggregatesFilter<"InternalLink"> | string | null
    anchorTexts?: StringNullableWithAggregatesFilter<"InternalLink"> | string | null
    priority?: IntWithAggregatesFilter<"InternalLink"> | number
    isActive?: BoolWithAggregatesFilter<"InternalLink"> | boolean
    usageCount?: IntWithAggregatesFilter<"InternalLink"> | number
    pageExists?: BoolWithAggregatesFilter<"InternalLink"> | boolean
    lastChecked?: DateTimeNullableWithAggregatesFilter<"InternalLink"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InternalLink"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InternalLink"> | Date | string
  }

  export type LinkUsageWhereInput = {
    AND?: LinkUsageWhereInput | LinkUsageWhereInput[]
    OR?: LinkUsageWhereInput[]
    NOT?: LinkUsageWhereInput | LinkUsageWhereInput[]
    id?: StringFilter<"LinkUsage"> | string
    linkId?: StringFilter<"LinkUsage"> | string
    blogId?: StringFilter<"LinkUsage"> | string
    anchorText?: StringFilter<"LinkUsage"> | string
    context?: StringNullableFilter<"LinkUsage"> | string | null
    position?: IntNullableFilter<"LinkUsage"> | number | null
    wasAutoInserted?: BoolFilter<"LinkUsage"> | boolean
    insertedAt?: DateTimeFilter<"LinkUsage"> | Date | string
    createdAt?: DateTimeFilter<"LinkUsage"> | Date | string
    link?: XOR<InternalLinkScalarRelationFilter, InternalLinkWhereInput>
    blog?: XOR<BlogScalarRelationFilter, BlogWhereInput>
  }

  export type LinkUsageOrderByWithRelationInput = {
    id?: SortOrder
    linkId?: SortOrder
    blogId?: SortOrder
    anchorText?: SortOrder
    context?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    wasAutoInserted?: SortOrder
    insertedAt?: SortOrder
    createdAt?: SortOrder
    link?: InternalLinkOrderByWithRelationInput
    blog?: BlogOrderByWithRelationInput
  }

  export type LinkUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LinkUsageWhereInput | LinkUsageWhereInput[]
    OR?: LinkUsageWhereInput[]
    NOT?: LinkUsageWhereInput | LinkUsageWhereInput[]
    linkId?: StringFilter<"LinkUsage"> | string
    blogId?: StringFilter<"LinkUsage"> | string
    anchorText?: StringFilter<"LinkUsage"> | string
    context?: StringNullableFilter<"LinkUsage"> | string | null
    position?: IntNullableFilter<"LinkUsage"> | number | null
    wasAutoInserted?: BoolFilter<"LinkUsage"> | boolean
    insertedAt?: DateTimeFilter<"LinkUsage"> | Date | string
    createdAt?: DateTimeFilter<"LinkUsage"> | Date | string
    link?: XOR<InternalLinkScalarRelationFilter, InternalLinkWhereInput>
    blog?: XOR<BlogScalarRelationFilter, BlogWhereInput>
  }, "id">

  export type LinkUsageOrderByWithAggregationInput = {
    id?: SortOrder
    linkId?: SortOrder
    blogId?: SortOrder
    anchorText?: SortOrder
    context?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    wasAutoInserted?: SortOrder
    insertedAt?: SortOrder
    createdAt?: SortOrder
    _count?: LinkUsageCountOrderByAggregateInput
    _avg?: LinkUsageAvgOrderByAggregateInput
    _max?: LinkUsageMaxOrderByAggregateInput
    _min?: LinkUsageMinOrderByAggregateInput
    _sum?: LinkUsageSumOrderByAggregateInput
  }

  export type LinkUsageScalarWhereWithAggregatesInput = {
    AND?: LinkUsageScalarWhereWithAggregatesInput | LinkUsageScalarWhereWithAggregatesInput[]
    OR?: LinkUsageScalarWhereWithAggregatesInput[]
    NOT?: LinkUsageScalarWhereWithAggregatesInput | LinkUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LinkUsage"> | string
    linkId?: StringWithAggregatesFilter<"LinkUsage"> | string
    blogId?: StringWithAggregatesFilter<"LinkUsage"> | string
    anchorText?: StringWithAggregatesFilter<"LinkUsage"> | string
    context?: StringNullableWithAggregatesFilter<"LinkUsage"> | string | null
    position?: IntNullableWithAggregatesFilter<"LinkUsage"> | number | null
    wasAutoInserted?: BoolWithAggregatesFilter<"LinkUsage"> | boolean
    insertedAt?: DateTimeWithAggregatesFilter<"LinkUsage"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"LinkUsage"> | Date | string
  }

  export type LandingPageSuggestionWhereInput = {
    AND?: LandingPageSuggestionWhereInput | LandingPageSuggestionWhereInput[]
    OR?: LandingPageSuggestionWhereInput[]
    NOT?: LandingPageSuggestionWhereInput | LandingPageSuggestionWhereInput[]
    id?: StringFilter<"LandingPageSuggestion"> | string
    suggestedUrl?: StringFilter<"LandingPageSuggestion"> | string
    suggestedTitle?: StringFilter<"LandingPageSuggestion"> | string
    description?: StringNullableFilter<"LandingPageSuggestion"> | string | null
    category?: StringFilter<"LandingPageSuggestion"> | string
    reason?: StringNullableFilter<"LandingPageSuggestion"> | string | null
    mentionCount?: IntFilter<"LandingPageSuggestion"> | number
    sourceBlogs?: StringNullableFilter<"LandingPageSuggestion"> | string | null
    status?: EnumLandingPageStatusFilter<"LandingPageSuggestion"> | $Enums.LandingPageStatus
    createdPageUrl?: StringNullableFilter<"LandingPageSuggestion"> | string | null
    createdAt?: DateTimeFilter<"LandingPageSuggestion"> | Date | string
    updatedAt?: DateTimeFilter<"LandingPageSuggestion"> | Date | string
  }

  export type LandingPageSuggestionOrderByWithRelationInput = {
    id?: SortOrder
    suggestedUrl?: SortOrder
    suggestedTitle?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    reason?: SortOrderInput | SortOrder
    mentionCount?: SortOrder
    sourceBlogs?: SortOrderInput | SortOrder
    status?: SortOrder
    createdPageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LandingPageSuggestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    suggestedUrl?: string
    AND?: LandingPageSuggestionWhereInput | LandingPageSuggestionWhereInput[]
    OR?: LandingPageSuggestionWhereInput[]
    NOT?: LandingPageSuggestionWhereInput | LandingPageSuggestionWhereInput[]
    suggestedTitle?: StringFilter<"LandingPageSuggestion"> | string
    description?: StringNullableFilter<"LandingPageSuggestion"> | string | null
    category?: StringFilter<"LandingPageSuggestion"> | string
    reason?: StringNullableFilter<"LandingPageSuggestion"> | string | null
    mentionCount?: IntFilter<"LandingPageSuggestion"> | number
    sourceBlogs?: StringNullableFilter<"LandingPageSuggestion"> | string | null
    status?: EnumLandingPageStatusFilter<"LandingPageSuggestion"> | $Enums.LandingPageStatus
    createdPageUrl?: StringNullableFilter<"LandingPageSuggestion"> | string | null
    createdAt?: DateTimeFilter<"LandingPageSuggestion"> | Date | string
    updatedAt?: DateTimeFilter<"LandingPageSuggestion"> | Date | string
  }, "id" | "suggestedUrl">

  export type LandingPageSuggestionOrderByWithAggregationInput = {
    id?: SortOrder
    suggestedUrl?: SortOrder
    suggestedTitle?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    reason?: SortOrderInput | SortOrder
    mentionCount?: SortOrder
    sourceBlogs?: SortOrderInput | SortOrder
    status?: SortOrder
    createdPageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LandingPageSuggestionCountOrderByAggregateInput
    _avg?: LandingPageSuggestionAvgOrderByAggregateInput
    _max?: LandingPageSuggestionMaxOrderByAggregateInput
    _min?: LandingPageSuggestionMinOrderByAggregateInput
    _sum?: LandingPageSuggestionSumOrderByAggregateInput
  }

  export type LandingPageSuggestionScalarWhereWithAggregatesInput = {
    AND?: LandingPageSuggestionScalarWhereWithAggregatesInput | LandingPageSuggestionScalarWhereWithAggregatesInput[]
    OR?: LandingPageSuggestionScalarWhereWithAggregatesInput[]
    NOT?: LandingPageSuggestionScalarWhereWithAggregatesInput | LandingPageSuggestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LandingPageSuggestion"> | string
    suggestedUrl?: StringWithAggregatesFilter<"LandingPageSuggestion"> | string
    suggestedTitle?: StringWithAggregatesFilter<"LandingPageSuggestion"> | string
    description?: StringNullableWithAggregatesFilter<"LandingPageSuggestion"> | string | null
    category?: StringWithAggregatesFilter<"LandingPageSuggestion"> | string
    reason?: StringNullableWithAggregatesFilter<"LandingPageSuggestion"> | string | null
    mentionCount?: IntWithAggregatesFilter<"LandingPageSuggestion"> | number
    sourceBlogs?: StringNullableWithAggregatesFilter<"LandingPageSuggestion"> | string | null
    status?: EnumLandingPageStatusWithAggregatesFilter<"LandingPageSuggestion"> | $Enums.LandingPageStatus
    createdPageUrl?: StringNullableWithAggregatesFilter<"LandingPageSuggestion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LandingPageSuggestion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LandingPageSuggestion"> | Date | string
  }

  export type LandingPageWhereInput = {
    AND?: LandingPageWhereInput | LandingPageWhereInput[]
    OR?: LandingPageWhereInput[]
    NOT?: LandingPageWhereInput | LandingPageWhereInput[]
    id?: StringFilter<"LandingPage"> | string
    url?: StringFilter<"LandingPage"> | string
    title?: StringFilter<"LandingPage"> | string
    category?: StringFilter<"LandingPage"> | string
    metaTitle?: StringNullableFilter<"LandingPage"> | string | null
    metaDescription?: StringNullableFilter<"LandingPage"> | string | null
    content?: StringFilter<"LandingPage"> | string
    faq?: JsonNullableFilter<"LandingPage">
    published?: BoolFilter<"LandingPage"> | boolean
    createdAt?: DateTimeFilter<"LandingPage"> | Date | string
    updatedAt?: DateTimeFilter<"LandingPage"> | Date | string
  }

  export type LandingPageOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    category?: SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    content?: SortOrder
    faq?: SortOrderInput | SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LandingPageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    url?: string
    AND?: LandingPageWhereInput | LandingPageWhereInput[]
    OR?: LandingPageWhereInput[]
    NOT?: LandingPageWhereInput | LandingPageWhereInput[]
    title?: StringFilter<"LandingPage"> | string
    category?: StringFilter<"LandingPage"> | string
    metaTitle?: StringNullableFilter<"LandingPage"> | string | null
    metaDescription?: StringNullableFilter<"LandingPage"> | string | null
    content?: StringFilter<"LandingPage"> | string
    faq?: JsonNullableFilter<"LandingPage">
    published?: BoolFilter<"LandingPage"> | boolean
    createdAt?: DateTimeFilter<"LandingPage"> | Date | string
    updatedAt?: DateTimeFilter<"LandingPage"> | Date | string
  }, "id" | "url">

  export type LandingPageOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    category?: SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    content?: SortOrder
    faq?: SortOrderInput | SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LandingPageCountOrderByAggregateInput
    _max?: LandingPageMaxOrderByAggregateInput
    _min?: LandingPageMinOrderByAggregateInput
  }

  export type LandingPageScalarWhereWithAggregatesInput = {
    AND?: LandingPageScalarWhereWithAggregatesInput | LandingPageScalarWhereWithAggregatesInput[]
    OR?: LandingPageScalarWhereWithAggregatesInput[]
    NOT?: LandingPageScalarWhereWithAggregatesInput | LandingPageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LandingPage"> | string
    url?: StringWithAggregatesFilter<"LandingPage"> | string
    title?: StringWithAggregatesFilter<"LandingPage"> | string
    category?: StringWithAggregatesFilter<"LandingPage"> | string
    metaTitle?: StringNullableWithAggregatesFilter<"LandingPage"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"LandingPage"> | string | null
    content?: StringWithAggregatesFilter<"LandingPage"> | string
    faq?: JsonNullableWithAggregatesFilter<"LandingPage">
    published?: BoolWithAggregatesFilter<"LandingPage"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LandingPage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LandingPage"> | Date | string
  }

  export type CompanyProfileWhereInput = {
    AND?: CompanyProfileWhereInput | CompanyProfileWhereInput[]
    OR?: CompanyProfileWhereInput[]
    NOT?: CompanyProfileWhereInput | CompanyProfileWhereInput[]
    id?: StringFilter<"CompanyProfile"> | string
    companyName?: StringNullableFilter<"CompanyProfile"> | string | null
    tagline?: StringNullableFilter<"CompanyProfile"> | string | null
    description?: StringNullableFilter<"CompanyProfile"> | string | null
    tone?: StringNullableFilter<"CompanyProfile"> | string | null
    writingStyle?: StringNullableFilter<"CompanyProfile"> | string | null
    targetAudience?: StringNullableFilter<"CompanyProfile"> | string | null
    targetLocations?: StringNullableFilter<"CompanyProfile"> | string | null
    usps?: StringNullableFilter<"CompanyProfile"> | string | null
    expertise?: StringNullableFilter<"CompanyProfile"> | string | null
    contentThemes?: StringNullableFilter<"CompanyProfile"> | string | null
    brandKeywords?: StringNullableFilter<"CompanyProfile"> | string | null
    avoidTopics?: StringNullableFilter<"CompanyProfile"> | string | null
    competitors?: StringNullableFilter<"CompanyProfile"> | string | null
    websiteUrl?: StringNullableFilter<"CompanyProfile"> | string | null
    lastAnalyzedAt?: DateTimeNullableFilter<"CompanyProfile"> | Date | string | null
    analysisData?: StringNullableFilter<"CompanyProfile"> | string | null
    createdAt?: DateTimeFilter<"CompanyProfile"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyProfile"> | Date | string
  }

  export type CompanyProfileOrderByWithRelationInput = {
    id?: SortOrder
    companyName?: SortOrderInput | SortOrder
    tagline?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    tone?: SortOrderInput | SortOrder
    writingStyle?: SortOrderInput | SortOrder
    targetAudience?: SortOrderInput | SortOrder
    targetLocations?: SortOrderInput | SortOrder
    usps?: SortOrderInput | SortOrder
    expertise?: SortOrderInput | SortOrder
    contentThemes?: SortOrderInput | SortOrder
    brandKeywords?: SortOrderInput | SortOrder
    avoidTopics?: SortOrderInput | SortOrder
    competitors?: SortOrderInput | SortOrder
    websiteUrl?: SortOrderInput | SortOrder
    lastAnalyzedAt?: SortOrderInput | SortOrder
    analysisData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyProfileWhereInput | CompanyProfileWhereInput[]
    OR?: CompanyProfileWhereInput[]
    NOT?: CompanyProfileWhereInput | CompanyProfileWhereInput[]
    companyName?: StringNullableFilter<"CompanyProfile"> | string | null
    tagline?: StringNullableFilter<"CompanyProfile"> | string | null
    description?: StringNullableFilter<"CompanyProfile"> | string | null
    tone?: StringNullableFilter<"CompanyProfile"> | string | null
    writingStyle?: StringNullableFilter<"CompanyProfile"> | string | null
    targetAudience?: StringNullableFilter<"CompanyProfile"> | string | null
    targetLocations?: StringNullableFilter<"CompanyProfile"> | string | null
    usps?: StringNullableFilter<"CompanyProfile"> | string | null
    expertise?: StringNullableFilter<"CompanyProfile"> | string | null
    contentThemes?: StringNullableFilter<"CompanyProfile"> | string | null
    brandKeywords?: StringNullableFilter<"CompanyProfile"> | string | null
    avoidTopics?: StringNullableFilter<"CompanyProfile"> | string | null
    competitors?: StringNullableFilter<"CompanyProfile"> | string | null
    websiteUrl?: StringNullableFilter<"CompanyProfile"> | string | null
    lastAnalyzedAt?: DateTimeNullableFilter<"CompanyProfile"> | Date | string | null
    analysisData?: StringNullableFilter<"CompanyProfile"> | string | null
    createdAt?: DateTimeFilter<"CompanyProfile"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyProfile"> | Date | string
  }, "id">

  export type CompanyProfileOrderByWithAggregationInput = {
    id?: SortOrder
    companyName?: SortOrderInput | SortOrder
    tagline?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    tone?: SortOrderInput | SortOrder
    writingStyle?: SortOrderInput | SortOrder
    targetAudience?: SortOrderInput | SortOrder
    targetLocations?: SortOrderInput | SortOrder
    usps?: SortOrderInput | SortOrder
    expertise?: SortOrderInput | SortOrder
    contentThemes?: SortOrderInput | SortOrder
    brandKeywords?: SortOrderInput | SortOrder
    avoidTopics?: SortOrderInput | SortOrder
    competitors?: SortOrderInput | SortOrder
    websiteUrl?: SortOrderInput | SortOrder
    lastAnalyzedAt?: SortOrderInput | SortOrder
    analysisData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyProfileCountOrderByAggregateInput
    _max?: CompanyProfileMaxOrderByAggregateInput
    _min?: CompanyProfileMinOrderByAggregateInput
  }

  export type CompanyProfileScalarWhereWithAggregatesInput = {
    AND?: CompanyProfileScalarWhereWithAggregatesInput | CompanyProfileScalarWhereWithAggregatesInput[]
    OR?: CompanyProfileScalarWhereWithAggregatesInput[]
    NOT?: CompanyProfileScalarWhereWithAggregatesInput | CompanyProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompanyProfile"> | string
    companyName?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    tagline?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    description?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    tone?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    writingStyle?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    targetAudience?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    targetLocations?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    usps?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    expertise?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    contentThemes?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    brandKeywords?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    avoidTopics?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    competitors?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    websiteUrl?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    lastAnalyzedAt?: DateTimeNullableWithAggregatesFilter<"CompanyProfile"> | Date | string | null
    analysisData?: StringNullableWithAggregatesFilter<"CompanyProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CompanyProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanyProfile"> | Date | string
  }

  export type BlogScheduleSettingsWhereInput = {
    AND?: BlogScheduleSettingsWhereInput | BlogScheduleSettingsWhereInput[]
    OR?: BlogScheduleSettingsWhereInput[]
    NOT?: BlogScheduleSettingsWhereInput | BlogScheduleSettingsWhereInput[]
    id?: StringFilter<"BlogScheduleSettings"> | string
    maxBlogsPerWeek?: IntFilter<"BlogScheduleSettings"> | number
    minDaysBetweenPosts?: IntFilter<"BlogScheduleSettings"> | number
    preferredPostTime?: StringNullableFilter<"BlogScheduleSettings"> | string | null
    preferredPostDays?: StringNullableFilter<"BlogScheduleSettings"> | string | null
    createdAt?: DateTimeFilter<"BlogScheduleSettings"> | Date | string
    updatedAt?: DateTimeFilter<"BlogScheduleSettings"> | Date | string
  }

  export type BlogScheduleSettingsOrderByWithRelationInput = {
    id?: SortOrder
    maxBlogsPerWeek?: SortOrder
    minDaysBetweenPosts?: SortOrder
    preferredPostTime?: SortOrderInput | SortOrder
    preferredPostDays?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogScheduleSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BlogScheduleSettingsWhereInput | BlogScheduleSettingsWhereInput[]
    OR?: BlogScheduleSettingsWhereInput[]
    NOT?: BlogScheduleSettingsWhereInput | BlogScheduleSettingsWhereInput[]
    maxBlogsPerWeek?: IntFilter<"BlogScheduleSettings"> | number
    minDaysBetweenPosts?: IntFilter<"BlogScheduleSettings"> | number
    preferredPostTime?: StringNullableFilter<"BlogScheduleSettings"> | string | null
    preferredPostDays?: StringNullableFilter<"BlogScheduleSettings"> | string | null
    createdAt?: DateTimeFilter<"BlogScheduleSettings"> | Date | string
    updatedAt?: DateTimeFilter<"BlogScheduleSettings"> | Date | string
  }, "id">

  export type BlogScheduleSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    maxBlogsPerWeek?: SortOrder
    minDaysBetweenPosts?: SortOrder
    preferredPostTime?: SortOrderInput | SortOrder
    preferredPostDays?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlogScheduleSettingsCountOrderByAggregateInput
    _avg?: BlogScheduleSettingsAvgOrderByAggregateInput
    _max?: BlogScheduleSettingsMaxOrderByAggregateInput
    _min?: BlogScheduleSettingsMinOrderByAggregateInput
    _sum?: BlogScheduleSettingsSumOrderByAggregateInput
  }

  export type BlogScheduleSettingsScalarWhereWithAggregatesInput = {
    AND?: BlogScheduleSettingsScalarWhereWithAggregatesInput | BlogScheduleSettingsScalarWhereWithAggregatesInput[]
    OR?: BlogScheduleSettingsScalarWhereWithAggregatesInput[]
    NOT?: BlogScheduleSettingsScalarWhereWithAggregatesInput | BlogScheduleSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogScheduleSettings"> | string
    maxBlogsPerWeek?: IntWithAggregatesFilter<"BlogScheduleSettings"> | number
    minDaysBetweenPosts?: IntWithAggregatesFilter<"BlogScheduleSettings"> | number
    preferredPostTime?: StringNullableWithAggregatesFilter<"BlogScheduleSettings"> | string | null
    preferredPostDays?: StringNullableWithAggregatesFilter<"BlogScheduleSettings"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BlogScheduleSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlogScheduleSettings"> | Date | string
  }

  export type TopicSuggestionWhereInput = {
    AND?: TopicSuggestionWhereInput | TopicSuggestionWhereInput[]
    OR?: TopicSuggestionWhereInput[]
    NOT?: TopicSuggestionWhereInput | TopicSuggestionWhereInput[]
    id?: StringFilter<"TopicSuggestion"> | string
    title?: StringFilter<"TopicSuggestion"> | string
    description?: StringNullableFilter<"TopicSuggestion"> | string | null
    category?: StringNullableFilter<"TopicSuggestion"> | string | null
    priority?: StringNullableFilter<"TopicSuggestion"> | string | null
    difficulty?: StringNullableFilter<"TopicSuggestion"> | string | null
    estimatedImpact?: StringNullableFilter<"TopicSuggestion"> | string | null
    language?: StringFilter<"TopicSuggestion"> | string
    status?: EnumTopicStatusFilter<"TopicSuggestion"> | $Enums.TopicStatus
    usedAt?: DateTimeNullableFilter<"TopicSuggestion"> | Date | string | null
    generatedBlogId?: StringNullableFilter<"TopicSuggestion"> | string | null
    batchId?: StringNullableFilter<"TopicSuggestion"> | string | null
    createdAt?: DateTimeFilter<"TopicSuggestion"> | Date | string
    updatedAt?: DateTimeFilter<"TopicSuggestion"> | Date | string
  }

  export type TopicSuggestionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    estimatedImpact?: SortOrderInput | SortOrder
    language?: SortOrder
    status?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    generatedBlogId?: SortOrderInput | SortOrder
    batchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicSuggestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TopicSuggestionWhereInput | TopicSuggestionWhereInput[]
    OR?: TopicSuggestionWhereInput[]
    NOT?: TopicSuggestionWhereInput | TopicSuggestionWhereInput[]
    title?: StringFilter<"TopicSuggestion"> | string
    description?: StringNullableFilter<"TopicSuggestion"> | string | null
    category?: StringNullableFilter<"TopicSuggestion"> | string | null
    priority?: StringNullableFilter<"TopicSuggestion"> | string | null
    difficulty?: StringNullableFilter<"TopicSuggestion"> | string | null
    estimatedImpact?: StringNullableFilter<"TopicSuggestion"> | string | null
    language?: StringFilter<"TopicSuggestion"> | string
    status?: EnumTopicStatusFilter<"TopicSuggestion"> | $Enums.TopicStatus
    usedAt?: DateTimeNullableFilter<"TopicSuggestion"> | Date | string | null
    generatedBlogId?: StringNullableFilter<"TopicSuggestion"> | string | null
    batchId?: StringNullableFilter<"TopicSuggestion"> | string | null
    createdAt?: DateTimeFilter<"TopicSuggestion"> | Date | string
    updatedAt?: DateTimeFilter<"TopicSuggestion"> | Date | string
  }, "id">

  export type TopicSuggestionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    estimatedImpact?: SortOrderInput | SortOrder
    language?: SortOrder
    status?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    generatedBlogId?: SortOrderInput | SortOrder
    batchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TopicSuggestionCountOrderByAggregateInput
    _max?: TopicSuggestionMaxOrderByAggregateInput
    _min?: TopicSuggestionMinOrderByAggregateInput
  }

  export type TopicSuggestionScalarWhereWithAggregatesInput = {
    AND?: TopicSuggestionScalarWhereWithAggregatesInput | TopicSuggestionScalarWhereWithAggregatesInput[]
    OR?: TopicSuggestionScalarWhereWithAggregatesInput[]
    NOT?: TopicSuggestionScalarWhereWithAggregatesInput | TopicSuggestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TopicSuggestion"> | string
    title?: StringWithAggregatesFilter<"TopicSuggestion"> | string
    description?: StringNullableWithAggregatesFilter<"TopicSuggestion"> | string | null
    category?: StringNullableWithAggregatesFilter<"TopicSuggestion"> | string | null
    priority?: StringNullableWithAggregatesFilter<"TopicSuggestion"> | string | null
    difficulty?: StringNullableWithAggregatesFilter<"TopicSuggestion"> | string | null
    estimatedImpact?: StringNullableWithAggregatesFilter<"TopicSuggestion"> | string | null
    language?: StringWithAggregatesFilter<"TopicSuggestion"> | string
    status?: EnumTopicStatusWithAggregatesFilter<"TopicSuggestion"> | $Enums.TopicStatus
    usedAt?: DateTimeNullableWithAggregatesFilter<"TopicSuggestion"> | Date | string | null
    generatedBlogId?: StringNullableWithAggregatesFilter<"TopicSuggestion"> | string | null
    batchId?: StringNullableWithAggregatesFilter<"TopicSuggestion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TopicSuggestion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TopicSuggestion"> | Date | string
  }

  export type ScheduledBlogWhereInput = {
    AND?: ScheduledBlogWhereInput | ScheduledBlogWhereInput[]
    OR?: ScheduledBlogWhereInput[]
    NOT?: ScheduledBlogWhereInput | ScheduledBlogWhereInput[]
    id?: StringFilter<"ScheduledBlog"> | string
    topicId?: StringNullableFilter<"ScheduledBlog"> | string | null
    topicTitle?: StringFilter<"ScheduledBlog"> | string
    language?: StringFilter<"ScheduledBlog"> | string
    length?: StringFilter<"ScheduledBlog"> | string
    tone?: StringFilter<"ScheduledBlog"> | string
    includeResearch?: BoolFilter<"ScheduledBlog"> | boolean
    scheduledFor?: DateTimeFilter<"ScheduledBlog"> | Date | string
    scheduledBy?: StringFilter<"ScheduledBlog"> | string
    status?: EnumScheduledBlogStatusFilter<"ScheduledBlog"> | $Enums.ScheduledBlogStatus
    generatedBlogId?: StringNullableFilter<"ScheduledBlog"> | string | null
    processingStartedAt?: DateTimeNullableFilter<"ScheduledBlog"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"ScheduledBlog"> | Date | string | null
    errorMessage?: StringNullableFilter<"ScheduledBlog"> | string | null
    createdAt?: DateTimeFilter<"ScheduledBlog"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledBlog"> | Date | string
  }

  export type ScheduledBlogOrderByWithRelationInput = {
    id?: SortOrder
    topicId?: SortOrderInput | SortOrder
    topicTitle?: SortOrder
    language?: SortOrder
    length?: SortOrder
    tone?: SortOrder
    includeResearch?: SortOrder
    scheduledFor?: SortOrder
    scheduledBy?: SortOrder
    status?: SortOrder
    generatedBlogId?: SortOrderInput | SortOrder
    processingStartedAt?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledBlogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduledBlogWhereInput | ScheduledBlogWhereInput[]
    OR?: ScheduledBlogWhereInput[]
    NOT?: ScheduledBlogWhereInput | ScheduledBlogWhereInput[]
    topicId?: StringNullableFilter<"ScheduledBlog"> | string | null
    topicTitle?: StringFilter<"ScheduledBlog"> | string
    language?: StringFilter<"ScheduledBlog"> | string
    length?: StringFilter<"ScheduledBlog"> | string
    tone?: StringFilter<"ScheduledBlog"> | string
    includeResearch?: BoolFilter<"ScheduledBlog"> | boolean
    scheduledFor?: DateTimeFilter<"ScheduledBlog"> | Date | string
    scheduledBy?: StringFilter<"ScheduledBlog"> | string
    status?: EnumScheduledBlogStatusFilter<"ScheduledBlog"> | $Enums.ScheduledBlogStatus
    generatedBlogId?: StringNullableFilter<"ScheduledBlog"> | string | null
    processingStartedAt?: DateTimeNullableFilter<"ScheduledBlog"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"ScheduledBlog"> | Date | string | null
    errorMessage?: StringNullableFilter<"ScheduledBlog"> | string | null
    createdAt?: DateTimeFilter<"ScheduledBlog"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledBlog"> | Date | string
  }, "id">

  export type ScheduledBlogOrderByWithAggregationInput = {
    id?: SortOrder
    topicId?: SortOrderInput | SortOrder
    topicTitle?: SortOrder
    language?: SortOrder
    length?: SortOrder
    tone?: SortOrder
    includeResearch?: SortOrder
    scheduledFor?: SortOrder
    scheduledBy?: SortOrder
    status?: SortOrder
    generatedBlogId?: SortOrderInput | SortOrder
    processingStartedAt?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduledBlogCountOrderByAggregateInput
    _max?: ScheduledBlogMaxOrderByAggregateInput
    _min?: ScheduledBlogMinOrderByAggregateInput
  }

  export type ScheduledBlogScalarWhereWithAggregatesInput = {
    AND?: ScheduledBlogScalarWhereWithAggregatesInput | ScheduledBlogScalarWhereWithAggregatesInput[]
    OR?: ScheduledBlogScalarWhereWithAggregatesInput[]
    NOT?: ScheduledBlogScalarWhereWithAggregatesInput | ScheduledBlogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduledBlog"> | string
    topicId?: StringNullableWithAggregatesFilter<"ScheduledBlog"> | string | null
    topicTitle?: StringWithAggregatesFilter<"ScheduledBlog"> | string
    language?: StringWithAggregatesFilter<"ScheduledBlog"> | string
    length?: StringWithAggregatesFilter<"ScheduledBlog"> | string
    tone?: StringWithAggregatesFilter<"ScheduledBlog"> | string
    includeResearch?: BoolWithAggregatesFilter<"ScheduledBlog"> | boolean
    scheduledFor?: DateTimeWithAggregatesFilter<"ScheduledBlog"> | Date | string
    scheduledBy?: StringWithAggregatesFilter<"ScheduledBlog"> | string
    status?: EnumScheduledBlogStatusWithAggregatesFilter<"ScheduledBlog"> | $Enums.ScheduledBlogStatus
    generatedBlogId?: StringNullableWithAggregatesFilter<"ScheduledBlog"> | string | null
    processingStartedAt?: DateTimeNullableWithAggregatesFilter<"ScheduledBlog"> | Date | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"ScheduledBlog"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"ScheduledBlog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ScheduledBlog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScheduledBlog"> | Date | string
  }

  export type HeroImageWhereInput = {
    AND?: HeroImageWhereInput | HeroImageWhereInput[]
    OR?: HeroImageWhereInput[]
    NOT?: HeroImageWhereInput | HeroImageWhereInput[]
    id?: StringFilter<"HeroImage"> | string
    page?: StringFilter<"HeroImage"> | string
    deviceType?: EnumHeroDeviceTypeFilter<"HeroImage"> | $Enums.HeroDeviceType
    imageUrl?: StringFilter<"HeroImage"> | string
    alt?: StringFilter<"HeroImage"> | string
    fileName?: StringNullableFilter<"HeroImage"> | string | null
    originalUrl?: StringNullableFilter<"HeroImage"> | string | null
    width?: IntNullableFilter<"HeroImage"> | number | null
    height?: IntNullableFilter<"HeroImage"> | number | null
    isAiGenerated?: BoolFilter<"HeroImage"> | boolean
    aiPrompt?: StringNullableFilter<"HeroImage"> | string | null
    originalSize?: IntNullableFilter<"HeroImage"> | number | null
    optimizedSize?: IntNullableFilter<"HeroImage"> | number | null
    isActive?: BoolFilter<"HeroImage"> | boolean
    createdAt?: DateTimeFilter<"HeroImage"> | Date | string
    updatedAt?: DateTimeFilter<"HeroImage"> | Date | string
  }

  export type HeroImageOrderByWithRelationInput = {
    id?: SortOrder
    page?: SortOrder
    deviceType?: SortOrder
    imageUrl?: SortOrder
    alt?: SortOrder
    fileName?: SortOrderInput | SortOrder
    originalUrl?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    isAiGenerated?: SortOrder
    aiPrompt?: SortOrderInput | SortOrder
    originalSize?: SortOrderInput | SortOrder
    optimizedSize?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HeroImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    page_deviceType?: HeroImagePageDeviceTypeCompoundUniqueInput
    AND?: HeroImageWhereInput | HeroImageWhereInput[]
    OR?: HeroImageWhereInput[]
    NOT?: HeroImageWhereInput | HeroImageWhereInput[]
    page?: StringFilter<"HeroImage"> | string
    deviceType?: EnumHeroDeviceTypeFilter<"HeroImage"> | $Enums.HeroDeviceType
    imageUrl?: StringFilter<"HeroImage"> | string
    alt?: StringFilter<"HeroImage"> | string
    fileName?: StringNullableFilter<"HeroImage"> | string | null
    originalUrl?: StringNullableFilter<"HeroImage"> | string | null
    width?: IntNullableFilter<"HeroImage"> | number | null
    height?: IntNullableFilter<"HeroImage"> | number | null
    isAiGenerated?: BoolFilter<"HeroImage"> | boolean
    aiPrompt?: StringNullableFilter<"HeroImage"> | string | null
    originalSize?: IntNullableFilter<"HeroImage"> | number | null
    optimizedSize?: IntNullableFilter<"HeroImage"> | number | null
    isActive?: BoolFilter<"HeroImage"> | boolean
    createdAt?: DateTimeFilter<"HeroImage"> | Date | string
    updatedAt?: DateTimeFilter<"HeroImage"> | Date | string
  }, "id" | "page_deviceType">

  export type HeroImageOrderByWithAggregationInput = {
    id?: SortOrder
    page?: SortOrder
    deviceType?: SortOrder
    imageUrl?: SortOrder
    alt?: SortOrder
    fileName?: SortOrderInput | SortOrder
    originalUrl?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    isAiGenerated?: SortOrder
    aiPrompt?: SortOrderInput | SortOrder
    originalSize?: SortOrderInput | SortOrder
    optimizedSize?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HeroImageCountOrderByAggregateInput
    _avg?: HeroImageAvgOrderByAggregateInput
    _max?: HeroImageMaxOrderByAggregateInput
    _min?: HeroImageMinOrderByAggregateInput
    _sum?: HeroImageSumOrderByAggregateInput
  }

  export type HeroImageScalarWhereWithAggregatesInput = {
    AND?: HeroImageScalarWhereWithAggregatesInput | HeroImageScalarWhereWithAggregatesInput[]
    OR?: HeroImageScalarWhereWithAggregatesInput[]
    NOT?: HeroImageScalarWhereWithAggregatesInput | HeroImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HeroImage"> | string
    page?: StringWithAggregatesFilter<"HeroImage"> | string
    deviceType?: EnumHeroDeviceTypeWithAggregatesFilter<"HeroImage"> | $Enums.HeroDeviceType
    imageUrl?: StringWithAggregatesFilter<"HeroImage"> | string
    alt?: StringWithAggregatesFilter<"HeroImage"> | string
    fileName?: StringNullableWithAggregatesFilter<"HeroImage"> | string | null
    originalUrl?: StringNullableWithAggregatesFilter<"HeroImage"> | string | null
    width?: IntNullableWithAggregatesFilter<"HeroImage"> | number | null
    height?: IntNullableWithAggregatesFilter<"HeroImage"> | number | null
    isAiGenerated?: BoolWithAggregatesFilter<"HeroImage"> | boolean
    aiPrompt?: StringNullableWithAggregatesFilter<"HeroImage"> | string | null
    originalSize?: IntNullableWithAggregatesFilter<"HeroImage"> | number | null
    optimizedSize?: IntNullableWithAggregatesFilter<"HeroImage"> | number | null
    isActive?: BoolWithAggregatesFilter<"HeroImage"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"HeroImage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HeroImage"> | Date | string
  }

  export type PropertyAlertWhereInput = {
    AND?: PropertyAlertWhereInput | PropertyAlertWhereInput[]
    OR?: PropertyAlertWhereInput[]
    NOT?: PropertyAlertWhereInput | PropertyAlertWhereInput[]
    id?: StringFilter<"PropertyAlert"> | string
    email?: StringFilter<"PropertyAlert"> | string
    name?: StringNullableFilter<"PropertyAlert"> | string | null
    phone?: StringNullableFilter<"PropertyAlert"> | string | null
    countryCode?: StringFilter<"PropertyAlert"> | string
    userId?: StringNullableFilter<"PropertyAlert"> | string | null
    propertyType?: EnumPropertyTypeNullableFilter<"PropertyAlert"> | $Enums.PropertyType | null
    category?: EnumPropertyCategoryNullableFilter<"PropertyAlert"> | $Enums.PropertyCategory | null
    locations?: StringNullableFilter<"PropertyAlert"> | string | null
    minPrice?: IntNullableFilter<"PropertyAlert"> | number | null
    maxPrice?: IntNullableFilter<"PropertyAlert"> | number | null
    minBeds?: IntNullableFilter<"PropertyAlert"> | number | null
    maxBeds?: IntNullableFilter<"PropertyAlert"> | number | null
    minBaths?: IntNullableFilter<"PropertyAlert"> | number | null
    maxBaths?: IntNullableFilter<"PropertyAlert"> | number | null
    minSqft?: IntNullableFilter<"PropertyAlert"> | number | null
    maxSqft?: IntNullableFilter<"PropertyAlert"> | number | null
    notifyImmediately?: BoolFilter<"PropertyAlert"> | boolean
    notifyDigest?: BoolFilter<"PropertyAlert"> | boolean
    digestDay?: StringNullableFilter<"PropertyAlert"> | string | null
    isActive?: BoolFilter<"PropertyAlert"> | boolean
    lastNotifiedAt?: DateTimeNullableFilter<"PropertyAlert"> | Date | string | null
    matchCount?: IntFilter<"PropertyAlert"> | number
    notificationCount?: IntFilter<"PropertyAlert"> | number
    verificationToken?: StringNullableFilter<"PropertyAlert"> | string | null
    isVerified?: BoolFilter<"PropertyAlert"> | boolean
    verifiedAt?: DateTimeNullableFilter<"PropertyAlert"> | Date | string | null
    unsubscribeToken?: StringFilter<"PropertyAlert"> | string
    ipAddress?: StringNullableFilter<"PropertyAlert"> | string | null
    userAgent?: StringNullableFilter<"PropertyAlert"> | string | null
    source?: StringNullableFilter<"PropertyAlert"> | string | null
    createdAt?: DateTimeFilter<"PropertyAlert"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyAlert"> | Date | string
  }

  export type PropertyAlertOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    countryCode?: SortOrder
    userId?: SortOrderInput | SortOrder
    propertyType?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    locations?: SortOrderInput | SortOrder
    minPrice?: SortOrderInput | SortOrder
    maxPrice?: SortOrderInput | SortOrder
    minBeds?: SortOrderInput | SortOrder
    maxBeds?: SortOrderInput | SortOrder
    minBaths?: SortOrderInput | SortOrder
    maxBaths?: SortOrderInput | SortOrder
    minSqft?: SortOrderInput | SortOrder
    maxSqft?: SortOrderInput | SortOrder
    notifyImmediately?: SortOrder
    notifyDigest?: SortOrder
    digestDay?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastNotifiedAt?: SortOrderInput | SortOrder
    matchCount?: SortOrder
    notificationCount?: SortOrder
    verificationToken?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    unsubscribeToken?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    verificationToken?: string
    unsubscribeToken?: string
    AND?: PropertyAlertWhereInput | PropertyAlertWhereInput[]
    OR?: PropertyAlertWhereInput[]
    NOT?: PropertyAlertWhereInput | PropertyAlertWhereInput[]
    email?: StringFilter<"PropertyAlert"> | string
    name?: StringNullableFilter<"PropertyAlert"> | string | null
    phone?: StringNullableFilter<"PropertyAlert"> | string | null
    countryCode?: StringFilter<"PropertyAlert"> | string
    userId?: StringNullableFilter<"PropertyAlert"> | string | null
    propertyType?: EnumPropertyTypeNullableFilter<"PropertyAlert"> | $Enums.PropertyType | null
    category?: EnumPropertyCategoryNullableFilter<"PropertyAlert"> | $Enums.PropertyCategory | null
    locations?: StringNullableFilter<"PropertyAlert"> | string | null
    minPrice?: IntNullableFilter<"PropertyAlert"> | number | null
    maxPrice?: IntNullableFilter<"PropertyAlert"> | number | null
    minBeds?: IntNullableFilter<"PropertyAlert"> | number | null
    maxBeds?: IntNullableFilter<"PropertyAlert"> | number | null
    minBaths?: IntNullableFilter<"PropertyAlert"> | number | null
    maxBaths?: IntNullableFilter<"PropertyAlert"> | number | null
    minSqft?: IntNullableFilter<"PropertyAlert"> | number | null
    maxSqft?: IntNullableFilter<"PropertyAlert"> | number | null
    notifyImmediately?: BoolFilter<"PropertyAlert"> | boolean
    notifyDigest?: BoolFilter<"PropertyAlert"> | boolean
    digestDay?: StringNullableFilter<"PropertyAlert"> | string | null
    isActive?: BoolFilter<"PropertyAlert"> | boolean
    lastNotifiedAt?: DateTimeNullableFilter<"PropertyAlert"> | Date | string | null
    matchCount?: IntFilter<"PropertyAlert"> | number
    notificationCount?: IntFilter<"PropertyAlert"> | number
    isVerified?: BoolFilter<"PropertyAlert"> | boolean
    verifiedAt?: DateTimeNullableFilter<"PropertyAlert"> | Date | string | null
    ipAddress?: StringNullableFilter<"PropertyAlert"> | string | null
    userAgent?: StringNullableFilter<"PropertyAlert"> | string | null
    source?: StringNullableFilter<"PropertyAlert"> | string | null
    createdAt?: DateTimeFilter<"PropertyAlert"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyAlert"> | Date | string
  }, "id" | "verificationToken" | "unsubscribeToken">

  export type PropertyAlertOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    countryCode?: SortOrder
    userId?: SortOrderInput | SortOrder
    propertyType?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    locations?: SortOrderInput | SortOrder
    minPrice?: SortOrderInput | SortOrder
    maxPrice?: SortOrderInput | SortOrder
    minBeds?: SortOrderInput | SortOrder
    maxBeds?: SortOrderInput | SortOrder
    minBaths?: SortOrderInput | SortOrder
    maxBaths?: SortOrderInput | SortOrder
    minSqft?: SortOrderInput | SortOrder
    maxSqft?: SortOrderInput | SortOrder
    notifyImmediately?: SortOrder
    notifyDigest?: SortOrder
    digestDay?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastNotifiedAt?: SortOrderInput | SortOrder
    matchCount?: SortOrder
    notificationCount?: SortOrder
    verificationToken?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    unsubscribeToken?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyAlertCountOrderByAggregateInput
    _avg?: PropertyAlertAvgOrderByAggregateInput
    _max?: PropertyAlertMaxOrderByAggregateInput
    _min?: PropertyAlertMinOrderByAggregateInput
    _sum?: PropertyAlertSumOrderByAggregateInput
  }

  export type PropertyAlertScalarWhereWithAggregatesInput = {
    AND?: PropertyAlertScalarWhereWithAggregatesInput | PropertyAlertScalarWhereWithAggregatesInput[]
    OR?: PropertyAlertScalarWhereWithAggregatesInput[]
    NOT?: PropertyAlertScalarWhereWithAggregatesInput | PropertyAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyAlert"> | string
    email?: StringWithAggregatesFilter<"PropertyAlert"> | string
    name?: StringNullableWithAggregatesFilter<"PropertyAlert"> | string | null
    phone?: StringNullableWithAggregatesFilter<"PropertyAlert"> | string | null
    countryCode?: StringWithAggregatesFilter<"PropertyAlert"> | string
    userId?: StringNullableWithAggregatesFilter<"PropertyAlert"> | string | null
    propertyType?: EnumPropertyTypeNullableWithAggregatesFilter<"PropertyAlert"> | $Enums.PropertyType | null
    category?: EnumPropertyCategoryNullableWithAggregatesFilter<"PropertyAlert"> | $Enums.PropertyCategory | null
    locations?: StringNullableWithAggregatesFilter<"PropertyAlert"> | string | null
    minPrice?: IntNullableWithAggregatesFilter<"PropertyAlert"> | number | null
    maxPrice?: IntNullableWithAggregatesFilter<"PropertyAlert"> | number | null
    minBeds?: IntNullableWithAggregatesFilter<"PropertyAlert"> | number | null
    maxBeds?: IntNullableWithAggregatesFilter<"PropertyAlert"> | number | null
    minBaths?: IntNullableWithAggregatesFilter<"PropertyAlert"> | number | null
    maxBaths?: IntNullableWithAggregatesFilter<"PropertyAlert"> | number | null
    minSqft?: IntNullableWithAggregatesFilter<"PropertyAlert"> | number | null
    maxSqft?: IntNullableWithAggregatesFilter<"PropertyAlert"> | number | null
    notifyImmediately?: BoolWithAggregatesFilter<"PropertyAlert"> | boolean
    notifyDigest?: BoolWithAggregatesFilter<"PropertyAlert"> | boolean
    digestDay?: StringNullableWithAggregatesFilter<"PropertyAlert"> | string | null
    isActive?: BoolWithAggregatesFilter<"PropertyAlert"> | boolean
    lastNotifiedAt?: DateTimeNullableWithAggregatesFilter<"PropertyAlert"> | Date | string | null
    matchCount?: IntWithAggregatesFilter<"PropertyAlert"> | number
    notificationCount?: IntWithAggregatesFilter<"PropertyAlert"> | number
    verificationToken?: StringNullableWithAggregatesFilter<"PropertyAlert"> | string | null
    isVerified?: BoolWithAggregatesFilter<"PropertyAlert"> | boolean
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"PropertyAlert"> | Date | string | null
    unsubscribeToken?: StringWithAggregatesFilter<"PropertyAlert"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"PropertyAlert"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"PropertyAlert"> | string | null
    source?: StringNullableWithAggregatesFilter<"PropertyAlert"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PropertyAlert"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertyAlert"> | Date | string
  }

  export type PropertyAlertNotificationWhereInput = {
    AND?: PropertyAlertNotificationWhereInput | PropertyAlertNotificationWhereInput[]
    OR?: PropertyAlertNotificationWhereInput[]
    NOT?: PropertyAlertNotificationWhereInput | PropertyAlertNotificationWhereInput[]
    id?: StringFilter<"PropertyAlertNotification"> | string
    alertId?: StringFilter<"PropertyAlertNotification"> | string
    propertyIds?: StringFilter<"PropertyAlertNotification"> | string
    propertyCount?: IntFilter<"PropertyAlertNotification"> | number
    emailSent?: BoolFilter<"PropertyAlertNotification"> | boolean
    emailSentAt?: DateTimeNullableFilter<"PropertyAlertNotification"> | Date | string | null
    emailError?: StringNullableFilter<"PropertyAlertNotification"> | string | null
    opened?: BoolFilter<"PropertyAlertNotification"> | boolean
    openedAt?: DateTimeNullableFilter<"PropertyAlertNotification"> | Date | string | null
    clicked?: BoolFilter<"PropertyAlertNotification"> | boolean
    clickedAt?: DateTimeNullableFilter<"PropertyAlertNotification"> | Date | string | null
    createdAt?: DateTimeFilter<"PropertyAlertNotification"> | Date | string
  }

  export type PropertyAlertNotificationOrderByWithRelationInput = {
    id?: SortOrder
    alertId?: SortOrder
    propertyIds?: SortOrder
    propertyCount?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrderInput | SortOrder
    emailError?: SortOrderInput | SortOrder
    opened?: SortOrder
    openedAt?: SortOrderInput | SortOrder
    clicked?: SortOrder
    clickedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type PropertyAlertNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyAlertNotificationWhereInput | PropertyAlertNotificationWhereInput[]
    OR?: PropertyAlertNotificationWhereInput[]
    NOT?: PropertyAlertNotificationWhereInput | PropertyAlertNotificationWhereInput[]
    alertId?: StringFilter<"PropertyAlertNotification"> | string
    propertyIds?: StringFilter<"PropertyAlertNotification"> | string
    propertyCount?: IntFilter<"PropertyAlertNotification"> | number
    emailSent?: BoolFilter<"PropertyAlertNotification"> | boolean
    emailSentAt?: DateTimeNullableFilter<"PropertyAlertNotification"> | Date | string | null
    emailError?: StringNullableFilter<"PropertyAlertNotification"> | string | null
    opened?: BoolFilter<"PropertyAlertNotification"> | boolean
    openedAt?: DateTimeNullableFilter<"PropertyAlertNotification"> | Date | string | null
    clicked?: BoolFilter<"PropertyAlertNotification"> | boolean
    clickedAt?: DateTimeNullableFilter<"PropertyAlertNotification"> | Date | string | null
    createdAt?: DateTimeFilter<"PropertyAlertNotification"> | Date | string
  }, "id">

  export type PropertyAlertNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    alertId?: SortOrder
    propertyIds?: SortOrder
    propertyCount?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrderInput | SortOrder
    emailError?: SortOrderInput | SortOrder
    opened?: SortOrder
    openedAt?: SortOrderInput | SortOrder
    clicked?: SortOrder
    clickedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PropertyAlertNotificationCountOrderByAggregateInput
    _avg?: PropertyAlertNotificationAvgOrderByAggregateInput
    _max?: PropertyAlertNotificationMaxOrderByAggregateInput
    _min?: PropertyAlertNotificationMinOrderByAggregateInput
    _sum?: PropertyAlertNotificationSumOrderByAggregateInput
  }

  export type PropertyAlertNotificationScalarWhereWithAggregatesInput = {
    AND?: PropertyAlertNotificationScalarWhereWithAggregatesInput | PropertyAlertNotificationScalarWhereWithAggregatesInput[]
    OR?: PropertyAlertNotificationScalarWhereWithAggregatesInput[]
    NOT?: PropertyAlertNotificationScalarWhereWithAggregatesInput | PropertyAlertNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyAlertNotification"> | string
    alertId?: StringWithAggregatesFilter<"PropertyAlertNotification"> | string
    propertyIds?: StringWithAggregatesFilter<"PropertyAlertNotification"> | string
    propertyCount?: IntWithAggregatesFilter<"PropertyAlertNotification"> | number
    emailSent?: BoolWithAggregatesFilter<"PropertyAlertNotification"> | boolean
    emailSentAt?: DateTimeNullableWithAggregatesFilter<"PropertyAlertNotification"> | Date | string | null
    emailError?: StringNullableWithAggregatesFilter<"PropertyAlertNotification"> | string | null
    opened?: BoolWithAggregatesFilter<"PropertyAlertNotification"> | boolean
    openedAt?: DateTimeNullableWithAggregatesFilter<"PropertyAlertNotification"> | Date | string | null
    clicked?: BoolWithAggregatesFilter<"PropertyAlertNotification"> | boolean
    clickedAt?: DateTimeNullableWithAggregatesFilter<"PropertyAlertNotification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PropertyAlertNotification"> | Date | string
  }

  export type PoiWhereInput = {
    AND?: PoiWhereInput | PoiWhereInput[]
    OR?: PoiWhereInput[]
    NOT?: PoiWhereInput | PoiWhereInput[]
    id?: StringFilter<"Poi"> | string
    externalId?: StringNullableFilter<"Poi"> | string | null
    source?: EnumPoiSourceFilter<"Poi"> | $Enums.PoiSource
    name?: StringFilter<"Poi"> | string
    nameTh?: StringNullableFilter<"Poi"> | string | null
    nameLocal?: StringNullableFilter<"Poi"> | string | null
    category?: EnumPoiCategoryFilter<"Poi"> | $Enums.PoiCategory
    subCategory?: StringNullableFilter<"Poi"> | string | null
    latitude?: FloatFilter<"Poi"> | number
    longitude?: FloatFilter<"Poi"> | number
    address?: StringNullableFilter<"Poi"> | string | null
    district?: StringNullableFilter<"Poi"> | string | null
    osmTags?: JsonNullableFilter<"Poi">
    importance?: IntFilter<"Poi"> | number
    isVerified?: BoolFilter<"Poi"> | boolean
    isActive?: BoolFilter<"Poi"> | boolean
    noiseLevel?: EnumNoiseLevelNullableFilter<"Poi"> | $Enums.NoiseLevel | null
    trafficLevel?: EnumTrafficLevelNullableFilter<"Poi"> | $Enums.TrafficLevel | null
    lastSyncedAt?: DateTimeNullableFilter<"Poi"> | Date | string | null
    syncError?: StringNullableFilter<"Poi"> | string | null
    createdAt?: DateTimeFilter<"Poi"> | Date | string
    updatedAt?: DateTimeFilter<"Poi"> | Date | string
    propertyDistances?: PropertyPoiDistanceListRelationFilter
  }

  export type PoiOrderByWithRelationInput = {
    id?: SortOrder
    externalId?: SortOrderInput | SortOrder
    source?: SortOrder
    name?: SortOrder
    nameTh?: SortOrderInput | SortOrder
    nameLocal?: SortOrderInput | SortOrder
    category?: SortOrder
    subCategory?: SortOrderInput | SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    address?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    osmTags?: SortOrderInput | SortOrder
    importance?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    noiseLevel?: SortOrderInput | SortOrder
    trafficLevel?: SortOrderInput | SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    syncError?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    propertyDistances?: PropertyPoiDistanceOrderByRelationAggregateInput
  }

  export type PoiWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    externalId_source?: PoiExternalIdSourceCompoundUniqueInput
    AND?: PoiWhereInput | PoiWhereInput[]
    OR?: PoiWhereInput[]
    NOT?: PoiWhereInput | PoiWhereInput[]
    externalId?: StringNullableFilter<"Poi"> | string | null
    source?: EnumPoiSourceFilter<"Poi"> | $Enums.PoiSource
    name?: StringFilter<"Poi"> | string
    nameTh?: StringNullableFilter<"Poi"> | string | null
    nameLocal?: StringNullableFilter<"Poi"> | string | null
    category?: EnumPoiCategoryFilter<"Poi"> | $Enums.PoiCategory
    subCategory?: StringNullableFilter<"Poi"> | string | null
    latitude?: FloatFilter<"Poi"> | number
    longitude?: FloatFilter<"Poi"> | number
    address?: StringNullableFilter<"Poi"> | string | null
    district?: StringNullableFilter<"Poi"> | string | null
    osmTags?: JsonNullableFilter<"Poi">
    importance?: IntFilter<"Poi"> | number
    isVerified?: BoolFilter<"Poi"> | boolean
    isActive?: BoolFilter<"Poi"> | boolean
    noiseLevel?: EnumNoiseLevelNullableFilter<"Poi"> | $Enums.NoiseLevel | null
    trafficLevel?: EnumTrafficLevelNullableFilter<"Poi"> | $Enums.TrafficLevel | null
    lastSyncedAt?: DateTimeNullableFilter<"Poi"> | Date | string | null
    syncError?: StringNullableFilter<"Poi"> | string | null
    createdAt?: DateTimeFilter<"Poi"> | Date | string
    updatedAt?: DateTimeFilter<"Poi"> | Date | string
    propertyDistances?: PropertyPoiDistanceListRelationFilter
  }, "id" | "externalId_source">

  export type PoiOrderByWithAggregationInput = {
    id?: SortOrder
    externalId?: SortOrderInput | SortOrder
    source?: SortOrder
    name?: SortOrder
    nameTh?: SortOrderInput | SortOrder
    nameLocal?: SortOrderInput | SortOrder
    category?: SortOrder
    subCategory?: SortOrderInput | SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    address?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    osmTags?: SortOrderInput | SortOrder
    importance?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    noiseLevel?: SortOrderInput | SortOrder
    trafficLevel?: SortOrderInput | SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    syncError?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PoiCountOrderByAggregateInput
    _avg?: PoiAvgOrderByAggregateInput
    _max?: PoiMaxOrderByAggregateInput
    _min?: PoiMinOrderByAggregateInput
    _sum?: PoiSumOrderByAggregateInput
  }

  export type PoiScalarWhereWithAggregatesInput = {
    AND?: PoiScalarWhereWithAggregatesInput | PoiScalarWhereWithAggregatesInput[]
    OR?: PoiScalarWhereWithAggregatesInput[]
    NOT?: PoiScalarWhereWithAggregatesInput | PoiScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Poi"> | string
    externalId?: StringNullableWithAggregatesFilter<"Poi"> | string | null
    source?: EnumPoiSourceWithAggregatesFilter<"Poi"> | $Enums.PoiSource
    name?: StringWithAggregatesFilter<"Poi"> | string
    nameTh?: StringNullableWithAggregatesFilter<"Poi"> | string | null
    nameLocal?: StringNullableWithAggregatesFilter<"Poi"> | string | null
    category?: EnumPoiCategoryWithAggregatesFilter<"Poi"> | $Enums.PoiCategory
    subCategory?: StringNullableWithAggregatesFilter<"Poi"> | string | null
    latitude?: FloatWithAggregatesFilter<"Poi"> | number
    longitude?: FloatWithAggregatesFilter<"Poi"> | number
    address?: StringNullableWithAggregatesFilter<"Poi"> | string | null
    district?: StringNullableWithAggregatesFilter<"Poi"> | string | null
    osmTags?: JsonNullableWithAggregatesFilter<"Poi">
    importance?: IntWithAggregatesFilter<"Poi"> | number
    isVerified?: BoolWithAggregatesFilter<"Poi"> | boolean
    isActive?: BoolWithAggregatesFilter<"Poi"> | boolean
    noiseLevel?: EnumNoiseLevelNullableWithAggregatesFilter<"Poi"> | $Enums.NoiseLevel | null
    trafficLevel?: EnumTrafficLevelNullableWithAggregatesFilter<"Poi"> | $Enums.TrafficLevel | null
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"Poi"> | Date | string | null
    syncError?: StringNullableWithAggregatesFilter<"Poi"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Poi"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Poi"> | Date | string
  }

  export type PropertyPoiDistanceWhereInput = {
    AND?: PropertyPoiDistanceWhereInput | PropertyPoiDistanceWhereInput[]
    OR?: PropertyPoiDistanceWhereInput[]
    NOT?: PropertyPoiDistanceWhereInput | PropertyPoiDistanceWhereInput[]
    id?: StringFilter<"PropertyPoiDistance"> | string
    propertyId?: StringFilter<"PropertyPoiDistance"> | string
    poiId?: StringFilter<"PropertyPoiDistance"> | string
    distanceMeters?: IntFilter<"PropertyPoiDistance"> | number
    walkingMinutes?: IntNullableFilter<"PropertyPoiDistance"> | number | null
    drivingMinutes?: IntNullableFilter<"PropertyPoiDistance"> | number | null
    isHighlight?: BoolFilter<"PropertyPoiDistance"> | boolean
    calculatedAt?: DateTimeFilter<"PropertyPoiDistance"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    poi?: XOR<PoiScalarRelationFilter, PoiWhereInput>
  }

  export type PropertyPoiDistanceOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    poiId?: SortOrder
    distanceMeters?: SortOrder
    walkingMinutes?: SortOrderInput | SortOrder
    drivingMinutes?: SortOrderInput | SortOrder
    isHighlight?: SortOrder
    calculatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
    poi?: PoiOrderByWithRelationInput
  }

  export type PropertyPoiDistanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    propertyId_poiId?: PropertyPoiDistancePropertyIdPoiIdCompoundUniqueInput
    AND?: PropertyPoiDistanceWhereInput | PropertyPoiDistanceWhereInput[]
    OR?: PropertyPoiDistanceWhereInput[]
    NOT?: PropertyPoiDistanceWhereInput | PropertyPoiDistanceWhereInput[]
    propertyId?: StringFilter<"PropertyPoiDistance"> | string
    poiId?: StringFilter<"PropertyPoiDistance"> | string
    distanceMeters?: IntFilter<"PropertyPoiDistance"> | number
    walkingMinutes?: IntNullableFilter<"PropertyPoiDistance"> | number | null
    drivingMinutes?: IntNullableFilter<"PropertyPoiDistance"> | number | null
    isHighlight?: BoolFilter<"PropertyPoiDistance"> | boolean
    calculatedAt?: DateTimeFilter<"PropertyPoiDistance"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    poi?: XOR<PoiScalarRelationFilter, PoiWhereInput>
  }, "id" | "propertyId_poiId">

  export type PropertyPoiDistanceOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    poiId?: SortOrder
    distanceMeters?: SortOrder
    walkingMinutes?: SortOrderInput | SortOrder
    drivingMinutes?: SortOrderInput | SortOrder
    isHighlight?: SortOrder
    calculatedAt?: SortOrder
    _count?: PropertyPoiDistanceCountOrderByAggregateInput
    _avg?: PropertyPoiDistanceAvgOrderByAggregateInput
    _max?: PropertyPoiDistanceMaxOrderByAggregateInput
    _min?: PropertyPoiDistanceMinOrderByAggregateInput
    _sum?: PropertyPoiDistanceSumOrderByAggregateInput
  }

  export type PropertyPoiDistanceScalarWhereWithAggregatesInput = {
    AND?: PropertyPoiDistanceScalarWhereWithAggregatesInput | PropertyPoiDistanceScalarWhereWithAggregatesInput[]
    OR?: PropertyPoiDistanceScalarWhereWithAggregatesInput[]
    NOT?: PropertyPoiDistanceScalarWhereWithAggregatesInput | PropertyPoiDistanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyPoiDistance"> | string
    propertyId?: StringWithAggregatesFilter<"PropertyPoiDistance"> | string
    poiId?: StringWithAggregatesFilter<"PropertyPoiDistance"> | string
    distanceMeters?: IntWithAggregatesFilter<"PropertyPoiDistance"> | number
    walkingMinutes?: IntNullableWithAggregatesFilter<"PropertyPoiDistance"> | number | null
    drivingMinutes?: IntNullableWithAggregatesFilter<"PropertyPoiDistance"> | number | null
    isHighlight?: BoolWithAggregatesFilter<"PropertyPoiDistance"> | boolean
    calculatedAt?: DateTimeWithAggregatesFilter<"PropertyPoiDistance"> | Date | string
  }

  export type PoiSyncJobWhereInput = {
    AND?: PoiSyncJobWhereInput | PoiSyncJobWhereInput[]
    OR?: PoiSyncJobWhereInput[]
    NOT?: PoiSyncJobWhereInput | PoiSyncJobWhereInput[]
    id?: StringFilter<"PoiSyncJob"> | string
    jobType?: EnumPoiSyncJobTypeFilter<"PoiSyncJob"> | $Enums.PoiSyncJobType
    status?: EnumPoiSyncJobStatusFilter<"PoiSyncJob"> | $Enums.PoiSyncJobStatus
    category?: EnumPoiCategoryNullableFilter<"PoiSyncJob"> | $Enums.PoiCategory | null
    district?: StringNullableFilter<"PoiSyncJob"> | string | null
    poisFetched?: IntFilter<"PoiSyncJob"> | number
    poisCreated?: IntFilter<"PoiSyncJob"> | number
    poisUpdated?: IntFilter<"PoiSyncJob"> | number
    poisSkipped?: IntFilter<"PoiSyncJob"> | number
    startedAt?: DateTimeNullableFilter<"PoiSyncJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"PoiSyncJob"> | Date | string | null
    errorMessage?: StringNullableFilter<"PoiSyncJob"> | string | null
    errorStack?: StringNullableFilter<"PoiSyncJob"> | string | null
    createdAt?: DateTimeFilter<"PoiSyncJob"> | Date | string
  }

  export type PoiSyncJobOrderByWithRelationInput = {
    id?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    category?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    poisFetched?: SortOrder
    poisCreated?: SortOrder
    poisUpdated?: SortOrder
    poisSkipped?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    errorStack?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type PoiSyncJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PoiSyncJobWhereInput | PoiSyncJobWhereInput[]
    OR?: PoiSyncJobWhereInput[]
    NOT?: PoiSyncJobWhereInput | PoiSyncJobWhereInput[]
    jobType?: EnumPoiSyncJobTypeFilter<"PoiSyncJob"> | $Enums.PoiSyncJobType
    status?: EnumPoiSyncJobStatusFilter<"PoiSyncJob"> | $Enums.PoiSyncJobStatus
    category?: EnumPoiCategoryNullableFilter<"PoiSyncJob"> | $Enums.PoiCategory | null
    district?: StringNullableFilter<"PoiSyncJob"> | string | null
    poisFetched?: IntFilter<"PoiSyncJob"> | number
    poisCreated?: IntFilter<"PoiSyncJob"> | number
    poisUpdated?: IntFilter<"PoiSyncJob"> | number
    poisSkipped?: IntFilter<"PoiSyncJob"> | number
    startedAt?: DateTimeNullableFilter<"PoiSyncJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"PoiSyncJob"> | Date | string | null
    errorMessage?: StringNullableFilter<"PoiSyncJob"> | string | null
    errorStack?: StringNullableFilter<"PoiSyncJob"> | string | null
    createdAt?: DateTimeFilter<"PoiSyncJob"> | Date | string
  }, "id">

  export type PoiSyncJobOrderByWithAggregationInput = {
    id?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    category?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    poisFetched?: SortOrder
    poisCreated?: SortOrder
    poisUpdated?: SortOrder
    poisSkipped?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    errorStack?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PoiSyncJobCountOrderByAggregateInput
    _avg?: PoiSyncJobAvgOrderByAggregateInput
    _max?: PoiSyncJobMaxOrderByAggregateInput
    _min?: PoiSyncJobMinOrderByAggregateInput
    _sum?: PoiSyncJobSumOrderByAggregateInput
  }

  export type PoiSyncJobScalarWhereWithAggregatesInput = {
    AND?: PoiSyncJobScalarWhereWithAggregatesInput | PoiSyncJobScalarWhereWithAggregatesInput[]
    OR?: PoiSyncJobScalarWhereWithAggregatesInput[]
    NOT?: PoiSyncJobScalarWhereWithAggregatesInput | PoiSyncJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PoiSyncJob"> | string
    jobType?: EnumPoiSyncJobTypeWithAggregatesFilter<"PoiSyncJob"> | $Enums.PoiSyncJobType
    status?: EnumPoiSyncJobStatusWithAggregatesFilter<"PoiSyncJob"> | $Enums.PoiSyncJobStatus
    category?: EnumPoiCategoryNullableWithAggregatesFilter<"PoiSyncJob"> | $Enums.PoiCategory | null
    district?: StringNullableWithAggregatesFilter<"PoiSyncJob"> | string | null
    poisFetched?: IntWithAggregatesFilter<"PoiSyncJob"> | number
    poisCreated?: IntWithAggregatesFilter<"PoiSyncJob"> | number
    poisUpdated?: IntWithAggregatesFilter<"PoiSyncJob"> | number
    poisSkipped?: IntWithAggregatesFilter<"PoiSyncJob"> | number
    startedAt?: DateTimeNullableWithAggregatesFilter<"PoiSyncJob"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"PoiSyncJob"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"PoiSyncJob"> | string | null
    errorStack?: StringNullableWithAggregatesFilter<"PoiSyncJob"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PoiSyncJob"> | Date | string
  }

  export type RentalPricingConfigWhereInput = {
    AND?: RentalPricingConfigWhereInput | RentalPricingConfigWhereInput[]
    OR?: RentalPricingConfigWhereInput[]
    NOT?: RentalPricingConfigWhereInput | RentalPricingConfigWhereInput[]
    id?: StringFilter<"RentalPricingConfig"> | string
    peakSeasonMonths?: IntNullableListFilter<"RentalPricingConfig">
    peakSeasonSurcharges?: JsonFilter<"RentalPricingConfig">
    lowSeasonSurcharges?: JsonFilter<"RentalPricingConfig">
    minimumStayDays?: IntFilter<"RentalPricingConfig"> | number
    maximumStayDays?: IntFilter<"RentalPricingConfig"> | number
    createdAt?: DateTimeFilter<"RentalPricingConfig"> | Date | string
    updatedAt?: DateTimeFilter<"RentalPricingConfig"> | Date | string
  }

  export type RentalPricingConfigOrderByWithRelationInput = {
    id?: SortOrder
    peakSeasonMonths?: SortOrder
    peakSeasonSurcharges?: SortOrder
    lowSeasonSurcharges?: SortOrder
    minimumStayDays?: SortOrder
    maximumStayDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RentalPricingConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RentalPricingConfigWhereInput | RentalPricingConfigWhereInput[]
    OR?: RentalPricingConfigWhereInput[]
    NOT?: RentalPricingConfigWhereInput | RentalPricingConfigWhereInput[]
    peakSeasonMonths?: IntNullableListFilter<"RentalPricingConfig">
    peakSeasonSurcharges?: JsonFilter<"RentalPricingConfig">
    lowSeasonSurcharges?: JsonFilter<"RentalPricingConfig">
    minimumStayDays?: IntFilter<"RentalPricingConfig"> | number
    maximumStayDays?: IntFilter<"RentalPricingConfig"> | number
    createdAt?: DateTimeFilter<"RentalPricingConfig"> | Date | string
    updatedAt?: DateTimeFilter<"RentalPricingConfig"> | Date | string
  }, "id">

  export type RentalPricingConfigOrderByWithAggregationInput = {
    id?: SortOrder
    peakSeasonMonths?: SortOrder
    peakSeasonSurcharges?: SortOrder
    lowSeasonSurcharges?: SortOrder
    minimumStayDays?: SortOrder
    maximumStayDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RentalPricingConfigCountOrderByAggregateInput
    _avg?: RentalPricingConfigAvgOrderByAggregateInput
    _max?: RentalPricingConfigMaxOrderByAggregateInput
    _min?: RentalPricingConfigMinOrderByAggregateInput
    _sum?: RentalPricingConfigSumOrderByAggregateInput
  }

  export type RentalPricingConfigScalarWhereWithAggregatesInput = {
    AND?: RentalPricingConfigScalarWhereWithAggregatesInput | RentalPricingConfigScalarWhereWithAggregatesInput[]
    OR?: RentalPricingConfigScalarWhereWithAggregatesInput[]
    NOT?: RentalPricingConfigScalarWhereWithAggregatesInput | RentalPricingConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RentalPricingConfig"> | string
    peakSeasonMonths?: IntNullableListFilter<"RentalPricingConfig">
    peakSeasonSurcharges?: JsonWithAggregatesFilter<"RentalPricingConfig">
    lowSeasonSurcharges?: JsonWithAggregatesFilter<"RentalPricingConfig">
    minimumStayDays?: IntWithAggregatesFilter<"RentalPricingConfig"> | number
    maximumStayDays?: IntWithAggregatesFilter<"RentalPricingConfig"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RentalPricingConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RentalPricingConfig"> | Date | string
  }

  export type RentalBookingWhereInput = {
    AND?: RentalBookingWhereInput | RentalBookingWhereInput[]
    OR?: RentalBookingWhereInput[]
    NOT?: RentalBookingWhereInput | RentalBookingWhereInput[]
    id?: StringFilter<"RentalBooking"> | string
    propertyId?: StringFilter<"RentalBooking"> | string
    userId?: StringFilter<"RentalBooking"> | string
    checkIn?: DateTimeFilter<"RentalBooking"> | Date | string
    checkOut?: DateTimeFilter<"RentalBooking"> | Date | string
    nights?: IntFilter<"RentalBooking"> | number
    adults?: IntFilter<"RentalBooking"> | number
    children?: IntFilter<"RentalBooking"> | number
    babies?: IntFilter<"RentalBooking"> | number
    pets?: IntFilter<"RentalBooking"> | number
    basePrice?: FloatFilter<"RentalBooking"> | number
    season?: StringFilter<"RentalBooking"> | string
    discountPercent?: FloatFilter<"RentalBooking"> | number
    totalPrice?: FloatFilter<"RentalBooking"> | number
    guestName?: StringFilter<"RentalBooking"> | string
    guestEmail?: StringFilter<"RentalBooking"> | string
    guestPhone?: StringFilter<"RentalBooking"> | string
    guestCountryCode?: StringFilter<"RentalBooking"> | string
    guestMessage?: StringNullableFilter<"RentalBooking"> | string | null
    status?: EnumRentalBookingStatusFilter<"RentalBooking"> | $Enums.RentalBookingStatus
    paymentStatus?: StringNullableFilter<"RentalBooking"> | string | null
    cancellationPolicy?: StringNullableFilter<"RentalBooking"> | string | null
    cancelledAt?: DateTimeNullableFilter<"RentalBooking"> | Date | string | null
    cancellationReason?: StringNullableFilter<"RentalBooking"> | string | null
    internalNotes?: StringNullableFilter<"RentalBooking"> | string | null
    checkInTime?: StringNullableFilter<"RentalBooking"> | string | null
    checkOutTime?: StringNullableFilter<"RentalBooking"> | string | null
    propertyAddress?: StringNullableFilter<"RentalBooking"> | string | null
    propertyInstructions?: StringNullableFilter<"RentalBooking"> | string | null
    wifiName?: StringNullableFilter<"RentalBooking"> | string | null
    wifiPassword?: StringNullableFilter<"RentalBooking"> | string | null
    accessCode?: StringNullableFilter<"RentalBooking"> | string | null
    emergencyContact?: StringNullableFilter<"RentalBooking"> | string | null
    houseRules?: StringNullableFilter<"RentalBooking"> | string | null
    confirmedAt?: DateTimeNullableFilter<"RentalBooking"> | Date | string | null
    agentId?: StringNullableFilter<"RentalBooking"> | string | null
    tm30Status?: EnumTM30BookingStatusFilter<"RentalBooking"> | $Enums.TM30BookingStatus
    tm30SubmittedAt?: DateTimeNullableFilter<"RentalBooking"> | Date | string | null
    tm30Reference?: StringNullableFilter<"RentalBooking"> | string | null
    tm30Error?: StringNullableFilter<"RentalBooking"> | string | null
    passportsRequired?: IntFilter<"RentalBooking"> | number
    passportsReceived?: IntFilter<"RentalBooking"> | number
    createdAt?: DateTimeFilter<"RentalBooking"> | Date | string
    updatedAt?: DateTimeFilter<"RentalBooking"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    agent?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    messages?: BookingMessageListRelationFilter
    guests?: BookingGuestListRelationFilter
  }

  export type RentalBookingOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    userId?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    nights?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    babies?: SortOrder
    pets?: SortOrder
    basePrice?: SortOrder
    season?: SortOrder
    discountPercent?: SortOrder
    totalPrice?: SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrder
    guestCountryCode?: SortOrder
    guestMessage?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    cancellationPolicy?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    internalNotes?: SortOrderInput | SortOrder
    checkInTime?: SortOrderInput | SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    propertyAddress?: SortOrderInput | SortOrder
    propertyInstructions?: SortOrderInput | SortOrder
    wifiName?: SortOrderInput | SortOrder
    wifiPassword?: SortOrderInput | SortOrder
    accessCode?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    houseRules?: SortOrderInput | SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    agentId?: SortOrderInput | SortOrder
    tm30Status?: SortOrder
    tm30SubmittedAt?: SortOrderInput | SortOrder
    tm30Reference?: SortOrderInput | SortOrder
    tm30Error?: SortOrderInput | SortOrder
    passportsRequired?: SortOrder
    passportsReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    agent?: UserOrderByWithRelationInput
    messages?: BookingMessageOrderByRelationAggregateInput
    guests?: BookingGuestOrderByRelationAggregateInput
  }

  export type RentalBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RentalBookingWhereInput | RentalBookingWhereInput[]
    OR?: RentalBookingWhereInput[]
    NOT?: RentalBookingWhereInput | RentalBookingWhereInput[]
    propertyId?: StringFilter<"RentalBooking"> | string
    userId?: StringFilter<"RentalBooking"> | string
    checkIn?: DateTimeFilter<"RentalBooking"> | Date | string
    checkOut?: DateTimeFilter<"RentalBooking"> | Date | string
    nights?: IntFilter<"RentalBooking"> | number
    adults?: IntFilter<"RentalBooking"> | number
    children?: IntFilter<"RentalBooking"> | number
    babies?: IntFilter<"RentalBooking"> | number
    pets?: IntFilter<"RentalBooking"> | number
    basePrice?: FloatFilter<"RentalBooking"> | number
    season?: StringFilter<"RentalBooking"> | string
    discountPercent?: FloatFilter<"RentalBooking"> | number
    totalPrice?: FloatFilter<"RentalBooking"> | number
    guestName?: StringFilter<"RentalBooking"> | string
    guestEmail?: StringFilter<"RentalBooking"> | string
    guestPhone?: StringFilter<"RentalBooking"> | string
    guestCountryCode?: StringFilter<"RentalBooking"> | string
    guestMessage?: StringNullableFilter<"RentalBooking"> | string | null
    status?: EnumRentalBookingStatusFilter<"RentalBooking"> | $Enums.RentalBookingStatus
    paymentStatus?: StringNullableFilter<"RentalBooking"> | string | null
    cancellationPolicy?: StringNullableFilter<"RentalBooking"> | string | null
    cancelledAt?: DateTimeNullableFilter<"RentalBooking"> | Date | string | null
    cancellationReason?: StringNullableFilter<"RentalBooking"> | string | null
    internalNotes?: StringNullableFilter<"RentalBooking"> | string | null
    checkInTime?: StringNullableFilter<"RentalBooking"> | string | null
    checkOutTime?: StringNullableFilter<"RentalBooking"> | string | null
    propertyAddress?: StringNullableFilter<"RentalBooking"> | string | null
    propertyInstructions?: StringNullableFilter<"RentalBooking"> | string | null
    wifiName?: StringNullableFilter<"RentalBooking"> | string | null
    wifiPassword?: StringNullableFilter<"RentalBooking"> | string | null
    accessCode?: StringNullableFilter<"RentalBooking"> | string | null
    emergencyContact?: StringNullableFilter<"RentalBooking"> | string | null
    houseRules?: StringNullableFilter<"RentalBooking"> | string | null
    confirmedAt?: DateTimeNullableFilter<"RentalBooking"> | Date | string | null
    agentId?: StringNullableFilter<"RentalBooking"> | string | null
    tm30Status?: EnumTM30BookingStatusFilter<"RentalBooking"> | $Enums.TM30BookingStatus
    tm30SubmittedAt?: DateTimeNullableFilter<"RentalBooking"> | Date | string | null
    tm30Reference?: StringNullableFilter<"RentalBooking"> | string | null
    tm30Error?: StringNullableFilter<"RentalBooking"> | string | null
    passportsRequired?: IntFilter<"RentalBooking"> | number
    passportsReceived?: IntFilter<"RentalBooking"> | number
    createdAt?: DateTimeFilter<"RentalBooking"> | Date | string
    updatedAt?: DateTimeFilter<"RentalBooking"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    agent?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    messages?: BookingMessageListRelationFilter
    guests?: BookingGuestListRelationFilter
  }, "id">

  export type RentalBookingOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    userId?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    nights?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    babies?: SortOrder
    pets?: SortOrder
    basePrice?: SortOrder
    season?: SortOrder
    discountPercent?: SortOrder
    totalPrice?: SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrder
    guestCountryCode?: SortOrder
    guestMessage?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    cancellationPolicy?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    internalNotes?: SortOrderInput | SortOrder
    checkInTime?: SortOrderInput | SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    propertyAddress?: SortOrderInput | SortOrder
    propertyInstructions?: SortOrderInput | SortOrder
    wifiName?: SortOrderInput | SortOrder
    wifiPassword?: SortOrderInput | SortOrder
    accessCode?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    houseRules?: SortOrderInput | SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    agentId?: SortOrderInput | SortOrder
    tm30Status?: SortOrder
    tm30SubmittedAt?: SortOrderInput | SortOrder
    tm30Reference?: SortOrderInput | SortOrder
    tm30Error?: SortOrderInput | SortOrder
    passportsRequired?: SortOrder
    passportsReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RentalBookingCountOrderByAggregateInput
    _avg?: RentalBookingAvgOrderByAggregateInput
    _max?: RentalBookingMaxOrderByAggregateInput
    _min?: RentalBookingMinOrderByAggregateInput
    _sum?: RentalBookingSumOrderByAggregateInput
  }

  export type RentalBookingScalarWhereWithAggregatesInput = {
    AND?: RentalBookingScalarWhereWithAggregatesInput | RentalBookingScalarWhereWithAggregatesInput[]
    OR?: RentalBookingScalarWhereWithAggregatesInput[]
    NOT?: RentalBookingScalarWhereWithAggregatesInput | RentalBookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RentalBooking"> | string
    propertyId?: StringWithAggregatesFilter<"RentalBooking"> | string
    userId?: StringWithAggregatesFilter<"RentalBooking"> | string
    checkIn?: DateTimeWithAggregatesFilter<"RentalBooking"> | Date | string
    checkOut?: DateTimeWithAggregatesFilter<"RentalBooking"> | Date | string
    nights?: IntWithAggregatesFilter<"RentalBooking"> | number
    adults?: IntWithAggregatesFilter<"RentalBooking"> | number
    children?: IntWithAggregatesFilter<"RentalBooking"> | number
    babies?: IntWithAggregatesFilter<"RentalBooking"> | number
    pets?: IntWithAggregatesFilter<"RentalBooking"> | number
    basePrice?: FloatWithAggregatesFilter<"RentalBooking"> | number
    season?: StringWithAggregatesFilter<"RentalBooking"> | string
    discountPercent?: FloatWithAggregatesFilter<"RentalBooking"> | number
    totalPrice?: FloatWithAggregatesFilter<"RentalBooking"> | number
    guestName?: StringWithAggregatesFilter<"RentalBooking"> | string
    guestEmail?: StringWithAggregatesFilter<"RentalBooking"> | string
    guestPhone?: StringWithAggregatesFilter<"RentalBooking"> | string
    guestCountryCode?: StringWithAggregatesFilter<"RentalBooking"> | string
    guestMessage?: StringNullableWithAggregatesFilter<"RentalBooking"> | string | null
    status?: EnumRentalBookingStatusWithAggregatesFilter<"RentalBooking"> | $Enums.RentalBookingStatus
    paymentStatus?: StringNullableWithAggregatesFilter<"RentalBooking"> | string | null
    cancellationPolicy?: StringNullableWithAggregatesFilter<"RentalBooking"> | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"RentalBooking"> | Date | string | null
    cancellationReason?: StringNullableWithAggregatesFilter<"RentalBooking"> | string | null
    internalNotes?: StringNullableWithAggregatesFilter<"RentalBooking"> | string | null
    checkInTime?: StringNullableWithAggregatesFilter<"RentalBooking"> | string | null
    checkOutTime?: StringNullableWithAggregatesFilter<"RentalBooking"> | string | null
    propertyAddress?: StringNullableWithAggregatesFilter<"RentalBooking"> | string | null
    propertyInstructions?: StringNullableWithAggregatesFilter<"RentalBooking"> | string | null
    wifiName?: StringNullableWithAggregatesFilter<"RentalBooking"> | string | null
    wifiPassword?: StringNullableWithAggregatesFilter<"RentalBooking"> | string | null
    accessCode?: StringNullableWithAggregatesFilter<"RentalBooking"> | string | null
    emergencyContact?: StringNullableWithAggregatesFilter<"RentalBooking"> | string | null
    houseRules?: StringNullableWithAggregatesFilter<"RentalBooking"> | string | null
    confirmedAt?: DateTimeNullableWithAggregatesFilter<"RentalBooking"> | Date | string | null
    agentId?: StringNullableWithAggregatesFilter<"RentalBooking"> | string | null
    tm30Status?: EnumTM30BookingStatusWithAggregatesFilter<"RentalBooking"> | $Enums.TM30BookingStatus
    tm30SubmittedAt?: DateTimeNullableWithAggregatesFilter<"RentalBooking"> | Date | string | null
    tm30Reference?: StringNullableWithAggregatesFilter<"RentalBooking"> | string | null
    tm30Error?: StringNullableWithAggregatesFilter<"RentalBooking"> | string | null
    passportsRequired?: IntWithAggregatesFilter<"RentalBooking"> | number
    passportsReceived?: IntWithAggregatesFilter<"RentalBooking"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RentalBooking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RentalBooking"> | Date | string
  }

  export type BookingMessageWhereInput = {
    AND?: BookingMessageWhereInput | BookingMessageWhereInput[]
    OR?: BookingMessageWhereInput[]
    NOT?: BookingMessageWhereInput | BookingMessageWhereInput[]
    id?: StringFilter<"BookingMessage"> | string
    bookingId?: StringFilter<"BookingMessage"> | string
    senderId?: StringFilter<"BookingMessage"> | string
    senderRole?: StringFilter<"BookingMessage"> | string
    message?: StringFilter<"BookingMessage"> | string
    isRead?: BoolFilter<"BookingMessage"> | boolean
    createdAt?: DateTimeFilter<"BookingMessage"> | Date | string
    updatedAt?: DateTimeFilter<"BookingMessage"> | Date | string
    booking?: XOR<RentalBookingScalarRelationFilter, RentalBookingWhereInput>
  }

  export type BookingMessageOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    senderId?: SortOrder
    senderRole?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: RentalBookingOrderByWithRelationInput
  }

  export type BookingMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingMessageWhereInput | BookingMessageWhereInput[]
    OR?: BookingMessageWhereInput[]
    NOT?: BookingMessageWhereInput | BookingMessageWhereInput[]
    bookingId?: StringFilter<"BookingMessage"> | string
    senderId?: StringFilter<"BookingMessage"> | string
    senderRole?: StringFilter<"BookingMessage"> | string
    message?: StringFilter<"BookingMessage"> | string
    isRead?: BoolFilter<"BookingMessage"> | boolean
    createdAt?: DateTimeFilter<"BookingMessage"> | Date | string
    updatedAt?: DateTimeFilter<"BookingMessage"> | Date | string
    booking?: XOR<RentalBookingScalarRelationFilter, RentalBookingWhereInput>
  }, "id">

  export type BookingMessageOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    senderId?: SortOrder
    senderRole?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookingMessageCountOrderByAggregateInput
    _max?: BookingMessageMaxOrderByAggregateInput
    _min?: BookingMessageMinOrderByAggregateInput
  }

  export type BookingMessageScalarWhereWithAggregatesInput = {
    AND?: BookingMessageScalarWhereWithAggregatesInput | BookingMessageScalarWhereWithAggregatesInput[]
    OR?: BookingMessageScalarWhereWithAggregatesInput[]
    NOT?: BookingMessageScalarWhereWithAggregatesInput | BookingMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookingMessage"> | string
    bookingId?: StringWithAggregatesFilter<"BookingMessage"> | string
    senderId?: StringWithAggregatesFilter<"BookingMessage"> | string
    senderRole?: StringWithAggregatesFilter<"BookingMessage"> | string
    message?: StringWithAggregatesFilter<"BookingMessage"> | string
    isRead?: BoolWithAggregatesFilter<"BookingMessage"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BookingMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BookingMessage"> | Date | string
  }

  export type BookingGuestWhereInput = {
    AND?: BookingGuestWhereInput | BookingGuestWhereInput[]
    OR?: BookingGuestWhereInput[]
    NOT?: BookingGuestWhereInput | BookingGuestWhereInput[]
    id?: StringFilter<"BookingGuest"> | string
    bookingId?: StringFilter<"BookingGuest"> | string
    guestType?: StringFilter<"BookingGuest"> | string
    guestNumber?: IntFilter<"BookingGuest"> | number
    firstName?: StringNullableFilter<"BookingGuest"> | string | null
    lastName?: StringNullableFilter<"BookingGuest"> | string | null
    fullName?: StringNullableFilter<"BookingGuest"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"BookingGuest"> | Date | string | null
    nationality?: StringNullableFilter<"BookingGuest"> | string | null
    gender?: StringNullableFilter<"BookingGuest"> | string | null
    passportNumber?: StringNullableFilter<"BookingGuest"> | string | null
    passportExpiry?: DateTimeNullableFilter<"BookingGuest"> | Date | string | null
    passportIssueDate?: DateTimeNullableFilter<"BookingGuest"> | Date | string | null
    passportCountry?: StringNullableFilter<"BookingGuest"> | string | null
    passportImageUrl?: StringNullableFilter<"BookingGuest"> | string | null
    passportImagePath?: StringNullableFilter<"BookingGuest"> | string | null
    ocrConfidence?: FloatNullableFilter<"BookingGuest"> | number | null
    ocrRawData?: JsonNullableFilter<"BookingGuest">
    ocrProcessedAt?: DateTimeNullableFilter<"BookingGuest"> | Date | string | null
    passportVerified?: BoolFilter<"BookingGuest"> | boolean
    verifiedBy?: StringNullableFilter<"BookingGuest"> | string | null
    verifiedAt?: DateTimeNullableFilter<"BookingGuest"> | Date | string | null
    tm30Status?: EnumTM30GuestStatusFilter<"BookingGuest"> | $Enums.TM30GuestStatus
    tm30SubmittedAt?: DateTimeNullableFilter<"BookingGuest"> | Date | string | null
    tm30Error?: StringNullableFilter<"BookingGuest"> | string | null
    whatsappMessageId?: StringNullableFilter<"BookingGuest"> | string | null
    whatsappReceivedAt?: DateTimeNullableFilter<"BookingGuest"> | Date | string | null
    createdAt?: DateTimeFilter<"BookingGuest"> | Date | string
    updatedAt?: DateTimeFilter<"BookingGuest"> | Date | string
    booking?: XOR<RentalBookingScalarRelationFilter, RentalBookingWhereInput>
  }

  export type BookingGuestOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    guestType?: SortOrder
    guestNumber?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    passportNumber?: SortOrderInput | SortOrder
    passportExpiry?: SortOrderInput | SortOrder
    passportIssueDate?: SortOrderInput | SortOrder
    passportCountry?: SortOrderInput | SortOrder
    passportImageUrl?: SortOrderInput | SortOrder
    passportImagePath?: SortOrderInput | SortOrder
    ocrConfidence?: SortOrderInput | SortOrder
    ocrRawData?: SortOrderInput | SortOrder
    ocrProcessedAt?: SortOrderInput | SortOrder
    passportVerified?: SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    tm30Status?: SortOrder
    tm30SubmittedAt?: SortOrderInput | SortOrder
    tm30Error?: SortOrderInput | SortOrder
    whatsappMessageId?: SortOrderInput | SortOrder
    whatsappReceivedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: RentalBookingOrderByWithRelationInput
  }

  export type BookingGuestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingGuestWhereInput | BookingGuestWhereInput[]
    OR?: BookingGuestWhereInput[]
    NOT?: BookingGuestWhereInput | BookingGuestWhereInput[]
    bookingId?: StringFilter<"BookingGuest"> | string
    guestType?: StringFilter<"BookingGuest"> | string
    guestNumber?: IntFilter<"BookingGuest"> | number
    firstName?: StringNullableFilter<"BookingGuest"> | string | null
    lastName?: StringNullableFilter<"BookingGuest"> | string | null
    fullName?: StringNullableFilter<"BookingGuest"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"BookingGuest"> | Date | string | null
    nationality?: StringNullableFilter<"BookingGuest"> | string | null
    gender?: StringNullableFilter<"BookingGuest"> | string | null
    passportNumber?: StringNullableFilter<"BookingGuest"> | string | null
    passportExpiry?: DateTimeNullableFilter<"BookingGuest"> | Date | string | null
    passportIssueDate?: DateTimeNullableFilter<"BookingGuest"> | Date | string | null
    passportCountry?: StringNullableFilter<"BookingGuest"> | string | null
    passportImageUrl?: StringNullableFilter<"BookingGuest"> | string | null
    passportImagePath?: StringNullableFilter<"BookingGuest"> | string | null
    ocrConfidence?: FloatNullableFilter<"BookingGuest"> | number | null
    ocrRawData?: JsonNullableFilter<"BookingGuest">
    ocrProcessedAt?: DateTimeNullableFilter<"BookingGuest"> | Date | string | null
    passportVerified?: BoolFilter<"BookingGuest"> | boolean
    verifiedBy?: StringNullableFilter<"BookingGuest"> | string | null
    verifiedAt?: DateTimeNullableFilter<"BookingGuest"> | Date | string | null
    tm30Status?: EnumTM30GuestStatusFilter<"BookingGuest"> | $Enums.TM30GuestStatus
    tm30SubmittedAt?: DateTimeNullableFilter<"BookingGuest"> | Date | string | null
    tm30Error?: StringNullableFilter<"BookingGuest"> | string | null
    whatsappMessageId?: StringNullableFilter<"BookingGuest"> | string | null
    whatsappReceivedAt?: DateTimeNullableFilter<"BookingGuest"> | Date | string | null
    createdAt?: DateTimeFilter<"BookingGuest"> | Date | string
    updatedAt?: DateTimeFilter<"BookingGuest"> | Date | string
    booking?: XOR<RentalBookingScalarRelationFilter, RentalBookingWhereInput>
  }, "id">

  export type BookingGuestOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    guestType?: SortOrder
    guestNumber?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    passportNumber?: SortOrderInput | SortOrder
    passportExpiry?: SortOrderInput | SortOrder
    passportIssueDate?: SortOrderInput | SortOrder
    passportCountry?: SortOrderInput | SortOrder
    passportImageUrl?: SortOrderInput | SortOrder
    passportImagePath?: SortOrderInput | SortOrder
    ocrConfidence?: SortOrderInput | SortOrder
    ocrRawData?: SortOrderInput | SortOrder
    ocrProcessedAt?: SortOrderInput | SortOrder
    passportVerified?: SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    tm30Status?: SortOrder
    tm30SubmittedAt?: SortOrderInput | SortOrder
    tm30Error?: SortOrderInput | SortOrder
    whatsappMessageId?: SortOrderInput | SortOrder
    whatsappReceivedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookingGuestCountOrderByAggregateInput
    _avg?: BookingGuestAvgOrderByAggregateInput
    _max?: BookingGuestMaxOrderByAggregateInput
    _min?: BookingGuestMinOrderByAggregateInput
    _sum?: BookingGuestSumOrderByAggregateInput
  }

  export type BookingGuestScalarWhereWithAggregatesInput = {
    AND?: BookingGuestScalarWhereWithAggregatesInput | BookingGuestScalarWhereWithAggregatesInput[]
    OR?: BookingGuestScalarWhereWithAggregatesInput[]
    NOT?: BookingGuestScalarWhereWithAggregatesInput | BookingGuestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookingGuest"> | string
    bookingId?: StringWithAggregatesFilter<"BookingGuest"> | string
    guestType?: StringWithAggregatesFilter<"BookingGuest"> | string
    guestNumber?: IntWithAggregatesFilter<"BookingGuest"> | number
    firstName?: StringNullableWithAggregatesFilter<"BookingGuest"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"BookingGuest"> | string | null
    fullName?: StringNullableWithAggregatesFilter<"BookingGuest"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"BookingGuest"> | Date | string | null
    nationality?: StringNullableWithAggregatesFilter<"BookingGuest"> | string | null
    gender?: StringNullableWithAggregatesFilter<"BookingGuest"> | string | null
    passportNumber?: StringNullableWithAggregatesFilter<"BookingGuest"> | string | null
    passportExpiry?: DateTimeNullableWithAggregatesFilter<"BookingGuest"> | Date | string | null
    passportIssueDate?: DateTimeNullableWithAggregatesFilter<"BookingGuest"> | Date | string | null
    passportCountry?: StringNullableWithAggregatesFilter<"BookingGuest"> | string | null
    passportImageUrl?: StringNullableWithAggregatesFilter<"BookingGuest"> | string | null
    passportImagePath?: StringNullableWithAggregatesFilter<"BookingGuest"> | string | null
    ocrConfidence?: FloatNullableWithAggregatesFilter<"BookingGuest"> | number | null
    ocrRawData?: JsonNullableWithAggregatesFilter<"BookingGuest">
    ocrProcessedAt?: DateTimeNullableWithAggregatesFilter<"BookingGuest"> | Date | string | null
    passportVerified?: BoolWithAggregatesFilter<"BookingGuest"> | boolean
    verifiedBy?: StringNullableWithAggregatesFilter<"BookingGuest"> | string | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"BookingGuest"> | Date | string | null
    tm30Status?: EnumTM30GuestStatusWithAggregatesFilter<"BookingGuest"> | $Enums.TM30GuestStatus
    tm30SubmittedAt?: DateTimeNullableWithAggregatesFilter<"BookingGuest"> | Date | string | null
    tm30Error?: StringNullableWithAggregatesFilter<"BookingGuest"> | string | null
    whatsappMessageId?: StringNullableWithAggregatesFilter<"BookingGuest"> | string | null
    whatsappReceivedAt?: DateTimeNullableWithAggregatesFilter<"BookingGuest"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BookingGuest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BookingGuest"> | Date | string
  }

  export type PropertyBlockedDateWhereInput = {
    AND?: PropertyBlockedDateWhereInput | PropertyBlockedDateWhereInput[]
    OR?: PropertyBlockedDateWhereInput[]
    NOT?: PropertyBlockedDateWhereInput | PropertyBlockedDateWhereInput[]
    id?: StringFilter<"PropertyBlockedDate"> | string
    propertyId?: StringFilter<"PropertyBlockedDate"> | string
    startDate?: DateTimeFilter<"PropertyBlockedDate"> | Date | string
    endDate?: DateTimeFilter<"PropertyBlockedDate"> | Date | string
    reason?: StringNullableFilter<"PropertyBlockedDate"> | string | null
    blockedBy?: StringNullableFilter<"PropertyBlockedDate"> | string | null
    createdAt?: DateTimeFilter<"PropertyBlockedDate"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyBlockedDate"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PropertyBlockedDateOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrderInput | SortOrder
    blockedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type PropertyBlockedDateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyBlockedDateWhereInput | PropertyBlockedDateWhereInput[]
    OR?: PropertyBlockedDateWhereInput[]
    NOT?: PropertyBlockedDateWhereInput | PropertyBlockedDateWhereInput[]
    propertyId?: StringFilter<"PropertyBlockedDate"> | string
    startDate?: DateTimeFilter<"PropertyBlockedDate"> | Date | string
    endDate?: DateTimeFilter<"PropertyBlockedDate"> | Date | string
    reason?: StringNullableFilter<"PropertyBlockedDate"> | string | null
    blockedBy?: StringNullableFilter<"PropertyBlockedDate"> | string | null
    createdAt?: DateTimeFilter<"PropertyBlockedDate"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyBlockedDate"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type PropertyBlockedDateOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrderInput | SortOrder
    blockedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyBlockedDateCountOrderByAggregateInput
    _max?: PropertyBlockedDateMaxOrderByAggregateInput
    _min?: PropertyBlockedDateMinOrderByAggregateInput
  }

  export type PropertyBlockedDateScalarWhereWithAggregatesInput = {
    AND?: PropertyBlockedDateScalarWhereWithAggregatesInput | PropertyBlockedDateScalarWhereWithAggregatesInput[]
    OR?: PropertyBlockedDateScalarWhereWithAggregatesInput[]
    NOT?: PropertyBlockedDateScalarWhereWithAggregatesInput | PropertyBlockedDateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyBlockedDate"> | string
    propertyId?: StringWithAggregatesFilter<"PropertyBlockedDate"> | string
    startDate?: DateTimeWithAggregatesFilter<"PropertyBlockedDate"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"PropertyBlockedDate"> | Date | string
    reason?: StringNullableWithAggregatesFilter<"PropertyBlockedDate"> | string | null
    blockedBy?: StringNullableWithAggregatesFilter<"PropertyBlockedDate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PropertyBlockedDate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertyBlockedDate"> | Date | string
  }

  export type Tm30AccommodationWhereInput = {
    AND?: Tm30AccommodationWhereInput | Tm30AccommodationWhereInput[]
    OR?: Tm30AccommodationWhereInput[]
    NOT?: Tm30AccommodationWhereInput | Tm30AccommodationWhereInput[]
    id?: StringFilter<"Tm30Accommodation"> | string
    tm30Id?: StringFilter<"Tm30Accommodation"> | string
    name?: StringFilter<"Tm30Accommodation"> | string
    address?: StringFilter<"Tm30Accommodation"> | string
    status?: StringNullableFilter<"Tm30Accommodation"> | string | null
    propertyId?: StringNullableFilter<"Tm30Accommodation"> | string | null
    matchScore?: FloatNullableFilter<"Tm30Accommodation"> | number | null
    matchedBy?: StringNullableFilter<"Tm30Accommodation"> | string | null
    matchedAt?: DateTimeNullableFilter<"Tm30Accommodation"> | Date | string | null
    lastSyncedAt?: DateTimeNullableFilter<"Tm30Accommodation"> | Date | string | null
    syncSource?: StringNullableFilter<"Tm30Accommodation"> | string | null
    createdAt?: DateTimeNullableFilter<"Tm30Accommodation"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Tm30Accommodation"> | Date | string | null
    property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
  }

  export type Tm30AccommodationOrderByWithRelationInput = {
    id?: SortOrder
    tm30Id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    status?: SortOrderInput | SortOrder
    propertyId?: SortOrderInput | SortOrder
    matchScore?: SortOrderInput | SortOrder
    matchedBy?: SortOrderInput | SortOrder
    matchedAt?: SortOrderInput | SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    syncSource?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type Tm30AccommodationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    propertyId?: string
    AND?: Tm30AccommodationWhereInput | Tm30AccommodationWhereInput[]
    OR?: Tm30AccommodationWhereInput[]
    NOT?: Tm30AccommodationWhereInput | Tm30AccommodationWhereInput[]
    tm30Id?: StringFilter<"Tm30Accommodation"> | string
    name?: StringFilter<"Tm30Accommodation"> | string
    address?: StringFilter<"Tm30Accommodation"> | string
    status?: StringNullableFilter<"Tm30Accommodation"> | string | null
    matchScore?: FloatNullableFilter<"Tm30Accommodation"> | number | null
    matchedBy?: StringNullableFilter<"Tm30Accommodation"> | string | null
    matchedAt?: DateTimeNullableFilter<"Tm30Accommodation"> | Date | string | null
    lastSyncedAt?: DateTimeNullableFilter<"Tm30Accommodation"> | Date | string | null
    syncSource?: StringNullableFilter<"Tm30Accommodation"> | string | null
    createdAt?: DateTimeNullableFilter<"Tm30Accommodation"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Tm30Accommodation"> | Date | string | null
    property?: XOR<PropertyNullableScalarRelationFilter, PropertyWhereInput> | null
  }, "id" | "propertyId">

  export type Tm30AccommodationOrderByWithAggregationInput = {
    id?: SortOrder
    tm30Id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    status?: SortOrderInput | SortOrder
    propertyId?: SortOrderInput | SortOrder
    matchScore?: SortOrderInput | SortOrder
    matchedBy?: SortOrderInput | SortOrder
    matchedAt?: SortOrderInput | SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    syncSource?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: Tm30AccommodationCountOrderByAggregateInput
    _avg?: Tm30AccommodationAvgOrderByAggregateInput
    _max?: Tm30AccommodationMaxOrderByAggregateInput
    _min?: Tm30AccommodationMinOrderByAggregateInput
    _sum?: Tm30AccommodationSumOrderByAggregateInput
  }

  export type Tm30AccommodationScalarWhereWithAggregatesInput = {
    AND?: Tm30AccommodationScalarWhereWithAggregatesInput | Tm30AccommodationScalarWhereWithAggregatesInput[]
    OR?: Tm30AccommodationScalarWhereWithAggregatesInput[]
    NOT?: Tm30AccommodationScalarWhereWithAggregatesInput | Tm30AccommodationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tm30Accommodation"> | string
    tm30Id?: StringWithAggregatesFilter<"Tm30Accommodation"> | string
    name?: StringWithAggregatesFilter<"Tm30Accommodation"> | string
    address?: StringWithAggregatesFilter<"Tm30Accommodation"> | string
    status?: StringNullableWithAggregatesFilter<"Tm30Accommodation"> | string | null
    propertyId?: StringNullableWithAggregatesFilter<"Tm30Accommodation"> | string | null
    matchScore?: FloatNullableWithAggregatesFilter<"Tm30Accommodation"> | number | null
    matchedBy?: StringNullableWithAggregatesFilter<"Tm30Accommodation"> | string | null
    matchedAt?: DateTimeNullableWithAggregatesFilter<"Tm30Accommodation"> | Date | string | null
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"Tm30Accommodation"> | Date | string | null
    syncSource?: StringNullableWithAggregatesFilter<"Tm30Accommodation"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Tm30Accommodation"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Tm30Accommodation"> | Date | string | null
  }

  export type Tm30AccommodationRequestWhereInput = {
    AND?: Tm30AccommodationRequestWhereInput | Tm30AccommodationRequestWhereInput[]
    OR?: Tm30AccommodationRequestWhereInput[]
    NOT?: Tm30AccommodationRequestWhereInput | Tm30AccommodationRequestWhereInput[]
    id?: StringFilter<"Tm30AccommodationRequest"> | string
    ownerSameAsRegistrant?: BoolFilter<"Tm30AccommodationRequest"> | boolean
    ownerNationalType?: StringFilter<"Tm30AccommodationRequest"> | string
    ownerNationalId?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    ownerPassportNumber?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    ownerFirstName?: StringFilter<"Tm30AccommodationRequest"> | string
    ownerMiddleName?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    ownerLastName?: StringFilter<"Tm30AccommodationRequest"> | string
    ownerTelephone?: StringFilter<"Tm30AccommodationRequest"> | string
    ownerGender?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    entityType?: StringFilter<"Tm30AccommodationRequest"> | string
    houseIdNumber?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    accommodationType?: StringFilter<"Tm30AccommodationRequest"> | string
    accommodationName?: StringFilter<"Tm30AccommodationRequest"> | string
    position?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    positionOther?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    addressNumber?: StringFilter<"Tm30AccommodationRequest"> | string
    villageNumber?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    alley?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    road?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    province?: StringFilter<"Tm30AccommodationRequest"> | string
    district?: StringFilter<"Tm30AccommodationRequest"> | string
    subDistrict?: StringFilter<"Tm30AccommodationRequest"> | string
    postalCode?: StringFilter<"Tm30AccommodationRequest"> | string
    latitude?: FloatNullableFilter<"Tm30AccommodationRequest"> | number | null
    longitude?: FloatNullableFilter<"Tm30AccommodationRequest"> | number | null
    houseRegistrationUrl?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    houseRegistrationPath?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    ocrProcessed?: BoolFilter<"Tm30AccommodationRequest"> | boolean
    ocrProcessedAt?: DateTimeNullableFilter<"Tm30AccommodationRequest"> | Date | string | null
    ocrRawData?: JsonNullableFilter<"Tm30AccommodationRequest">
    ocrConfidence?: FloatNullableFilter<"Tm30AccommodationRequest"> | number | null
    status?: EnumTm30AccomRequestStatusFilter<"Tm30AccommodationRequest"> | $Enums.Tm30AccomRequestStatus
    tm30Id?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    submittedAt?: DateTimeNullableFilter<"Tm30AccommodationRequest"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"Tm30AccommodationRequest"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"Tm30AccommodationRequest"> | Date | string | null
    rejectionReason?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    errorMessage?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    propertyId?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    propertyOwnerId?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    whatsappPhone?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    whatsappSessionId?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    createdBy?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    updatedBy?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    createdAt?: DateTimeFilter<"Tm30AccommodationRequest"> | Date | string
    updatedAt?: DateTimeFilter<"Tm30AccommodationRequest"> | Date | string
    propertyOwner?: XOR<PropertyOwnerNullableScalarRelationFilter, PropertyOwnerWhereInput> | null
  }

  export type Tm30AccommodationRequestOrderByWithRelationInput = {
    id?: SortOrder
    ownerSameAsRegistrant?: SortOrder
    ownerNationalType?: SortOrder
    ownerNationalId?: SortOrderInput | SortOrder
    ownerPassportNumber?: SortOrderInput | SortOrder
    ownerFirstName?: SortOrder
    ownerMiddleName?: SortOrderInput | SortOrder
    ownerLastName?: SortOrder
    ownerTelephone?: SortOrder
    ownerGender?: SortOrderInput | SortOrder
    entityType?: SortOrder
    houseIdNumber?: SortOrderInput | SortOrder
    accommodationType?: SortOrder
    accommodationName?: SortOrder
    position?: SortOrderInput | SortOrder
    positionOther?: SortOrderInput | SortOrder
    addressNumber?: SortOrder
    villageNumber?: SortOrderInput | SortOrder
    alley?: SortOrderInput | SortOrder
    road?: SortOrderInput | SortOrder
    province?: SortOrder
    district?: SortOrder
    subDistrict?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    houseRegistrationUrl?: SortOrderInput | SortOrder
    houseRegistrationPath?: SortOrderInput | SortOrder
    ocrProcessed?: SortOrder
    ocrProcessedAt?: SortOrderInput | SortOrder
    ocrRawData?: SortOrderInput | SortOrder
    ocrConfidence?: SortOrderInput | SortOrder
    status?: SortOrder
    tm30Id?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    propertyId?: SortOrderInput | SortOrder
    propertyOwnerId?: SortOrderInput | SortOrder
    whatsappPhone?: SortOrderInput | SortOrder
    whatsappSessionId?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    propertyOwner?: PropertyOwnerOrderByWithRelationInput
  }

  export type Tm30AccommodationRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    propertyId?: string
    AND?: Tm30AccommodationRequestWhereInput | Tm30AccommodationRequestWhereInput[]
    OR?: Tm30AccommodationRequestWhereInput[]
    NOT?: Tm30AccommodationRequestWhereInput | Tm30AccommodationRequestWhereInput[]
    ownerSameAsRegistrant?: BoolFilter<"Tm30AccommodationRequest"> | boolean
    ownerNationalType?: StringFilter<"Tm30AccommodationRequest"> | string
    ownerNationalId?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    ownerPassportNumber?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    ownerFirstName?: StringFilter<"Tm30AccommodationRequest"> | string
    ownerMiddleName?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    ownerLastName?: StringFilter<"Tm30AccommodationRequest"> | string
    ownerTelephone?: StringFilter<"Tm30AccommodationRequest"> | string
    ownerGender?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    entityType?: StringFilter<"Tm30AccommodationRequest"> | string
    houseIdNumber?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    accommodationType?: StringFilter<"Tm30AccommodationRequest"> | string
    accommodationName?: StringFilter<"Tm30AccommodationRequest"> | string
    position?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    positionOther?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    addressNumber?: StringFilter<"Tm30AccommodationRequest"> | string
    villageNumber?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    alley?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    road?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    province?: StringFilter<"Tm30AccommodationRequest"> | string
    district?: StringFilter<"Tm30AccommodationRequest"> | string
    subDistrict?: StringFilter<"Tm30AccommodationRequest"> | string
    postalCode?: StringFilter<"Tm30AccommodationRequest"> | string
    latitude?: FloatNullableFilter<"Tm30AccommodationRequest"> | number | null
    longitude?: FloatNullableFilter<"Tm30AccommodationRequest"> | number | null
    houseRegistrationUrl?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    houseRegistrationPath?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    ocrProcessed?: BoolFilter<"Tm30AccommodationRequest"> | boolean
    ocrProcessedAt?: DateTimeNullableFilter<"Tm30AccommodationRequest"> | Date | string | null
    ocrRawData?: JsonNullableFilter<"Tm30AccommodationRequest">
    ocrConfidence?: FloatNullableFilter<"Tm30AccommodationRequest"> | number | null
    status?: EnumTm30AccomRequestStatusFilter<"Tm30AccommodationRequest"> | $Enums.Tm30AccomRequestStatus
    tm30Id?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    submittedAt?: DateTimeNullableFilter<"Tm30AccommodationRequest"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"Tm30AccommodationRequest"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"Tm30AccommodationRequest"> | Date | string | null
    rejectionReason?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    errorMessage?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    propertyOwnerId?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    whatsappPhone?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    whatsappSessionId?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    createdBy?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    updatedBy?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    createdAt?: DateTimeFilter<"Tm30AccommodationRequest"> | Date | string
    updatedAt?: DateTimeFilter<"Tm30AccommodationRequest"> | Date | string
    propertyOwner?: XOR<PropertyOwnerNullableScalarRelationFilter, PropertyOwnerWhereInput> | null
  }, "id" | "propertyId">

  export type Tm30AccommodationRequestOrderByWithAggregationInput = {
    id?: SortOrder
    ownerSameAsRegistrant?: SortOrder
    ownerNationalType?: SortOrder
    ownerNationalId?: SortOrderInput | SortOrder
    ownerPassportNumber?: SortOrderInput | SortOrder
    ownerFirstName?: SortOrder
    ownerMiddleName?: SortOrderInput | SortOrder
    ownerLastName?: SortOrder
    ownerTelephone?: SortOrder
    ownerGender?: SortOrderInput | SortOrder
    entityType?: SortOrder
    houseIdNumber?: SortOrderInput | SortOrder
    accommodationType?: SortOrder
    accommodationName?: SortOrder
    position?: SortOrderInput | SortOrder
    positionOther?: SortOrderInput | SortOrder
    addressNumber?: SortOrder
    villageNumber?: SortOrderInput | SortOrder
    alley?: SortOrderInput | SortOrder
    road?: SortOrderInput | SortOrder
    province?: SortOrder
    district?: SortOrder
    subDistrict?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    houseRegistrationUrl?: SortOrderInput | SortOrder
    houseRegistrationPath?: SortOrderInput | SortOrder
    ocrProcessed?: SortOrder
    ocrProcessedAt?: SortOrderInput | SortOrder
    ocrRawData?: SortOrderInput | SortOrder
    ocrConfidence?: SortOrderInput | SortOrder
    status?: SortOrder
    tm30Id?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    propertyId?: SortOrderInput | SortOrder
    propertyOwnerId?: SortOrderInput | SortOrder
    whatsappPhone?: SortOrderInput | SortOrder
    whatsappSessionId?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: Tm30AccommodationRequestCountOrderByAggregateInput
    _avg?: Tm30AccommodationRequestAvgOrderByAggregateInput
    _max?: Tm30AccommodationRequestMaxOrderByAggregateInput
    _min?: Tm30AccommodationRequestMinOrderByAggregateInput
    _sum?: Tm30AccommodationRequestSumOrderByAggregateInput
  }

  export type Tm30AccommodationRequestScalarWhereWithAggregatesInput = {
    AND?: Tm30AccommodationRequestScalarWhereWithAggregatesInput | Tm30AccommodationRequestScalarWhereWithAggregatesInput[]
    OR?: Tm30AccommodationRequestScalarWhereWithAggregatesInput[]
    NOT?: Tm30AccommodationRequestScalarWhereWithAggregatesInput | Tm30AccommodationRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tm30AccommodationRequest"> | string
    ownerSameAsRegistrant?: BoolWithAggregatesFilter<"Tm30AccommodationRequest"> | boolean
    ownerNationalType?: StringWithAggregatesFilter<"Tm30AccommodationRequest"> | string
    ownerNationalId?: StringNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | string | null
    ownerPassportNumber?: StringNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | string | null
    ownerFirstName?: StringWithAggregatesFilter<"Tm30AccommodationRequest"> | string
    ownerMiddleName?: StringNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | string | null
    ownerLastName?: StringWithAggregatesFilter<"Tm30AccommodationRequest"> | string
    ownerTelephone?: StringWithAggregatesFilter<"Tm30AccommodationRequest"> | string
    ownerGender?: StringNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | string | null
    entityType?: StringWithAggregatesFilter<"Tm30AccommodationRequest"> | string
    houseIdNumber?: StringNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | string | null
    accommodationType?: StringWithAggregatesFilter<"Tm30AccommodationRequest"> | string
    accommodationName?: StringWithAggregatesFilter<"Tm30AccommodationRequest"> | string
    position?: StringNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | string | null
    positionOther?: StringNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | string | null
    addressNumber?: StringWithAggregatesFilter<"Tm30AccommodationRequest"> | string
    villageNumber?: StringNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | string | null
    alley?: StringNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | string | null
    road?: StringNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | string | null
    province?: StringWithAggregatesFilter<"Tm30AccommodationRequest"> | string
    district?: StringWithAggregatesFilter<"Tm30AccommodationRequest"> | string
    subDistrict?: StringWithAggregatesFilter<"Tm30AccommodationRequest"> | string
    postalCode?: StringWithAggregatesFilter<"Tm30AccommodationRequest"> | string
    latitude?: FloatNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | number | null
    houseRegistrationUrl?: StringNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | string | null
    houseRegistrationPath?: StringNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | string | null
    ocrProcessed?: BoolWithAggregatesFilter<"Tm30AccommodationRequest"> | boolean
    ocrProcessedAt?: DateTimeNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | Date | string | null
    ocrRawData?: JsonNullableWithAggregatesFilter<"Tm30AccommodationRequest">
    ocrConfidence?: FloatNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | number | null
    status?: EnumTm30AccomRequestStatusWithAggregatesFilter<"Tm30AccommodationRequest"> | $Enums.Tm30AccomRequestStatus
    tm30Id?: StringNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | string | null
    submittedAt?: DateTimeNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | Date | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | Date | string | null
    rejectedAt?: DateTimeNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | Date | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | string | null
    propertyId?: StringNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | string | null
    propertyOwnerId?: StringNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | string | null
    whatsappPhone?: StringNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | string | null
    whatsappSessionId?: StringNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Tm30AccommodationRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tm30AccommodationRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tm30AccommodationRequest"> | Date | string
  }

  export type PropertyOwnerWhereInput = {
    AND?: PropertyOwnerWhereInput | PropertyOwnerWhereInput[]
    OR?: PropertyOwnerWhereInput[]
    NOT?: PropertyOwnerWhereInput | PropertyOwnerWhereInput[]
    id?: StringFilter<"PropertyOwner"> | string
    firstName?: StringFilter<"PropertyOwner"> | string
    lastName?: StringFilter<"PropertyOwner"> | string
    thaiIdNumber?: StringNullableFilter<"PropertyOwner"> | string | null
    phone?: StringFilter<"PropertyOwner"> | string
    email?: StringNullableFilter<"PropertyOwner"> | string | null
    gender?: StringNullableFilter<"PropertyOwner"> | string | null
    idCardUrl?: StringNullableFilter<"PropertyOwner"> | string | null
    idCardPath?: StringNullableFilter<"PropertyOwner"> | string | null
    idCardOcrData?: JsonNullableFilter<"PropertyOwner">
    idCardVerified?: BoolFilter<"PropertyOwner"> | boolean
    idCardUploadedAt?: DateTimeNullableFilter<"PropertyOwner"> | Date | string | null
    isActive?: BoolFilter<"PropertyOwner"> | boolean
    isVerified?: BoolFilter<"PropertyOwner"> | boolean
    createdAt?: DateTimeFilter<"PropertyOwner"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyOwner"> | Date | string
    documents?: OwnerDocumentListRelationFilter
    properties?: PropertyListRelationFilter
    tm30Requests?: Tm30AccommodationRequestListRelationFilter
  }

  export type PropertyOwnerOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    thaiIdNumber?: SortOrderInput | SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    idCardUrl?: SortOrderInput | SortOrder
    idCardPath?: SortOrderInput | SortOrder
    idCardOcrData?: SortOrderInput | SortOrder
    idCardVerified?: SortOrder
    idCardUploadedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    documents?: OwnerDocumentOrderByRelationAggregateInput
    properties?: PropertyOrderByRelationAggregateInput
    tm30Requests?: Tm30AccommodationRequestOrderByRelationAggregateInput
  }

  export type PropertyOwnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    thaiIdNumber?: string
    phone?: string
    AND?: PropertyOwnerWhereInput | PropertyOwnerWhereInput[]
    OR?: PropertyOwnerWhereInput[]
    NOT?: PropertyOwnerWhereInput | PropertyOwnerWhereInput[]
    firstName?: StringFilter<"PropertyOwner"> | string
    lastName?: StringFilter<"PropertyOwner"> | string
    email?: StringNullableFilter<"PropertyOwner"> | string | null
    gender?: StringNullableFilter<"PropertyOwner"> | string | null
    idCardUrl?: StringNullableFilter<"PropertyOwner"> | string | null
    idCardPath?: StringNullableFilter<"PropertyOwner"> | string | null
    idCardOcrData?: JsonNullableFilter<"PropertyOwner">
    idCardVerified?: BoolFilter<"PropertyOwner"> | boolean
    idCardUploadedAt?: DateTimeNullableFilter<"PropertyOwner"> | Date | string | null
    isActive?: BoolFilter<"PropertyOwner"> | boolean
    isVerified?: BoolFilter<"PropertyOwner"> | boolean
    createdAt?: DateTimeFilter<"PropertyOwner"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyOwner"> | Date | string
    documents?: OwnerDocumentListRelationFilter
    properties?: PropertyListRelationFilter
    tm30Requests?: Tm30AccommodationRequestListRelationFilter
  }, "id" | "thaiIdNumber" | "phone">

  export type PropertyOwnerOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    thaiIdNumber?: SortOrderInput | SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    idCardUrl?: SortOrderInput | SortOrder
    idCardPath?: SortOrderInput | SortOrder
    idCardOcrData?: SortOrderInput | SortOrder
    idCardVerified?: SortOrder
    idCardUploadedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyOwnerCountOrderByAggregateInput
    _max?: PropertyOwnerMaxOrderByAggregateInput
    _min?: PropertyOwnerMinOrderByAggregateInput
  }

  export type PropertyOwnerScalarWhereWithAggregatesInput = {
    AND?: PropertyOwnerScalarWhereWithAggregatesInput | PropertyOwnerScalarWhereWithAggregatesInput[]
    OR?: PropertyOwnerScalarWhereWithAggregatesInput[]
    NOT?: PropertyOwnerScalarWhereWithAggregatesInput | PropertyOwnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyOwner"> | string
    firstName?: StringWithAggregatesFilter<"PropertyOwner"> | string
    lastName?: StringWithAggregatesFilter<"PropertyOwner"> | string
    thaiIdNumber?: StringNullableWithAggregatesFilter<"PropertyOwner"> | string | null
    phone?: StringWithAggregatesFilter<"PropertyOwner"> | string
    email?: StringNullableWithAggregatesFilter<"PropertyOwner"> | string | null
    gender?: StringNullableWithAggregatesFilter<"PropertyOwner"> | string | null
    idCardUrl?: StringNullableWithAggregatesFilter<"PropertyOwner"> | string | null
    idCardPath?: StringNullableWithAggregatesFilter<"PropertyOwner"> | string | null
    idCardOcrData?: JsonNullableWithAggregatesFilter<"PropertyOwner">
    idCardVerified?: BoolWithAggregatesFilter<"PropertyOwner"> | boolean
    idCardUploadedAt?: DateTimeNullableWithAggregatesFilter<"PropertyOwner"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"PropertyOwner"> | boolean
    isVerified?: BoolWithAggregatesFilter<"PropertyOwner"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PropertyOwner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertyOwner"> | Date | string
  }

  export type OwnerDocumentWhereInput = {
    AND?: OwnerDocumentWhereInput | OwnerDocumentWhereInput[]
    OR?: OwnerDocumentWhereInput[]
    NOT?: OwnerDocumentWhereInput | OwnerDocumentWhereInput[]
    id?: StringFilter<"OwnerDocument"> | string
    ownerId?: StringFilter<"OwnerDocument"> | string
    documentType?: EnumOwnerDocumentTypeFilter<"OwnerDocument"> | $Enums.OwnerDocumentType
    imageUrl?: StringFilter<"OwnerDocument"> | string
    imagePath?: StringFilter<"OwnerDocument"> | string
    fileName?: StringNullableFilter<"OwnerDocument"> | string | null
    ocrData?: JsonNullableFilter<"OwnerDocument">
    ocrProcessedAt?: DateTimeNullableFilter<"OwnerDocument"> | Date | string | null
    ocrConfidence?: FloatNullableFilter<"OwnerDocument"> | number | null
    propertyId?: StringNullableFilter<"OwnerDocument"> | string | null
    houseId?: StringNullableFilter<"OwnerDocument"> | string | null
    extractedAddress?: StringNullableFilter<"OwnerDocument"> | string | null
    isVerified?: BoolFilter<"OwnerDocument"> | boolean
    verifiedBy?: StringNullableFilter<"OwnerDocument"> | string | null
    verifiedAt?: DateTimeNullableFilter<"OwnerDocument"> | Date | string | null
    createdAt?: DateTimeFilter<"OwnerDocument"> | Date | string
    updatedAt?: DateTimeFilter<"OwnerDocument"> | Date | string
    owner?: XOR<PropertyOwnerScalarRelationFilter, PropertyOwnerWhereInput>
  }

  export type OwnerDocumentOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    documentType?: SortOrder
    imageUrl?: SortOrder
    imagePath?: SortOrder
    fileName?: SortOrderInput | SortOrder
    ocrData?: SortOrderInput | SortOrder
    ocrProcessedAt?: SortOrderInput | SortOrder
    ocrConfidence?: SortOrderInput | SortOrder
    propertyId?: SortOrderInput | SortOrder
    houseId?: SortOrderInput | SortOrder
    extractedAddress?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: PropertyOwnerOrderByWithRelationInput
  }

  export type OwnerDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    propertyId?: string
    AND?: OwnerDocumentWhereInput | OwnerDocumentWhereInput[]
    OR?: OwnerDocumentWhereInput[]
    NOT?: OwnerDocumentWhereInput | OwnerDocumentWhereInput[]
    ownerId?: StringFilter<"OwnerDocument"> | string
    documentType?: EnumOwnerDocumentTypeFilter<"OwnerDocument"> | $Enums.OwnerDocumentType
    imageUrl?: StringFilter<"OwnerDocument"> | string
    imagePath?: StringFilter<"OwnerDocument"> | string
    fileName?: StringNullableFilter<"OwnerDocument"> | string | null
    ocrData?: JsonNullableFilter<"OwnerDocument">
    ocrProcessedAt?: DateTimeNullableFilter<"OwnerDocument"> | Date | string | null
    ocrConfidence?: FloatNullableFilter<"OwnerDocument"> | number | null
    houseId?: StringNullableFilter<"OwnerDocument"> | string | null
    extractedAddress?: StringNullableFilter<"OwnerDocument"> | string | null
    isVerified?: BoolFilter<"OwnerDocument"> | boolean
    verifiedBy?: StringNullableFilter<"OwnerDocument"> | string | null
    verifiedAt?: DateTimeNullableFilter<"OwnerDocument"> | Date | string | null
    createdAt?: DateTimeFilter<"OwnerDocument"> | Date | string
    updatedAt?: DateTimeFilter<"OwnerDocument"> | Date | string
    owner?: XOR<PropertyOwnerScalarRelationFilter, PropertyOwnerWhereInput>
  }, "id" | "propertyId">

  export type OwnerDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    documentType?: SortOrder
    imageUrl?: SortOrder
    imagePath?: SortOrder
    fileName?: SortOrderInput | SortOrder
    ocrData?: SortOrderInput | SortOrder
    ocrProcessedAt?: SortOrderInput | SortOrder
    ocrConfidence?: SortOrderInput | SortOrder
    propertyId?: SortOrderInput | SortOrder
    houseId?: SortOrderInput | SortOrder
    extractedAddress?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OwnerDocumentCountOrderByAggregateInput
    _avg?: OwnerDocumentAvgOrderByAggregateInput
    _max?: OwnerDocumentMaxOrderByAggregateInput
    _min?: OwnerDocumentMinOrderByAggregateInput
    _sum?: OwnerDocumentSumOrderByAggregateInput
  }

  export type OwnerDocumentScalarWhereWithAggregatesInput = {
    AND?: OwnerDocumentScalarWhereWithAggregatesInput | OwnerDocumentScalarWhereWithAggregatesInput[]
    OR?: OwnerDocumentScalarWhereWithAggregatesInput[]
    NOT?: OwnerDocumentScalarWhereWithAggregatesInput | OwnerDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OwnerDocument"> | string
    ownerId?: StringWithAggregatesFilter<"OwnerDocument"> | string
    documentType?: EnumOwnerDocumentTypeWithAggregatesFilter<"OwnerDocument"> | $Enums.OwnerDocumentType
    imageUrl?: StringWithAggregatesFilter<"OwnerDocument"> | string
    imagePath?: StringWithAggregatesFilter<"OwnerDocument"> | string
    fileName?: StringNullableWithAggregatesFilter<"OwnerDocument"> | string | null
    ocrData?: JsonNullableWithAggregatesFilter<"OwnerDocument">
    ocrProcessedAt?: DateTimeNullableWithAggregatesFilter<"OwnerDocument"> | Date | string | null
    ocrConfidence?: FloatNullableWithAggregatesFilter<"OwnerDocument"> | number | null
    propertyId?: StringNullableWithAggregatesFilter<"OwnerDocument"> | string | null
    houseId?: StringNullableWithAggregatesFilter<"OwnerDocument"> | string | null
    extractedAddress?: StringNullableWithAggregatesFilter<"OwnerDocument"> | string | null
    isVerified?: BoolWithAggregatesFilter<"OwnerDocument"> | boolean
    verifiedBy?: StringNullableWithAggregatesFilter<"OwnerDocument"> | string | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"OwnerDocument"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OwnerDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OwnerDocument"> | Date | string
  }

  export type WhatsappListingSessionWhereInput = {
    AND?: WhatsappListingSessionWhereInput | WhatsappListingSessionWhereInput[]
    OR?: WhatsappListingSessionWhereInput[]
    NOT?: WhatsappListingSessionWhereInput | WhatsappListingSessionWhereInput[]
    id?: StringFilter<"WhatsappListingSession"> | string
    phone?: StringFilter<"WhatsappListingSession"> | string
    status?: StringFilter<"WhatsappListingSession"> | string
    currentAction?: StringNullableFilter<"WhatsappListingSession"> | string | null
    ownerId?: StringNullableFilter<"WhatsappListingSession"> | string | null
    currentPropertyId?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30RequestId?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30OwnerFirstName?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30OwnerLastName?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30OwnerGender?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30OwnerPhone?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30ThaiIdNumber?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30IdCardUrl?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30BluebookUrl?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30HouseId?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30Province?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30District?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30SubDistrict?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30AddressNumber?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30PostalCode?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30AccommodationName?: StringNullableFilter<"WhatsappListingSession"> | string | null
    pendingData?: JsonNullableFilter<"WhatsappListingSession">
    lastMessageAt?: DateTimeFilter<"WhatsappListingSession"> | Date | string
    createdAt?: DateTimeFilter<"WhatsappListingSession"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsappListingSession"> | Date | string
  }

  export type WhatsappListingSessionOrderByWithRelationInput = {
    id?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    currentAction?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    currentPropertyId?: SortOrderInput | SortOrder
    tm30RequestId?: SortOrderInput | SortOrder
    tm30OwnerFirstName?: SortOrderInput | SortOrder
    tm30OwnerLastName?: SortOrderInput | SortOrder
    tm30OwnerGender?: SortOrderInput | SortOrder
    tm30OwnerPhone?: SortOrderInput | SortOrder
    tm30ThaiIdNumber?: SortOrderInput | SortOrder
    tm30IdCardUrl?: SortOrderInput | SortOrder
    tm30BluebookUrl?: SortOrderInput | SortOrder
    tm30HouseId?: SortOrderInput | SortOrder
    tm30Province?: SortOrderInput | SortOrder
    tm30District?: SortOrderInput | SortOrder
    tm30SubDistrict?: SortOrderInput | SortOrder
    tm30AddressNumber?: SortOrderInput | SortOrder
    tm30PostalCode?: SortOrderInput | SortOrder
    tm30AccommodationName?: SortOrderInput | SortOrder
    pendingData?: SortOrderInput | SortOrder
    lastMessageAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsappListingSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phone?: string
    AND?: WhatsappListingSessionWhereInput | WhatsappListingSessionWhereInput[]
    OR?: WhatsappListingSessionWhereInput[]
    NOT?: WhatsappListingSessionWhereInput | WhatsappListingSessionWhereInput[]
    status?: StringFilter<"WhatsappListingSession"> | string
    currentAction?: StringNullableFilter<"WhatsappListingSession"> | string | null
    ownerId?: StringNullableFilter<"WhatsappListingSession"> | string | null
    currentPropertyId?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30RequestId?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30OwnerFirstName?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30OwnerLastName?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30OwnerGender?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30OwnerPhone?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30ThaiIdNumber?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30IdCardUrl?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30BluebookUrl?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30HouseId?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30Province?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30District?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30SubDistrict?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30AddressNumber?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30PostalCode?: StringNullableFilter<"WhatsappListingSession"> | string | null
    tm30AccommodationName?: StringNullableFilter<"WhatsappListingSession"> | string | null
    pendingData?: JsonNullableFilter<"WhatsappListingSession">
    lastMessageAt?: DateTimeFilter<"WhatsappListingSession"> | Date | string
    createdAt?: DateTimeFilter<"WhatsappListingSession"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsappListingSession"> | Date | string
  }, "id" | "phone">

  export type WhatsappListingSessionOrderByWithAggregationInput = {
    id?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    currentAction?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    currentPropertyId?: SortOrderInput | SortOrder
    tm30RequestId?: SortOrderInput | SortOrder
    tm30OwnerFirstName?: SortOrderInput | SortOrder
    tm30OwnerLastName?: SortOrderInput | SortOrder
    tm30OwnerGender?: SortOrderInput | SortOrder
    tm30OwnerPhone?: SortOrderInput | SortOrder
    tm30ThaiIdNumber?: SortOrderInput | SortOrder
    tm30IdCardUrl?: SortOrderInput | SortOrder
    tm30BluebookUrl?: SortOrderInput | SortOrder
    tm30HouseId?: SortOrderInput | SortOrder
    tm30Province?: SortOrderInput | SortOrder
    tm30District?: SortOrderInput | SortOrder
    tm30SubDistrict?: SortOrderInput | SortOrder
    tm30AddressNumber?: SortOrderInput | SortOrder
    tm30PostalCode?: SortOrderInput | SortOrder
    tm30AccommodationName?: SortOrderInput | SortOrder
    pendingData?: SortOrderInput | SortOrder
    lastMessageAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WhatsappListingSessionCountOrderByAggregateInput
    _max?: WhatsappListingSessionMaxOrderByAggregateInput
    _min?: WhatsappListingSessionMinOrderByAggregateInput
  }

  export type WhatsappListingSessionScalarWhereWithAggregatesInput = {
    AND?: WhatsappListingSessionScalarWhereWithAggregatesInput | WhatsappListingSessionScalarWhereWithAggregatesInput[]
    OR?: WhatsappListingSessionScalarWhereWithAggregatesInput[]
    NOT?: WhatsappListingSessionScalarWhereWithAggregatesInput | WhatsappListingSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhatsappListingSession"> | string
    phone?: StringWithAggregatesFilter<"WhatsappListingSession"> | string
    status?: StringWithAggregatesFilter<"WhatsappListingSession"> | string
    currentAction?: StringNullableWithAggregatesFilter<"WhatsappListingSession"> | string | null
    ownerId?: StringNullableWithAggregatesFilter<"WhatsappListingSession"> | string | null
    currentPropertyId?: StringNullableWithAggregatesFilter<"WhatsappListingSession"> | string | null
    tm30RequestId?: StringNullableWithAggregatesFilter<"WhatsappListingSession"> | string | null
    tm30OwnerFirstName?: StringNullableWithAggregatesFilter<"WhatsappListingSession"> | string | null
    tm30OwnerLastName?: StringNullableWithAggregatesFilter<"WhatsappListingSession"> | string | null
    tm30OwnerGender?: StringNullableWithAggregatesFilter<"WhatsappListingSession"> | string | null
    tm30OwnerPhone?: StringNullableWithAggregatesFilter<"WhatsappListingSession"> | string | null
    tm30ThaiIdNumber?: StringNullableWithAggregatesFilter<"WhatsappListingSession"> | string | null
    tm30IdCardUrl?: StringNullableWithAggregatesFilter<"WhatsappListingSession"> | string | null
    tm30BluebookUrl?: StringNullableWithAggregatesFilter<"WhatsappListingSession"> | string | null
    tm30HouseId?: StringNullableWithAggregatesFilter<"WhatsappListingSession"> | string | null
    tm30Province?: StringNullableWithAggregatesFilter<"WhatsappListingSession"> | string | null
    tm30District?: StringNullableWithAggregatesFilter<"WhatsappListingSession"> | string | null
    tm30SubDistrict?: StringNullableWithAggregatesFilter<"WhatsappListingSession"> | string | null
    tm30AddressNumber?: StringNullableWithAggregatesFilter<"WhatsappListingSession"> | string | null
    tm30PostalCode?: StringNullableWithAggregatesFilter<"WhatsappListingSession"> | string | null
    tm30AccommodationName?: StringNullableWithAggregatesFilter<"WhatsappListingSession"> | string | null
    pendingData?: JsonNullableWithAggregatesFilter<"WhatsappListingSession">
    lastMessageAt?: DateTimeWithAggregatesFilter<"WhatsappListingSession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"WhatsappListingSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhatsappListingSession"> | Date | string
  }

  export type AIAgentConfigWhereInput = {
    AND?: AIAgentConfigWhereInput | AIAgentConfigWhereInput[]
    OR?: AIAgentConfigWhereInput[]
    NOT?: AIAgentConfigWhereInput | AIAgentConfigWhereInput[]
    id?: StringFilter<"AIAgentConfig"> | string
    enabled?: BoolFilter<"AIAgentConfig"> | boolean
    autonomousMode?: BoolFilter<"AIAgentConfig"> | boolean
    minConfidenceThreshold?: FloatFilter<"AIAgentConfig"> | number
    dailyDecisionLimit?: IntFilter<"AIAgentConfig"> | number
    dailyAutoExecuteLimit?: IntFilter<"AIAgentConfig"> | number
    notifyOnDecision?: BoolFilter<"AIAgentConfig"> | boolean
    notifyOnAutoExecute?: BoolFilter<"AIAgentConfig"> | boolean
    notifyEmail?: StringNullableFilter<"AIAgentConfig"> | string | null
    allowedAutonomousTypes?: StringFilter<"AIAgentConfig"> | string
    forbiddenPatterns?: StringFilter<"AIAgentConfig"> | string
    learningEnabled?: BoolFilter<"AIAgentConfig"> | boolean
    feedbackLoopDays?: IntFilter<"AIAgentConfig"> | number
    killSwitch?: BoolFilter<"AIAgentConfig"> | boolean
    pausedUntil?: DateTimeNullableFilter<"AIAgentConfig"> | Date | string | null
    pauseReason?: StringNullableFilter<"AIAgentConfig"> | string | null
    createdAt?: DateTimeFilter<"AIAgentConfig"> | Date | string
    updatedAt?: DateTimeFilter<"AIAgentConfig"> | Date | string
  }

  export type AIAgentConfigOrderByWithRelationInput = {
    id?: SortOrder
    enabled?: SortOrder
    autonomousMode?: SortOrder
    minConfidenceThreshold?: SortOrder
    dailyDecisionLimit?: SortOrder
    dailyAutoExecuteLimit?: SortOrder
    notifyOnDecision?: SortOrder
    notifyOnAutoExecute?: SortOrder
    notifyEmail?: SortOrderInput | SortOrder
    allowedAutonomousTypes?: SortOrder
    forbiddenPatterns?: SortOrder
    learningEnabled?: SortOrder
    feedbackLoopDays?: SortOrder
    killSwitch?: SortOrder
    pausedUntil?: SortOrderInput | SortOrder
    pauseReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIAgentConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIAgentConfigWhereInput | AIAgentConfigWhereInput[]
    OR?: AIAgentConfigWhereInput[]
    NOT?: AIAgentConfigWhereInput | AIAgentConfigWhereInput[]
    enabled?: BoolFilter<"AIAgentConfig"> | boolean
    autonomousMode?: BoolFilter<"AIAgentConfig"> | boolean
    minConfidenceThreshold?: FloatFilter<"AIAgentConfig"> | number
    dailyDecisionLimit?: IntFilter<"AIAgentConfig"> | number
    dailyAutoExecuteLimit?: IntFilter<"AIAgentConfig"> | number
    notifyOnDecision?: BoolFilter<"AIAgentConfig"> | boolean
    notifyOnAutoExecute?: BoolFilter<"AIAgentConfig"> | boolean
    notifyEmail?: StringNullableFilter<"AIAgentConfig"> | string | null
    allowedAutonomousTypes?: StringFilter<"AIAgentConfig"> | string
    forbiddenPatterns?: StringFilter<"AIAgentConfig"> | string
    learningEnabled?: BoolFilter<"AIAgentConfig"> | boolean
    feedbackLoopDays?: IntFilter<"AIAgentConfig"> | number
    killSwitch?: BoolFilter<"AIAgentConfig"> | boolean
    pausedUntil?: DateTimeNullableFilter<"AIAgentConfig"> | Date | string | null
    pauseReason?: StringNullableFilter<"AIAgentConfig"> | string | null
    createdAt?: DateTimeFilter<"AIAgentConfig"> | Date | string
    updatedAt?: DateTimeFilter<"AIAgentConfig"> | Date | string
  }, "id">

  export type AIAgentConfigOrderByWithAggregationInput = {
    id?: SortOrder
    enabled?: SortOrder
    autonomousMode?: SortOrder
    minConfidenceThreshold?: SortOrder
    dailyDecisionLimit?: SortOrder
    dailyAutoExecuteLimit?: SortOrder
    notifyOnDecision?: SortOrder
    notifyOnAutoExecute?: SortOrder
    notifyEmail?: SortOrderInput | SortOrder
    allowedAutonomousTypes?: SortOrder
    forbiddenPatterns?: SortOrder
    learningEnabled?: SortOrder
    feedbackLoopDays?: SortOrder
    killSwitch?: SortOrder
    pausedUntil?: SortOrderInput | SortOrder
    pauseReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AIAgentConfigCountOrderByAggregateInput
    _avg?: AIAgentConfigAvgOrderByAggregateInput
    _max?: AIAgentConfigMaxOrderByAggregateInput
    _min?: AIAgentConfigMinOrderByAggregateInput
    _sum?: AIAgentConfigSumOrderByAggregateInput
  }

  export type AIAgentConfigScalarWhereWithAggregatesInput = {
    AND?: AIAgentConfigScalarWhereWithAggregatesInput | AIAgentConfigScalarWhereWithAggregatesInput[]
    OR?: AIAgentConfigScalarWhereWithAggregatesInput[]
    NOT?: AIAgentConfigScalarWhereWithAggregatesInput | AIAgentConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIAgentConfig"> | string
    enabled?: BoolWithAggregatesFilter<"AIAgentConfig"> | boolean
    autonomousMode?: BoolWithAggregatesFilter<"AIAgentConfig"> | boolean
    minConfidenceThreshold?: FloatWithAggregatesFilter<"AIAgentConfig"> | number
    dailyDecisionLimit?: IntWithAggregatesFilter<"AIAgentConfig"> | number
    dailyAutoExecuteLimit?: IntWithAggregatesFilter<"AIAgentConfig"> | number
    notifyOnDecision?: BoolWithAggregatesFilter<"AIAgentConfig"> | boolean
    notifyOnAutoExecute?: BoolWithAggregatesFilter<"AIAgentConfig"> | boolean
    notifyEmail?: StringNullableWithAggregatesFilter<"AIAgentConfig"> | string | null
    allowedAutonomousTypes?: StringWithAggregatesFilter<"AIAgentConfig"> | string
    forbiddenPatterns?: StringWithAggregatesFilter<"AIAgentConfig"> | string
    learningEnabled?: BoolWithAggregatesFilter<"AIAgentConfig"> | boolean
    feedbackLoopDays?: IntWithAggregatesFilter<"AIAgentConfig"> | number
    killSwitch?: BoolWithAggregatesFilter<"AIAgentConfig"> | boolean
    pausedUntil?: DateTimeNullableWithAggregatesFilter<"AIAgentConfig"> | Date | string | null
    pauseReason?: StringNullableWithAggregatesFilter<"AIAgentConfig"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIAgentConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIAgentConfig"> | Date | string
  }

  export type AIDecisionWhereInput = {
    AND?: AIDecisionWhereInput | AIDecisionWhereInput[]
    OR?: AIDecisionWhereInput[]
    NOT?: AIDecisionWhereInput | AIDecisionWhereInput[]
    id?: StringFilter<"AIDecision"> | string
    type?: StringFilter<"AIDecision"> | string
    subType?: StringNullableFilter<"AIDecision"> | string | null
    priority?: StringFilter<"AIDecision"> | string
    confidence?: FloatFilter<"AIDecision"> | number
    reasoning?: StringFilter<"AIDecision"> | string
    dataSnapshot?: JsonNullableFilter<"AIDecision">
    actionType?: StringFilter<"AIDecision"> | string
    actionPayload?: JsonFilter<"AIDecision">
    estimatedImpact?: StringNullableFilter<"AIDecision"> | string | null
    rollbackPlan?: StringNullableFilter<"AIDecision"> | string | null
    requiresApproval?: BoolFilter<"AIDecision"> | boolean
    autoApproved?: BoolFilter<"AIDecision"> | boolean
    status?: EnumAIDecisionStatusFilter<"AIDecision"> | $Enums.AIDecisionStatus
    approvedBy?: StringNullableFilter<"AIDecision"> | string | null
    approvedByName?: StringNullableFilter<"AIDecision"> | string | null
    approvedAt?: DateTimeNullableFilter<"AIDecision"> | Date | string | null
    rejectedBy?: StringNullableFilter<"AIDecision"> | string | null
    rejectedByName?: StringNullableFilter<"AIDecision"> | string | null
    rejectedAt?: DateTimeNullableFilter<"AIDecision"> | Date | string | null
    rejectionReason?: StringNullableFilter<"AIDecision"> | string | null
    executedAt?: DateTimeNullableFilter<"AIDecision"> | Date | string | null
    executionResult?: JsonNullableFilter<"AIDecision">
    executionError?: StringNullableFilter<"AIDecision"> | string | null
    executionDuration?: IntNullableFilter<"AIDecision"> | number | null
    rolledBackAt?: DateTimeNullableFilter<"AIDecision"> | Date | string | null
    rolledBackBy?: StringNullableFilter<"AIDecision"> | string | null
    rollbackReason?: StringNullableFilter<"AIDecision"> | string | null
    feedbackDueAt?: DateTimeNullableFilter<"AIDecision"> | Date | string | null
    actualImpact?: JsonNullableFilter<"AIDecision">
    wasSuccessful?: BoolNullableFilter<"AIDecision"> | boolean | null
    successScore?: FloatNullableFilter<"AIDecision"> | number | null
    feedbackNotes?: StringNullableFilter<"AIDecision"> | string | null
    createdAt?: DateTimeFilter<"AIDecision"> | Date | string
    updatedAt?: DateTimeFilter<"AIDecision"> | Date | string
    codeChanges?: AICodeChangeListRelationFilter
    logs?: AIAgentLogListRelationFilter
  }

  export type AIDecisionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    subType?: SortOrderInput | SortOrder
    priority?: SortOrder
    confidence?: SortOrder
    reasoning?: SortOrder
    dataSnapshot?: SortOrderInput | SortOrder
    actionType?: SortOrder
    actionPayload?: SortOrder
    estimatedImpact?: SortOrderInput | SortOrder
    rollbackPlan?: SortOrderInput | SortOrder
    requiresApproval?: SortOrder
    autoApproved?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedByName?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedBy?: SortOrderInput | SortOrder
    rejectedByName?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    executedAt?: SortOrderInput | SortOrder
    executionResult?: SortOrderInput | SortOrder
    executionError?: SortOrderInput | SortOrder
    executionDuration?: SortOrderInput | SortOrder
    rolledBackAt?: SortOrderInput | SortOrder
    rolledBackBy?: SortOrderInput | SortOrder
    rollbackReason?: SortOrderInput | SortOrder
    feedbackDueAt?: SortOrderInput | SortOrder
    actualImpact?: SortOrderInput | SortOrder
    wasSuccessful?: SortOrderInput | SortOrder
    successScore?: SortOrderInput | SortOrder
    feedbackNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    codeChanges?: AICodeChangeOrderByRelationAggregateInput
    logs?: AIAgentLogOrderByRelationAggregateInput
  }

  export type AIDecisionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIDecisionWhereInput | AIDecisionWhereInput[]
    OR?: AIDecisionWhereInput[]
    NOT?: AIDecisionWhereInput | AIDecisionWhereInput[]
    type?: StringFilter<"AIDecision"> | string
    subType?: StringNullableFilter<"AIDecision"> | string | null
    priority?: StringFilter<"AIDecision"> | string
    confidence?: FloatFilter<"AIDecision"> | number
    reasoning?: StringFilter<"AIDecision"> | string
    dataSnapshot?: JsonNullableFilter<"AIDecision">
    actionType?: StringFilter<"AIDecision"> | string
    actionPayload?: JsonFilter<"AIDecision">
    estimatedImpact?: StringNullableFilter<"AIDecision"> | string | null
    rollbackPlan?: StringNullableFilter<"AIDecision"> | string | null
    requiresApproval?: BoolFilter<"AIDecision"> | boolean
    autoApproved?: BoolFilter<"AIDecision"> | boolean
    status?: EnumAIDecisionStatusFilter<"AIDecision"> | $Enums.AIDecisionStatus
    approvedBy?: StringNullableFilter<"AIDecision"> | string | null
    approvedByName?: StringNullableFilter<"AIDecision"> | string | null
    approvedAt?: DateTimeNullableFilter<"AIDecision"> | Date | string | null
    rejectedBy?: StringNullableFilter<"AIDecision"> | string | null
    rejectedByName?: StringNullableFilter<"AIDecision"> | string | null
    rejectedAt?: DateTimeNullableFilter<"AIDecision"> | Date | string | null
    rejectionReason?: StringNullableFilter<"AIDecision"> | string | null
    executedAt?: DateTimeNullableFilter<"AIDecision"> | Date | string | null
    executionResult?: JsonNullableFilter<"AIDecision">
    executionError?: StringNullableFilter<"AIDecision"> | string | null
    executionDuration?: IntNullableFilter<"AIDecision"> | number | null
    rolledBackAt?: DateTimeNullableFilter<"AIDecision"> | Date | string | null
    rolledBackBy?: StringNullableFilter<"AIDecision"> | string | null
    rollbackReason?: StringNullableFilter<"AIDecision"> | string | null
    feedbackDueAt?: DateTimeNullableFilter<"AIDecision"> | Date | string | null
    actualImpact?: JsonNullableFilter<"AIDecision">
    wasSuccessful?: BoolNullableFilter<"AIDecision"> | boolean | null
    successScore?: FloatNullableFilter<"AIDecision"> | number | null
    feedbackNotes?: StringNullableFilter<"AIDecision"> | string | null
    createdAt?: DateTimeFilter<"AIDecision"> | Date | string
    updatedAt?: DateTimeFilter<"AIDecision"> | Date | string
    codeChanges?: AICodeChangeListRelationFilter
    logs?: AIAgentLogListRelationFilter
  }, "id">

  export type AIDecisionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    subType?: SortOrderInput | SortOrder
    priority?: SortOrder
    confidence?: SortOrder
    reasoning?: SortOrder
    dataSnapshot?: SortOrderInput | SortOrder
    actionType?: SortOrder
    actionPayload?: SortOrder
    estimatedImpact?: SortOrderInput | SortOrder
    rollbackPlan?: SortOrderInput | SortOrder
    requiresApproval?: SortOrder
    autoApproved?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedByName?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedBy?: SortOrderInput | SortOrder
    rejectedByName?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    executedAt?: SortOrderInput | SortOrder
    executionResult?: SortOrderInput | SortOrder
    executionError?: SortOrderInput | SortOrder
    executionDuration?: SortOrderInput | SortOrder
    rolledBackAt?: SortOrderInput | SortOrder
    rolledBackBy?: SortOrderInput | SortOrder
    rollbackReason?: SortOrderInput | SortOrder
    feedbackDueAt?: SortOrderInput | SortOrder
    actualImpact?: SortOrderInput | SortOrder
    wasSuccessful?: SortOrderInput | SortOrder
    successScore?: SortOrderInput | SortOrder
    feedbackNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AIDecisionCountOrderByAggregateInput
    _avg?: AIDecisionAvgOrderByAggregateInput
    _max?: AIDecisionMaxOrderByAggregateInput
    _min?: AIDecisionMinOrderByAggregateInput
    _sum?: AIDecisionSumOrderByAggregateInput
  }

  export type AIDecisionScalarWhereWithAggregatesInput = {
    AND?: AIDecisionScalarWhereWithAggregatesInput | AIDecisionScalarWhereWithAggregatesInput[]
    OR?: AIDecisionScalarWhereWithAggregatesInput[]
    NOT?: AIDecisionScalarWhereWithAggregatesInput | AIDecisionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIDecision"> | string
    type?: StringWithAggregatesFilter<"AIDecision"> | string
    subType?: StringNullableWithAggregatesFilter<"AIDecision"> | string | null
    priority?: StringWithAggregatesFilter<"AIDecision"> | string
    confidence?: FloatWithAggregatesFilter<"AIDecision"> | number
    reasoning?: StringWithAggregatesFilter<"AIDecision"> | string
    dataSnapshot?: JsonNullableWithAggregatesFilter<"AIDecision">
    actionType?: StringWithAggregatesFilter<"AIDecision"> | string
    actionPayload?: JsonWithAggregatesFilter<"AIDecision">
    estimatedImpact?: StringNullableWithAggregatesFilter<"AIDecision"> | string | null
    rollbackPlan?: StringNullableWithAggregatesFilter<"AIDecision"> | string | null
    requiresApproval?: BoolWithAggregatesFilter<"AIDecision"> | boolean
    autoApproved?: BoolWithAggregatesFilter<"AIDecision"> | boolean
    status?: EnumAIDecisionStatusWithAggregatesFilter<"AIDecision"> | $Enums.AIDecisionStatus
    approvedBy?: StringNullableWithAggregatesFilter<"AIDecision"> | string | null
    approvedByName?: StringNullableWithAggregatesFilter<"AIDecision"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"AIDecision"> | Date | string | null
    rejectedBy?: StringNullableWithAggregatesFilter<"AIDecision"> | string | null
    rejectedByName?: StringNullableWithAggregatesFilter<"AIDecision"> | string | null
    rejectedAt?: DateTimeNullableWithAggregatesFilter<"AIDecision"> | Date | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"AIDecision"> | string | null
    executedAt?: DateTimeNullableWithAggregatesFilter<"AIDecision"> | Date | string | null
    executionResult?: JsonNullableWithAggregatesFilter<"AIDecision">
    executionError?: StringNullableWithAggregatesFilter<"AIDecision"> | string | null
    executionDuration?: IntNullableWithAggregatesFilter<"AIDecision"> | number | null
    rolledBackAt?: DateTimeNullableWithAggregatesFilter<"AIDecision"> | Date | string | null
    rolledBackBy?: StringNullableWithAggregatesFilter<"AIDecision"> | string | null
    rollbackReason?: StringNullableWithAggregatesFilter<"AIDecision"> | string | null
    feedbackDueAt?: DateTimeNullableWithAggregatesFilter<"AIDecision"> | Date | string | null
    actualImpact?: JsonNullableWithAggregatesFilter<"AIDecision">
    wasSuccessful?: BoolNullableWithAggregatesFilter<"AIDecision"> | boolean | null
    successScore?: FloatNullableWithAggregatesFilter<"AIDecision"> | number | null
    feedbackNotes?: StringNullableWithAggregatesFilter<"AIDecision"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIDecision"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIDecision"> | Date | string
  }

  export type AICodeChangeWhereInput = {
    AND?: AICodeChangeWhereInput | AICodeChangeWhereInput[]
    OR?: AICodeChangeWhereInput[]
    NOT?: AICodeChangeWhereInput | AICodeChangeWhereInput[]
    id?: StringFilter<"AICodeChange"> | string
    decisionId?: StringFilter<"AICodeChange"> | string
    filePath?: StringFilter<"AICodeChange"> | string
    action?: EnumAICodeActionFilter<"AICodeChange"> | $Enums.AICodeAction
    originalContent?: StringNullableFilter<"AICodeChange"> | string | null
    newContent?: StringNullableFilter<"AICodeChange"> | string | null
    diff?: StringNullableFilter<"AICodeChange"> | string | null
    syntaxValid?: BoolFilter<"AICodeChange"> | boolean
    typesValid?: BoolFilter<"AICodeChange"> | boolean
    lintPassed?: BoolFilter<"AICodeChange"> | boolean
    testsPassed?: BoolNullableFilter<"AICodeChange"> | boolean | null
    appliedAt?: DateTimeNullableFilter<"AICodeChange"> | Date | string | null
    rolledBackAt?: DateTimeNullableFilter<"AICodeChange"> | Date | string | null
    createdAt?: DateTimeFilter<"AICodeChange"> | Date | string
    decision?: XOR<AIDecisionScalarRelationFilter, AIDecisionWhereInput>
  }

  export type AICodeChangeOrderByWithRelationInput = {
    id?: SortOrder
    decisionId?: SortOrder
    filePath?: SortOrder
    action?: SortOrder
    originalContent?: SortOrderInput | SortOrder
    newContent?: SortOrderInput | SortOrder
    diff?: SortOrderInput | SortOrder
    syntaxValid?: SortOrder
    typesValid?: SortOrder
    lintPassed?: SortOrder
    testsPassed?: SortOrderInput | SortOrder
    appliedAt?: SortOrderInput | SortOrder
    rolledBackAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    decision?: AIDecisionOrderByWithRelationInput
  }

  export type AICodeChangeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AICodeChangeWhereInput | AICodeChangeWhereInput[]
    OR?: AICodeChangeWhereInput[]
    NOT?: AICodeChangeWhereInput | AICodeChangeWhereInput[]
    decisionId?: StringFilter<"AICodeChange"> | string
    filePath?: StringFilter<"AICodeChange"> | string
    action?: EnumAICodeActionFilter<"AICodeChange"> | $Enums.AICodeAction
    originalContent?: StringNullableFilter<"AICodeChange"> | string | null
    newContent?: StringNullableFilter<"AICodeChange"> | string | null
    diff?: StringNullableFilter<"AICodeChange"> | string | null
    syntaxValid?: BoolFilter<"AICodeChange"> | boolean
    typesValid?: BoolFilter<"AICodeChange"> | boolean
    lintPassed?: BoolFilter<"AICodeChange"> | boolean
    testsPassed?: BoolNullableFilter<"AICodeChange"> | boolean | null
    appliedAt?: DateTimeNullableFilter<"AICodeChange"> | Date | string | null
    rolledBackAt?: DateTimeNullableFilter<"AICodeChange"> | Date | string | null
    createdAt?: DateTimeFilter<"AICodeChange"> | Date | string
    decision?: XOR<AIDecisionScalarRelationFilter, AIDecisionWhereInput>
  }, "id">

  export type AICodeChangeOrderByWithAggregationInput = {
    id?: SortOrder
    decisionId?: SortOrder
    filePath?: SortOrder
    action?: SortOrder
    originalContent?: SortOrderInput | SortOrder
    newContent?: SortOrderInput | SortOrder
    diff?: SortOrderInput | SortOrder
    syntaxValid?: SortOrder
    typesValid?: SortOrder
    lintPassed?: SortOrder
    testsPassed?: SortOrderInput | SortOrder
    appliedAt?: SortOrderInput | SortOrder
    rolledBackAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AICodeChangeCountOrderByAggregateInput
    _max?: AICodeChangeMaxOrderByAggregateInput
    _min?: AICodeChangeMinOrderByAggregateInput
  }

  export type AICodeChangeScalarWhereWithAggregatesInput = {
    AND?: AICodeChangeScalarWhereWithAggregatesInput | AICodeChangeScalarWhereWithAggregatesInput[]
    OR?: AICodeChangeScalarWhereWithAggregatesInput[]
    NOT?: AICodeChangeScalarWhereWithAggregatesInput | AICodeChangeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AICodeChange"> | string
    decisionId?: StringWithAggregatesFilter<"AICodeChange"> | string
    filePath?: StringWithAggregatesFilter<"AICodeChange"> | string
    action?: EnumAICodeActionWithAggregatesFilter<"AICodeChange"> | $Enums.AICodeAction
    originalContent?: StringNullableWithAggregatesFilter<"AICodeChange"> | string | null
    newContent?: StringNullableWithAggregatesFilter<"AICodeChange"> | string | null
    diff?: StringNullableWithAggregatesFilter<"AICodeChange"> | string | null
    syntaxValid?: BoolWithAggregatesFilter<"AICodeChange"> | boolean
    typesValid?: BoolWithAggregatesFilter<"AICodeChange"> | boolean
    lintPassed?: BoolWithAggregatesFilter<"AICodeChange"> | boolean
    testsPassed?: BoolNullableWithAggregatesFilter<"AICodeChange"> | boolean | null
    appliedAt?: DateTimeNullableWithAggregatesFilter<"AICodeChange"> | Date | string | null
    rolledBackAt?: DateTimeNullableWithAggregatesFilter<"AICodeChange"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AICodeChange"> | Date | string
  }

  export type AIAgentLogWhereInput = {
    AND?: AIAgentLogWhereInput | AIAgentLogWhereInput[]
    OR?: AIAgentLogWhereInput[]
    NOT?: AIAgentLogWhereInput | AIAgentLogWhereInput[]
    id?: StringFilter<"AIAgentLog"> | string
    level?: EnumAILogLevelFilter<"AIAgentLog"> | $Enums.AILogLevel
    category?: StringFilter<"AIAgentLog"> | string
    message?: StringFilter<"AIAgentLog"> | string
    data?: JsonNullableFilter<"AIAgentLog">
    decisionId?: StringNullableFilter<"AIAgentLog"> | string | null
    errorCode?: StringNullableFilter<"AIAgentLog"> | string | null
    errorStack?: StringNullableFilter<"AIAgentLog"> | string | null
    durationMs?: IntNullableFilter<"AIAgentLog"> | number | null
    createdAt?: DateTimeFilter<"AIAgentLog"> | Date | string
    decision?: XOR<AIDecisionNullableScalarRelationFilter, AIDecisionWhereInput> | null
  }

  export type AIAgentLogOrderByWithRelationInput = {
    id?: SortOrder
    level?: SortOrder
    category?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    decisionId?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorStack?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    decision?: AIDecisionOrderByWithRelationInput
  }

  export type AIAgentLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIAgentLogWhereInput | AIAgentLogWhereInput[]
    OR?: AIAgentLogWhereInput[]
    NOT?: AIAgentLogWhereInput | AIAgentLogWhereInput[]
    level?: EnumAILogLevelFilter<"AIAgentLog"> | $Enums.AILogLevel
    category?: StringFilter<"AIAgentLog"> | string
    message?: StringFilter<"AIAgentLog"> | string
    data?: JsonNullableFilter<"AIAgentLog">
    decisionId?: StringNullableFilter<"AIAgentLog"> | string | null
    errorCode?: StringNullableFilter<"AIAgentLog"> | string | null
    errorStack?: StringNullableFilter<"AIAgentLog"> | string | null
    durationMs?: IntNullableFilter<"AIAgentLog"> | number | null
    createdAt?: DateTimeFilter<"AIAgentLog"> | Date | string
    decision?: XOR<AIDecisionNullableScalarRelationFilter, AIDecisionWhereInput> | null
  }, "id">

  export type AIAgentLogOrderByWithAggregationInput = {
    id?: SortOrder
    level?: SortOrder
    category?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    decisionId?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorStack?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AIAgentLogCountOrderByAggregateInput
    _avg?: AIAgentLogAvgOrderByAggregateInput
    _max?: AIAgentLogMaxOrderByAggregateInput
    _min?: AIAgentLogMinOrderByAggregateInput
    _sum?: AIAgentLogSumOrderByAggregateInput
  }

  export type AIAgentLogScalarWhereWithAggregatesInput = {
    AND?: AIAgentLogScalarWhereWithAggregatesInput | AIAgentLogScalarWhereWithAggregatesInput[]
    OR?: AIAgentLogScalarWhereWithAggregatesInput[]
    NOT?: AIAgentLogScalarWhereWithAggregatesInput | AIAgentLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIAgentLog"> | string
    level?: EnumAILogLevelWithAggregatesFilter<"AIAgentLog"> | $Enums.AILogLevel
    category?: StringWithAggregatesFilter<"AIAgentLog"> | string
    message?: StringWithAggregatesFilter<"AIAgentLog"> | string
    data?: JsonNullableWithAggregatesFilter<"AIAgentLog">
    decisionId?: StringNullableWithAggregatesFilter<"AIAgentLog"> | string | null
    errorCode?: StringNullableWithAggregatesFilter<"AIAgentLog"> | string | null
    errorStack?: StringNullableWithAggregatesFilter<"AIAgentLog"> | string | null
    durationMs?: IntNullableWithAggregatesFilter<"AIAgentLog"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"AIAgentLog"> | Date | string
  }

  export type AIDataSnapshotWhereInput = {
    AND?: AIDataSnapshotWhereInput | AIDataSnapshotWhereInput[]
    OR?: AIDataSnapshotWhereInput[]
    NOT?: AIDataSnapshotWhereInput | AIDataSnapshotWhereInput[]
    id?: StringFilter<"AIDataSnapshot"> | string
    snapshotType?: StringFilter<"AIDataSnapshot"> | string
    totalViews?: IntFilter<"AIDataSnapshot"> | number
    uniqueVisitors?: IntFilter<"AIDataSnapshot"> | number
    bounceRate?: FloatNullableFilter<"AIDataSnapshot"> | number | null
    avgSessionDuration?: FloatNullableFilter<"AIDataSnapshot"> | number | null
    totalInquiries?: IntFilter<"AIDataSnapshot"> | number
    viewingRequests?: IntFilter<"AIDataSnapshot"> | number
    investorLeads?: IntFilter<"AIDataSnapshot"> | number
    rentalLeads?: IntFilter<"AIDataSnapshot"> | number
    conversionRate?: FloatNullableFilter<"AIDataSnapshot"> | number | null
    totalProperties?: IntFilter<"AIDataSnapshot"> | number
    activeListings?: IntFilter<"AIDataSnapshot"> | number
    newListings?: IntFilter<"AIDataSnapshot"> | number
    avgPropertyViews?: FloatNullableFilter<"AIDataSnapshot"> | number | null
    totalBlogs?: IntFilter<"AIDataSnapshot"> | number
    publishedBlogs?: IntFilter<"AIDataSnapshot"> | number
    avgBlogViews?: FloatNullableFilter<"AIDataSnapshot"> | number | null
    organicTraffic?: IntNullableFilter<"AIDataSnapshot"> | number | null
    topKeywords?: JsonNullableFilter<"AIDataSnapshot">
    avgPosition?: FloatNullableFilter<"AIDataSnapshot"> | number | null
    estimatedLeadValue?: FloatNullableFilter<"AIDataSnapshot"> | number | null
    errorCount?: IntFilter<"AIDataSnapshot"> | number
    slowPages?: JsonNullableFilter<"AIDataSnapshot">
    brokenLinks?: IntFilter<"AIDataSnapshot"> | number
    rawData?: JsonNullableFilter<"AIDataSnapshot">
    periodStart?: DateTimeFilter<"AIDataSnapshot"> | Date | string
    periodEnd?: DateTimeFilter<"AIDataSnapshot"> | Date | string
    createdAt?: DateTimeFilter<"AIDataSnapshot"> | Date | string
  }

  export type AIDataSnapshotOrderByWithRelationInput = {
    id?: SortOrder
    snapshotType?: SortOrder
    totalViews?: SortOrder
    uniqueVisitors?: SortOrder
    bounceRate?: SortOrderInput | SortOrder
    avgSessionDuration?: SortOrderInput | SortOrder
    totalInquiries?: SortOrder
    viewingRequests?: SortOrder
    investorLeads?: SortOrder
    rentalLeads?: SortOrder
    conversionRate?: SortOrderInput | SortOrder
    totalProperties?: SortOrder
    activeListings?: SortOrder
    newListings?: SortOrder
    avgPropertyViews?: SortOrderInput | SortOrder
    totalBlogs?: SortOrder
    publishedBlogs?: SortOrder
    avgBlogViews?: SortOrderInput | SortOrder
    organicTraffic?: SortOrderInput | SortOrder
    topKeywords?: SortOrderInput | SortOrder
    avgPosition?: SortOrderInput | SortOrder
    estimatedLeadValue?: SortOrderInput | SortOrder
    errorCount?: SortOrder
    slowPages?: SortOrderInput | SortOrder
    brokenLinks?: SortOrder
    rawData?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
  }

  export type AIDataSnapshotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIDataSnapshotWhereInput | AIDataSnapshotWhereInput[]
    OR?: AIDataSnapshotWhereInput[]
    NOT?: AIDataSnapshotWhereInput | AIDataSnapshotWhereInput[]
    snapshotType?: StringFilter<"AIDataSnapshot"> | string
    totalViews?: IntFilter<"AIDataSnapshot"> | number
    uniqueVisitors?: IntFilter<"AIDataSnapshot"> | number
    bounceRate?: FloatNullableFilter<"AIDataSnapshot"> | number | null
    avgSessionDuration?: FloatNullableFilter<"AIDataSnapshot"> | number | null
    totalInquiries?: IntFilter<"AIDataSnapshot"> | number
    viewingRequests?: IntFilter<"AIDataSnapshot"> | number
    investorLeads?: IntFilter<"AIDataSnapshot"> | number
    rentalLeads?: IntFilter<"AIDataSnapshot"> | number
    conversionRate?: FloatNullableFilter<"AIDataSnapshot"> | number | null
    totalProperties?: IntFilter<"AIDataSnapshot"> | number
    activeListings?: IntFilter<"AIDataSnapshot"> | number
    newListings?: IntFilter<"AIDataSnapshot"> | number
    avgPropertyViews?: FloatNullableFilter<"AIDataSnapshot"> | number | null
    totalBlogs?: IntFilter<"AIDataSnapshot"> | number
    publishedBlogs?: IntFilter<"AIDataSnapshot"> | number
    avgBlogViews?: FloatNullableFilter<"AIDataSnapshot"> | number | null
    organicTraffic?: IntNullableFilter<"AIDataSnapshot"> | number | null
    topKeywords?: JsonNullableFilter<"AIDataSnapshot">
    avgPosition?: FloatNullableFilter<"AIDataSnapshot"> | number | null
    estimatedLeadValue?: FloatNullableFilter<"AIDataSnapshot"> | number | null
    errorCount?: IntFilter<"AIDataSnapshot"> | number
    slowPages?: JsonNullableFilter<"AIDataSnapshot">
    brokenLinks?: IntFilter<"AIDataSnapshot"> | number
    rawData?: JsonNullableFilter<"AIDataSnapshot">
    periodStart?: DateTimeFilter<"AIDataSnapshot"> | Date | string
    periodEnd?: DateTimeFilter<"AIDataSnapshot"> | Date | string
    createdAt?: DateTimeFilter<"AIDataSnapshot"> | Date | string
  }, "id">

  export type AIDataSnapshotOrderByWithAggregationInput = {
    id?: SortOrder
    snapshotType?: SortOrder
    totalViews?: SortOrder
    uniqueVisitors?: SortOrder
    bounceRate?: SortOrderInput | SortOrder
    avgSessionDuration?: SortOrderInput | SortOrder
    totalInquiries?: SortOrder
    viewingRequests?: SortOrder
    investorLeads?: SortOrder
    rentalLeads?: SortOrder
    conversionRate?: SortOrderInput | SortOrder
    totalProperties?: SortOrder
    activeListings?: SortOrder
    newListings?: SortOrder
    avgPropertyViews?: SortOrderInput | SortOrder
    totalBlogs?: SortOrder
    publishedBlogs?: SortOrder
    avgBlogViews?: SortOrderInput | SortOrder
    organicTraffic?: SortOrderInput | SortOrder
    topKeywords?: SortOrderInput | SortOrder
    avgPosition?: SortOrderInput | SortOrder
    estimatedLeadValue?: SortOrderInput | SortOrder
    errorCount?: SortOrder
    slowPages?: SortOrderInput | SortOrder
    brokenLinks?: SortOrder
    rawData?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
    _count?: AIDataSnapshotCountOrderByAggregateInput
    _avg?: AIDataSnapshotAvgOrderByAggregateInput
    _max?: AIDataSnapshotMaxOrderByAggregateInput
    _min?: AIDataSnapshotMinOrderByAggregateInput
    _sum?: AIDataSnapshotSumOrderByAggregateInput
  }

  export type AIDataSnapshotScalarWhereWithAggregatesInput = {
    AND?: AIDataSnapshotScalarWhereWithAggregatesInput | AIDataSnapshotScalarWhereWithAggregatesInput[]
    OR?: AIDataSnapshotScalarWhereWithAggregatesInput[]
    NOT?: AIDataSnapshotScalarWhereWithAggregatesInput | AIDataSnapshotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIDataSnapshot"> | string
    snapshotType?: StringWithAggregatesFilter<"AIDataSnapshot"> | string
    totalViews?: IntWithAggregatesFilter<"AIDataSnapshot"> | number
    uniqueVisitors?: IntWithAggregatesFilter<"AIDataSnapshot"> | number
    bounceRate?: FloatNullableWithAggregatesFilter<"AIDataSnapshot"> | number | null
    avgSessionDuration?: FloatNullableWithAggregatesFilter<"AIDataSnapshot"> | number | null
    totalInquiries?: IntWithAggregatesFilter<"AIDataSnapshot"> | number
    viewingRequests?: IntWithAggregatesFilter<"AIDataSnapshot"> | number
    investorLeads?: IntWithAggregatesFilter<"AIDataSnapshot"> | number
    rentalLeads?: IntWithAggregatesFilter<"AIDataSnapshot"> | number
    conversionRate?: FloatNullableWithAggregatesFilter<"AIDataSnapshot"> | number | null
    totalProperties?: IntWithAggregatesFilter<"AIDataSnapshot"> | number
    activeListings?: IntWithAggregatesFilter<"AIDataSnapshot"> | number
    newListings?: IntWithAggregatesFilter<"AIDataSnapshot"> | number
    avgPropertyViews?: FloatNullableWithAggregatesFilter<"AIDataSnapshot"> | number | null
    totalBlogs?: IntWithAggregatesFilter<"AIDataSnapshot"> | number
    publishedBlogs?: IntWithAggregatesFilter<"AIDataSnapshot"> | number
    avgBlogViews?: FloatNullableWithAggregatesFilter<"AIDataSnapshot"> | number | null
    organicTraffic?: IntNullableWithAggregatesFilter<"AIDataSnapshot"> | number | null
    topKeywords?: JsonNullableWithAggregatesFilter<"AIDataSnapshot">
    avgPosition?: FloatNullableWithAggregatesFilter<"AIDataSnapshot"> | number | null
    estimatedLeadValue?: FloatNullableWithAggregatesFilter<"AIDataSnapshot"> | number | null
    errorCount?: IntWithAggregatesFilter<"AIDataSnapshot"> | number
    slowPages?: JsonNullableWithAggregatesFilter<"AIDataSnapshot">
    brokenLinks?: IntWithAggregatesFilter<"AIDataSnapshot"> | number
    rawData?: JsonNullableWithAggregatesFilter<"AIDataSnapshot">
    periodStart?: DateTimeWithAggregatesFilter<"AIDataSnapshot"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"AIDataSnapshot"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AIDataSnapshot"> | Date | string
  }

  export type AIOpportunityWhereInput = {
    AND?: AIOpportunityWhereInput | AIOpportunityWhereInput[]
    OR?: AIOpportunityWhereInput[]
    NOT?: AIOpportunityWhereInput | AIOpportunityWhereInput[]
    id?: StringFilter<"AIOpportunity"> | string
    type?: StringFilter<"AIOpportunity"> | string
    subType?: StringNullableFilter<"AIOpportunity"> | string | null
    title?: StringFilter<"AIOpportunity"> | string
    description?: StringFilter<"AIOpportunity"> | string
    trigger?: StringFilter<"AIOpportunity"> | string
    priority?: IntFilter<"AIOpportunity"> | number
    estimatedEffort?: StringFilter<"AIOpportunity"> | string
    estimatedImpact?: StringFilter<"AIOpportunity"> | string
    potentialRevenue?: FloatNullableFilter<"AIOpportunity"> | number | null
    potentialLeads?: IntNullableFilter<"AIOpportunity"> | number | null
    status?: EnumAIOpportunityStatusFilter<"AIOpportunity"> | $Enums.AIOpportunityStatus
    decisionId?: StringNullableFilter<"AIOpportunity"> | string | null
    identifiedAt?: DateTimeFilter<"AIOpportunity"> | Date | string
    addressedAt?: DateTimeNullableFilter<"AIOpportunity"> | Date | string | null
    createdAt?: DateTimeFilter<"AIOpportunity"> | Date | string
    updatedAt?: DateTimeFilter<"AIOpportunity"> | Date | string
  }

  export type AIOpportunityOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    subType?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrder
    trigger?: SortOrder
    priority?: SortOrder
    estimatedEffort?: SortOrder
    estimatedImpact?: SortOrder
    potentialRevenue?: SortOrderInput | SortOrder
    potentialLeads?: SortOrderInput | SortOrder
    status?: SortOrder
    decisionId?: SortOrderInput | SortOrder
    identifiedAt?: SortOrder
    addressedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIOpportunityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    decisionId?: string
    AND?: AIOpportunityWhereInput | AIOpportunityWhereInput[]
    OR?: AIOpportunityWhereInput[]
    NOT?: AIOpportunityWhereInput | AIOpportunityWhereInput[]
    type?: StringFilter<"AIOpportunity"> | string
    subType?: StringNullableFilter<"AIOpportunity"> | string | null
    title?: StringFilter<"AIOpportunity"> | string
    description?: StringFilter<"AIOpportunity"> | string
    trigger?: StringFilter<"AIOpportunity"> | string
    priority?: IntFilter<"AIOpportunity"> | number
    estimatedEffort?: StringFilter<"AIOpportunity"> | string
    estimatedImpact?: StringFilter<"AIOpportunity"> | string
    potentialRevenue?: FloatNullableFilter<"AIOpportunity"> | number | null
    potentialLeads?: IntNullableFilter<"AIOpportunity"> | number | null
    status?: EnumAIOpportunityStatusFilter<"AIOpportunity"> | $Enums.AIOpportunityStatus
    identifiedAt?: DateTimeFilter<"AIOpportunity"> | Date | string
    addressedAt?: DateTimeNullableFilter<"AIOpportunity"> | Date | string | null
    createdAt?: DateTimeFilter<"AIOpportunity"> | Date | string
    updatedAt?: DateTimeFilter<"AIOpportunity"> | Date | string
  }, "id" | "decisionId">

  export type AIOpportunityOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    subType?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrder
    trigger?: SortOrder
    priority?: SortOrder
    estimatedEffort?: SortOrder
    estimatedImpact?: SortOrder
    potentialRevenue?: SortOrderInput | SortOrder
    potentialLeads?: SortOrderInput | SortOrder
    status?: SortOrder
    decisionId?: SortOrderInput | SortOrder
    identifiedAt?: SortOrder
    addressedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AIOpportunityCountOrderByAggregateInput
    _avg?: AIOpportunityAvgOrderByAggregateInput
    _max?: AIOpportunityMaxOrderByAggregateInput
    _min?: AIOpportunityMinOrderByAggregateInput
    _sum?: AIOpportunitySumOrderByAggregateInput
  }

  export type AIOpportunityScalarWhereWithAggregatesInput = {
    AND?: AIOpportunityScalarWhereWithAggregatesInput | AIOpportunityScalarWhereWithAggregatesInput[]
    OR?: AIOpportunityScalarWhereWithAggregatesInput[]
    NOT?: AIOpportunityScalarWhereWithAggregatesInput | AIOpportunityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIOpportunity"> | string
    type?: StringWithAggregatesFilter<"AIOpportunity"> | string
    subType?: StringNullableWithAggregatesFilter<"AIOpportunity"> | string | null
    title?: StringWithAggregatesFilter<"AIOpportunity"> | string
    description?: StringWithAggregatesFilter<"AIOpportunity"> | string
    trigger?: StringWithAggregatesFilter<"AIOpportunity"> | string
    priority?: IntWithAggregatesFilter<"AIOpportunity"> | number
    estimatedEffort?: StringWithAggregatesFilter<"AIOpportunity"> | string
    estimatedImpact?: StringWithAggregatesFilter<"AIOpportunity"> | string
    potentialRevenue?: FloatNullableWithAggregatesFilter<"AIOpportunity"> | number | null
    potentialLeads?: IntNullableWithAggregatesFilter<"AIOpportunity"> | number | null
    status?: EnumAIOpportunityStatusWithAggregatesFilter<"AIOpportunity"> | $Enums.AIOpportunityStatus
    decisionId?: StringNullableWithAggregatesFilter<"AIOpportunity"> | string | null
    identifiedAt?: DateTimeWithAggregatesFilter<"AIOpportunity"> | Date | string
    addressedAt?: DateTimeNullableWithAggregatesFilter<"AIOpportunity"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIOpportunity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIOpportunity"> | Date | string
  }

  export type AILearningWhereInput = {
    AND?: AILearningWhereInput | AILearningWhereInput[]
    OR?: AILearningWhereInput[]
    NOT?: AILearningWhereInput | AILearningWhereInput[]
    id?: StringFilter<"AILearning"> | string
    category?: StringFilter<"AILearning"> | string
    insight?: StringFilter<"AILearning"> | string
    sourceDecisionId?: StringNullableFilter<"AILearning"> | string | null
    confidence?: FloatFilter<"AILearning"> | number
    impactArea?: StringFilter<"AILearning"> | string
    adjustment?: StringFilter<"AILearning"> | string
    validatedBy?: StringNullableFilter<"AILearning"> | string | null
    validatedAt?: DateTimeNullableFilter<"AILearning"> | Date | string | null
    isValid?: BoolFilter<"AILearning"> | boolean
    createdAt?: DateTimeFilter<"AILearning"> | Date | string
  }

  export type AILearningOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    insight?: SortOrder
    sourceDecisionId?: SortOrderInput | SortOrder
    confidence?: SortOrder
    impactArea?: SortOrder
    adjustment?: SortOrder
    validatedBy?: SortOrderInput | SortOrder
    validatedAt?: SortOrderInput | SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
  }

  export type AILearningWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AILearningWhereInput | AILearningWhereInput[]
    OR?: AILearningWhereInput[]
    NOT?: AILearningWhereInput | AILearningWhereInput[]
    category?: StringFilter<"AILearning"> | string
    insight?: StringFilter<"AILearning"> | string
    sourceDecisionId?: StringNullableFilter<"AILearning"> | string | null
    confidence?: FloatFilter<"AILearning"> | number
    impactArea?: StringFilter<"AILearning"> | string
    adjustment?: StringFilter<"AILearning"> | string
    validatedBy?: StringNullableFilter<"AILearning"> | string | null
    validatedAt?: DateTimeNullableFilter<"AILearning"> | Date | string | null
    isValid?: BoolFilter<"AILearning"> | boolean
    createdAt?: DateTimeFilter<"AILearning"> | Date | string
  }, "id">

  export type AILearningOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    insight?: SortOrder
    sourceDecisionId?: SortOrderInput | SortOrder
    confidence?: SortOrder
    impactArea?: SortOrder
    adjustment?: SortOrder
    validatedBy?: SortOrderInput | SortOrder
    validatedAt?: SortOrderInput | SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
    _count?: AILearningCountOrderByAggregateInput
    _avg?: AILearningAvgOrderByAggregateInput
    _max?: AILearningMaxOrderByAggregateInput
    _min?: AILearningMinOrderByAggregateInput
    _sum?: AILearningSumOrderByAggregateInput
  }

  export type AILearningScalarWhereWithAggregatesInput = {
    AND?: AILearningScalarWhereWithAggregatesInput | AILearningScalarWhereWithAggregatesInput[]
    OR?: AILearningScalarWhereWithAggregatesInput[]
    NOT?: AILearningScalarWhereWithAggregatesInput | AILearningScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AILearning"> | string
    category?: StringWithAggregatesFilter<"AILearning"> | string
    insight?: StringWithAggregatesFilter<"AILearning"> | string
    sourceDecisionId?: StringNullableWithAggregatesFilter<"AILearning"> | string | null
    confidence?: FloatWithAggregatesFilter<"AILearning"> | number
    impactArea?: StringWithAggregatesFilter<"AILearning"> | string
    adjustment?: StringWithAggregatesFilter<"AILearning"> | string
    validatedBy?: StringNullableWithAggregatesFilter<"AILearning"> | string | null
    validatedAt?: DateTimeNullableWithAggregatesFilter<"AILearning"> | Date | string | null
    isValid?: BoolWithAggregatesFilter<"AILearning"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AILearning"> | Date | string
  }

  export type AccountCreateInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
    impersonatedBy?: string | null
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateManyInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
    impersonatedBy?: string | null
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    investorLeads?: InvestorLeadCreateNestedManyWithoutAssignedToInput
    rentalLeads?: RentalLeadCreateNestedManyWithoutAssignedToInput
    blogs?: BlogCreateNestedManyWithoutAuthorInput
    rentalBookings?: RentalBookingCreateNestedManyWithoutUserInput
    bookingsAsAgent?: RentalBookingCreateNestedManyWithoutAgentInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    investorLeads?: InvestorLeadUncheckedCreateNestedManyWithoutAssignedToInput
    rentalLeads?: RentalLeadUncheckedCreateNestedManyWithoutAssignedToInput
    blogs?: BlogUncheckedCreateNestedManyWithoutAuthorInput
    rentalBookings?: RentalBookingUncheckedCreateNestedManyWithoutUserInput
    bookingsAsAgent?: RentalBookingUncheckedCreateNestedManyWithoutAgentInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    investorLeads?: InvestorLeadUpdateManyWithoutAssignedToNestedInput
    rentalLeads?: RentalLeadUpdateManyWithoutAssignedToNestedInput
    blogs?: BlogUpdateManyWithoutAuthorNestedInput
    rentalBookings?: RentalBookingUpdateManyWithoutUserNestedInput
    bookingsAsAgent?: RentalBookingUpdateManyWithoutAgentNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    investorLeads?: InvestorLeadUncheckedUpdateManyWithoutAssignedToNestedInput
    rentalLeads?: RentalLeadUncheckedUpdateManyWithoutAssignedToNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutAuthorNestedInput
    rentalBookings?: RentalBookingUncheckedUpdateManyWithoutUserNestedInput
    bookingsAsAgent?: RentalBookingUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUncheckedCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationCreateManyInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AgentInviteCreateInput = {
    id?: string
    code: string
    email?: string | null
    role?: string
    maxUses?: number
    usedCount?: number
    usedBy?: string | null
    usedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdBy: string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentInviteUncheckedCreateInput = {
    id?: string
    code: string
    email?: string | null
    role?: string
    maxUses?: number
    usedCount?: number
    usedBy?: string | null
    usedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdBy: string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentInviteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    maxUses?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    usedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentInviteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    maxUses?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    usedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentInviteCreateManyInput = {
    id?: string
    code: string
    email?: string | null
    role?: string
    maxUses?: number
    usedCount?: number
    usedBy?: string | null
    usedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdBy: string
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentInviteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    maxUses?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    usedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentInviteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    maxUses?: IntFieldUpdateOperationsInput | number
    usedCount?: IntFieldUpdateOperationsInput | number
    usedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    views?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyOwner?: PropertyOwnerCreateNestedOneWithoutPropertiesInput
    poiDistances?: PropertyPoiDistanceCreateNestedManyWithoutPropertyInput
    user: UserCreateNestedOneWithoutPropertiesInput
    viewingRequests?: ViewingRequestCreateNestedManyWithoutPropertyInput
    rentalBookings?: RentalBookingCreateNestedManyWithoutPropertyInput
    blockedDates?: PropertyBlockedDateCreateNestedManyWithoutPropertyInput
    tm30Accommodation?: Tm30AccommodationCreateNestedOneWithoutPropertyInput
  }

  export type PropertyUncheckedCreateInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    propertyOwnerId?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    views?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    poiDistances?: PropertyPoiDistanceUncheckedCreateNestedManyWithoutPropertyInput
    viewingRequests?: ViewingRequestUncheckedCreateNestedManyWithoutPropertyInput
    rentalBookings?: RentalBookingUncheckedCreateNestedManyWithoutPropertyInput
    blockedDates?: PropertyBlockedDateUncheckedCreateNestedManyWithoutPropertyInput
    tm30Accommodation?: Tm30AccommodationUncheckedCreateNestedOneWithoutPropertyInput
  }

  export type PropertyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    views?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyOwner?: PropertyOwnerUpdateOneWithoutPropertiesNestedInput
    poiDistances?: PropertyPoiDistanceUpdateManyWithoutPropertyNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    viewingRequests?: ViewingRequestUpdateManyWithoutPropertyNestedInput
    rentalBookings?: RentalBookingUpdateManyWithoutPropertyNestedInput
    blockedDates?: PropertyBlockedDateUpdateManyWithoutPropertyNestedInput
    tm30Accommodation?: Tm30AccommodationUpdateOneWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    propertyOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    views?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    poiDistances?: PropertyPoiDistanceUncheckedUpdateManyWithoutPropertyNestedInput
    viewingRequests?: ViewingRequestUncheckedUpdateManyWithoutPropertyNestedInput
    rentalBookings?: RentalBookingUncheckedUpdateManyWithoutPropertyNestedInput
    blockedDates?: PropertyBlockedDateUncheckedUpdateManyWithoutPropertyNestedInput
    tm30Accommodation?: Tm30AccommodationUncheckedUpdateOneWithoutPropertyNestedInput
  }

  export type PropertyCreateManyInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    propertyOwnerId?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    propertyOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyImageCreateInput = {
    id?: string
    url?: string | null
    position: number
    alt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutImagesInput
  }

  export type PropertyImageUncheckedCreateInput = {
    id?: string
    propertyId: string
    url?: string | null
    position: number
    alt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutImagesNestedInput
  }

  export type PropertyImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyImageCreateManyInput = {
    id?: string
    propertyId: string
    url?: string | null
    position: number
    alt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyViewCreateInput = {
    id?: string
    viewedAt?: Date | string
    country?: string | null
    city?: string | null
    ipHash?: string | null
    userAgent?: string | null
    referrer?: string | null
    sessionId?: string | null
    property: PropertyCreateNestedOneWithoutViewsInput
  }

  export type PropertyViewUncheckedCreateInput = {
    id?: string
    propertyId: string
    viewedAt?: Date | string
    country?: string | null
    city?: string | null
    ipHash?: string | null
    userAgent?: string | null
    referrer?: string | null
    sessionId?: string | null
  }

  export type PropertyViewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    property?: PropertyUpdateOneRequiredWithoutViewsNestedInput
  }

  export type PropertyViewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyViewCreateManyInput = {
    id?: string
    propertyId: string
    viewedAt?: Date | string
    country?: string | null
    city?: string | null
    ipHash?: string | null
    userAgent?: string | null
    referrer?: string | null
    sessionId?: string | null
  }

  export type PropertyViewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyViewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ViewingRequestCreateInput = {
    id?: string
    requestType: $Enums.RequestType
    viewingDate?: Date | string | null
    name: string
    email: string
    phone: string
    countryCode?: string
    language?: string | null
    message?: string | null
    offerAmount?: string | null
    offerCurrency?: string | null
    status?: $Enums.RequestStatus
    confirmedBy?: string | null
    confirmedByName?: string | null
    confirmedAt?: Date | string | null
    completedBy?: string | null
    completedByName?: string | null
    completedAt?: Date | string | null
    cancelledBy?: string | null
    cancelledByName?: string | null
    cancelledAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property?: PropertyCreateNestedOneWithoutViewingRequestsInput
  }

  export type ViewingRequestUncheckedCreateInput = {
    id?: string
    propertyId?: string | null
    requestType: $Enums.RequestType
    viewingDate?: Date | string | null
    name: string
    email: string
    phone: string
    countryCode?: string
    language?: string | null
    message?: string | null
    offerAmount?: string | null
    offerCurrency?: string | null
    status?: $Enums.RequestStatus
    confirmedBy?: string | null
    confirmedByName?: string | null
    confirmedAt?: Date | string | null
    completedBy?: string | null
    completedByName?: string | null
    completedAt?: Date | string | null
    cancelledBy?: string | null
    cancelledByName?: string | null
    cancelledAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViewingRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    viewingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    offerAmount?: NullableStringFieldUpdateOperationsInput | string | null
    offerCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedByName?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByName?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneWithoutViewingRequestsNestedInput
  }

  export type ViewingRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    viewingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    offerAmount?: NullableStringFieldUpdateOperationsInput | string | null
    offerCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedByName?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByName?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewingRequestCreateManyInput = {
    id?: string
    propertyId?: string | null
    requestType: $Enums.RequestType
    viewingDate?: Date | string | null
    name: string
    email: string
    phone: string
    countryCode?: string
    language?: string | null
    message?: string | null
    offerAmount?: string | null
    offerCurrency?: string | null
    status?: $Enums.RequestStatus
    confirmedBy?: string | null
    confirmedByName?: string | null
    confirmedAt?: Date | string | null
    completedBy?: string | null
    completedByName?: string | null
    completedAt?: Date | string | null
    cancelledBy?: string | null
    cancelledByName?: string | null
    cancelledAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViewingRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    viewingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    offerAmount?: NullableStringFieldUpdateOperationsInput | string | null
    offerCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedByName?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByName?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewingRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    viewingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    offerAmount?: NullableStringFieldUpdateOperationsInput | string | null
    offerCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedByName?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByName?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorLeadCreateInput = {
    id?: string
    name: string
    email: string
    phone: string
    countryCode?: string
    currency?: string
    investmentBudget: string
    investmentGoal: string
    timeline: string
    preferredAreas?: string | null
    propertyType?: string | null
    experience?: string | null
    financing?: string | null
    message?: string | null
    newsletter?: boolean
    status?: $Enums.LeadStatus
    ipAddress?: string | null
    userAgent?: string | null
    source?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutInvestorLeadsInput
  }

  export type InvestorLeadUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone: string
    countryCode?: string
    currency?: string
    investmentBudget: string
    investmentGoal: string
    timeline: string
    preferredAreas?: string | null
    propertyType?: string | null
    experience?: string | null
    financing?: string | null
    message?: string | null
    newsletter?: boolean
    status?: $Enums.LeadStatus
    assignedToId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    source?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorLeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    investmentBudget?: StringFieldUpdateOperationsInput | string
    investmentGoal?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    preferredAreas?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    financing?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    newsletter?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutInvestorLeadsNestedInput
  }

  export type InvestorLeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    investmentBudget?: StringFieldUpdateOperationsInput | string
    investmentGoal?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    preferredAreas?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    financing?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    newsletter?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorLeadCreateManyInput = {
    id?: string
    name: string
    email: string
    phone: string
    countryCode?: string
    currency?: string
    investmentBudget: string
    investmentGoal: string
    timeline: string
    preferredAreas?: string | null
    propertyType?: string | null
    experience?: string | null
    financing?: string | null
    message?: string | null
    newsletter?: boolean
    status?: $Enums.LeadStatus
    assignedToId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    source?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorLeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    investmentBudget?: StringFieldUpdateOperationsInput | string
    investmentGoal?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    preferredAreas?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    financing?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    newsletter?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorLeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    investmentBudget?: StringFieldUpdateOperationsInput | string
    investmentGoal?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    preferredAreas?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    financing?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    newsletter?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalLeadCreateInput = {
    id?: string
    name: string
    email: string
    phone: string
    countryCode?: string
    propertyType: string
    bedrooms: string
    budget: string
    rentalDuration: string
    preferredAreas?: string | null
    moveInDate?: string | null
    furnished?: string | null
    pets?: string | null
    message?: string | null
    newsletter?: boolean
    status?: $Enums.RentalLeadStatus
    ipAddress?: string | null
    userAgent?: string | null
    source?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutRentalLeadsInput
  }

  export type RentalLeadUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone: string
    countryCode?: string
    propertyType: string
    bedrooms: string
    budget: string
    rentalDuration: string
    preferredAreas?: string | null
    moveInDate?: string | null
    furnished?: string | null
    pets?: string | null
    message?: string | null
    newsletter?: boolean
    status?: $Enums.RentalLeadStatus
    assignedToId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    source?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RentalLeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    propertyType?: StringFieldUpdateOperationsInput | string
    bedrooms?: StringFieldUpdateOperationsInput | string
    budget?: StringFieldUpdateOperationsInput | string
    rentalDuration?: StringFieldUpdateOperationsInput | string
    preferredAreas?: NullableStringFieldUpdateOperationsInput | string | null
    moveInDate?: NullableStringFieldUpdateOperationsInput | string | null
    furnished?: NullableStringFieldUpdateOperationsInput | string | null
    pets?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    newsletter?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRentalLeadStatusFieldUpdateOperationsInput | $Enums.RentalLeadStatus
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutRentalLeadsNestedInput
  }

  export type RentalLeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    propertyType?: StringFieldUpdateOperationsInput | string
    bedrooms?: StringFieldUpdateOperationsInput | string
    budget?: StringFieldUpdateOperationsInput | string
    rentalDuration?: StringFieldUpdateOperationsInput | string
    preferredAreas?: NullableStringFieldUpdateOperationsInput | string | null
    moveInDate?: NullableStringFieldUpdateOperationsInput | string | null
    furnished?: NullableStringFieldUpdateOperationsInput | string | null
    pets?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    newsletter?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRentalLeadStatusFieldUpdateOperationsInput | $Enums.RentalLeadStatus
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalLeadCreateManyInput = {
    id?: string
    name: string
    email: string
    phone: string
    countryCode?: string
    propertyType: string
    bedrooms: string
    budget: string
    rentalDuration: string
    preferredAreas?: string | null
    moveInDate?: string | null
    furnished?: string | null
    pets?: string | null
    message?: string | null
    newsletter?: boolean
    status?: $Enums.RentalLeadStatus
    assignedToId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    source?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RentalLeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    propertyType?: StringFieldUpdateOperationsInput | string
    bedrooms?: StringFieldUpdateOperationsInput | string
    budget?: StringFieldUpdateOperationsInput | string
    rentalDuration?: StringFieldUpdateOperationsInput | string
    preferredAreas?: NullableStringFieldUpdateOperationsInput | string | null
    moveInDate?: NullableStringFieldUpdateOperationsInput | string | null
    furnished?: NullableStringFieldUpdateOperationsInput | string | null
    pets?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    newsletter?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRentalLeadStatusFieldUpdateOperationsInput | $Enums.RentalLeadStatus
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalLeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    propertyType?: StringFieldUpdateOperationsInput | string
    bedrooms?: StringFieldUpdateOperationsInput | string
    budget?: StringFieldUpdateOperationsInput | string
    rentalDuration?: StringFieldUpdateOperationsInput | string
    preferredAreas?: NullableStringFieldUpdateOperationsInput | string | null
    moveInDate?: NullableStringFieldUpdateOperationsInput | string | null
    furnished?: NullableStringFieldUpdateOperationsInput | string | null
    pets?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    newsletter?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRentalLeadStatusFieldUpdateOperationsInput | $Enums.RentalLeadStatus
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCreateInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    coverImage?: string | null
    coverImageAlt?: string | null
    tag?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    published?: boolean
    publishedAt?: Date | string | null
    originalContent?: string | null
    linkOptimizedAt?: Date | string | null
    internalLinkCount?: number
    hasDynamicProperties?: boolean
    poiQueryParams?: string | null
    poiTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: BlogCategoryCreateNestedOneWithoutBlogsInput
    linkUsages?: LinkUsageCreateNestedManyWithoutBlogInput
    author: UserCreateNestedOneWithoutBlogsInput
  }

  export type BlogUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    coverImage?: string | null
    coverImageAlt?: string | null
    tag?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    categoryId?: string | null
    published?: boolean
    publishedAt?: Date | string | null
    originalContent?: string | null
    linkOptimizedAt?: Date | string | null
    internalLinkCount?: number
    hasDynamicProperties?: boolean
    poiQueryParams?: string | null
    poiTemplateId?: string | null
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    linkUsages?: LinkUsageUncheckedCreateNestedManyWithoutBlogInput
  }

  export type BlogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    linkOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalLinkCount?: IntFieldUpdateOperationsInput | number
    hasDynamicProperties?: BoolFieldUpdateOperationsInput | boolean
    poiQueryParams?: NullableStringFieldUpdateOperationsInput | string | null
    poiTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: BlogCategoryUpdateOneWithoutBlogsNestedInput
    linkUsages?: LinkUsageUpdateManyWithoutBlogNestedInput
    author?: UserUpdateOneRequiredWithoutBlogsNestedInput
  }

  export type BlogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    linkOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalLinkCount?: IntFieldUpdateOperationsInput | number
    hasDynamicProperties?: BoolFieldUpdateOperationsInput | boolean
    poiQueryParams?: NullableStringFieldUpdateOperationsInput | string | null
    poiTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkUsages?: LinkUsageUncheckedUpdateManyWithoutBlogNestedInput
  }

  export type BlogCreateManyInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    coverImage?: string | null
    coverImageAlt?: string | null
    tag?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    categoryId?: string | null
    published?: boolean
    publishedAt?: Date | string | null
    originalContent?: string | null
    linkOptimizedAt?: Date | string | null
    internalLinkCount?: number
    hasDynamicProperties?: boolean
    poiQueryParams?: string | null
    poiTemplateId?: string | null
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    linkOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalLinkCount?: IntFieldUpdateOperationsInput | number
    hasDynamicProperties?: BoolFieldUpdateOperationsInput | boolean
    poiQueryParams?: NullableStringFieldUpdateOperationsInput | string | null
    poiTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    linkOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalLinkCount?: IntFieldUpdateOperationsInput | number
    hasDynamicProperties?: BoolFieldUpdateOperationsInput | boolean
    poiQueryParams?: NullableStringFieldUpdateOperationsInput | string | null
    poiTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCategoryCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    icon?: string | null
    color?: string | null
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: BlogCategoryCreateNestedOneWithoutChildrenInput
    children?: BlogCategoryCreateNestedManyWithoutParentInput
    blogs?: BlogCreateNestedManyWithoutCategoryInput
  }

  export type BlogCategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    icon?: string | null
    color?: string | null
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: BlogCategoryUncheckedCreateNestedManyWithoutParentInput
    blogs?: BlogUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type BlogCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: BlogCategoryUpdateOneWithoutChildrenNestedInput
    children?: BlogCategoryUpdateManyWithoutParentNestedInput
    blogs?: BlogUpdateManyWithoutCategoryNestedInput
  }

  export type BlogCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: BlogCategoryUncheckedUpdateManyWithoutParentNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type BlogCategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    icon?: string | null
    color?: string | null
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertySubmissionCreateInput = {
    id?: string
    ownerName: string
    ownerEmail: string
    ownerPhone: string
    ownerCountryCode?: string
    accessToken?: string
    propertyTitle: string
    propertyCategory: $Enums.PropertyCategory
    propertyType: $Enums.PropertyType
    location: string
    askingPrice: string
    beds: number
    baths: number
    sqft: number
    description: string
    images?: PropertySubmissionCreateimagesInput | string[]
    exclusiveRights?: boolean
    commissionRate?: number
    agreementAccepted?: boolean
    status?: $Enums.SubmissionStatus
    reviewNotes?: string | null
    reviewedBy?: string | null
    reviewedByName?: string | null
    reviewedAt?: Date | string | null
    imagesApprovedAt?: Date | string | null
    imagesApprovedBy?: string | null
    publishedAt?: Date | string | null
    publishedBy?: string | null
    convertedPropertyId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    source?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertySubmissionUncheckedCreateInput = {
    id?: string
    ownerName: string
    ownerEmail: string
    ownerPhone: string
    ownerCountryCode?: string
    accessToken?: string
    propertyTitle: string
    propertyCategory: $Enums.PropertyCategory
    propertyType: $Enums.PropertyType
    location: string
    askingPrice: string
    beds: number
    baths: number
    sqft: number
    description: string
    images?: PropertySubmissionCreateimagesInput | string[]
    exclusiveRights?: boolean
    commissionRate?: number
    agreementAccepted?: boolean
    status?: $Enums.SubmissionStatus
    reviewNotes?: string | null
    reviewedBy?: string | null
    reviewedByName?: string | null
    reviewedAt?: Date | string | null
    imagesApprovedAt?: Date | string | null
    imagesApprovedBy?: string | null
    publishedAt?: Date | string | null
    publishedBy?: string | null
    convertedPropertyId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    source?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertySubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerEmail?: StringFieldUpdateOperationsInput | string
    ownerPhone?: StringFieldUpdateOperationsInput | string
    ownerCountryCode?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    propertyTitle?: StringFieldUpdateOperationsInput | string
    propertyCategory?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    location?: StringFieldUpdateOperationsInput | string
    askingPrice?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    images?: PropertySubmissionUpdateimagesInput | string[]
    exclusiveRights?: BoolFieldUpdateOperationsInput | boolean
    commissionRate?: FloatFieldUpdateOperationsInput | number
    agreementAccepted?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedByName?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imagesApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imagesApprovedBy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedBy?: NullableStringFieldUpdateOperationsInput | string | null
    convertedPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertySubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerEmail?: StringFieldUpdateOperationsInput | string
    ownerPhone?: StringFieldUpdateOperationsInput | string
    ownerCountryCode?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    propertyTitle?: StringFieldUpdateOperationsInput | string
    propertyCategory?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    location?: StringFieldUpdateOperationsInput | string
    askingPrice?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    images?: PropertySubmissionUpdateimagesInput | string[]
    exclusiveRights?: BoolFieldUpdateOperationsInput | boolean
    commissionRate?: FloatFieldUpdateOperationsInput | number
    agreementAccepted?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedByName?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imagesApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imagesApprovedBy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedBy?: NullableStringFieldUpdateOperationsInput | string | null
    convertedPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertySubmissionCreateManyInput = {
    id?: string
    ownerName: string
    ownerEmail: string
    ownerPhone: string
    ownerCountryCode?: string
    accessToken?: string
    propertyTitle: string
    propertyCategory: $Enums.PropertyCategory
    propertyType: $Enums.PropertyType
    location: string
    askingPrice: string
    beds: number
    baths: number
    sqft: number
    description: string
    images?: PropertySubmissionCreateimagesInput | string[]
    exclusiveRights?: boolean
    commissionRate?: number
    agreementAccepted?: boolean
    status?: $Enums.SubmissionStatus
    reviewNotes?: string | null
    reviewedBy?: string | null
    reviewedByName?: string | null
    reviewedAt?: Date | string | null
    imagesApprovedAt?: Date | string | null
    imagesApprovedBy?: string | null
    publishedAt?: Date | string | null
    publishedBy?: string | null
    convertedPropertyId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    source?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertySubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerEmail?: StringFieldUpdateOperationsInput | string
    ownerPhone?: StringFieldUpdateOperationsInput | string
    ownerCountryCode?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    propertyTitle?: StringFieldUpdateOperationsInput | string
    propertyCategory?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    location?: StringFieldUpdateOperationsInput | string
    askingPrice?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    images?: PropertySubmissionUpdateimagesInput | string[]
    exclusiveRights?: BoolFieldUpdateOperationsInput | boolean
    commissionRate?: FloatFieldUpdateOperationsInput | number
    agreementAccepted?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedByName?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imagesApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imagesApprovedBy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedBy?: NullableStringFieldUpdateOperationsInput | string | null
    convertedPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertySubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerEmail?: StringFieldUpdateOperationsInput | string
    ownerPhone?: StringFieldUpdateOperationsInput | string
    ownerCountryCode?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    propertyTitle?: StringFieldUpdateOperationsInput | string
    propertyCategory?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    propertyType?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    location?: StringFieldUpdateOperationsInput | string
    askingPrice?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    images?: PropertySubmissionUpdateimagesInput | string[]
    exclusiveRights?: BoolFieldUpdateOperationsInput | boolean
    commissionRate?: FloatFieldUpdateOperationsInput | number
    agreementAccepted?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedByName?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imagesApprovedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imagesApprovedBy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedBy?: NullableStringFieldUpdateOperationsInput | string | null
    convertedPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingsCreateInput = {
    id?: string
    smtpHost?: string | null
    smtpPort?: number | null
    smtpSecure?: boolean
    smtpUser?: string | null
    smtpPassword?: string | null
    smtpFromName?: string | null
    smtpFromEmail?: string | null
    siteName?: string | null
    siteEmail?: string | null
    adminNotifyEmail?: string | null
    notifyOnSubmission?: boolean
    notifyOnImageUpload?: boolean
    companyDescription?: string | null
    companyTone?: string | null
    companyUSPs?: string | null
    targetAudience?: string | null
    brandKeywords?: string | null
    avoidTopics?: string | null
    websiteUrl?: string | null
    lastScannedAt?: Date | string | null
    scannedPagesCount?: number | null
    scanConfidence?: number | null
    detectedThemes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteSettingsUncheckedCreateInput = {
    id?: string
    smtpHost?: string | null
    smtpPort?: number | null
    smtpSecure?: boolean
    smtpUser?: string | null
    smtpPassword?: string | null
    smtpFromName?: string | null
    smtpFromEmail?: string | null
    siteName?: string | null
    siteEmail?: string | null
    adminNotifyEmail?: string | null
    notifyOnSubmission?: boolean
    notifyOnImageUpload?: boolean
    companyDescription?: string | null
    companyTone?: string | null
    companyUSPs?: string | null
    targetAudience?: string | null
    brandKeywords?: string | null
    avoidTopics?: string | null
    websiteUrl?: string | null
    lastScannedAt?: Date | string | null
    scannedPagesCount?: number | null
    scanConfidence?: number | null
    detectedThemes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpSecure?: BoolFieldUpdateOperationsInput | boolean
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    smtpFromName?: NullableStringFieldUpdateOperationsInput | string | null
    smtpFromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    siteEmail?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotifyEmail?: NullableStringFieldUpdateOperationsInput | string | null
    notifyOnSubmission?: BoolFieldUpdateOperationsInput | boolean
    notifyOnImageUpload?: BoolFieldUpdateOperationsInput | boolean
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    companyTone?: NullableStringFieldUpdateOperationsInput | string | null
    companyUSPs?: NullableStringFieldUpdateOperationsInput | string | null
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    brandKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    avoidTopics?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastScannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scannedPagesCount?: NullableIntFieldUpdateOperationsInput | number | null
    scanConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    detectedThemes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpSecure?: BoolFieldUpdateOperationsInput | boolean
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    smtpFromName?: NullableStringFieldUpdateOperationsInput | string | null
    smtpFromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    siteEmail?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotifyEmail?: NullableStringFieldUpdateOperationsInput | string | null
    notifyOnSubmission?: BoolFieldUpdateOperationsInput | boolean
    notifyOnImageUpload?: BoolFieldUpdateOperationsInput | boolean
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    companyTone?: NullableStringFieldUpdateOperationsInput | string | null
    companyUSPs?: NullableStringFieldUpdateOperationsInput | string | null
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    brandKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    avoidTopics?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastScannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scannedPagesCount?: NullableIntFieldUpdateOperationsInput | number | null
    scanConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    detectedThemes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingsCreateManyInput = {
    id?: string
    smtpHost?: string | null
    smtpPort?: number | null
    smtpSecure?: boolean
    smtpUser?: string | null
    smtpPassword?: string | null
    smtpFromName?: string | null
    smtpFromEmail?: string | null
    siteName?: string | null
    siteEmail?: string | null
    adminNotifyEmail?: string | null
    notifyOnSubmission?: boolean
    notifyOnImageUpload?: boolean
    companyDescription?: string | null
    companyTone?: string | null
    companyUSPs?: string | null
    targetAudience?: string | null
    brandKeywords?: string | null
    avoidTopics?: string | null
    websiteUrl?: string | null
    lastScannedAt?: Date | string | null
    scannedPagesCount?: number | null
    scanConfidence?: number | null
    detectedThemes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpSecure?: BoolFieldUpdateOperationsInput | boolean
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    smtpFromName?: NullableStringFieldUpdateOperationsInput | string | null
    smtpFromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    siteEmail?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotifyEmail?: NullableStringFieldUpdateOperationsInput | string | null
    notifyOnSubmission?: BoolFieldUpdateOperationsInput | boolean
    notifyOnImageUpload?: BoolFieldUpdateOperationsInput | boolean
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    companyTone?: NullableStringFieldUpdateOperationsInput | string | null
    companyUSPs?: NullableStringFieldUpdateOperationsInput | string | null
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    brandKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    avoidTopics?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastScannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scannedPagesCount?: NullableIntFieldUpdateOperationsInput | number | null
    scanConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    detectedThemes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    smtpHost?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPort?: NullableIntFieldUpdateOperationsInput | number | null
    smtpSecure?: BoolFieldUpdateOperationsInput | boolean
    smtpUser?: NullableStringFieldUpdateOperationsInput | string | null
    smtpPassword?: NullableStringFieldUpdateOperationsInput | string | null
    smtpFromName?: NullableStringFieldUpdateOperationsInput | string | null
    smtpFromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    siteName?: NullableStringFieldUpdateOperationsInput | string | null
    siteEmail?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotifyEmail?: NullableStringFieldUpdateOperationsInput | string | null
    notifyOnSubmission?: BoolFieldUpdateOperationsInput | boolean
    notifyOnImageUpload?: BoolFieldUpdateOperationsInput | boolean
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    companyTone?: NullableStringFieldUpdateOperationsInput | string | null
    companyUSPs?: NullableStringFieldUpdateOperationsInput | string | null
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    brandKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    avoidTopics?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastScannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scannedPagesCount?: NullableIntFieldUpdateOperationsInput | number | null
    scanConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    detectedThemes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternalLinkCreateInput = {
    id?: string
    url: string
    title: string
    description?: string | null
    category?: string | null
    subCategory?: string | null
    keywords?: string | null
    anchorTexts?: string | null
    priority?: number
    isActive?: boolean
    usageCount?: number
    pageExists?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usages?: LinkUsageCreateNestedManyWithoutLinkInput
  }

  export type InternalLinkUncheckedCreateInput = {
    id?: string
    url: string
    title: string
    description?: string | null
    category?: string | null
    subCategory?: string | null
    keywords?: string | null
    anchorTexts?: string | null
    priority?: number
    isActive?: boolean
    usageCount?: number
    pageExists?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usages?: LinkUsageUncheckedCreateNestedManyWithoutLinkInput
  }

  export type InternalLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    anchorTexts?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    pageExists?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usages?: LinkUsageUpdateManyWithoutLinkNestedInput
  }

  export type InternalLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    anchorTexts?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    pageExists?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usages?: LinkUsageUncheckedUpdateManyWithoutLinkNestedInput
  }

  export type InternalLinkCreateManyInput = {
    id?: string
    url: string
    title: string
    description?: string | null
    category?: string | null
    subCategory?: string | null
    keywords?: string | null
    anchorTexts?: string | null
    priority?: number
    isActive?: boolean
    usageCount?: number
    pageExists?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InternalLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    anchorTexts?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    pageExists?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternalLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    anchorTexts?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    pageExists?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkUsageCreateInput = {
    id?: string
    anchorText: string
    context?: string | null
    position?: number | null
    wasAutoInserted?: boolean
    insertedAt?: Date | string
    createdAt?: Date | string
    link: InternalLinkCreateNestedOneWithoutUsagesInput
    blog: BlogCreateNestedOneWithoutLinkUsagesInput
  }

  export type LinkUsageUncheckedCreateInput = {
    id?: string
    linkId: string
    blogId: string
    anchorText: string
    context?: string | null
    position?: number | null
    wasAutoInserted?: boolean
    insertedAt?: Date | string
    createdAt?: Date | string
  }

  export type LinkUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    anchorText?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    wasAutoInserted?: BoolFieldUpdateOperationsInput | boolean
    insertedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: InternalLinkUpdateOneRequiredWithoutUsagesNestedInput
    blog?: BlogUpdateOneRequiredWithoutLinkUsagesNestedInput
  }

  export type LinkUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkId?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    anchorText?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    wasAutoInserted?: BoolFieldUpdateOperationsInput | boolean
    insertedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkUsageCreateManyInput = {
    id?: string
    linkId: string
    blogId: string
    anchorText: string
    context?: string | null
    position?: number | null
    wasAutoInserted?: boolean
    insertedAt?: Date | string
    createdAt?: Date | string
  }

  export type LinkUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    anchorText?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    wasAutoInserted?: BoolFieldUpdateOperationsInput | boolean
    insertedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkId?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    anchorText?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    wasAutoInserted?: BoolFieldUpdateOperationsInput | boolean
    insertedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandingPageSuggestionCreateInput = {
    id?: string
    suggestedUrl: string
    suggestedTitle: string
    description?: string | null
    category: string
    reason?: string | null
    mentionCount?: number
    sourceBlogs?: string | null
    status?: $Enums.LandingPageStatus
    createdPageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LandingPageSuggestionUncheckedCreateInput = {
    id?: string
    suggestedUrl: string
    suggestedTitle: string
    description?: string | null
    category: string
    reason?: string | null
    mentionCount?: number
    sourceBlogs?: string | null
    status?: $Enums.LandingPageStatus
    createdPageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LandingPageSuggestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    suggestedUrl?: StringFieldUpdateOperationsInput | string
    suggestedTitle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    mentionCount?: IntFieldUpdateOperationsInput | number
    sourceBlogs?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLandingPageStatusFieldUpdateOperationsInput | $Enums.LandingPageStatus
    createdPageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandingPageSuggestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    suggestedUrl?: StringFieldUpdateOperationsInput | string
    suggestedTitle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    mentionCount?: IntFieldUpdateOperationsInput | number
    sourceBlogs?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLandingPageStatusFieldUpdateOperationsInput | $Enums.LandingPageStatus
    createdPageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandingPageSuggestionCreateManyInput = {
    id?: string
    suggestedUrl: string
    suggestedTitle: string
    description?: string | null
    category: string
    reason?: string | null
    mentionCount?: number
    sourceBlogs?: string | null
    status?: $Enums.LandingPageStatus
    createdPageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LandingPageSuggestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    suggestedUrl?: StringFieldUpdateOperationsInput | string
    suggestedTitle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    mentionCount?: IntFieldUpdateOperationsInput | number
    sourceBlogs?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLandingPageStatusFieldUpdateOperationsInput | $Enums.LandingPageStatus
    createdPageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandingPageSuggestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    suggestedUrl?: StringFieldUpdateOperationsInput | string
    suggestedTitle?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    mentionCount?: IntFieldUpdateOperationsInput | number
    sourceBlogs?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLandingPageStatusFieldUpdateOperationsInput | $Enums.LandingPageStatus
    createdPageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandingPageCreateInput = {
    id?: string
    url: string
    title: string
    category: string
    metaTitle?: string | null
    metaDescription?: string | null
    content: string
    faq?: NullableJsonNullValueInput | InputJsonValue
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LandingPageUncheckedCreateInput = {
    id?: string
    url: string
    title: string
    category: string
    metaTitle?: string | null
    metaDescription?: string | null
    content: string
    faq?: NullableJsonNullValueInput | InputJsonValue
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LandingPageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    faq?: NullableJsonNullValueInput | InputJsonValue
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandingPageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    faq?: NullableJsonNullValueInput | InputJsonValue
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandingPageCreateManyInput = {
    id?: string
    url: string
    title: string
    category: string
    metaTitle?: string | null
    metaDescription?: string | null
    content: string
    faq?: NullableJsonNullValueInput | InputJsonValue
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LandingPageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    faq?: NullableJsonNullValueInput | InputJsonValue
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LandingPageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    faq?: NullableJsonNullValueInput | InputJsonValue
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyProfileCreateInput = {
    id?: string
    companyName?: string | null
    tagline?: string | null
    description?: string | null
    tone?: string | null
    writingStyle?: string | null
    targetAudience?: string | null
    targetLocations?: string | null
    usps?: string | null
    expertise?: string | null
    contentThemes?: string | null
    brandKeywords?: string | null
    avoidTopics?: string | null
    competitors?: string | null
    websiteUrl?: string | null
    lastAnalyzedAt?: Date | string | null
    analysisData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyProfileUncheckedCreateInput = {
    id?: string
    companyName?: string | null
    tagline?: string | null
    description?: string | null
    tone?: string | null
    writingStyle?: string | null
    targetAudience?: string | null
    targetLocations?: string | null
    usps?: string | null
    expertise?: string | null
    contentThemes?: string | null
    brandKeywords?: string | null
    avoidTopics?: string | null
    competitors?: string | null
    websiteUrl?: string | null
    lastAnalyzedAt?: Date | string | null
    analysisData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: NullableStringFieldUpdateOperationsInput | string | null
    writingStyle?: NullableStringFieldUpdateOperationsInput | string | null
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    targetLocations?: NullableStringFieldUpdateOperationsInput | string | null
    usps?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    contentThemes?: NullableStringFieldUpdateOperationsInput | string | null
    brandKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    avoidTopics?: NullableStringFieldUpdateOperationsInput | string | null
    competitors?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: NullableStringFieldUpdateOperationsInput | string | null
    writingStyle?: NullableStringFieldUpdateOperationsInput | string | null
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    targetLocations?: NullableStringFieldUpdateOperationsInput | string | null
    usps?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    contentThemes?: NullableStringFieldUpdateOperationsInput | string | null
    brandKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    avoidTopics?: NullableStringFieldUpdateOperationsInput | string | null
    competitors?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyProfileCreateManyInput = {
    id?: string
    companyName?: string | null
    tagline?: string | null
    description?: string | null
    tone?: string | null
    writingStyle?: string | null
    targetAudience?: string | null
    targetLocations?: string | null
    usps?: string | null
    expertise?: string | null
    contentThemes?: string | null
    brandKeywords?: string | null
    avoidTopics?: string | null
    competitors?: string | null
    websiteUrl?: string | null
    lastAnalyzedAt?: Date | string | null
    analysisData?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: NullableStringFieldUpdateOperationsInput | string | null
    writingStyle?: NullableStringFieldUpdateOperationsInput | string | null
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    targetLocations?: NullableStringFieldUpdateOperationsInput | string | null
    usps?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    contentThemes?: NullableStringFieldUpdateOperationsInput | string | null
    brandKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    avoidTopics?: NullableStringFieldUpdateOperationsInput | string | null
    competitors?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: NullableStringFieldUpdateOperationsInput | string | null
    writingStyle?: NullableStringFieldUpdateOperationsInput | string | null
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    targetLocations?: NullableStringFieldUpdateOperationsInput | string | null
    usps?: NullableStringFieldUpdateOperationsInput | string | null
    expertise?: NullableStringFieldUpdateOperationsInput | string | null
    contentThemes?: NullableStringFieldUpdateOperationsInput | string | null
    brandKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    avoidTopics?: NullableStringFieldUpdateOperationsInput | string | null
    competitors?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lastAnalyzedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    analysisData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogScheduleSettingsCreateInput = {
    id?: string
    maxBlogsPerWeek?: number
    minDaysBetweenPosts?: number
    preferredPostTime?: string | null
    preferredPostDays?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogScheduleSettingsUncheckedCreateInput = {
    id?: string
    maxBlogsPerWeek?: number
    minDaysBetweenPosts?: number
    preferredPostTime?: string | null
    preferredPostDays?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogScheduleSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxBlogsPerWeek?: IntFieldUpdateOperationsInput | number
    minDaysBetweenPosts?: IntFieldUpdateOperationsInput | number
    preferredPostTime?: NullableStringFieldUpdateOperationsInput | string | null
    preferredPostDays?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogScheduleSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxBlogsPerWeek?: IntFieldUpdateOperationsInput | number
    minDaysBetweenPosts?: IntFieldUpdateOperationsInput | number
    preferredPostTime?: NullableStringFieldUpdateOperationsInput | string | null
    preferredPostDays?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogScheduleSettingsCreateManyInput = {
    id?: string
    maxBlogsPerWeek?: number
    minDaysBetweenPosts?: number
    preferredPostTime?: string | null
    preferredPostDays?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogScheduleSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxBlogsPerWeek?: IntFieldUpdateOperationsInput | number
    minDaysBetweenPosts?: IntFieldUpdateOperationsInput | number
    preferredPostTime?: NullableStringFieldUpdateOperationsInput | string | null
    preferredPostDays?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogScheduleSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxBlogsPerWeek?: IntFieldUpdateOperationsInput | number
    minDaysBetweenPosts?: IntFieldUpdateOperationsInput | number
    preferredPostTime?: NullableStringFieldUpdateOperationsInput | string | null
    preferredPostDays?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicSuggestionCreateInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    priority?: string | null
    difficulty?: string | null
    estimatedImpact?: string | null
    language?: string
    status?: $Enums.TopicStatus
    usedAt?: Date | string | null
    generatedBlogId?: string | null
    batchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopicSuggestionUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    priority?: string | null
    difficulty?: string | null
    estimatedImpact?: string | null
    language?: string
    status?: $Enums.TopicStatus
    usedAt?: Date | string | null
    generatedBlogId?: string | null
    batchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopicSuggestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedImpact?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    generatedBlogId?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicSuggestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedImpact?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    generatedBlogId?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicSuggestionCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    priority?: string | null
    difficulty?: string | null
    estimatedImpact?: string | null
    language?: string
    status?: $Enums.TopicStatus
    usedAt?: Date | string | null
    generatedBlogId?: string | null
    batchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopicSuggestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedImpact?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    generatedBlogId?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicSuggestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedImpact?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumTopicStatusFieldUpdateOperationsInput | $Enums.TopicStatus
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    generatedBlogId?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledBlogCreateInput = {
    id?: string
    topicId?: string | null
    topicTitle: string
    language?: string
    length?: string
    tone?: string
    includeResearch?: boolean
    scheduledFor: Date | string
    scheduledBy: string
    status?: $Enums.ScheduledBlogStatus
    generatedBlogId?: string | null
    processingStartedAt?: Date | string | null
    processedAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledBlogUncheckedCreateInput = {
    id?: string
    topicId?: string | null
    topicTitle: string
    language?: string
    length?: string
    tone?: string
    includeResearch?: boolean
    scheduledFor: Date | string
    scheduledBy: string
    status?: $Enums.ScheduledBlogStatus
    generatedBlogId?: string | null
    processingStartedAt?: Date | string | null
    processedAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledBlogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    topicTitle?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    length?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    includeResearch?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledBy?: StringFieldUpdateOperationsInput | string
    status?: EnumScheduledBlogStatusFieldUpdateOperationsInput | $Enums.ScheduledBlogStatus
    generatedBlogId?: NullableStringFieldUpdateOperationsInput | string | null
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledBlogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    topicTitle?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    length?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    includeResearch?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledBy?: StringFieldUpdateOperationsInput | string
    status?: EnumScheduledBlogStatusFieldUpdateOperationsInput | $Enums.ScheduledBlogStatus
    generatedBlogId?: NullableStringFieldUpdateOperationsInput | string | null
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledBlogCreateManyInput = {
    id?: string
    topicId?: string | null
    topicTitle: string
    language?: string
    length?: string
    tone?: string
    includeResearch?: boolean
    scheduledFor: Date | string
    scheduledBy: string
    status?: $Enums.ScheduledBlogStatus
    generatedBlogId?: string | null
    processingStartedAt?: Date | string | null
    processedAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduledBlogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    topicTitle?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    length?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    includeResearch?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledBy?: StringFieldUpdateOperationsInput | string
    status?: EnumScheduledBlogStatusFieldUpdateOperationsInput | $Enums.ScheduledBlogStatus
    generatedBlogId?: NullableStringFieldUpdateOperationsInput | string | null
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledBlogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    topicTitle?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    length?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    includeResearch?: BoolFieldUpdateOperationsInput | boolean
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledBy?: StringFieldUpdateOperationsInput | string
    status?: EnumScheduledBlogStatusFieldUpdateOperationsInput | $Enums.ScheduledBlogStatus
    generatedBlogId?: NullableStringFieldUpdateOperationsInput | string | null
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroImageCreateInput = {
    id?: string
    page?: string
    deviceType: $Enums.HeroDeviceType
    imageUrl: string
    alt: string
    fileName?: string | null
    originalUrl?: string | null
    width?: number | null
    height?: number | null
    isAiGenerated?: boolean
    aiPrompt?: string | null
    originalSize?: number | null
    optimizedSize?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HeroImageUncheckedCreateInput = {
    id?: string
    page?: string
    deviceType: $Enums.HeroDeviceType
    imageUrl: string
    alt: string
    fileName?: string | null
    originalUrl?: string | null
    width?: number | null
    height?: number | null
    isAiGenerated?: boolean
    aiPrompt?: string | null
    originalSize?: number | null
    optimizedSize?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HeroImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumHeroDeviceTypeFieldUpdateOperationsInput | $Enums.HeroDeviceType
    imageUrl?: StringFieldUpdateOperationsInput | string
    alt?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    originalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    isAiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    originalSize?: NullableIntFieldUpdateOperationsInput | number | null
    optimizedSize?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumHeroDeviceTypeFieldUpdateOperationsInput | $Enums.HeroDeviceType
    imageUrl?: StringFieldUpdateOperationsInput | string
    alt?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    originalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    isAiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    originalSize?: NullableIntFieldUpdateOperationsInput | number | null
    optimizedSize?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroImageCreateManyInput = {
    id?: string
    page?: string
    deviceType: $Enums.HeroDeviceType
    imageUrl: string
    alt: string
    fileName?: string | null
    originalUrl?: string | null
    width?: number | null
    height?: number | null
    isAiGenerated?: boolean
    aiPrompt?: string | null
    originalSize?: number | null
    optimizedSize?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HeroImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumHeroDeviceTypeFieldUpdateOperationsInput | $Enums.HeroDeviceType
    imageUrl?: StringFieldUpdateOperationsInput | string
    alt?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    originalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    isAiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    originalSize?: NullableIntFieldUpdateOperationsInput | number | null
    optimizedSize?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumHeroDeviceTypeFieldUpdateOperationsInput | $Enums.HeroDeviceType
    imageUrl?: StringFieldUpdateOperationsInput | string
    alt?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    originalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    isAiGenerated?: BoolFieldUpdateOperationsInput | boolean
    aiPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    originalSize?: NullableIntFieldUpdateOperationsInput | number | null
    optimizedSize?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAlertCreateInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    countryCode?: string
    userId?: string | null
    propertyType?: $Enums.PropertyType | null
    category?: $Enums.PropertyCategory | null
    locations?: string | null
    minPrice?: number | null
    maxPrice?: number | null
    minBeds?: number | null
    maxBeds?: number | null
    minBaths?: number | null
    maxBaths?: number | null
    minSqft?: number | null
    maxSqft?: number | null
    notifyImmediately?: boolean
    notifyDigest?: boolean
    digestDay?: string | null
    isActive?: boolean
    lastNotifiedAt?: Date | string | null
    matchCount?: number
    notificationCount?: number
    verificationToken?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    unsubscribeToken?: string
    ipAddress?: string | null
    userAgent?: string | null
    source?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyAlertUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    countryCode?: string
    userId?: string | null
    propertyType?: $Enums.PropertyType | null
    category?: $Enums.PropertyCategory | null
    locations?: string | null
    minPrice?: number | null
    maxPrice?: number | null
    minBeds?: number | null
    maxBeds?: number | null
    minBaths?: number | null
    maxBaths?: number | null
    minSqft?: number | null
    maxSqft?: number | null
    notifyImmediately?: boolean
    notifyDigest?: boolean
    digestDay?: string | null
    isActive?: boolean
    lastNotifiedAt?: Date | string | null
    matchCount?: number
    notificationCount?: number
    verificationToken?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    unsubscribeToken?: string
    ipAddress?: string | null
    userAgent?: string | null
    source?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    category?: NullableEnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory | null
    locations?: NullableStringFieldUpdateOperationsInput | string | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    minBeds?: NullableIntFieldUpdateOperationsInput | number | null
    maxBeds?: NullableIntFieldUpdateOperationsInput | number | null
    minBaths?: NullableIntFieldUpdateOperationsInput | number | null
    maxBaths?: NullableIntFieldUpdateOperationsInput | number | null
    minSqft?: NullableIntFieldUpdateOperationsInput | number | null
    maxSqft?: NullableIntFieldUpdateOperationsInput | number | null
    notifyImmediately?: BoolFieldUpdateOperationsInput | boolean
    notifyDigest?: BoolFieldUpdateOperationsInput | boolean
    digestDay?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    matchCount?: IntFieldUpdateOperationsInput | number
    notificationCount?: IntFieldUpdateOperationsInput | number
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unsubscribeToken?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    category?: NullableEnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory | null
    locations?: NullableStringFieldUpdateOperationsInput | string | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    minBeds?: NullableIntFieldUpdateOperationsInput | number | null
    maxBeds?: NullableIntFieldUpdateOperationsInput | number | null
    minBaths?: NullableIntFieldUpdateOperationsInput | number | null
    maxBaths?: NullableIntFieldUpdateOperationsInput | number | null
    minSqft?: NullableIntFieldUpdateOperationsInput | number | null
    maxSqft?: NullableIntFieldUpdateOperationsInput | number | null
    notifyImmediately?: BoolFieldUpdateOperationsInput | boolean
    notifyDigest?: BoolFieldUpdateOperationsInput | boolean
    digestDay?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    matchCount?: IntFieldUpdateOperationsInput | number
    notificationCount?: IntFieldUpdateOperationsInput | number
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unsubscribeToken?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAlertCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    countryCode?: string
    userId?: string | null
    propertyType?: $Enums.PropertyType | null
    category?: $Enums.PropertyCategory | null
    locations?: string | null
    minPrice?: number | null
    maxPrice?: number | null
    minBeds?: number | null
    maxBeds?: number | null
    minBaths?: number | null
    maxBaths?: number | null
    minSqft?: number | null
    maxSqft?: number | null
    notifyImmediately?: boolean
    notifyDigest?: boolean
    digestDay?: string | null
    isActive?: boolean
    lastNotifiedAt?: Date | string | null
    matchCount?: number
    notificationCount?: number
    verificationToken?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    unsubscribeToken?: string
    ipAddress?: string | null
    userAgent?: string | null
    source?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    category?: NullableEnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory | null
    locations?: NullableStringFieldUpdateOperationsInput | string | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    minBeds?: NullableIntFieldUpdateOperationsInput | number | null
    maxBeds?: NullableIntFieldUpdateOperationsInput | number | null
    minBaths?: NullableIntFieldUpdateOperationsInput | number | null
    maxBaths?: NullableIntFieldUpdateOperationsInput | number | null
    minSqft?: NullableIntFieldUpdateOperationsInput | number | null
    maxSqft?: NullableIntFieldUpdateOperationsInput | number | null
    notifyImmediately?: BoolFieldUpdateOperationsInput | boolean
    notifyDigest?: BoolFieldUpdateOperationsInput | boolean
    digestDay?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    matchCount?: IntFieldUpdateOperationsInput | number
    notificationCount?: IntFieldUpdateOperationsInput | number
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unsubscribeToken?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableEnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType | null
    category?: NullableEnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory | null
    locations?: NullableStringFieldUpdateOperationsInput | string | null
    minPrice?: NullableIntFieldUpdateOperationsInput | number | null
    maxPrice?: NullableIntFieldUpdateOperationsInput | number | null
    minBeds?: NullableIntFieldUpdateOperationsInput | number | null
    maxBeds?: NullableIntFieldUpdateOperationsInput | number | null
    minBaths?: NullableIntFieldUpdateOperationsInput | number | null
    maxBaths?: NullableIntFieldUpdateOperationsInput | number | null
    minSqft?: NullableIntFieldUpdateOperationsInput | number | null
    maxSqft?: NullableIntFieldUpdateOperationsInput | number | null
    notifyImmediately?: BoolFieldUpdateOperationsInput | boolean
    notifyDigest?: BoolFieldUpdateOperationsInput | boolean
    digestDay?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastNotifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    matchCount?: IntFieldUpdateOperationsInput | number
    notificationCount?: IntFieldUpdateOperationsInput | number
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unsubscribeToken?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAlertNotificationCreateInput = {
    id?: string
    alertId: string
    propertyIds: string
    propertyCount: number
    emailSent?: boolean
    emailSentAt?: Date | string | null
    emailError?: string | null
    opened?: boolean
    openedAt?: Date | string | null
    clicked?: boolean
    clickedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PropertyAlertNotificationUncheckedCreateInput = {
    id?: string
    alertId: string
    propertyIds: string
    propertyCount: number
    emailSent?: boolean
    emailSentAt?: Date | string | null
    emailError?: string | null
    opened?: boolean
    openedAt?: Date | string | null
    clicked?: boolean
    clickedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PropertyAlertNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    propertyIds?: StringFieldUpdateOperationsInput | string
    propertyCount?: IntFieldUpdateOperationsInput | number
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailError?: NullableStringFieldUpdateOperationsInput | string | null
    opened?: BoolFieldUpdateOperationsInput | boolean
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clicked?: BoolFieldUpdateOperationsInput | boolean
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAlertNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    propertyIds?: StringFieldUpdateOperationsInput | string
    propertyCount?: IntFieldUpdateOperationsInput | number
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailError?: NullableStringFieldUpdateOperationsInput | string | null
    opened?: BoolFieldUpdateOperationsInput | boolean
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clicked?: BoolFieldUpdateOperationsInput | boolean
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAlertNotificationCreateManyInput = {
    id?: string
    alertId: string
    propertyIds: string
    propertyCount: number
    emailSent?: boolean
    emailSentAt?: Date | string | null
    emailError?: string | null
    opened?: boolean
    openedAt?: Date | string | null
    clicked?: boolean
    clickedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PropertyAlertNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    propertyIds?: StringFieldUpdateOperationsInput | string
    propertyCount?: IntFieldUpdateOperationsInput | number
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailError?: NullableStringFieldUpdateOperationsInput | string | null
    opened?: BoolFieldUpdateOperationsInput | boolean
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clicked?: BoolFieldUpdateOperationsInput | boolean
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAlertNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    propertyIds?: StringFieldUpdateOperationsInput | string
    propertyCount?: IntFieldUpdateOperationsInput | number
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailError?: NullableStringFieldUpdateOperationsInput | string | null
    opened?: BoolFieldUpdateOperationsInput | boolean
    openedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clicked?: BoolFieldUpdateOperationsInput | boolean
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PoiCreateInput = {
    id?: string
    externalId?: string | null
    source?: $Enums.PoiSource
    name: string
    nameTh?: string | null
    nameLocal?: string | null
    category: $Enums.PoiCategory
    subCategory?: string | null
    latitude: number
    longitude: number
    address?: string | null
    district?: string | null
    osmTags?: NullableJsonNullValueInput | InputJsonValue
    importance?: number
    isVerified?: boolean
    isActive?: boolean
    noiseLevel?: $Enums.NoiseLevel | null
    trafficLevel?: $Enums.TrafficLevel | null
    lastSyncedAt?: Date | string | null
    syncError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyDistances?: PropertyPoiDistanceCreateNestedManyWithoutPoiInput
  }

  export type PoiUncheckedCreateInput = {
    id?: string
    externalId?: string | null
    source?: $Enums.PoiSource
    name: string
    nameTh?: string | null
    nameLocal?: string | null
    category: $Enums.PoiCategory
    subCategory?: string | null
    latitude: number
    longitude: number
    address?: string | null
    district?: string | null
    osmTags?: NullableJsonNullValueInput | InputJsonValue
    importance?: number
    isVerified?: boolean
    isActive?: boolean
    noiseLevel?: $Enums.NoiseLevel | null
    trafficLevel?: $Enums.TrafficLevel | null
    lastSyncedAt?: Date | string | null
    syncError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyDistances?: PropertyPoiDistanceUncheckedCreateNestedManyWithoutPoiInput
  }

  export type PoiUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumPoiSourceFieldUpdateOperationsInput | $Enums.PoiSource
    name?: StringFieldUpdateOperationsInput | string
    nameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nameLocal?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPoiCategoryFieldUpdateOperationsInput | $Enums.PoiCategory
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    osmTags?: NullableJsonNullValueInput | InputJsonValue
    importance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    noiseLevel?: NullableEnumNoiseLevelFieldUpdateOperationsInput | $Enums.NoiseLevel | null
    trafficLevel?: NullableEnumTrafficLevelFieldUpdateOperationsInput | $Enums.TrafficLevel | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyDistances?: PropertyPoiDistanceUpdateManyWithoutPoiNestedInput
  }

  export type PoiUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumPoiSourceFieldUpdateOperationsInput | $Enums.PoiSource
    name?: StringFieldUpdateOperationsInput | string
    nameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nameLocal?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPoiCategoryFieldUpdateOperationsInput | $Enums.PoiCategory
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    osmTags?: NullableJsonNullValueInput | InputJsonValue
    importance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    noiseLevel?: NullableEnumNoiseLevelFieldUpdateOperationsInput | $Enums.NoiseLevel | null
    trafficLevel?: NullableEnumTrafficLevelFieldUpdateOperationsInput | $Enums.TrafficLevel | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyDistances?: PropertyPoiDistanceUncheckedUpdateManyWithoutPoiNestedInput
  }

  export type PoiCreateManyInput = {
    id?: string
    externalId?: string | null
    source?: $Enums.PoiSource
    name: string
    nameTh?: string | null
    nameLocal?: string | null
    category: $Enums.PoiCategory
    subCategory?: string | null
    latitude: number
    longitude: number
    address?: string | null
    district?: string | null
    osmTags?: NullableJsonNullValueInput | InputJsonValue
    importance?: number
    isVerified?: boolean
    isActive?: boolean
    noiseLevel?: $Enums.NoiseLevel | null
    trafficLevel?: $Enums.TrafficLevel | null
    lastSyncedAt?: Date | string | null
    syncError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PoiUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumPoiSourceFieldUpdateOperationsInput | $Enums.PoiSource
    name?: StringFieldUpdateOperationsInput | string
    nameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nameLocal?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPoiCategoryFieldUpdateOperationsInput | $Enums.PoiCategory
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    osmTags?: NullableJsonNullValueInput | InputJsonValue
    importance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    noiseLevel?: NullableEnumNoiseLevelFieldUpdateOperationsInput | $Enums.NoiseLevel | null
    trafficLevel?: NullableEnumTrafficLevelFieldUpdateOperationsInput | $Enums.TrafficLevel | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PoiUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumPoiSourceFieldUpdateOperationsInput | $Enums.PoiSource
    name?: StringFieldUpdateOperationsInput | string
    nameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nameLocal?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPoiCategoryFieldUpdateOperationsInput | $Enums.PoiCategory
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    osmTags?: NullableJsonNullValueInput | InputJsonValue
    importance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    noiseLevel?: NullableEnumNoiseLevelFieldUpdateOperationsInput | $Enums.NoiseLevel | null
    trafficLevel?: NullableEnumTrafficLevelFieldUpdateOperationsInput | $Enums.TrafficLevel | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPoiDistanceCreateInput = {
    id?: string
    distanceMeters: number
    walkingMinutes?: number | null
    drivingMinutes?: number | null
    isHighlight?: boolean
    calculatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutPoiDistancesInput
    poi: PoiCreateNestedOneWithoutPropertyDistancesInput
  }

  export type PropertyPoiDistanceUncheckedCreateInput = {
    id?: string
    propertyId: string
    poiId: string
    distanceMeters: number
    walkingMinutes?: number | null
    drivingMinutes?: number | null
    isHighlight?: boolean
    calculatedAt?: Date | string
  }

  export type PropertyPoiDistanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    distanceMeters?: IntFieldUpdateOperationsInput | number
    walkingMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    drivingMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isHighlight?: BoolFieldUpdateOperationsInput | boolean
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutPoiDistancesNestedInput
    poi?: PoiUpdateOneRequiredWithoutPropertyDistancesNestedInput
  }

  export type PropertyPoiDistanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    poiId?: StringFieldUpdateOperationsInput | string
    distanceMeters?: IntFieldUpdateOperationsInput | number
    walkingMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    drivingMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isHighlight?: BoolFieldUpdateOperationsInput | boolean
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPoiDistanceCreateManyInput = {
    id?: string
    propertyId: string
    poiId: string
    distanceMeters: number
    walkingMinutes?: number | null
    drivingMinutes?: number | null
    isHighlight?: boolean
    calculatedAt?: Date | string
  }

  export type PropertyPoiDistanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    distanceMeters?: IntFieldUpdateOperationsInput | number
    walkingMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    drivingMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isHighlight?: BoolFieldUpdateOperationsInput | boolean
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPoiDistanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    poiId?: StringFieldUpdateOperationsInput | string
    distanceMeters?: IntFieldUpdateOperationsInput | number
    walkingMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    drivingMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isHighlight?: BoolFieldUpdateOperationsInput | boolean
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PoiSyncJobCreateInput = {
    id?: string
    jobType: $Enums.PoiSyncJobType
    status?: $Enums.PoiSyncJobStatus
    category?: $Enums.PoiCategory | null
    district?: string | null
    poisFetched?: number
    poisCreated?: number
    poisUpdated?: number
    poisSkipped?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    errorStack?: string | null
    createdAt?: Date | string
  }

  export type PoiSyncJobUncheckedCreateInput = {
    id?: string
    jobType: $Enums.PoiSyncJobType
    status?: $Enums.PoiSyncJobStatus
    category?: $Enums.PoiCategory | null
    district?: string | null
    poisFetched?: number
    poisCreated?: number
    poisUpdated?: number
    poisSkipped?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    errorStack?: string | null
    createdAt?: Date | string
  }

  export type PoiSyncJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: EnumPoiSyncJobTypeFieldUpdateOperationsInput | $Enums.PoiSyncJobType
    status?: EnumPoiSyncJobStatusFieldUpdateOperationsInput | $Enums.PoiSyncJobStatus
    category?: NullableEnumPoiCategoryFieldUpdateOperationsInput | $Enums.PoiCategory | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisFetched?: IntFieldUpdateOperationsInput | number
    poisCreated?: IntFieldUpdateOperationsInput | number
    poisUpdated?: IntFieldUpdateOperationsInput | number
    poisSkipped?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PoiSyncJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: EnumPoiSyncJobTypeFieldUpdateOperationsInput | $Enums.PoiSyncJobType
    status?: EnumPoiSyncJobStatusFieldUpdateOperationsInput | $Enums.PoiSyncJobStatus
    category?: NullableEnumPoiCategoryFieldUpdateOperationsInput | $Enums.PoiCategory | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisFetched?: IntFieldUpdateOperationsInput | number
    poisCreated?: IntFieldUpdateOperationsInput | number
    poisUpdated?: IntFieldUpdateOperationsInput | number
    poisSkipped?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PoiSyncJobCreateManyInput = {
    id?: string
    jobType: $Enums.PoiSyncJobType
    status?: $Enums.PoiSyncJobStatus
    category?: $Enums.PoiCategory | null
    district?: string | null
    poisFetched?: number
    poisCreated?: number
    poisUpdated?: number
    poisSkipped?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    errorStack?: string | null
    createdAt?: Date | string
  }

  export type PoiSyncJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: EnumPoiSyncJobTypeFieldUpdateOperationsInput | $Enums.PoiSyncJobType
    status?: EnumPoiSyncJobStatusFieldUpdateOperationsInput | $Enums.PoiSyncJobStatus
    category?: NullableEnumPoiCategoryFieldUpdateOperationsInput | $Enums.PoiCategory | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisFetched?: IntFieldUpdateOperationsInput | number
    poisCreated?: IntFieldUpdateOperationsInput | number
    poisUpdated?: IntFieldUpdateOperationsInput | number
    poisSkipped?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PoiSyncJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobType?: EnumPoiSyncJobTypeFieldUpdateOperationsInput | $Enums.PoiSyncJobType
    status?: EnumPoiSyncJobStatusFieldUpdateOperationsInput | $Enums.PoiSyncJobStatus
    category?: NullableEnumPoiCategoryFieldUpdateOperationsInput | $Enums.PoiCategory | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisFetched?: IntFieldUpdateOperationsInput | number
    poisCreated?: IntFieldUpdateOperationsInput | number
    poisUpdated?: IntFieldUpdateOperationsInput | number
    poisSkipped?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalPricingConfigCreateInput = {
    id?: string
    peakSeasonMonths?: RentalPricingConfigCreatepeakSeasonMonthsInput | number[]
    peakSeasonSurcharges?: JsonNullValueInput | InputJsonValue
    lowSeasonSurcharges?: JsonNullValueInput | InputJsonValue
    minimumStayDays?: number
    maximumStayDays?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RentalPricingConfigUncheckedCreateInput = {
    id?: string
    peakSeasonMonths?: RentalPricingConfigCreatepeakSeasonMonthsInput | number[]
    peakSeasonSurcharges?: JsonNullValueInput | InputJsonValue
    lowSeasonSurcharges?: JsonNullValueInput | InputJsonValue
    minimumStayDays?: number
    maximumStayDays?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RentalPricingConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    peakSeasonMonths?: RentalPricingConfigUpdatepeakSeasonMonthsInput | number[]
    peakSeasonSurcharges?: JsonNullValueInput | InputJsonValue
    lowSeasonSurcharges?: JsonNullValueInput | InputJsonValue
    minimumStayDays?: IntFieldUpdateOperationsInput | number
    maximumStayDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalPricingConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    peakSeasonMonths?: RentalPricingConfigUpdatepeakSeasonMonthsInput | number[]
    peakSeasonSurcharges?: JsonNullValueInput | InputJsonValue
    lowSeasonSurcharges?: JsonNullValueInput | InputJsonValue
    minimumStayDays?: IntFieldUpdateOperationsInput | number
    maximumStayDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalPricingConfigCreateManyInput = {
    id?: string
    peakSeasonMonths?: RentalPricingConfigCreatepeakSeasonMonthsInput | number[]
    peakSeasonSurcharges?: JsonNullValueInput | InputJsonValue
    lowSeasonSurcharges?: JsonNullValueInput | InputJsonValue
    minimumStayDays?: number
    maximumStayDays?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RentalPricingConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    peakSeasonMonths?: RentalPricingConfigUpdatepeakSeasonMonthsInput | number[]
    peakSeasonSurcharges?: JsonNullValueInput | InputJsonValue
    lowSeasonSurcharges?: JsonNullValueInput | InputJsonValue
    minimumStayDays?: IntFieldUpdateOperationsInput | number
    maximumStayDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalPricingConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    peakSeasonMonths?: RentalPricingConfigUpdatepeakSeasonMonthsInput | number[]
    peakSeasonSurcharges?: JsonNullValueInput | InputJsonValue
    lowSeasonSurcharges?: JsonNullValueInput | InputJsonValue
    minimumStayDays?: IntFieldUpdateOperationsInput | number
    maximumStayDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalBookingCreateInput = {
    id?: string
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    adults?: number
    children?: number
    babies?: number
    pets?: number
    basePrice: number
    season: string
    discountPercent: number
    totalPrice: number
    guestName: string
    guestEmail: string
    guestPhone: string
    guestCountryCode?: string
    guestMessage?: string | null
    status?: $Enums.RentalBookingStatus
    paymentStatus?: string | null
    cancellationPolicy?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    internalNotes?: string | null
    checkInTime?: string | null
    checkOutTime?: string | null
    propertyAddress?: string | null
    propertyInstructions?: string | null
    wifiName?: string | null
    wifiPassword?: string | null
    accessCode?: string | null
    emergencyContact?: string | null
    houseRules?: string | null
    confirmedAt?: Date | string | null
    tm30Status?: $Enums.TM30BookingStatus
    tm30SubmittedAt?: Date | string | null
    tm30Reference?: string | null
    tm30Error?: string | null
    passportsRequired?: number
    passportsReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutRentalBookingsInput
    user: UserCreateNestedOneWithoutRentalBookingsInput
    agent?: UserCreateNestedOneWithoutBookingsAsAgentInput
    messages?: BookingMessageCreateNestedManyWithoutBookingInput
    guests?: BookingGuestCreateNestedManyWithoutBookingInput
  }

  export type RentalBookingUncheckedCreateInput = {
    id?: string
    propertyId: string
    userId: string
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    adults?: number
    children?: number
    babies?: number
    pets?: number
    basePrice: number
    season: string
    discountPercent: number
    totalPrice: number
    guestName: string
    guestEmail: string
    guestPhone: string
    guestCountryCode?: string
    guestMessage?: string | null
    status?: $Enums.RentalBookingStatus
    paymentStatus?: string | null
    cancellationPolicy?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    internalNotes?: string | null
    checkInTime?: string | null
    checkOutTime?: string | null
    propertyAddress?: string | null
    propertyInstructions?: string | null
    wifiName?: string | null
    wifiPassword?: string | null
    accessCode?: string | null
    emergencyContact?: string | null
    houseRules?: string | null
    confirmedAt?: Date | string | null
    agentId?: string | null
    tm30Status?: $Enums.TM30BookingStatus
    tm30SubmittedAt?: Date | string | null
    tm30Reference?: string | null
    tm30Error?: string | null
    passportsRequired?: number
    passportsReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: BookingMessageUncheckedCreateNestedManyWithoutBookingInput
    guests?: BookingGuestUncheckedCreateNestedManyWithoutBookingInput
  }

  export type RentalBookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    babies?: IntFieldUpdateOperationsInput | number
    pets?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    discountPercent?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: StringFieldUpdateOperationsInput | string
    guestCountryCode?: StringFieldUpdateOperationsInput | string
    guestMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRentalBookingStatusFieldUpdateOperationsInput | $Enums.RentalBookingStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    wifiName?: NullableStringFieldUpdateOperationsInput | string | null
    wifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Status?: EnumTM30BookingStatusFieldUpdateOperationsInput | $Enums.TM30BookingStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Reference?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    passportsRequired?: IntFieldUpdateOperationsInput | number
    passportsReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutRentalBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutRentalBookingsNestedInput
    agent?: UserUpdateOneWithoutBookingsAsAgentNestedInput
    messages?: BookingMessageUpdateManyWithoutBookingNestedInput
    guests?: BookingGuestUpdateManyWithoutBookingNestedInput
  }

  export type RentalBookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    babies?: IntFieldUpdateOperationsInput | number
    pets?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    discountPercent?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: StringFieldUpdateOperationsInput | string
    guestCountryCode?: StringFieldUpdateOperationsInput | string
    guestMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRentalBookingStatusFieldUpdateOperationsInput | $Enums.RentalBookingStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    wifiName?: NullableStringFieldUpdateOperationsInput | string | null
    wifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Status?: EnumTM30BookingStatusFieldUpdateOperationsInput | $Enums.TM30BookingStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Reference?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    passportsRequired?: IntFieldUpdateOperationsInput | number
    passportsReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: BookingMessageUncheckedUpdateManyWithoutBookingNestedInput
    guests?: BookingGuestUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type RentalBookingCreateManyInput = {
    id?: string
    propertyId: string
    userId: string
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    adults?: number
    children?: number
    babies?: number
    pets?: number
    basePrice: number
    season: string
    discountPercent: number
    totalPrice: number
    guestName: string
    guestEmail: string
    guestPhone: string
    guestCountryCode?: string
    guestMessage?: string | null
    status?: $Enums.RentalBookingStatus
    paymentStatus?: string | null
    cancellationPolicy?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    internalNotes?: string | null
    checkInTime?: string | null
    checkOutTime?: string | null
    propertyAddress?: string | null
    propertyInstructions?: string | null
    wifiName?: string | null
    wifiPassword?: string | null
    accessCode?: string | null
    emergencyContact?: string | null
    houseRules?: string | null
    confirmedAt?: Date | string | null
    agentId?: string | null
    tm30Status?: $Enums.TM30BookingStatus
    tm30SubmittedAt?: Date | string | null
    tm30Reference?: string | null
    tm30Error?: string | null
    passportsRequired?: number
    passportsReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RentalBookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    babies?: IntFieldUpdateOperationsInput | number
    pets?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    discountPercent?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: StringFieldUpdateOperationsInput | string
    guestCountryCode?: StringFieldUpdateOperationsInput | string
    guestMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRentalBookingStatusFieldUpdateOperationsInput | $Enums.RentalBookingStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    wifiName?: NullableStringFieldUpdateOperationsInput | string | null
    wifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Status?: EnumTM30BookingStatusFieldUpdateOperationsInput | $Enums.TM30BookingStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Reference?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    passportsRequired?: IntFieldUpdateOperationsInput | number
    passportsReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalBookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    babies?: IntFieldUpdateOperationsInput | number
    pets?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    discountPercent?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: StringFieldUpdateOperationsInput | string
    guestCountryCode?: StringFieldUpdateOperationsInput | string
    guestMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRentalBookingStatusFieldUpdateOperationsInput | $Enums.RentalBookingStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    wifiName?: NullableStringFieldUpdateOperationsInput | string | null
    wifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Status?: EnumTM30BookingStatusFieldUpdateOperationsInput | $Enums.TM30BookingStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Reference?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    passportsRequired?: IntFieldUpdateOperationsInput | number
    passportsReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingMessageCreateInput = {
    id?: string
    senderId: string
    senderRole?: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: RentalBookingCreateNestedOneWithoutMessagesInput
  }

  export type BookingMessageUncheckedCreateInput = {
    id?: string
    bookingId: string
    senderId: string
    senderRole?: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderRole?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: RentalBookingUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type BookingMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderRole?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingMessageCreateManyInput = {
    id?: string
    bookingId: string
    senderId: string
    senderRole?: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderRole?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderRole?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingGuestCreateInput = {
    id?: string
    guestType?: string
    guestNumber?: number
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    gender?: string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    passportIssueDate?: Date | string | null
    passportCountry?: string | null
    passportImageUrl?: string | null
    passportImagePath?: string | null
    ocrConfidence?: number | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: Date | string | null
    passportVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    tm30Status?: $Enums.TM30GuestStatus
    tm30SubmittedAt?: Date | string | null
    tm30Error?: string | null
    whatsappMessageId?: string | null
    whatsappReceivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: RentalBookingCreateNestedOneWithoutGuestsInput
  }

  export type BookingGuestUncheckedCreateInput = {
    id?: string
    bookingId: string
    guestType?: string
    guestNumber?: number
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    gender?: string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    passportIssueDate?: Date | string | null
    passportCountry?: string | null
    passportImageUrl?: string | null
    passportImagePath?: string | null
    ocrConfidence?: number | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: Date | string | null
    passportVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    tm30Status?: $Enums.TM30GuestStatus
    tm30SubmittedAt?: Date | string | null
    tm30Error?: string | null
    whatsappMessageId?: string | null
    whatsappReceivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingGuestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestType?: StringFieldUpdateOperationsInput | string
    guestNumber?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportIssueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportCountry?: NullableStringFieldUpdateOperationsInput | string | null
    passportImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passportImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    ocrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Status?: EnumTM30GuestStatusFieldUpdateOperationsInput | $Enums.TM30GuestStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: RentalBookingUpdateOneRequiredWithoutGuestsNestedInput
  }

  export type BookingGuestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    guestType?: StringFieldUpdateOperationsInput | string
    guestNumber?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportIssueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportCountry?: NullableStringFieldUpdateOperationsInput | string | null
    passportImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passportImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    ocrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Status?: EnumTM30GuestStatusFieldUpdateOperationsInput | $Enums.TM30GuestStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingGuestCreateManyInput = {
    id?: string
    bookingId: string
    guestType?: string
    guestNumber?: number
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    gender?: string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    passportIssueDate?: Date | string | null
    passportCountry?: string | null
    passportImageUrl?: string | null
    passportImagePath?: string | null
    ocrConfidence?: number | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: Date | string | null
    passportVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    tm30Status?: $Enums.TM30GuestStatus
    tm30SubmittedAt?: Date | string | null
    tm30Error?: string | null
    whatsappMessageId?: string | null
    whatsappReceivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingGuestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestType?: StringFieldUpdateOperationsInput | string
    guestNumber?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportIssueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportCountry?: NullableStringFieldUpdateOperationsInput | string | null
    passportImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passportImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    ocrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Status?: EnumTM30GuestStatusFieldUpdateOperationsInput | $Enums.TM30GuestStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingGuestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    guestType?: StringFieldUpdateOperationsInput | string
    guestNumber?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportIssueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportCountry?: NullableStringFieldUpdateOperationsInput | string | null
    passportImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passportImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    ocrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Status?: EnumTM30GuestStatusFieldUpdateOperationsInput | $Enums.TM30GuestStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyBlockedDateCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    blockedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutBlockedDatesInput
  }

  export type PropertyBlockedDateUncheckedCreateInput = {
    id?: string
    propertyId: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    blockedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyBlockedDateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    blockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutBlockedDatesNestedInput
  }

  export type PropertyBlockedDateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    blockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyBlockedDateCreateManyInput = {
    id?: string
    propertyId: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    blockedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyBlockedDateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    blockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyBlockedDateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    blockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Tm30AccommodationCreateInput = {
    id?: string
    tm30Id: string
    name: string
    address: string
    status?: string | null
    matchScore?: number | null
    matchedBy?: string | null
    matchedAt?: Date | string | null
    lastSyncedAt?: Date | string | null
    syncSource?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    property?: PropertyCreateNestedOneWithoutTm30AccommodationInput
  }

  export type Tm30AccommodationUncheckedCreateInput = {
    id?: string
    tm30Id: string
    name: string
    address: string
    status?: string | null
    propertyId?: string | null
    matchScore?: number | null
    matchedBy?: string | null
    matchedAt?: Date | string | null
    lastSyncedAt?: Date | string | null
    syncSource?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type Tm30AccommodationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tm30Id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    matchScore?: NullableFloatFieldUpdateOperationsInput | number | null
    matchedBy?: NullableStringFieldUpdateOperationsInput | string | null
    matchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    property?: PropertyUpdateOneWithoutTm30AccommodationNestedInput
  }

  export type Tm30AccommodationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tm30Id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    matchScore?: NullableFloatFieldUpdateOperationsInput | number | null
    matchedBy?: NullableStringFieldUpdateOperationsInput | string | null
    matchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Tm30AccommodationCreateManyInput = {
    id?: string
    tm30Id: string
    name: string
    address: string
    status?: string | null
    propertyId?: string | null
    matchScore?: number | null
    matchedBy?: string | null
    matchedAt?: Date | string | null
    lastSyncedAt?: Date | string | null
    syncSource?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type Tm30AccommodationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tm30Id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    matchScore?: NullableFloatFieldUpdateOperationsInput | number | null
    matchedBy?: NullableStringFieldUpdateOperationsInput | string | null
    matchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Tm30AccommodationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tm30Id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    matchScore?: NullableFloatFieldUpdateOperationsInput | number | null
    matchedBy?: NullableStringFieldUpdateOperationsInput | string | null
    matchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Tm30AccommodationRequestCreateInput = {
    id?: string
    ownerSameAsRegistrant?: boolean
    ownerNationalType?: string
    ownerNationalId?: string | null
    ownerPassportNumber?: string | null
    ownerFirstName: string
    ownerMiddleName?: string | null
    ownerLastName: string
    ownerTelephone: string
    ownerGender?: string | null
    entityType?: string
    houseIdNumber?: string | null
    accommodationType: string
    accommodationName: string
    position?: string | null
    positionOther?: string | null
    addressNumber: string
    villageNumber?: string | null
    alley?: string | null
    road?: string | null
    province: string
    district: string
    subDistrict: string
    postalCode: string
    latitude?: number | null
    longitude?: number | null
    houseRegistrationUrl?: string | null
    houseRegistrationPath?: string | null
    ocrProcessed?: boolean
    ocrProcessedAt?: Date | string | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrConfidence?: number | null
    status?: $Enums.Tm30AccomRequestStatus
    tm30Id?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    errorMessage?: string | null
    propertyId?: string | null
    whatsappPhone?: string | null
    whatsappSessionId?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    propertyOwner?: PropertyOwnerCreateNestedOneWithoutTm30RequestsInput
  }

  export type Tm30AccommodationRequestUncheckedCreateInput = {
    id?: string
    ownerSameAsRegistrant?: boolean
    ownerNationalType?: string
    ownerNationalId?: string | null
    ownerPassportNumber?: string | null
    ownerFirstName: string
    ownerMiddleName?: string | null
    ownerLastName: string
    ownerTelephone: string
    ownerGender?: string | null
    entityType?: string
    houseIdNumber?: string | null
    accommodationType: string
    accommodationName: string
    position?: string | null
    positionOther?: string | null
    addressNumber: string
    villageNumber?: string | null
    alley?: string | null
    road?: string | null
    province: string
    district: string
    subDistrict: string
    postalCode: string
    latitude?: number | null
    longitude?: number | null
    houseRegistrationUrl?: string | null
    houseRegistrationPath?: string | null
    ocrProcessed?: boolean
    ocrProcessedAt?: Date | string | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrConfidence?: number | null
    status?: $Enums.Tm30AccomRequestStatus
    tm30Id?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    errorMessage?: string | null
    propertyId?: string | null
    propertyOwnerId?: string | null
    whatsappPhone?: string | null
    whatsappSessionId?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Tm30AccommodationRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerSameAsRegistrant?: BoolFieldUpdateOperationsInput | boolean
    ownerNationalType?: StringFieldUpdateOperationsInput | string
    ownerNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPassportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ownerFirstName?: StringFieldUpdateOperationsInput | string
    ownerMiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerLastName?: StringFieldUpdateOperationsInput | string
    ownerTelephone?: StringFieldUpdateOperationsInput | string
    ownerGender?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    houseIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationType?: StringFieldUpdateOperationsInput | string
    accommodationName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    positionOther?: NullableStringFieldUpdateOperationsInput | string | null
    addressNumber?: StringFieldUpdateOperationsInput | string
    villageNumber?: NullableStringFieldUpdateOperationsInput | string | null
    alley?: NullableStringFieldUpdateOperationsInput | string | null
    road?: NullableStringFieldUpdateOperationsInput | string | null
    province?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    subDistrict?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    houseRegistrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    houseRegistrationPath?: NullableStringFieldUpdateOperationsInput | string | null
    ocrProcessed?: BoolFieldUpdateOperationsInput | boolean
    ocrProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumTm30AccomRequestStatusFieldUpdateOperationsInput | $Enums.Tm30AccomRequestStatus
    tm30Id?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propertyOwner?: PropertyOwnerUpdateOneWithoutTm30RequestsNestedInput
  }

  export type Tm30AccommodationRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerSameAsRegistrant?: BoolFieldUpdateOperationsInput | boolean
    ownerNationalType?: StringFieldUpdateOperationsInput | string
    ownerNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPassportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ownerFirstName?: StringFieldUpdateOperationsInput | string
    ownerMiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerLastName?: StringFieldUpdateOperationsInput | string
    ownerTelephone?: StringFieldUpdateOperationsInput | string
    ownerGender?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    houseIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationType?: StringFieldUpdateOperationsInput | string
    accommodationName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    positionOther?: NullableStringFieldUpdateOperationsInput | string | null
    addressNumber?: StringFieldUpdateOperationsInput | string
    villageNumber?: NullableStringFieldUpdateOperationsInput | string | null
    alley?: NullableStringFieldUpdateOperationsInput | string | null
    road?: NullableStringFieldUpdateOperationsInput | string | null
    province?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    subDistrict?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    houseRegistrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    houseRegistrationPath?: NullableStringFieldUpdateOperationsInput | string | null
    ocrProcessed?: BoolFieldUpdateOperationsInput | boolean
    ocrProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumTm30AccomRequestStatusFieldUpdateOperationsInput | $Enums.Tm30AccomRequestStatus
    tm30Id?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Tm30AccommodationRequestCreateManyInput = {
    id?: string
    ownerSameAsRegistrant?: boolean
    ownerNationalType?: string
    ownerNationalId?: string | null
    ownerPassportNumber?: string | null
    ownerFirstName: string
    ownerMiddleName?: string | null
    ownerLastName: string
    ownerTelephone: string
    ownerGender?: string | null
    entityType?: string
    houseIdNumber?: string | null
    accommodationType: string
    accommodationName: string
    position?: string | null
    positionOther?: string | null
    addressNumber: string
    villageNumber?: string | null
    alley?: string | null
    road?: string | null
    province: string
    district: string
    subDistrict: string
    postalCode: string
    latitude?: number | null
    longitude?: number | null
    houseRegistrationUrl?: string | null
    houseRegistrationPath?: string | null
    ocrProcessed?: boolean
    ocrProcessedAt?: Date | string | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrConfidence?: number | null
    status?: $Enums.Tm30AccomRequestStatus
    tm30Id?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    errorMessage?: string | null
    propertyId?: string | null
    propertyOwnerId?: string | null
    whatsappPhone?: string | null
    whatsappSessionId?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Tm30AccommodationRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerSameAsRegistrant?: BoolFieldUpdateOperationsInput | boolean
    ownerNationalType?: StringFieldUpdateOperationsInput | string
    ownerNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPassportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ownerFirstName?: StringFieldUpdateOperationsInput | string
    ownerMiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerLastName?: StringFieldUpdateOperationsInput | string
    ownerTelephone?: StringFieldUpdateOperationsInput | string
    ownerGender?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    houseIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationType?: StringFieldUpdateOperationsInput | string
    accommodationName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    positionOther?: NullableStringFieldUpdateOperationsInput | string | null
    addressNumber?: StringFieldUpdateOperationsInput | string
    villageNumber?: NullableStringFieldUpdateOperationsInput | string | null
    alley?: NullableStringFieldUpdateOperationsInput | string | null
    road?: NullableStringFieldUpdateOperationsInput | string | null
    province?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    subDistrict?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    houseRegistrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    houseRegistrationPath?: NullableStringFieldUpdateOperationsInput | string | null
    ocrProcessed?: BoolFieldUpdateOperationsInput | boolean
    ocrProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumTm30AccomRequestStatusFieldUpdateOperationsInput | $Enums.Tm30AccomRequestStatus
    tm30Id?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Tm30AccommodationRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerSameAsRegistrant?: BoolFieldUpdateOperationsInput | boolean
    ownerNationalType?: StringFieldUpdateOperationsInput | string
    ownerNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPassportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ownerFirstName?: StringFieldUpdateOperationsInput | string
    ownerMiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerLastName?: StringFieldUpdateOperationsInput | string
    ownerTelephone?: StringFieldUpdateOperationsInput | string
    ownerGender?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    houseIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationType?: StringFieldUpdateOperationsInput | string
    accommodationName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    positionOther?: NullableStringFieldUpdateOperationsInput | string | null
    addressNumber?: StringFieldUpdateOperationsInput | string
    villageNumber?: NullableStringFieldUpdateOperationsInput | string | null
    alley?: NullableStringFieldUpdateOperationsInput | string | null
    road?: NullableStringFieldUpdateOperationsInput | string | null
    province?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    subDistrict?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    houseRegistrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    houseRegistrationPath?: NullableStringFieldUpdateOperationsInput | string | null
    ocrProcessed?: BoolFieldUpdateOperationsInput | boolean
    ocrProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumTm30AccomRequestStatusFieldUpdateOperationsInput | $Enums.Tm30AccomRequestStatus
    tm30Id?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyOwnerCreateInput = {
    id?: string
    firstName: string
    lastName: string
    thaiIdNumber?: string | null
    phone: string
    email?: string | null
    gender?: string | null
    idCardUrl?: string | null
    idCardPath?: string | null
    idCardOcrData?: NullableJsonNullValueInput | InputJsonValue
    idCardVerified?: boolean
    idCardUploadedAt?: Date | string | null
    isActive?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: OwnerDocumentCreateNestedManyWithoutOwnerInput
    properties?: PropertyCreateNestedManyWithoutPropertyOwnerInput
    tm30Requests?: Tm30AccommodationRequestCreateNestedManyWithoutPropertyOwnerInput
  }

  export type PropertyOwnerUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    thaiIdNumber?: string | null
    phone: string
    email?: string | null
    gender?: string | null
    idCardUrl?: string | null
    idCardPath?: string | null
    idCardOcrData?: NullableJsonNullValueInput | InputJsonValue
    idCardVerified?: boolean
    idCardUploadedAt?: Date | string | null
    isActive?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: OwnerDocumentUncheckedCreateNestedManyWithoutOwnerInput
    properties?: PropertyUncheckedCreateNestedManyWithoutPropertyOwnerInput
    tm30Requests?: Tm30AccommodationRequestUncheckedCreateNestedManyWithoutPropertyOwnerInput
  }

  export type PropertyOwnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    idCardUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idCardPath?: NullableStringFieldUpdateOperationsInput | string | null
    idCardOcrData?: NullableJsonNullValueInput | InputJsonValue
    idCardVerified?: BoolFieldUpdateOperationsInput | boolean
    idCardUploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: OwnerDocumentUpdateManyWithoutOwnerNestedInput
    properties?: PropertyUpdateManyWithoutPropertyOwnerNestedInput
    tm30Requests?: Tm30AccommodationRequestUpdateManyWithoutPropertyOwnerNestedInput
  }

  export type PropertyOwnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    idCardUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idCardPath?: NullableStringFieldUpdateOperationsInput | string | null
    idCardOcrData?: NullableJsonNullValueInput | InputJsonValue
    idCardVerified?: BoolFieldUpdateOperationsInput | boolean
    idCardUploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: OwnerDocumentUncheckedUpdateManyWithoutOwnerNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutPropertyOwnerNestedInput
    tm30Requests?: Tm30AccommodationRequestUncheckedUpdateManyWithoutPropertyOwnerNestedInput
  }

  export type PropertyOwnerCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    thaiIdNumber?: string | null
    phone: string
    email?: string | null
    gender?: string | null
    idCardUrl?: string | null
    idCardPath?: string | null
    idCardOcrData?: NullableJsonNullValueInput | InputJsonValue
    idCardVerified?: boolean
    idCardUploadedAt?: Date | string | null
    isActive?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyOwnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    idCardUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idCardPath?: NullableStringFieldUpdateOperationsInput | string | null
    idCardOcrData?: NullableJsonNullValueInput | InputJsonValue
    idCardVerified?: BoolFieldUpdateOperationsInput | boolean
    idCardUploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyOwnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    idCardUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idCardPath?: NullableStringFieldUpdateOperationsInput | string | null
    idCardOcrData?: NullableJsonNullValueInput | InputJsonValue
    idCardVerified?: BoolFieldUpdateOperationsInput | boolean
    idCardUploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerDocumentCreateInput = {
    id?: string
    documentType: $Enums.OwnerDocumentType
    imageUrl: string
    imagePath: string
    fileName?: string | null
    ocrData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: Date | string | null
    ocrConfidence?: number | null
    propertyId?: string | null
    houseId?: string | null
    extractedAddress?: string | null
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: PropertyOwnerCreateNestedOneWithoutDocumentsInput
  }

  export type OwnerDocumentUncheckedCreateInput = {
    id?: string
    ownerId: string
    documentType: $Enums.OwnerDocumentType
    imageUrl: string
    imagePath: string
    fileName?: string | null
    ocrData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: Date | string | null
    ocrConfidence?: number | null
    propertyId?: string | null
    houseId?: string | null
    extractedAddress?: string | null
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OwnerDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumOwnerDocumentTypeFieldUpdateOperationsInput | $Enums.OwnerDocumentType
    imageUrl?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    ocrData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ocrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    houseId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: PropertyOwnerUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type OwnerDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumOwnerDocumentTypeFieldUpdateOperationsInput | $Enums.OwnerDocumentType
    imageUrl?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    ocrData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ocrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    houseId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerDocumentCreateManyInput = {
    id?: string
    ownerId: string
    documentType: $Enums.OwnerDocumentType
    imageUrl: string
    imagePath: string
    fileName?: string | null
    ocrData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: Date | string | null
    ocrConfidence?: number | null
    propertyId?: string | null
    houseId?: string | null
    extractedAddress?: string | null
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OwnerDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumOwnerDocumentTypeFieldUpdateOperationsInput | $Enums.OwnerDocumentType
    imageUrl?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    ocrData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ocrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    houseId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumOwnerDocumentTypeFieldUpdateOperationsInput | $Enums.OwnerDocumentType
    imageUrl?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    ocrData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ocrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    houseId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsappListingSessionCreateInput = {
    id?: string
    phone: string
    status?: string
    currentAction?: string | null
    ownerId?: string | null
    currentPropertyId?: string | null
    tm30RequestId?: string | null
    tm30OwnerFirstName?: string | null
    tm30OwnerLastName?: string | null
    tm30OwnerGender?: string | null
    tm30OwnerPhone?: string | null
    tm30ThaiIdNumber?: string | null
    tm30IdCardUrl?: string | null
    tm30BluebookUrl?: string | null
    tm30HouseId?: string | null
    tm30Province?: string | null
    tm30District?: string | null
    tm30SubDistrict?: string | null
    tm30AddressNumber?: string | null
    tm30PostalCode?: string | null
    tm30AccommodationName?: string | null
    pendingData?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsappListingSessionUncheckedCreateInput = {
    id?: string
    phone: string
    status?: string
    currentAction?: string | null
    ownerId?: string | null
    currentPropertyId?: string | null
    tm30RequestId?: string | null
    tm30OwnerFirstName?: string | null
    tm30OwnerLastName?: string | null
    tm30OwnerGender?: string | null
    tm30OwnerPhone?: string | null
    tm30ThaiIdNumber?: string | null
    tm30IdCardUrl?: string | null
    tm30BluebookUrl?: string | null
    tm30HouseId?: string | null
    tm30Province?: string | null
    tm30District?: string | null
    tm30SubDistrict?: string | null
    tm30AddressNumber?: string | null
    tm30PostalCode?: string | null
    tm30AccommodationName?: string | null
    pendingData?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsappListingSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentAction?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30RequestId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30OwnerFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tm30OwnerLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tm30OwnerGender?: NullableStringFieldUpdateOperationsInput | string | null
    tm30OwnerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tm30ThaiIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tm30IdCardUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tm30BluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tm30HouseId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Province?: NullableStringFieldUpdateOperationsInput | string | null
    tm30District?: NullableStringFieldUpdateOperationsInput | string | null
    tm30SubDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AddressNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tm30PostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    pendingData?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsappListingSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentAction?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30RequestId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30OwnerFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tm30OwnerLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tm30OwnerGender?: NullableStringFieldUpdateOperationsInput | string | null
    tm30OwnerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tm30ThaiIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tm30IdCardUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tm30BluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tm30HouseId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Province?: NullableStringFieldUpdateOperationsInput | string | null
    tm30District?: NullableStringFieldUpdateOperationsInput | string | null
    tm30SubDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AddressNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tm30PostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    pendingData?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsappListingSessionCreateManyInput = {
    id?: string
    phone: string
    status?: string
    currentAction?: string | null
    ownerId?: string | null
    currentPropertyId?: string | null
    tm30RequestId?: string | null
    tm30OwnerFirstName?: string | null
    tm30OwnerLastName?: string | null
    tm30OwnerGender?: string | null
    tm30OwnerPhone?: string | null
    tm30ThaiIdNumber?: string | null
    tm30IdCardUrl?: string | null
    tm30BluebookUrl?: string | null
    tm30HouseId?: string | null
    tm30Province?: string | null
    tm30District?: string | null
    tm30SubDistrict?: string | null
    tm30AddressNumber?: string | null
    tm30PostalCode?: string | null
    tm30AccommodationName?: string | null
    pendingData?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsappListingSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentAction?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30RequestId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30OwnerFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tm30OwnerLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tm30OwnerGender?: NullableStringFieldUpdateOperationsInput | string | null
    tm30OwnerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tm30ThaiIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tm30IdCardUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tm30BluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tm30HouseId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Province?: NullableStringFieldUpdateOperationsInput | string | null
    tm30District?: NullableStringFieldUpdateOperationsInput | string | null
    tm30SubDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AddressNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tm30PostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    pendingData?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsappListingSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    currentAction?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPropertyId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30RequestId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30OwnerFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tm30OwnerLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tm30OwnerGender?: NullableStringFieldUpdateOperationsInput | string | null
    tm30OwnerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tm30ThaiIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tm30IdCardUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tm30BluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tm30HouseId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Province?: NullableStringFieldUpdateOperationsInput | string | null
    tm30District?: NullableStringFieldUpdateOperationsInput | string | null
    tm30SubDistrict?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AddressNumber?: NullableStringFieldUpdateOperationsInput | string | null
    tm30PostalCode?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    pendingData?: NullableJsonNullValueInput | InputJsonValue
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAgentConfigCreateInput = {
    id?: string
    enabled?: boolean
    autonomousMode?: boolean
    minConfidenceThreshold?: number
    dailyDecisionLimit?: number
    dailyAutoExecuteLimit?: number
    notifyOnDecision?: boolean
    notifyOnAutoExecute?: boolean
    notifyEmail?: string | null
    allowedAutonomousTypes?: string
    forbiddenPatterns?: string
    learningEnabled?: boolean
    feedbackLoopDays?: number
    killSwitch?: boolean
    pausedUntil?: Date | string | null
    pauseReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIAgentConfigUncheckedCreateInput = {
    id?: string
    enabled?: boolean
    autonomousMode?: boolean
    minConfidenceThreshold?: number
    dailyDecisionLimit?: number
    dailyAutoExecuteLimit?: number
    notifyOnDecision?: boolean
    notifyOnAutoExecute?: boolean
    notifyEmail?: string | null
    allowedAutonomousTypes?: string
    forbiddenPatterns?: string
    learningEnabled?: boolean
    feedbackLoopDays?: number
    killSwitch?: boolean
    pausedUntil?: Date | string | null
    pauseReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIAgentConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    autonomousMode?: BoolFieldUpdateOperationsInput | boolean
    minConfidenceThreshold?: FloatFieldUpdateOperationsInput | number
    dailyDecisionLimit?: IntFieldUpdateOperationsInput | number
    dailyAutoExecuteLimit?: IntFieldUpdateOperationsInput | number
    notifyOnDecision?: BoolFieldUpdateOperationsInput | boolean
    notifyOnAutoExecute?: BoolFieldUpdateOperationsInput | boolean
    notifyEmail?: NullableStringFieldUpdateOperationsInput | string | null
    allowedAutonomousTypes?: StringFieldUpdateOperationsInput | string
    forbiddenPatterns?: StringFieldUpdateOperationsInput | string
    learningEnabled?: BoolFieldUpdateOperationsInput | boolean
    feedbackLoopDays?: IntFieldUpdateOperationsInput | number
    killSwitch?: BoolFieldUpdateOperationsInput | boolean
    pausedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAgentConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    autonomousMode?: BoolFieldUpdateOperationsInput | boolean
    minConfidenceThreshold?: FloatFieldUpdateOperationsInput | number
    dailyDecisionLimit?: IntFieldUpdateOperationsInput | number
    dailyAutoExecuteLimit?: IntFieldUpdateOperationsInput | number
    notifyOnDecision?: BoolFieldUpdateOperationsInput | boolean
    notifyOnAutoExecute?: BoolFieldUpdateOperationsInput | boolean
    notifyEmail?: NullableStringFieldUpdateOperationsInput | string | null
    allowedAutonomousTypes?: StringFieldUpdateOperationsInput | string
    forbiddenPatterns?: StringFieldUpdateOperationsInput | string
    learningEnabled?: BoolFieldUpdateOperationsInput | boolean
    feedbackLoopDays?: IntFieldUpdateOperationsInput | number
    killSwitch?: BoolFieldUpdateOperationsInput | boolean
    pausedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAgentConfigCreateManyInput = {
    id?: string
    enabled?: boolean
    autonomousMode?: boolean
    minConfidenceThreshold?: number
    dailyDecisionLimit?: number
    dailyAutoExecuteLimit?: number
    notifyOnDecision?: boolean
    notifyOnAutoExecute?: boolean
    notifyEmail?: string | null
    allowedAutonomousTypes?: string
    forbiddenPatterns?: string
    learningEnabled?: boolean
    feedbackLoopDays?: number
    killSwitch?: boolean
    pausedUntil?: Date | string | null
    pauseReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIAgentConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    autonomousMode?: BoolFieldUpdateOperationsInput | boolean
    minConfidenceThreshold?: FloatFieldUpdateOperationsInput | number
    dailyDecisionLimit?: IntFieldUpdateOperationsInput | number
    dailyAutoExecuteLimit?: IntFieldUpdateOperationsInput | number
    notifyOnDecision?: BoolFieldUpdateOperationsInput | boolean
    notifyOnAutoExecute?: BoolFieldUpdateOperationsInput | boolean
    notifyEmail?: NullableStringFieldUpdateOperationsInput | string | null
    allowedAutonomousTypes?: StringFieldUpdateOperationsInput | string
    forbiddenPatterns?: StringFieldUpdateOperationsInput | string
    learningEnabled?: BoolFieldUpdateOperationsInput | boolean
    feedbackLoopDays?: IntFieldUpdateOperationsInput | number
    killSwitch?: BoolFieldUpdateOperationsInput | boolean
    pausedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAgentConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    autonomousMode?: BoolFieldUpdateOperationsInput | boolean
    minConfidenceThreshold?: FloatFieldUpdateOperationsInput | number
    dailyDecisionLimit?: IntFieldUpdateOperationsInput | number
    dailyAutoExecuteLimit?: IntFieldUpdateOperationsInput | number
    notifyOnDecision?: BoolFieldUpdateOperationsInput | boolean
    notifyOnAutoExecute?: BoolFieldUpdateOperationsInput | boolean
    notifyEmail?: NullableStringFieldUpdateOperationsInput | string | null
    allowedAutonomousTypes?: StringFieldUpdateOperationsInput | string
    forbiddenPatterns?: StringFieldUpdateOperationsInput | string
    learningEnabled?: BoolFieldUpdateOperationsInput | boolean
    feedbackLoopDays?: IntFieldUpdateOperationsInput | number
    killSwitch?: BoolFieldUpdateOperationsInput | boolean
    pausedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIDecisionCreateInput = {
    id?: string
    type: string
    subType?: string | null
    priority: string
    confidence: number
    reasoning: string
    dataSnapshot?: NullableJsonNullValueInput | InputJsonValue
    actionType: string
    actionPayload: JsonNullValueInput | InputJsonValue
    estimatedImpact?: string | null
    rollbackPlan?: string | null
    requiresApproval?: boolean
    autoApproved?: boolean
    status?: $Enums.AIDecisionStatus
    approvedBy?: string | null
    approvedByName?: string | null
    approvedAt?: Date | string | null
    rejectedBy?: string | null
    rejectedByName?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    executedAt?: Date | string | null
    executionResult?: NullableJsonNullValueInput | InputJsonValue
    executionError?: string | null
    executionDuration?: number | null
    rolledBackAt?: Date | string | null
    rolledBackBy?: string | null
    rollbackReason?: string | null
    feedbackDueAt?: Date | string | null
    actualImpact?: NullableJsonNullValueInput | InputJsonValue
    wasSuccessful?: boolean | null
    successScore?: number | null
    feedbackNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    codeChanges?: AICodeChangeCreateNestedManyWithoutDecisionInput
    logs?: AIAgentLogCreateNestedManyWithoutDecisionInput
  }

  export type AIDecisionUncheckedCreateInput = {
    id?: string
    type: string
    subType?: string | null
    priority: string
    confidence: number
    reasoning: string
    dataSnapshot?: NullableJsonNullValueInput | InputJsonValue
    actionType: string
    actionPayload: JsonNullValueInput | InputJsonValue
    estimatedImpact?: string | null
    rollbackPlan?: string | null
    requiresApproval?: boolean
    autoApproved?: boolean
    status?: $Enums.AIDecisionStatus
    approvedBy?: string | null
    approvedByName?: string | null
    approvedAt?: Date | string | null
    rejectedBy?: string | null
    rejectedByName?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    executedAt?: Date | string | null
    executionResult?: NullableJsonNullValueInput | InputJsonValue
    executionError?: string | null
    executionDuration?: number | null
    rolledBackAt?: Date | string | null
    rolledBackBy?: string | null
    rollbackReason?: string | null
    feedbackDueAt?: Date | string | null
    actualImpact?: NullableJsonNullValueInput | InputJsonValue
    wasSuccessful?: boolean | null
    successScore?: number | null
    feedbackNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    codeChanges?: AICodeChangeUncheckedCreateNestedManyWithoutDecisionInput
    logs?: AIAgentLogUncheckedCreateNestedManyWithoutDecisionInput
  }

  export type AIDecisionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    reasoning?: StringFieldUpdateOperationsInput | string
    dataSnapshot?: NullableJsonNullValueInput | InputJsonValue
    actionType?: StringFieldUpdateOperationsInput | string
    actionPayload?: JsonNullValueInput | InputJsonValue
    estimatedImpact?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackPlan?: NullableStringFieldUpdateOperationsInput | string | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    autoApproved?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAIDecisionStatusFieldUpdateOperationsInput | $Enums.AIDecisionStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByName?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedByName?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionResult?: NullableJsonNullValueInput | InputJsonValue
    executionError?: NullableStringFieldUpdateOperationsInput | string | null
    executionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    rolledBackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rolledBackBy?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackReason?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpact?: NullableJsonNullValueInput | InputJsonValue
    wasSuccessful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    successScore?: NullableFloatFieldUpdateOperationsInput | number | null
    feedbackNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codeChanges?: AICodeChangeUpdateManyWithoutDecisionNestedInput
    logs?: AIAgentLogUpdateManyWithoutDecisionNestedInput
  }

  export type AIDecisionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    reasoning?: StringFieldUpdateOperationsInput | string
    dataSnapshot?: NullableJsonNullValueInput | InputJsonValue
    actionType?: StringFieldUpdateOperationsInput | string
    actionPayload?: JsonNullValueInput | InputJsonValue
    estimatedImpact?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackPlan?: NullableStringFieldUpdateOperationsInput | string | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    autoApproved?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAIDecisionStatusFieldUpdateOperationsInput | $Enums.AIDecisionStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByName?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedByName?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionResult?: NullableJsonNullValueInput | InputJsonValue
    executionError?: NullableStringFieldUpdateOperationsInput | string | null
    executionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    rolledBackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rolledBackBy?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackReason?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpact?: NullableJsonNullValueInput | InputJsonValue
    wasSuccessful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    successScore?: NullableFloatFieldUpdateOperationsInput | number | null
    feedbackNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codeChanges?: AICodeChangeUncheckedUpdateManyWithoutDecisionNestedInput
    logs?: AIAgentLogUncheckedUpdateManyWithoutDecisionNestedInput
  }

  export type AIDecisionCreateManyInput = {
    id?: string
    type: string
    subType?: string | null
    priority: string
    confidence: number
    reasoning: string
    dataSnapshot?: NullableJsonNullValueInput | InputJsonValue
    actionType: string
    actionPayload: JsonNullValueInput | InputJsonValue
    estimatedImpact?: string | null
    rollbackPlan?: string | null
    requiresApproval?: boolean
    autoApproved?: boolean
    status?: $Enums.AIDecisionStatus
    approvedBy?: string | null
    approvedByName?: string | null
    approvedAt?: Date | string | null
    rejectedBy?: string | null
    rejectedByName?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    executedAt?: Date | string | null
    executionResult?: NullableJsonNullValueInput | InputJsonValue
    executionError?: string | null
    executionDuration?: number | null
    rolledBackAt?: Date | string | null
    rolledBackBy?: string | null
    rollbackReason?: string | null
    feedbackDueAt?: Date | string | null
    actualImpact?: NullableJsonNullValueInput | InputJsonValue
    wasSuccessful?: boolean | null
    successScore?: number | null
    feedbackNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIDecisionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    reasoning?: StringFieldUpdateOperationsInput | string
    dataSnapshot?: NullableJsonNullValueInput | InputJsonValue
    actionType?: StringFieldUpdateOperationsInput | string
    actionPayload?: JsonNullValueInput | InputJsonValue
    estimatedImpact?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackPlan?: NullableStringFieldUpdateOperationsInput | string | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    autoApproved?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAIDecisionStatusFieldUpdateOperationsInput | $Enums.AIDecisionStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByName?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedByName?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionResult?: NullableJsonNullValueInput | InputJsonValue
    executionError?: NullableStringFieldUpdateOperationsInput | string | null
    executionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    rolledBackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rolledBackBy?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackReason?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpact?: NullableJsonNullValueInput | InputJsonValue
    wasSuccessful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    successScore?: NullableFloatFieldUpdateOperationsInput | number | null
    feedbackNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIDecisionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    reasoning?: StringFieldUpdateOperationsInput | string
    dataSnapshot?: NullableJsonNullValueInput | InputJsonValue
    actionType?: StringFieldUpdateOperationsInput | string
    actionPayload?: JsonNullValueInput | InputJsonValue
    estimatedImpact?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackPlan?: NullableStringFieldUpdateOperationsInput | string | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    autoApproved?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAIDecisionStatusFieldUpdateOperationsInput | $Enums.AIDecisionStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByName?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedByName?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionResult?: NullableJsonNullValueInput | InputJsonValue
    executionError?: NullableStringFieldUpdateOperationsInput | string | null
    executionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    rolledBackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rolledBackBy?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackReason?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpact?: NullableJsonNullValueInput | InputJsonValue
    wasSuccessful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    successScore?: NullableFloatFieldUpdateOperationsInput | number | null
    feedbackNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AICodeChangeCreateInput = {
    id?: string
    filePath: string
    action: $Enums.AICodeAction
    originalContent?: string | null
    newContent?: string | null
    diff?: string | null
    syntaxValid?: boolean
    typesValid?: boolean
    lintPassed?: boolean
    testsPassed?: boolean | null
    appliedAt?: Date | string | null
    rolledBackAt?: Date | string | null
    createdAt?: Date | string
    decision: AIDecisionCreateNestedOneWithoutCodeChangesInput
  }

  export type AICodeChangeUncheckedCreateInput = {
    id?: string
    decisionId: string
    filePath: string
    action: $Enums.AICodeAction
    originalContent?: string | null
    newContent?: string | null
    diff?: string | null
    syntaxValid?: boolean
    typesValid?: boolean
    lintPassed?: boolean
    testsPassed?: boolean | null
    appliedAt?: Date | string | null
    rolledBackAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AICodeChangeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    action?: EnumAICodeActionFieldUpdateOperationsInput | $Enums.AICodeAction
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    newContent?: NullableStringFieldUpdateOperationsInput | string | null
    diff?: NullableStringFieldUpdateOperationsInput | string | null
    syntaxValid?: BoolFieldUpdateOperationsInput | boolean
    typesValid?: BoolFieldUpdateOperationsInput | boolean
    lintPassed?: BoolFieldUpdateOperationsInput | boolean
    testsPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rolledBackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decision?: AIDecisionUpdateOneRequiredWithoutCodeChangesNestedInput
  }

  export type AICodeChangeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    decisionId?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    action?: EnumAICodeActionFieldUpdateOperationsInput | $Enums.AICodeAction
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    newContent?: NullableStringFieldUpdateOperationsInput | string | null
    diff?: NullableStringFieldUpdateOperationsInput | string | null
    syntaxValid?: BoolFieldUpdateOperationsInput | boolean
    typesValid?: BoolFieldUpdateOperationsInput | boolean
    lintPassed?: BoolFieldUpdateOperationsInput | boolean
    testsPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rolledBackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AICodeChangeCreateManyInput = {
    id?: string
    decisionId: string
    filePath: string
    action: $Enums.AICodeAction
    originalContent?: string | null
    newContent?: string | null
    diff?: string | null
    syntaxValid?: boolean
    typesValid?: boolean
    lintPassed?: boolean
    testsPassed?: boolean | null
    appliedAt?: Date | string | null
    rolledBackAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AICodeChangeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    action?: EnumAICodeActionFieldUpdateOperationsInput | $Enums.AICodeAction
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    newContent?: NullableStringFieldUpdateOperationsInput | string | null
    diff?: NullableStringFieldUpdateOperationsInput | string | null
    syntaxValid?: BoolFieldUpdateOperationsInput | boolean
    typesValid?: BoolFieldUpdateOperationsInput | boolean
    lintPassed?: BoolFieldUpdateOperationsInput | boolean
    testsPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rolledBackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AICodeChangeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    decisionId?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    action?: EnumAICodeActionFieldUpdateOperationsInput | $Enums.AICodeAction
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    newContent?: NullableStringFieldUpdateOperationsInput | string | null
    diff?: NullableStringFieldUpdateOperationsInput | string | null
    syntaxValid?: BoolFieldUpdateOperationsInput | boolean
    typesValid?: BoolFieldUpdateOperationsInput | boolean
    lintPassed?: BoolFieldUpdateOperationsInput | boolean
    testsPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rolledBackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAgentLogCreateInput = {
    id?: string
    level?: $Enums.AILogLevel
    category: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    errorCode?: string | null
    errorStack?: string | null
    durationMs?: number | null
    createdAt?: Date | string
    decision?: AIDecisionCreateNestedOneWithoutLogsInput
  }

  export type AIAgentLogUncheckedCreateInput = {
    id?: string
    level?: $Enums.AILogLevel
    category: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    decisionId?: string | null
    errorCode?: string | null
    errorStack?: string | null
    durationMs?: number | null
    createdAt?: Date | string
  }

  export type AIAgentLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumAILogLevelFieldUpdateOperationsInput | $Enums.AILogLevel
    category?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decision?: AIDecisionUpdateOneWithoutLogsNestedInput
  }

  export type AIAgentLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumAILogLevelFieldUpdateOperationsInput | $Enums.AILogLevel
    category?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    decisionId?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAgentLogCreateManyInput = {
    id?: string
    level?: $Enums.AILogLevel
    category: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    decisionId?: string | null
    errorCode?: string | null
    errorStack?: string | null
    durationMs?: number | null
    createdAt?: Date | string
  }

  export type AIAgentLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumAILogLevelFieldUpdateOperationsInput | $Enums.AILogLevel
    category?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAgentLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumAILogLevelFieldUpdateOperationsInput | $Enums.AILogLevel
    category?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    decisionId?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIDataSnapshotCreateInput = {
    id?: string
    snapshotType: string
    totalViews?: number
    uniqueVisitors?: number
    bounceRate?: number | null
    avgSessionDuration?: number | null
    totalInquiries?: number
    viewingRequests?: number
    investorLeads?: number
    rentalLeads?: number
    conversionRate?: number | null
    totalProperties?: number
    activeListings?: number
    newListings?: number
    avgPropertyViews?: number | null
    totalBlogs?: number
    publishedBlogs?: number
    avgBlogViews?: number | null
    organicTraffic?: number | null
    topKeywords?: NullableJsonNullValueInput | InputJsonValue
    avgPosition?: number | null
    estimatedLeadValue?: number | null
    errorCount?: number
    slowPages?: NullableJsonNullValueInput | InputJsonValue
    brokenLinks?: number
    rawData?: NullableJsonNullValueInput | InputJsonValue
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
  }

  export type AIDataSnapshotUncheckedCreateInput = {
    id?: string
    snapshotType: string
    totalViews?: number
    uniqueVisitors?: number
    bounceRate?: number | null
    avgSessionDuration?: number | null
    totalInquiries?: number
    viewingRequests?: number
    investorLeads?: number
    rentalLeads?: number
    conversionRate?: number | null
    totalProperties?: number
    activeListings?: number
    newListings?: number
    avgPropertyViews?: number | null
    totalBlogs?: number
    publishedBlogs?: number
    avgBlogViews?: number | null
    organicTraffic?: number | null
    topKeywords?: NullableJsonNullValueInput | InputJsonValue
    avgPosition?: number | null
    estimatedLeadValue?: number | null
    errorCount?: number
    slowPages?: NullableJsonNullValueInput | InputJsonValue
    brokenLinks?: number
    rawData?: NullableJsonNullValueInput | InputJsonValue
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
  }

  export type AIDataSnapshotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotType?: StringFieldUpdateOperationsInput | string
    totalViews?: IntFieldUpdateOperationsInput | number
    uniqueVisitors?: IntFieldUpdateOperationsInput | number
    bounceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    avgSessionDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    totalInquiries?: IntFieldUpdateOperationsInput | number
    viewingRequests?: IntFieldUpdateOperationsInput | number
    investorLeads?: IntFieldUpdateOperationsInput | number
    rentalLeads?: IntFieldUpdateOperationsInput | number
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    totalProperties?: IntFieldUpdateOperationsInput | number
    activeListings?: IntFieldUpdateOperationsInput | number
    newListings?: IntFieldUpdateOperationsInput | number
    avgPropertyViews?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBlogs?: IntFieldUpdateOperationsInput | number
    publishedBlogs?: IntFieldUpdateOperationsInput | number
    avgBlogViews?: NullableFloatFieldUpdateOperationsInput | number | null
    organicTraffic?: NullableIntFieldUpdateOperationsInput | number | null
    topKeywords?: NullableJsonNullValueInput | InputJsonValue
    avgPosition?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedLeadValue?: NullableFloatFieldUpdateOperationsInput | number | null
    errorCount?: IntFieldUpdateOperationsInput | number
    slowPages?: NullableJsonNullValueInput | InputJsonValue
    brokenLinks?: IntFieldUpdateOperationsInput | number
    rawData?: NullableJsonNullValueInput | InputJsonValue
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIDataSnapshotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotType?: StringFieldUpdateOperationsInput | string
    totalViews?: IntFieldUpdateOperationsInput | number
    uniqueVisitors?: IntFieldUpdateOperationsInput | number
    bounceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    avgSessionDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    totalInquiries?: IntFieldUpdateOperationsInput | number
    viewingRequests?: IntFieldUpdateOperationsInput | number
    investorLeads?: IntFieldUpdateOperationsInput | number
    rentalLeads?: IntFieldUpdateOperationsInput | number
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    totalProperties?: IntFieldUpdateOperationsInput | number
    activeListings?: IntFieldUpdateOperationsInput | number
    newListings?: IntFieldUpdateOperationsInput | number
    avgPropertyViews?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBlogs?: IntFieldUpdateOperationsInput | number
    publishedBlogs?: IntFieldUpdateOperationsInput | number
    avgBlogViews?: NullableFloatFieldUpdateOperationsInput | number | null
    organicTraffic?: NullableIntFieldUpdateOperationsInput | number | null
    topKeywords?: NullableJsonNullValueInput | InputJsonValue
    avgPosition?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedLeadValue?: NullableFloatFieldUpdateOperationsInput | number | null
    errorCount?: IntFieldUpdateOperationsInput | number
    slowPages?: NullableJsonNullValueInput | InputJsonValue
    brokenLinks?: IntFieldUpdateOperationsInput | number
    rawData?: NullableJsonNullValueInput | InputJsonValue
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIDataSnapshotCreateManyInput = {
    id?: string
    snapshotType: string
    totalViews?: number
    uniqueVisitors?: number
    bounceRate?: number | null
    avgSessionDuration?: number | null
    totalInquiries?: number
    viewingRequests?: number
    investorLeads?: number
    rentalLeads?: number
    conversionRate?: number | null
    totalProperties?: number
    activeListings?: number
    newListings?: number
    avgPropertyViews?: number | null
    totalBlogs?: number
    publishedBlogs?: number
    avgBlogViews?: number | null
    organicTraffic?: number | null
    topKeywords?: NullableJsonNullValueInput | InputJsonValue
    avgPosition?: number | null
    estimatedLeadValue?: number | null
    errorCount?: number
    slowPages?: NullableJsonNullValueInput | InputJsonValue
    brokenLinks?: number
    rawData?: NullableJsonNullValueInput | InputJsonValue
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
  }

  export type AIDataSnapshotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotType?: StringFieldUpdateOperationsInput | string
    totalViews?: IntFieldUpdateOperationsInput | number
    uniqueVisitors?: IntFieldUpdateOperationsInput | number
    bounceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    avgSessionDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    totalInquiries?: IntFieldUpdateOperationsInput | number
    viewingRequests?: IntFieldUpdateOperationsInput | number
    investorLeads?: IntFieldUpdateOperationsInput | number
    rentalLeads?: IntFieldUpdateOperationsInput | number
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    totalProperties?: IntFieldUpdateOperationsInput | number
    activeListings?: IntFieldUpdateOperationsInput | number
    newListings?: IntFieldUpdateOperationsInput | number
    avgPropertyViews?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBlogs?: IntFieldUpdateOperationsInput | number
    publishedBlogs?: IntFieldUpdateOperationsInput | number
    avgBlogViews?: NullableFloatFieldUpdateOperationsInput | number | null
    organicTraffic?: NullableIntFieldUpdateOperationsInput | number | null
    topKeywords?: NullableJsonNullValueInput | InputJsonValue
    avgPosition?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedLeadValue?: NullableFloatFieldUpdateOperationsInput | number | null
    errorCount?: IntFieldUpdateOperationsInput | number
    slowPages?: NullableJsonNullValueInput | InputJsonValue
    brokenLinks?: IntFieldUpdateOperationsInput | number
    rawData?: NullableJsonNullValueInput | InputJsonValue
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIDataSnapshotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotType?: StringFieldUpdateOperationsInput | string
    totalViews?: IntFieldUpdateOperationsInput | number
    uniqueVisitors?: IntFieldUpdateOperationsInput | number
    bounceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    avgSessionDuration?: NullableFloatFieldUpdateOperationsInput | number | null
    totalInquiries?: IntFieldUpdateOperationsInput | number
    viewingRequests?: IntFieldUpdateOperationsInput | number
    investorLeads?: IntFieldUpdateOperationsInput | number
    rentalLeads?: IntFieldUpdateOperationsInput | number
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    totalProperties?: IntFieldUpdateOperationsInput | number
    activeListings?: IntFieldUpdateOperationsInput | number
    newListings?: IntFieldUpdateOperationsInput | number
    avgPropertyViews?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBlogs?: IntFieldUpdateOperationsInput | number
    publishedBlogs?: IntFieldUpdateOperationsInput | number
    avgBlogViews?: NullableFloatFieldUpdateOperationsInput | number | null
    organicTraffic?: NullableIntFieldUpdateOperationsInput | number | null
    topKeywords?: NullableJsonNullValueInput | InputJsonValue
    avgPosition?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedLeadValue?: NullableFloatFieldUpdateOperationsInput | number | null
    errorCount?: IntFieldUpdateOperationsInput | number
    slowPages?: NullableJsonNullValueInput | InputJsonValue
    brokenLinks?: IntFieldUpdateOperationsInput | number
    rawData?: NullableJsonNullValueInput | InputJsonValue
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOpportunityCreateInput = {
    id?: string
    type: string
    subType?: string | null
    title: string
    description: string
    trigger: string
    priority?: number
    estimatedEffort: string
    estimatedImpact: string
    potentialRevenue?: number | null
    potentialLeads?: number | null
    status?: $Enums.AIOpportunityStatus
    decisionId?: string | null
    identifiedAt?: Date | string
    addressedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIOpportunityUncheckedCreateInput = {
    id?: string
    type: string
    subType?: string | null
    title: string
    description: string
    trigger: string
    priority?: number
    estimatedEffort: string
    estimatedImpact: string
    potentialRevenue?: number | null
    potentialLeads?: number | null
    status?: $Enums.AIOpportunityStatus
    decisionId?: string | null
    identifiedAt?: Date | string
    addressedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIOpportunityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    estimatedEffort?: StringFieldUpdateOperationsInput | string
    estimatedImpact?: StringFieldUpdateOperationsInput | string
    potentialRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    potentialLeads?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAIOpportunityStatusFieldUpdateOperationsInput | $Enums.AIOpportunityStatus
    decisionId?: NullableStringFieldUpdateOperationsInput | string | null
    identifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOpportunityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    estimatedEffort?: StringFieldUpdateOperationsInput | string
    estimatedImpact?: StringFieldUpdateOperationsInput | string
    potentialRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    potentialLeads?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAIOpportunityStatusFieldUpdateOperationsInput | $Enums.AIOpportunityStatus
    decisionId?: NullableStringFieldUpdateOperationsInput | string | null
    identifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOpportunityCreateManyInput = {
    id?: string
    type: string
    subType?: string | null
    title: string
    description: string
    trigger: string
    priority?: number
    estimatedEffort: string
    estimatedImpact: string
    potentialRevenue?: number | null
    potentialLeads?: number | null
    status?: $Enums.AIOpportunityStatus
    decisionId?: string | null
    identifiedAt?: Date | string
    addressedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIOpportunityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    estimatedEffort?: StringFieldUpdateOperationsInput | string
    estimatedImpact?: StringFieldUpdateOperationsInput | string
    potentialRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    potentialLeads?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAIOpportunityStatusFieldUpdateOperationsInput | $Enums.AIOpportunityStatus
    decisionId?: NullableStringFieldUpdateOperationsInput | string | null
    identifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIOpportunityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    estimatedEffort?: StringFieldUpdateOperationsInput | string
    estimatedImpact?: StringFieldUpdateOperationsInput | string
    potentialRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    potentialLeads?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAIOpportunityStatusFieldUpdateOperationsInput | $Enums.AIOpportunityStatus
    decisionId?: NullableStringFieldUpdateOperationsInput | string | null
    identifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addressedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AILearningCreateInput = {
    id?: string
    category: string
    insight: string
    sourceDecisionId?: string | null
    confidence: number
    impactArea: string
    adjustment: string
    validatedBy?: string | null
    validatedAt?: Date | string | null
    isValid?: boolean
    createdAt?: Date | string
  }

  export type AILearningUncheckedCreateInput = {
    id?: string
    category: string
    insight: string
    sourceDecisionId?: string | null
    confidence: number
    impactArea: string
    adjustment: string
    validatedBy?: string | null
    validatedAt?: Date | string | null
    isValid?: boolean
    createdAt?: Date | string
  }

  export type AILearningUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    insight?: StringFieldUpdateOperationsInput | string
    sourceDecisionId?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: FloatFieldUpdateOperationsInput | number
    impactArea?: StringFieldUpdateOperationsInput | string
    adjustment?: StringFieldUpdateOperationsInput | string
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AILearningUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    insight?: StringFieldUpdateOperationsInput | string
    sourceDecisionId?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: FloatFieldUpdateOperationsInput | number
    impactArea?: StringFieldUpdateOperationsInput | string
    adjustment?: StringFieldUpdateOperationsInput | string
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AILearningCreateManyInput = {
    id?: string
    category: string
    insight: string
    sourceDecisionId?: string | null
    confidence: number
    impactArea: string
    adjustment: string
    validatedBy?: string | null
    validatedAt?: Date | string | null
    isValid?: boolean
    createdAt?: Date | string
  }

  export type AILearningUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    insight?: StringFieldUpdateOperationsInput | string
    sourceDecisionId?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: FloatFieldUpdateOperationsInput | number
    impactArea?: StringFieldUpdateOperationsInput | string
    adjustment?: StringFieldUpdateOperationsInput | string
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AILearningUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    insight?: StringFieldUpdateOperationsInput | string
    sourceDecisionId?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: FloatFieldUpdateOperationsInput | number
    impactArea?: StringFieldUpdateOperationsInput | string
    adjustment?: StringFieldUpdateOperationsInput | string
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    impersonatedBy?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    impersonatedBy?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
    impersonatedBy?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type PropertyListRelationFilter = {
    every?: PropertyWhereInput
    some?: PropertyWhereInput
    none?: PropertyWhereInput
  }

  export type InvestorLeadListRelationFilter = {
    every?: InvestorLeadWhereInput
    some?: InvestorLeadWhereInput
    none?: InvestorLeadWhereInput
  }

  export type RentalLeadListRelationFilter = {
    every?: RentalLeadWhereInput
    some?: RentalLeadWhereInput
    none?: RentalLeadWhereInput
  }

  export type BlogListRelationFilter = {
    every?: BlogWhereInput
    some?: BlogWhereInput
    none?: BlogWhereInput
  }

  export type RentalBookingListRelationFilter = {
    every?: RentalBookingWhereInput
    some?: RentalBookingWhereInput
    none?: RentalBookingWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvestorLeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RentalLeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RentalBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AgentInviteCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    role?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    usedBy?: SortOrder
    usedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentInviteAvgOrderByAggregateInput = {
    maxUses?: SortOrder
    usedCount?: SortOrder
  }

  export type AgentInviteMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    role?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    usedBy?: SortOrder
    usedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentInviteMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    role?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    usedBy?: SortOrder
    usedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentInviteSumOrderByAggregateInput = {
    maxUses?: SortOrder
    usedCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumPropertyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeFilter<$PrismaModel> | $Enums.PropertyType
  }

  export type EnumPropertyCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyCategory | EnumPropertyCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyCategoryFilter<$PrismaModel> | $Enums.PropertyCategory
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type EnumOwnershipTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OwnershipType | EnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOwnershipTypeNullableFilter<$PrismaModel> | $Enums.OwnershipType | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type PropertyImageListRelationFilter = {
    every?: PropertyImageWhereInput
    some?: PropertyImageWhereInput
    none?: PropertyImageWhereInput
  }

  export type PropertyViewListRelationFilter = {
    every?: PropertyViewWhereInput
    some?: PropertyViewWhereInput
    none?: PropertyViewWhereInput
  }

  export type PropertyOwnerNullableScalarRelationFilter = {
    is?: PropertyOwnerWhereInput | null
    isNot?: PropertyOwnerWhereInput | null
  }

  export type PropertyPoiDistanceListRelationFilter = {
    every?: PropertyPoiDistanceWhereInput
    some?: PropertyPoiDistanceWhereInput
    none?: PropertyPoiDistanceWhereInput
  }

  export type ViewingRequestListRelationFilter = {
    every?: ViewingRequestWhereInput
    some?: ViewingRequestWhereInput
    none?: ViewingRequestWhereInput
  }

  export type PropertyBlockedDateListRelationFilter = {
    every?: PropertyBlockedDateWhereInput
    some?: PropertyBlockedDateWhereInput
    none?: PropertyBlockedDateWhereInput
  }

  export type Tm30AccommodationNullableScalarRelationFilter = {
    is?: Tm30AccommodationWhereInput | null
    isNot?: Tm30AccommodationWhereInput | null
  }

  export type PropertyImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyViewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyPoiDistanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ViewingRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyBlockedDateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyCountOrderByAggregateInput = {
    id?: SortOrder
    listingNumber?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    location?: SortOrder
    price?: SortOrder
    beds?: SortOrder
    baths?: SortOrder
    sqft?: SortOrder
    plotSize?: SortOrder
    type?: SortOrder
    category?: SortOrder
    tag?: SortOrder
    status?: SortOrder
    isHighlighted?: SortOrder
    ownershipType?: SortOrder
    isResale?: SortOrder
    image?: SortOrder
    shortDescription?: SortOrder
    descriptionParagraphs?: SortOrder
    propertyFeatures?: SortOrder
    amenities?: SortOrder
    amenitiesWithIcons?: SortOrder
    content?: SortOrder
    yearBuilt?: SortOrder
    mapUrl?: SortOrder
    monthlyRentalPrice?: SortOrder
    allowPets?: SortOrder
    enableDailyRental?: SortOrder
    maxGuests?: SortOrder
    provinceSlug?: SortOrder
    areaSlug?: SortOrder
    ownerName?: SortOrder
    ownerEmail?: SortOrder
    ownerPhone?: SortOrder
    ownerCountryCode?: SortOrder
    ownerCompany?: SortOrder
    ownerNotes?: SortOrder
    propertyOwnerId?: SortOrder
    bluebookUrl?: SortOrder
    bluebookHouseId?: SortOrder
    commissionRate?: SortOrder
    tm30AccommodationId?: SortOrder
    tm30AccommodationName?: SortOrder
    defaultCheckInTime?: SortOrder
    defaultCheckOutTime?: SortOrder
    defaultPropertyAddress?: SortOrder
    defaultWifiName?: SortOrder
    defaultWifiPassword?: SortOrder
    defaultAccessCode?: SortOrder
    defaultEmergencyContact?: SortOrder
    defaultPropertyInstructions?: SortOrder
    defaultHouseRules?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    beachScore?: SortOrder
    familyScore?: SortOrder
    convenienceScore?: SortOrder
    quietnessScore?: SortOrder
    hasSeaView?: SortOrder
    seaViewDirection?: SortOrder
    seaDistance?: SortOrder
    district?: SortOrder
    poisLastCalculatedAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyAvgOrderByAggregateInput = {
    beds?: SortOrder
    baths?: SortOrder
    sqft?: SortOrder
    plotSize?: SortOrder
    yearBuilt?: SortOrder
    monthlyRentalPrice?: SortOrder
    maxGuests?: SortOrder
    commissionRate?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    beachScore?: SortOrder
    familyScore?: SortOrder
    convenienceScore?: SortOrder
    quietnessScore?: SortOrder
    seaDistance?: SortOrder
  }

  export type PropertyMaxOrderByAggregateInput = {
    id?: SortOrder
    listingNumber?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    location?: SortOrder
    price?: SortOrder
    beds?: SortOrder
    baths?: SortOrder
    sqft?: SortOrder
    plotSize?: SortOrder
    type?: SortOrder
    category?: SortOrder
    tag?: SortOrder
    status?: SortOrder
    isHighlighted?: SortOrder
    ownershipType?: SortOrder
    isResale?: SortOrder
    image?: SortOrder
    shortDescription?: SortOrder
    content?: SortOrder
    yearBuilt?: SortOrder
    mapUrl?: SortOrder
    monthlyRentalPrice?: SortOrder
    allowPets?: SortOrder
    enableDailyRental?: SortOrder
    maxGuests?: SortOrder
    provinceSlug?: SortOrder
    areaSlug?: SortOrder
    ownerName?: SortOrder
    ownerEmail?: SortOrder
    ownerPhone?: SortOrder
    ownerCountryCode?: SortOrder
    ownerCompany?: SortOrder
    ownerNotes?: SortOrder
    propertyOwnerId?: SortOrder
    bluebookUrl?: SortOrder
    bluebookHouseId?: SortOrder
    commissionRate?: SortOrder
    tm30AccommodationId?: SortOrder
    tm30AccommodationName?: SortOrder
    defaultCheckInTime?: SortOrder
    defaultCheckOutTime?: SortOrder
    defaultPropertyAddress?: SortOrder
    defaultWifiName?: SortOrder
    defaultWifiPassword?: SortOrder
    defaultAccessCode?: SortOrder
    defaultEmergencyContact?: SortOrder
    defaultPropertyInstructions?: SortOrder
    defaultHouseRules?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    beachScore?: SortOrder
    familyScore?: SortOrder
    convenienceScore?: SortOrder
    quietnessScore?: SortOrder
    hasSeaView?: SortOrder
    seaViewDirection?: SortOrder
    seaDistance?: SortOrder
    district?: SortOrder
    poisLastCalculatedAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyMinOrderByAggregateInput = {
    id?: SortOrder
    listingNumber?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    location?: SortOrder
    price?: SortOrder
    beds?: SortOrder
    baths?: SortOrder
    sqft?: SortOrder
    plotSize?: SortOrder
    type?: SortOrder
    category?: SortOrder
    tag?: SortOrder
    status?: SortOrder
    isHighlighted?: SortOrder
    ownershipType?: SortOrder
    isResale?: SortOrder
    image?: SortOrder
    shortDescription?: SortOrder
    content?: SortOrder
    yearBuilt?: SortOrder
    mapUrl?: SortOrder
    monthlyRentalPrice?: SortOrder
    allowPets?: SortOrder
    enableDailyRental?: SortOrder
    maxGuests?: SortOrder
    provinceSlug?: SortOrder
    areaSlug?: SortOrder
    ownerName?: SortOrder
    ownerEmail?: SortOrder
    ownerPhone?: SortOrder
    ownerCountryCode?: SortOrder
    ownerCompany?: SortOrder
    ownerNotes?: SortOrder
    propertyOwnerId?: SortOrder
    bluebookUrl?: SortOrder
    bluebookHouseId?: SortOrder
    commissionRate?: SortOrder
    tm30AccommodationId?: SortOrder
    tm30AccommodationName?: SortOrder
    defaultCheckInTime?: SortOrder
    defaultCheckOutTime?: SortOrder
    defaultPropertyAddress?: SortOrder
    defaultWifiName?: SortOrder
    defaultWifiPassword?: SortOrder
    defaultAccessCode?: SortOrder
    defaultEmergencyContact?: SortOrder
    defaultPropertyInstructions?: SortOrder
    defaultHouseRules?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    beachScore?: SortOrder
    familyScore?: SortOrder
    convenienceScore?: SortOrder
    quietnessScore?: SortOrder
    hasSeaView?: SortOrder
    seaViewDirection?: SortOrder
    seaDistance?: SortOrder
    district?: SortOrder
    poisLastCalculatedAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertySumOrderByAggregateInput = {
    beds?: SortOrder
    baths?: SortOrder
    sqft?: SortOrder
    plotSize?: SortOrder
    yearBuilt?: SortOrder
    monthlyRentalPrice?: SortOrder
    maxGuests?: SortOrder
    commissionRate?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    beachScore?: SortOrder
    familyScore?: SortOrder
    convenienceScore?: SortOrder
    quietnessScore?: SortOrder
    seaDistance?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumPropertyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeFilter<$PrismaModel>
  }

  export type EnumPropertyCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyCategory | EnumPropertyCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PropertyCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyCategoryFilter<$PrismaModel>
    _max?: NestedEnumPropertyCategoryFilter<$PrismaModel>
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type EnumOwnershipTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OwnershipType | EnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOwnershipTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.OwnershipType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOwnershipTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumOwnershipTypeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type PropertyScalarRelationFilter = {
    is?: PropertyWhereInput
    isNot?: PropertyWhereInput
  }

  export type PropertyImagePropertyIdPositionCompoundUniqueInput = {
    propertyId: string
    position: number
  }

  export type PropertyImageCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    url?: SortOrder
    position?: SortOrder
    alt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyImageAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type PropertyImageMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    url?: SortOrder
    position?: SortOrder
    alt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyImageMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    url?: SortOrder
    position?: SortOrder
    alt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyImageSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type PropertyViewCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    viewedAt?: SortOrder
    country?: SortOrder
    city?: SortOrder
    ipHash?: SortOrder
    userAgent?: SortOrder
    referrer?: SortOrder
    sessionId?: SortOrder
  }

  export type PropertyViewMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    viewedAt?: SortOrder
    country?: SortOrder
    city?: SortOrder
    ipHash?: SortOrder
    userAgent?: SortOrder
    referrer?: SortOrder
    sessionId?: SortOrder
  }

  export type PropertyViewMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    viewedAt?: SortOrder
    country?: SortOrder
    city?: SortOrder
    ipHash?: SortOrder
    userAgent?: SortOrder
    referrer?: SortOrder
    sessionId?: SortOrder
  }

  export type EnumRequestTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestType | EnumRequestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestTypeFilter<$PrismaModel> | $Enums.RequestType
  }

  export type EnumRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusFilter<$PrismaModel> | $Enums.RequestStatus
  }

  export type PropertyNullableScalarRelationFilter = {
    is?: PropertyWhereInput | null
    isNot?: PropertyWhereInput | null
  }

  export type ViewingRequestCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    requestType?: SortOrder
    viewingDate?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    countryCode?: SortOrder
    language?: SortOrder
    message?: SortOrder
    offerAmount?: SortOrder
    offerCurrency?: SortOrder
    status?: SortOrder
    confirmedBy?: SortOrder
    confirmedByName?: SortOrder
    confirmedAt?: SortOrder
    completedBy?: SortOrder
    completedByName?: SortOrder
    completedAt?: SortOrder
    cancelledBy?: SortOrder
    cancelledByName?: SortOrder
    cancelledAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ViewingRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    requestType?: SortOrder
    viewingDate?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    countryCode?: SortOrder
    language?: SortOrder
    message?: SortOrder
    offerAmount?: SortOrder
    offerCurrency?: SortOrder
    status?: SortOrder
    confirmedBy?: SortOrder
    confirmedByName?: SortOrder
    confirmedAt?: SortOrder
    completedBy?: SortOrder
    completedByName?: SortOrder
    completedAt?: SortOrder
    cancelledBy?: SortOrder
    cancelledByName?: SortOrder
    cancelledAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ViewingRequestMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    requestType?: SortOrder
    viewingDate?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    countryCode?: SortOrder
    language?: SortOrder
    message?: SortOrder
    offerAmount?: SortOrder
    offerCurrency?: SortOrder
    status?: SortOrder
    confirmedBy?: SortOrder
    confirmedByName?: SortOrder
    confirmedAt?: SortOrder
    completedBy?: SortOrder
    completedByName?: SortOrder
    completedAt?: SortOrder
    cancelledBy?: SortOrder
    cancelledByName?: SortOrder
    cancelledAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRequestTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestType | EnumRequestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestTypeWithAggregatesFilter<$PrismaModel> | $Enums.RequestType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestTypeFilter<$PrismaModel>
    _max?: NestedEnumRequestTypeFilter<$PrismaModel>
  }

  export type EnumRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRequestStatusFilter<$PrismaModel>
  }

  export type EnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type InvestorLeadCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    countryCode?: SortOrder
    currency?: SortOrder
    investmentBudget?: SortOrder
    investmentGoal?: SortOrder
    timeline?: SortOrder
    preferredAreas?: SortOrder
    propertyType?: SortOrder
    experience?: SortOrder
    financing?: SortOrder
    message?: SortOrder
    newsletter?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorLeadMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    countryCode?: SortOrder
    currency?: SortOrder
    investmentBudget?: SortOrder
    investmentGoal?: SortOrder
    timeline?: SortOrder
    preferredAreas?: SortOrder
    propertyType?: SortOrder
    experience?: SortOrder
    financing?: SortOrder
    message?: SortOrder
    newsletter?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorLeadMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    countryCode?: SortOrder
    currency?: SortOrder
    investmentBudget?: SortOrder
    investmentGoal?: SortOrder
    timeline?: SortOrder
    preferredAreas?: SortOrder
    propertyType?: SortOrder
    experience?: SortOrder
    financing?: SortOrder
    message?: SortOrder
    newsletter?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type EnumRentalLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RentalLeadStatus | EnumRentalLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RentalLeadStatus[] | ListEnumRentalLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RentalLeadStatus[] | ListEnumRentalLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRentalLeadStatusFilter<$PrismaModel> | $Enums.RentalLeadStatus
  }

  export type RentalLeadCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    countryCode?: SortOrder
    propertyType?: SortOrder
    bedrooms?: SortOrder
    budget?: SortOrder
    rentalDuration?: SortOrder
    preferredAreas?: SortOrder
    moveInDate?: SortOrder
    furnished?: SortOrder
    pets?: SortOrder
    message?: SortOrder
    newsletter?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RentalLeadMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    countryCode?: SortOrder
    propertyType?: SortOrder
    bedrooms?: SortOrder
    budget?: SortOrder
    rentalDuration?: SortOrder
    preferredAreas?: SortOrder
    moveInDate?: SortOrder
    furnished?: SortOrder
    pets?: SortOrder
    message?: SortOrder
    newsletter?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RentalLeadMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    countryCode?: SortOrder
    propertyType?: SortOrder
    bedrooms?: SortOrder
    budget?: SortOrder
    rentalDuration?: SortOrder
    preferredAreas?: SortOrder
    moveInDate?: SortOrder
    furnished?: SortOrder
    pets?: SortOrder
    message?: SortOrder
    newsletter?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRentalLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RentalLeadStatus | EnumRentalLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RentalLeadStatus[] | ListEnumRentalLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RentalLeadStatus[] | ListEnumRentalLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRentalLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.RentalLeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRentalLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumRentalLeadStatusFilter<$PrismaModel>
  }

  export type BlogCategoryNullableScalarRelationFilter = {
    is?: BlogCategoryWhereInput | null
    isNot?: BlogCategoryWhereInput | null
  }

  export type LinkUsageListRelationFilter = {
    every?: LinkUsageWhereInput
    some?: LinkUsageWhereInput
    none?: LinkUsageWhereInput
  }

  export type LinkUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    coverImage?: SortOrder
    coverImageAlt?: SortOrder
    tag?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    categoryId?: SortOrder
    published?: SortOrder
    publishedAt?: SortOrder
    originalContent?: SortOrder
    linkOptimizedAt?: SortOrder
    internalLinkCount?: SortOrder
    hasDynamicProperties?: SortOrder
    poiQueryParams?: SortOrder
    poiTemplateId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogAvgOrderByAggregateInput = {
    internalLinkCount?: SortOrder
  }

  export type BlogMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    coverImage?: SortOrder
    coverImageAlt?: SortOrder
    tag?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    categoryId?: SortOrder
    published?: SortOrder
    publishedAt?: SortOrder
    originalContent?: SortOrder
    linkOptimizedAt?: SortOrder
    internalLinkCount?: SortOrder
    hasDynamicProperties?: SortOrder
    poiQueryParams?: SortOrder
    poiTemplateId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    coverImage?: SortOrder
    coverImageAlt?: SortOrder
    tag?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    categoryId?: SortOrder
    published?: SortOrder
    publishedAt?: SortOrder
    originalContent?: SortOrder
    linkOptimizedAt?: SortOrder
    internalLinkCount?: SortOrder
    hasDynamicProperties?: SortOrder
    poiQueryParams?: SortOrder
    poiTemplateId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogSumOrderByAggregateInput = {
    internalLinkCount?: SortOrder
  }

  export type BlogCategoryListRelationFilter = {
    every?: BlogCategoryWhereInput
    some?: BlogCategoryWhereInput
    none?: BlogCategoryWhereInput
  }

  export type BlogCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogCategoryAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type BlogCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogCategorySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumSubmissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionStatusFilter<$PrismaModel> | $Enums.SubmissionStatus
  }

  export type PropertySubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    ownerName?: SortOrder
    ownerEmail?: SortOrder
    ownerPhone?: SortOrder
    ownerCountryCode?: SortOrder
    accessToken?: SortOrder
    propertyTitle?: SortOrder
    propertyCategory?: SortOrder
    propertyType?: SortOrder
    location?: SortOrder
    askingPrice?: SortOrder
    beds?: SortOrder
    baths?: SortOrder
    sqft?: SortOrder
    description?: SortOrder
    images?: SortOrder
    exclusiveRights?: SortOrder
    commissionRate?: SortOrder
    agreementAccepted?: SortOrder
    status?: SortOrder
    reviewNotes?: SortOrder
    reviewedBy?: SortOrder
    reviewedByName?: SortOrder
    reviewedAt?: SortOrder
    imagesApprovedAt?: SortOrder
    imagesApprovedBy?: SortOrder
    publishedAt?: SortOrder
    publishedBy?: SortOrder
    convertedPropertyId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertySubmissionAvgOrderByAggregateInput = {
    beds?: SortOrder
    baths?: SortOrder
    sqft?: SortOrder
    commissionRate?: SortOrder
  }

  export type PropertySubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerName?: SortOrder
    ownerEmail?: SortOrder
    ownerPhone?: SortOrder
    ownerCountryCode?: SortOrder
    accessToken?: SortOrder
    propertyTitle?: SortOrder
    propertyCategory?: SortOrder
    propertyType?: SortOrder
    location?: SortOrder
    askingPrice?: SortOrder
    beds?: SortOrder
    baths?: SortOrder
    sqft?: SortOrder
    description?: SortOrder
    exclusiveRights?: SortOrder
    commissionRate?: SortOrder
    agreementAccepted?: SortOrder
    status?: SortOrder
    reviewNotes?: SortOrder
    reviewedBy?: SortOrder
    reviewedByName?: SortOrder
    reviewedAt?: SortOrder
    imagesApprovedAt?: SortOrder
    imagesApprovedBy?: SortOrder
    publishedAt?: SortOrder
    publishedBy?: SortOrder
    convertedPropertyId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertySubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    ownerName?: SortOrder
    ownerEmail?: SortOrder
    ownerPhone?: SortOrder
    ownerCountryCode?: SortOrder
    accessToken?: SortOrder
    propertyTitle?: SortOrder
    propertyCategory?: SortOrder
    propertyType?: SortOrder
    location?: SortOrder
    askingPrice?: SortOrder
    beds?: SortOrder
    baths?: SortOrder
    sqft?: SortOrder
    description?: SortOrder
    exclusiveRights?: SortOrder
    commissionRate?: SortOrder
    agreementAccepted?: SortOrder
    status?: SortOrder
    reviewNotes?: SortOrder
    reviewedBy?: SortOrder
    reviewedByName?: SortOrder
    reviewedAt?: SortOrder
    imagesApprovedAt?: SortOrder
    imagesApprovedBy?: SortOrder
    publishedAt?: SortOrder
    publishedBy?: SortOrder
    convertedPropertyId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertySubmissionSumOrderByAggregateInput = {
    beds?: SortOrder
    baths?: SortOrder
    sqft?: SortOrder
    commissionRate?: SortOrder
  }

  export type EnumSubmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubmissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubmissionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubmissionStatusFilter<$PrismaModel>
  }

  export type SiteSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    smtpHost?: SortOrder
    smtpPort?: SortOrder
    smtpSecure?: SortOrder
    smtpUser?: SortOrder
    smtpPassword?: SortOrder
    smtpFromName?: SortOrder
    smtpFromEmail?: SortOrder
    siteName?: SortOrder
    siteEmail?: SortOrder
    adminNotifyEmail?: SortOrder
    notifyOnSubmission?: SortOrder
    notifyOnImageUpload?: SortOrder
    companyDescription?: SortOrder
    companyTone?: SortOrder
    companyUSPs?: SortOrder
    targetAudience?: SortOrder
    brandKeywords?: SortOrder
    avoidTopics?: SortOrder
    websiteUrl?: SortOrder
    lastScannedAt?: SortOrder
    scannedPagesCount?: SortOrder
    scanConfidence?: SortOrder
    detectedThemes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteSettingsAvgOrderByAggregateInput = {
    smtpPort?: SortOrder
    scannedPagesCount?: SortOrder
    scanConfidence?: SortOrder
  }

  export type SiteSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    smtpHost?: SortOrder
    smtpPort?: SortOrder
    smtpSecure?: SortOrder
    smtpUser?: SortOrder
    smtpPassword?: SortOrder
    smtpFromName?: SortOrder
    smtpFromEmail?: SortOrder
    siteName?: SortOrder
    siteEmail?: SortOrder
    adminNotifyEmail?: SortOrder
    notifyOnSubmission?: SortOrder
    notifyOnImageUpload?: SortOrder
    companyDescription?: SortOrder
    companyTone?: SortOrder
    companyUSPs?: SortOrder
    targetAudience?: SortOrder
    brandKeywords?: SortOrder
    avoidTopics?: SortOrder
    websiteUrl?: SortOrder
    lastScannedAt?: SortOrder
    scannedPagesCount?: SortOrder
    scanConfidence?: SortOrder
    detectedThemes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    smtpHost?: SortOrder
    smtpPort?: SortOrder
    smtpSecure?: SortOrder
    smtpUser?: SortOrder
    smtpPassword?: SortOrder
    smtpFromName?: SortOrder
    smtpFromEmail?: SortOrder
    siteName?: SortOrder
    siteEmail?: SortOrder
    adminNotifyEmail?: SortOrder
    notifyOnSubmission?: SortOrder
    notifyOnImageUpload?: SortOrder
    companyDescription?: SortOrder
    companyTone?: SortOrder
    companyUSPs?: SortOrder
    targetAudience?: SortOrder
    brandKeywords?: SortOrder
    avoidTopics?: SortOrder
    websiteUrl?: SortOrder
    lastScannedAt?: SortOrder
    scannedPagesCount?: SortOrder
    scanConfidence?: SortOrder
    detectedThemes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteSettingsSumOrderByAggregateInput = {
    smtpPort?: SortOrder
    scannedPagesCount?: SortOrder
    scanConfidence?: SortOrder
  }

  export type InternalLinkCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    keywords?: SortOrder
    anchorTexts?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    usageCount?: SortOrder
    pageExists?: SortOrder
    lastChecked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InternalLinkAvgOrderByAggregateInput = {
    priority?: SortOrder
    usageCount?: SortOrder
  }

  export type InternalLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    keywords?: SortOrder
    anchorTexts?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    usageCount?: SortOrder
    pageExists?: SortOrder
    lastChecked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InternalLinkMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    keywords?: SortOrder
    anchorTexts?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    usageCount?: SortOrder
    pageExists?: SortOrder
    lastChecked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InternalLinkSumOrderByAggregateInput = {
    priority?: SortOrder
    usageCount?: SortOrder
  }

  export type InternalLinkScalarRelationFilter = {
    is?: InternalLinkWhereInput
    isNot?: InternalLinkWhereInput
  }

  export type BlogScalarRelationFilter = {
    is?: BlogWhereInput
    isNot?: BlogWhereInput
  }

  export type LinkUsageCountOrderByAggregateInput = {
    id?: SortOrder
    linkId?: SortOrder
    blogId?: SortOrder
    anchorText?: SortOrder
    context?: SortOrder
    position?: SortOrder
    wasAutoInserted?: SortOrder
    insertedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LinkUsageAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type LinkUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    linkId?: SortOrder
    blogId?: SortOrder
    anchorText?: SortOrder
    context?: SortOrder
    position?: SortOrder
    wasAutoInserted?: SortOrder
    insertedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LinkUsageMinOrderByAggregateInput = {
    id?: SortOrder
    linkId?: SortOrder
    blogId?: SortOrder
    anchorText?: SortOrder
    context?: SortOrder
    position?: SortOrder
    wasAutoInserted?: SortOrder
    insertedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LinkUsageSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type EnumLandingPageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LandingPageStatus | EnumLandingPageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LandingPageStatus[] | ListEnumLandingPageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LandingPageStatus[] | ListEnumLandingPageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLandingPageStatusFilter<$PrismaModel> | $Enums.LandingPageStatus
  }

  export type LandingPageSuggestionCountOrderByAggregateInput = {
    id?: SortOrder
    suggestedUrl?: SortOrder
    suggestedTitle?: SortOrder
    description?: SortOrder
    category?: SortOrder
    reason?: SortOrder
    mentionCount?: SortOrder
    sourceBlogs?: SortOrder
    status?: SortOrder
    createdPageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LandingPageSuggestionAvgOrderByAggregateInput = {
    mentionCount?: SortOrder
  }

  export type LandingPageSuggestionMaxOrderByAggregateInput = {
    id?: SortOrder
    suggestedUrl?: SortOrder
    suggestedTitle?: SortOrder
    description?: SortOrder
    category?: SortOrder
    reason?: SortOrder
    mentionCount?: SortOrder
    sourceBlogs?: SortOrder
    status?: SortOrder
    createdPageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LandingPageSuggestionMinOrderByAggregateInput = {
    id?: SortOrder
    suggestedUrl?: SortOrder
    suggestedTitle?: SortOrder
    description?: SortOrder
    category?: SortOrder
    reason?: SortOrder
    mentionCount?: SortOrder
    sourceBlogs?: SortOrder
    status?: SortOrder
    createdPageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LandingPageSuggestionSumOrderByAggregateInput = {
    mentionCount?: SortOrder
  }

  export type EnumLandingPageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LandingPageStatus | EnumLandingPageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LandingPageStatus[] | ListEnumLandingPageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LandingPageStatus[] | ListEnumLandingPageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLandingPageStatusWithAggregatesFilter<$PrismaModel> | $Enums.LandingPageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLandingPageStatusFilter<$PrismaModel>
    _max?: NestedEnumLandingPageStatusFilter<$PrismaModel>
  }

  export type LandingPageCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    category?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    content?: SortOrder
    faq?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LandingPageMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    category?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    content?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LandingPageMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    category?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    content?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyProfileCountOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    tagline?: SortOrder
    description?: SortOrder
    tone?: SortOrder
    writingStyle?: SortOrder
    targetAudience?: SortOrder
    targetLocations?: SortOrder
    usps?: SortOrder
    expertise?: SortOrder
    contentThemes?: SortOrder
    brandKeywords?: SortOrder
    avoidTopics?: SortOrder
    competitors?: SortOrder
    websiteUrl?: SortOrder
    lastAnalyzedAt?: SortOrder
    analysisData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    tagline?: SortOrder
    description?: SortOrder
    tone?: SortOrder
    writingStyle?: SortOrder
    targetAudience?: SortOrder
    targetLocations?: SortOrder
    usps?: SortOrder
    expertise?: SortOrder
    contentThemes?: SortOrder
    brandKeywords?: SortOrder
    avoidTopics?: SortOrder
    competitors?: SortOrder
    websiteUrl?: SortOrder
    lastAnalyzedAt?: SortOrder
    analysisData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyProfileMinOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    tagline?: SortOrder
    description?: SortOrder
    tone?: SortOrder
    writingStyle?: SortOrder
    targetAudience?: SortOrder
    targetLocations?: SortOrder
    usps?: SortOrder
    expertise?: SortOrder
    contentThemes?: SortOrder
    brandKeywords?: SortOrder
    avoidTopics?: SortOrder
    competitors?: SortOrder
    websiteUrl?: SortOrder
    lastAnalyzedAt?: SortOrder
    analysisData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogScheduleSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    maxBlogsPerWeek?: SortOrder
    minDaysBetweenPosts?: SortOrder
    preferredPostTime?: SortOrder
    preferredPostDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogScheduleSettingsAvgOrderByAggregateInput = {
    maxBlogsPerWeek?: SortOrder
    minDaysBetweenPosts?: SortOrder
  }

  export type BlogScheduleSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    maxBlogsPerWeek?: SortOrder
    minDaysBetweenPosts?: SortOrder
    preferredPostTime?: SortOrder
    preferredPostDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogScheduleSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    maxBlogsPerWeek?: SortOrder
    minDaysBetweenPosts?: SortOrder
    preferredPostTime?: SortOrder
    preferredPostDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogScheduleSettingsSumOrderByAggregateInput = {
    maxBlogsPerWeek?: SortOrder
    minDaysBetweenPosts?: SortOrder
  }

  export type EnumTopicStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TopicStatus | EnumTopicStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTopicStatusFilter<$PrismaModel> | $Enums.TopicStatus
  }

  export type TopicSuggestionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    difficulty?: SortOrder
    estimatedImpact?: SortOrder
    language?: SortOrder
    status?: SortOrder
    usedAt?: SortOrder
    generatedBlogId?: SortOrder
    batchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicSuggestionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    difficulty?: SortOrder
    estimatedImpact?: SortOrder
    language?: SortOrder
    status?: SortOrder
    usedAt?: SortOrder
    generatedBlogId?: SortOrder
    batchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicSuggestionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    difficulty?: SortOrder
    estimatedImpact?: SortOrder
    language?: SortOrder
    status?: SortOrder
    usedAt?: SortOrder
    generatedBlogId?: SortOrder
    batchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTopicStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TopicStatus | EnumTopicStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTopicStatusWithAggregatesFilter<$PrismaModel> | $Enums.TopicStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTopicStatusFilter<$PrismaModel>
    _max?: NestedEnumTopicStatusFilter<$PrismaModel>
  }

  export type EnumScheduledBlogStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduledBlogStatus | EnumScheduledBlogStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduledBlogStatus[] | ListEnumScheduledBlogStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduledBlogStatus[] | ListEnumScheduledBlogStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduledBlogStatusFilter<$PrismaModel> | $Enums.ScheduledBlogStatus
  }

  export type ScheduledBlogCountOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    topicTitle?: SortOrder
    language?: SortOrder
    length?: SortOrder
    tone?: SortOrder
    includeResearch?: SortOrder
    scheduledFor?: SortOrder
    scheduledBy?: SortOrder
    status?: SortOrder
    generatedBlogId?: SortOrder
    processingStartedAt?: SortOrder
    processedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledBlogMaxOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    topicTitle?: SortOrder
    language?: SortOrder
    length?: SortOrder
    tone?: SortOrder
    includeResearch?: SortOrder
    scheduledFor?: SortOrder
    scheduledBy?: SortOrder
    status?: SortOrder
    generatedBlogId?: SortOrder
    processingStartedAt?: SortOrder
    processedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduledBlogMinOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    topicTitle?: SortOrder
    language?: SortOrder
    length?: SortOrder
    tone?: SortOrder
    includeResearch?: SortOrder
    scheduledFor?: SortOrder
    scheduledBy?: SortOrder
    status?: SortOrder
    generatedBlogId?: SortOrder
    processingStartedAt?: SortOrder
    processedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumScheduledBlogStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduledBlogStatus | EnumScheduledBlogStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduledBlogStatus[] | ListEnumScheduledBlogStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduledBlogStatus[] | ListEnumScheduledBlogStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduledBlogStatusWithAggregatesFilter<$PrismaModel> | $Enums.ScheduledBlogStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduledBlogStatusFilter<$PrismaModel>
    _max?: NestedEnumScheduledBlogStatusFilter<$PrismaModel>
  }

  export type EnumHeroDeviceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.HeroDeviceType | EnumHeroDeviceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HeroDeviceType[] | ListEnumHeroDeviceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HeroDeviceType[] | ListEnumHeroDeviceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHeroDeviceTypeFilter<$PrismaModel> | $Enums.HeroDeviceType
  }

  export type HeroImagePageDeviceTypeCompoundUniqueInput = {
    page: string
    deviceType: $Enums.HeroDeviceType
  }

  export type HeroImageCountOrderByAggregateInput = {
    id?: SortOrder
    page?: SortOrder
    deviceType?: SortOrder
    imageUrl?: SortOrder
    alt?: SortOrder
    fileName?: SortOrder
    originalUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    isAiGenerated?: SortOrder
    aiPrompt?: SortOrder
    originalSize?: SortOrder
    optimizedSize?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HeroImageAvgOrderByAggregateInput = {
    width?: SortOrder
    height?: SortOrder
    originalSize?: SortOrder
    optimizedSize?: SortOrder
  }

  export type HeroImageMaxOrderByAggregateInput = {
    id?: SortOrder
    page?: SortOrder
    deviceType?: SortOrder
    imageUrl?: SortOrder
    alt?: SortOrder
    fileName?: SortOrder
    originalUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    isAiGenerated?: SortOrder
    aiPrompt?: SortOrder
    originalSize?: SortOrder
    optimizedSize?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HeroImageMinOrderByAggregateInput = {
    id?: SortOrder
    page?: SortOrder
    deviceType?: SortOrder
    imageUrl?: SortOrder
    alt?: SortOrder
    fileName?: SortOrder
    originalUrl?: SortOrder
    width?: SortOrder
    height?: SortOrder
    isAiGenerated?: SortOrder
    aiPrompt?: SortOrder
    originalSize?: SortOrder
    optimizedSize?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HeroImageSumOrderByAggregateInput = {
    width?: SortOrder
    height?: SortOrder
    originalSize?: SortOrder
    optimizedSize?: SortOrder
  }

  export type EnumHeroDeviceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HeroDeviceType | EnumHeroDeviceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HeroDeviceType[] | ListEnumHeroDeviceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HeroDeviceType[] | ListEnumHeroDeviceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHeroDeviceTypeWithAggregatesFilter<$PrismaModel> | $Enums.HeroDeviceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHeroDeviceTypeFilter<$PrismaModel>
    _max?: NestedEnumHeroDeviceTypeFilter<$PrismaModel>
  }

  export type EnumPropertyTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyTypeNullableFilter<$PrismaModel> | $Enums.PropertyType | null
  }

  export type EnumPropertyCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyCategory | EnumPropertyCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyCategoryNullableFilter<$PrismaModel> | $Enums.PropertyCategory | null
  }

  export type PropertyAlertCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    countryCode?: SortOrder
    userId?: SortOrder
    propertyType?: SortOrder
    category?: SortOrder
    locations?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    minBeds?: SortOrder
    maxBeds?: SortOrder
    minBaths?: SortOrder
    maxBaths?: SortOrder
    minSqft?: SortOrder
    maxSqft?: SortOrder
    notifyImmediately?: SortOrder
    notifyDigest?: SortOrder
    digestDay?: SortOrder
    isActive?: SortOrder
    lastNotifiedAt?: SortOrder
    matchCount?: SortOrder
    notificationCount?: SortOrder
    verificationToken?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    unsubscribeToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyAlertAvgOrderByAggregateInput = {
    minPrice?: SortOrder
    maxPrice?: SortOrder
    minBeds?: SortOrder
    maxBeds?: SortOrder
    minBaths?: SortOrder
    maxBaths?: SortOrder
    minSqft?: SortOrder
    maxSqft?: SortOrder
    matchCount?: SortOrder
    notificationCount?: SortOrder
  }

  export type PropertyAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    countryCode?: SortOrder
    userId?: SortOrder
    propertyType?: SortOrder
    category?: SortOrder
    locations?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    minBeds?: SortOrder
    maxBeds?: SortOrder
    minBaths?: SortOrder
    maxBaths?: SortOrder
    minSqft?: SortOrder
    maxSqft?: SortOrder
    notifyImmediately?: SortOrder
    notifyDigest?: SortOrder
    digestDay?: SortOrder
    isActive?: SortOrder
    lastNotifiedAt?: SortOrder
    matchCount?: SortOrder
    notificationCount?: SortOrder
    verificationToken?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    unsubscribeToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyAlertMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    countryCode?: SortOrder
    userId?: SortOrder
    propertyType?: SortOrder
    category?: SortOrder
    locations?: SortOrder
    minPrice?: SortOrder
    maxPrice?: SortOrder
    minBeds?: SortOrder
    maxBeds?: SortOrder
    minBaths?: SortOrder
    maxBaths?: SortOrder
    minSqft?: SortOrder
    maxSqft?: SortOrder
    notifyImmediately?: SortOrder
    notifyDigest?: SortOrder
    digestDay?: SortOrder
    isActive?: SortOrder
    lastNotifiedAt?: SortOrder
    matchCount?: SortOrder
    notificationCount?: SortOrder
    verificationToken?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    unsubscribeToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyAlertSumOrderByAggregateInput = {
    minPrice?: SortOrder
    maxPrice?: SortOrder
    minBeds?: SortOrder
    maxBeds?: SortOrder
    minBaths?: SortOrder
    maxBaths?: SortOrder
    minSqft?: SortOrder
    maxSqft?: SortOrder
    matchCount?: SortOrder
    notificationCount?: SortOrder
  }

  export type EnumPropertyTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeNullableFilter<$PrismaModel>
  }

  export type EnumPropertyCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyCategory | EnumPropertyCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.PropertyCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPropertyCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumPropertyCategoryNullableFilter<$PrismaModel>
  }

  export type PropertyAlertNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    alertId?: SortOrder
    propertyIds?: SortOrder
    propertyCount?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrder
    emailError?: SortOrder
    opened?: SortOrder
    openedAt?: SortOrder
    clicked?: SortOrder
    clickedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyAlertNotificationAvgOrderByAggregateInput = {
    propertyCount?: SortOrder
  }

  export type PropertyAlertNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    alertId?: SortOrder
    propertyIds?: SortOrder
    propertyCount?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrder
    emailError?: SortOrder
    opened?: SortOrder
    openedAt?: SortOrder
    clicked?: SortOrder
    clickedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyAlertNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    alertId?: SortOrder
    propertyIds?: SortOrder
    propertyCount?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrder
    emailError?: SortOrder
    opened?: SortOrder
    openedAt?: SortOrder
    clicked?: SortOrder
    clickedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyAlertNotificationSumOrderByAggregateInput = {
    propertyCount?: SortOrder
  }

  export type EnumPoiSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.PoiSource | EnumPoiSourceFieldRefInput<$PrismaModel>
    in?: $Enums.PoiSource[] | ListEnumPoiSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoiSource[] | ListEnumPoiSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumPoiSourceFilter<$PrismaModel> | $Enums.PoiSource
  }

  export type EnumPoiCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PoiCategory | EnumPoiCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PoiCategory[] | ListEnumPoiCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoiCategory[] | ListEnumPoiCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPoiCategoryFilter<$PrismaModel> | $Enums.PoiCategory
  }

  export type EnumNoiseLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.NoiseLevel | EnumNoiseLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.NoiseLevel[] | ListEnumNoiseLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NoiseLevel[] | ListEnumNoiseLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNoiseLevelNullableFilter<$PrismaModel> | $Enums.NoiseLevel | null
  }

  export type EnumTrafficLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TrafficLevel | EnumTrafficLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.TrafficLevel[] | ListEnumTrafficLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TrafficLevel[] | ListEnumTrafficLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTrafficLevelNullableFilter<$PrismaModel> | $Enums.TrafficLevel | null
  }

  export type PoiExternalIdSourceCompoundUniqueInput = {
    externalId: string
    source: $Enums.PoiSource
  }

  export type PoiCountOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    source?: SortOrder
    name?: SortOrder
    nameTh?: SortOrder
    nameLocal?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    address?: SortOrder
    district?: SortOrder
    osmTags?: SortOrder
    importance?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    noiseLevel?: SortOrder
    trafficLevel?: SortOrder
    lastSyncedAt?: SortOrder
    syncError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PoiAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    importance?: SortOrder
  }

  export type PoiMaxOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    source?: SortOrder
    name?: SortOrder
    nameTh?: SortOrder
    nameLocal?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    address?: SortOrder
    district?: SortOrder
    importance?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    noiseLevel?: SortOrder
    trafficLevel?: SortOrder
    lastSyncedAt?: SortOrder
    syncError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PoiMinOrderByAggregateInput = {
    id?: SortOrder
    externalId?: SortOrder
    source?: SortOrder
    name?: SortOrder
    nameTh?: SortOrder
    nameLocal?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    address?: SortOrder
    district?: SortOrder
    importance?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    noiseLevel?: SortOrder
    trafficLevel?: SortOrder
    lastSyncedAt?: SortOrder
    syncError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PoiSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    importance?: SortOrder
  }

  export type EnumPoiSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoiSource | EnumPoiSourceFieldRefInput<$PrismaModel>
    in?: $Enums.PoiSource[] | ListEnumPoiSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoiSource[] | ListEnumPoiSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumPoiSourceWithAggregatesFilter<$PrismaModel> | $Enums.PoiSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPoiSourceFilter<$PrismaModel>
    _max?: NestedEnumPoiSourceFilter<$PrismaModel>
  }

  export type EnumPoiCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoiCategory | EnumPoiCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PoiCategory[] | ListEnumPoiCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoiCategory[] | ListEnumPoiCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPoiCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PoiCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPoiCategoryFilter<$PrismaModel>
    _max?: NestedEnumPoiCategoryFilter<$PrismaModel>
  }

  export type EnumNoiseLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NoiseLevel | EnumNoiseLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.NoiseLevel[] | ListEnumNoiseLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NoiseLevel[] | ListEnumNoiseLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNoiseLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.NoiseLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumNoiseLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumNoiseLevelNullableFilter<$PrismaModel>
  }

  export type EnumTrafficLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrafficLevel | EnumTrafficLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.TrafficLevel[] | ListEnumTrafficLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TrafficLevel[] | ListEnumTrafficLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTrafficLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.TrafficLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTrafficLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumTrafficLevelNullableFilter<$PrismaModel>
  }

  export type PoiScalarRelationFilter = {
    is?: PoiWhereInput
    isNot?: PoiWhereInput
  }

  export type PropertyPoiDistancePropertyIdPoiIdCompoundUniqueInput = {
    propertyId: string
    poiId: string
  }

  export type PropertyPoiDistanceCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    poiId?: SortOrder
    distanceMeters?: SortOrder
    walkingMinutes?: SortOrder
    drivingMinutes?: SortOrder
    isHighlight?: SortOrder
    calculatedAt?: SortOrder
  }

  export type PropertyPoiDistanceAvgOrderByAggregateInput = {
    distanceMeters?: SortOrder
    walkingMinutes?: SortOrder
    drivingMinutes?: SortOrder
  }

  export type PropertyPoiDistanceMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    poiId?: SortOrder
    distanceMeters?: SortOrder
    walkingMinutes?: SortOrder
    drivingMinutes?: SortOrder
    isHighlight?: SortOrder
    calculatedAt?: SortOrder
  }

  export type PropertyPoiDistanceMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    poiId?: SortOrder
    distanceMeters?: SortOrder
    walkingMinutes?: SortOrder
    drivingMinutes?: SortOrder
    isHighlight?: SortOrder
    calculatedAt?: SortOrder
  }

  export type PropertyPoiDistanceSumOrderByAggregateInput = {
    distanceMeters?: SortOrder
    walkingMinutes?: SortOrder
    drivingMinutes?: SortOrder
  }

  export type EnumPoiSyncJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PoiSyncJobType | EnumPoiSyncJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PoiSyncJobType[] | ListEnumPoiSyncJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoiSyncJobType[] | ListEnumPoiSyncJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPoiSyncJobTypeFilter<$PrismaModel> | $Enums.PoiSyncJobType
  }

  export type EnumPoiSyncJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PoiSyncJobStatus | EnumPoiSyncJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PoiSyncJobStatus[] | ListEnumPoiSyncJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoiSyncJobStatus[] | ListEnumPoiSyncJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPoiSyncJobStatusFilter<$PrismaModel> | $Enums.PoiSyncJobStatus
  }

  export type EnumPoiCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PoiCategory | EnumPoiCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.PoiCategory[] | ListEnumPoiCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PoiCategory[] | ListEnumPoiCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPoiCategoryNullableFilter<$PrismaModel> | $Enums.PoiCategory | null
  }

  export type PoiSyncJobCountOrderByAggregateInput = {
    id?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    category?: SortOrder
    district?: SortOrder
    poisFetched?: SortOrder
    poisCreated?: SortOrder
    poisUpdated?: SortOrder
    poisSkipped?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    errorStack?: SortOrder
    createdAt?: SortOrder
  }

  export type PoiSyncJobAvgOrderByAggregateInput = {
    poisFetched?: SortOrder
    poisCreated?: SortOrder
    poisUpdated?: SortOrder
    poisSkipped?: SortOrder
  }

  export type PoiSyncJobMaxOrderByAggregateInput = {
    id?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    category?: SortOrder
    district?: SortOrder
    poisFetched?: SortOrder
    poisCreated?: SortOrder
    poisUpdated?: SortOrder
    poisSkipped?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    errorStack?: SortOrder
    createdAt?: SortOrder
  }

  export type PoiSyncJobMinOrderByAggregateInput = {
    id?: SortOrder
    jobType?: SortOrder
    status?: SortOrder
    category?: SortOrder
    district?: SortOrder
    poisFetched?: SortOrder
    poisCreated?: SortOrder
    poisUpdated?: SortOrder
    poisSkipped?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    errorStack?: SortOrder
    createdAt?: SortOrder
  }

  export type PoiSyncJobSumOrderByAggregateInput = {
    poisFetched?: SortOrder
    poisCreated?: SortOrder
    poisUpdated?: SortOrder
    poisSkipped?: SortOrder
  }

  export type EnumPoiSyncJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoiSyncJobType | EnumPoiSyncJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PoiSyncJobType[] | ListEnumPoiSyncJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoiSyncJobType[] | ListEnumPoiSyncJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPoiSyncJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.PoiSyncJobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPoiSyncJobTypeFilter<$PrismaModel>
    _max?: NestedEnumPoiSyncJobTypeFilter<$PrismaModel>
  }

  export type EnumPoiSyncJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoiSyncJobStatus | EnumPoiSyncJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PoiSyncJobStatus[] | ListEnumPoiSyncJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoiSyncJobStatus[] | ListEnumPoiSyncJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPoiSyncJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.PoiSyncJobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPoiSyncJobStatusFilter<$PrismaModel>
    _max?: NestedEnumPoiSyncJobStatusFilter<$PrismaModel>
  }

  export type EnumPoiCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoiCategory | EnumPoiCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.PoiCategory[] | ListEnumPoiCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PoiCategory[] | ListEnumPoiCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPoiCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.PoiCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPoiCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumPoiCategoryNullableFilter<$PrismaModel>
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type RentalPricingConfigCountOrderByAggregateInput = {
    id?: SortOrder
    peakSeasonMonths?: SortOrder
    peakSeasonSurcharges?: SortOrder
    lowSeasonSurcharges?: SortOrder
    minimumStayDays?: SortOrder
    maximumStayDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RentalPricingConfigAvgOrderByAggregateInput = {
    peakSeasonMonths?: SortOrder
    minimumStayDays?: SortOrder
    maximumStayDays?: SortOrder
  }

  export type RentalPricingConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    minimumStayDays?: SortOrder
    maximumStayDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RentalPricingConfigMinOrderByAggregateInput = {
    id?: SortOrder
    minimumStayDays?: SortOrder
    maximumStayDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RentalPricingConfigSumOrderByAggregateInput = {
    peakSeasonMonths?: SortOrder
    minimumStayDays?: SortOrder
    maximumStayDays?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumRentalBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RentalBookingStatus | EnumRentalBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RentalBookingStatus[] | ListEnumRentalBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RentalBookingStatus[] | ListEnumRentalBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRentalBookingStatusFilter<$PrismaModel> | $Enums.RentalBookingStatus
  }

  export type EnumTM30BookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TM30BookingStatus | EnumTM30BookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TM30BookingStatus[] | ListEnumTM30BookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TM30BookingStatus[] | ListEnumTM30BookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTM30BookingStatusFilter<$PrismaModel> | $Enums.TM30BookingStatus
  }

  export type BookingMessageListRelationFilter = {
    every?: BookingMessageWhereInput
    some?: BookingMessageWhereInput
    none?: BookingMessageWhereInput
  }

  export type BookingGuestListRelationFilter = {
    every?: BookingGuestWhereInput
    some?: BookingGuestWhereInput
    none?: BookingGuestWhereInput
  }

  export type BookingMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingGuestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RentalBookingCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    userId?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    nights?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    babies?: SortOrder
    pets?: SortOrder
    basePrice?: SortOrder
    season?: SortOrder
    discountPercent?: SortOrder
    totalPrice?: SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrder
    guestCountryCode?: SortOrder
    guestMessage?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    cancellationPolicy?: SortOrder
    cancelledAt?: SortOrder
    cancellationReason?: SortOrder
    internalNotes?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    propertyAddress?: SortOrder
    propertyInstructions?: SortOrder
    wifiName?: SortOrder
    wifiPassword?: SortOrder
    accessCode?: SortOrder
    emergencyContact?: SortOrder
    houseRules?: SortOrder
    confirmedAt?: SortOrder
    agentId?: SortOrder
    tm30Status?: SortOrder
    tm30SubmittedAt?: SortOrder
    tm30Reference?: SortOrder
    tm30Error?: SortOrder
    passportsRequired?: SortOrder
    passportsReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RentalBookingAvgOrderByAggregateInput = {
    nights?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    babies?: SortOrder
    pets?: SortOrder
    basePrice?: SortOrder
    discountPercent?: SortOrder
    totalPrice?: SortOrder
    passportsRequired?: SortOrder
    passportsReceived?: SortOrder
  }

  export type RentalBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    userId?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    nights?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    babies?: SortOrder
    pets?: SortOrder
    basePrice?: SortOrder
    season?: SortOrder
    discountPercent?: SortOrder
    totalPrice?: SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrder
    guestCountryCode?: SortOrder
    guestMessage?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    cancellationPolicy?: SortOrder
    cancelledAt?: SortOrder
    cancellationReason?: SortOrder
    internalNotes?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    propertyAddress?: SortOrder
    propertyInstructions?: SortOrder
    wifiName?: SortOrder
    wifiPassword?: SortOrder
    accessCode?: SortOrder
    emergencyContact?: SortOrder
    houseRules?: SortOrder
    confirmedAt?: SortOrder
    agentId?: SortOrder
    tm30Status?: SortOrder
    tm30SubmittedAt?: SortOrder
    tm30Reference?: SortOrder
    tm30Error?: SortOrder
    passportsRequired?: SortOrder
    passportsReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RentalBookingMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    userId?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    nights?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    babies?: SortOrder
    pets?: SortOrder
    basePrice?: SortOrder
    season?: SortOrder
    discountPercent?: SortOrder
    totalPrice?: SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrder
    guestCountryCode?: SortOrder
    guestMessage?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    cancellationPolicy?: SortOrder
    cancelledAt?: SortOrder
    cancellationReason?: SortOrder
    internalNotes?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    propertyAddress?: SortOrder
    propertyInstructions?: SortOrder
    wifiName?: SortOrder
    wifiPassword?: SortOrder
    accessCode?: SortOrder
    emergencyContact?: SortOrder
    houseRules?: SortOrder
    confirmedAt?: SortOrder
    agentId?: SortOrder
    tm30Status?: SortOrder
    tm30SubmittedAt?: SortOrder
    tm30Reference?: SortOrder
    tm30Error?: SortOrder
    passportsRequired?: SortOrder
    passportsReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RentalBookingSumOrderByAggregateInput = {
    nights?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    babies?: SortOrder
    pets?: SortOrder
    basePrice?: SortOrder
    discountPercent?: SortOrder
    totalPrice?: SortOrder
    passportsRequired?: SortOrder
    passportsReceived?: SortOrder
  }

  export type EnumRentalBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RentalBookingStatus | EnumRentalBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RentalBookingStatus[] | ListEnumRentalBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RentalBookingStatus[] | ListEnumRentalBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRentalBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.RentalBookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRentalBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumRentalBookingStatusFilter<$PrismaModel>
  }

  export type EnumTM30BookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TM30BookingStatus | EnumTM30BookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TM30BookingStatus[] | ListEnumTM30BookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TM30BookingStatus[] | ListEnumTM30BookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTM30BookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.TM30BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTM30BookingStatusFilter<$PrismaModel>
    _max?: NestedEnumTM30BookingStatusFilter<$PrismaModel>
  }

  export type RentalBookingScalarRelationFilter = {
    is?: RentalBookingWhereInput
    isNot?: RentalBookingWhereInput
  }

  export type BookingMessageCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    senderId?: SortOrder
    senderRole?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    senderId?: SortOrder
    senderRole?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingMessageMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    senderId?: SortOrder
    senderRole?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTM30GuestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TM30GuestStatus | EnumTM30GuestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TM30GuestStatus[] | ListEnumTM30GuestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TM30GuestStatus[] | ListEnumTM30GuestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTM30GuestStatusFilter<$PrismaModel> | $Enums.TM30GuestStatus
  }

  export type BookingGuestCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    guestType?: SortOrder
    guestNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    gender?: SortOrder
    passportNumber?: SortOrder
    passportExpiry?: SortOrder
    passportIssueDate?: SortOrder
    passportCountry?: SortOrder
    passportImageUrl?: SortOrder
    passportImagePath?: SortOrder
    ocrConfidence?: SortOrder
    ocrRawData?: SortOrder
    ocrProcessedAt?: SortOrder
    passportVerified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    tm30Status?: SortOrder
    tm30SubmittedAt?: SortOrder
    tm30Error?: SortOrder
    whatsappMessageId?: SortOrder
    whatsappReceivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingGuestAvgOrderByAggregateInput = {
    guestNumber?: SortOrder
    ocrConfidence?: SortOrder
  }

  export type BookingGuestMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    guestType?: SortOrder
    guestNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    gender?: SortOrder
    passportNumber?: SortOrder
    passportExpiry?: SortOrder
    passportIssueDate?: SortOrder
    passportCountry?: SortOrder
    passportImageUrl?: SortOrder
    passportImagePath?: SortOrder
    ocrConfidence?: SortOrder
    ocrProcessedAt?: SortOrder
    passportVerified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    tm30Status?: SortOrder
    tm30SubmittedAt?: SortOrder
    tm30Error?: SortOrder
    whatsappMessageId?: SortOrder
    whatsappReceivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingGuestMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    guestType?: SortOrder
    guestNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    dateOfBirth?: SortOrder
    nationality?: SortOrder
    gender?: SortOrder
    passportNumber?: SortOrder
    passportExpiry?: SortOrder
    passportIssueDate?: SortOrder
    passportCountry?: SortOrder
    passportImageUrl?: SortOrder
    passportImagePath?: SortOrder
    ocrConfidence?: SortOrder
    ocrProcessedAt?: SortOrder
    passportVerified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    tm30Status?: SortOrder
    tm30SubmittedAt?: SortOrder
    tm30Error?: SortOrder
    whatsappMessageId?: SortOrder
    whatsappReceivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingGuestSumOrderByAggregateInput = {
    guestNumber?: SortOrder
    ocrConfidence?: SortOrder
  }

  export type EnumTM30GuestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TM30GuestStatus | EnumTM30GuestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TM30GuestStatus[] | ListEnumTM30GuestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TM30GuestStatus[] | ListEnumTM30GuestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTM30GuestStatusWithAggregatesFilter<$PrismaModel> | $Enums.TM30GuestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTM30GuestStatusFilter<$PrismaModel>
    _max?: NestedEnumTM30GuestStatusFilter<$PrismaModel>
  }

  export type PropertyBlockedDateCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
    blockedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyBlockedDateMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
    blockedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyBlockedDateMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
    blockedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Tm30AccommodationCountOrderByAggregateInput = {
    id?: SortOrder
    tm30Id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    status?: SortOrder
    propertyId?: SortOrder
    matchScore?: SortOrder
    matchedBy?: SortOrder
    matchedAt?: SortOrder
    lastSyncedAt?: SortOrder
    syncSource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Tm30AccommodationAvgOrderByAggregateInput = {
    matchScore?: SortOrder
  }

  export type Tm30AccommodationMaxOrderByAggregateInput = {
    id?: SortOrder
    tm30Id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    status?: SortOrder
    propertyId?: SortOrder
    matchScore?: SortOrder
    matchedBy?: SortOrder
    matchedAt?: SortOrder
    lastSyncedAt?: SortOrder
    syncSource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Tm30AccommodationMinOrderByAggregateInput = {
    id?: SortOrder
    tm30Id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    status?: SortOrder
    propertyId?: SortOrder
    matchScore?: SortOrder
    matchedBy?: SortOrder
    matchedAt?: SortOrder
    lastSyncedAt?: SortOrder
    syncSource?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Tm30AccommodationSumOrderByAggregateInput = {
    matchScore?: SortOrder
  }

  export type EnumTm30AccomRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Tm30AccomRequestStatus | EnumTm30AccomRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Tm30AccomRequestStatus[] | ListEnumTm30AccomRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Tm30AccomRequestStatus[] | ListEnumTm30AccomRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTm30AccomRequestStatusFilter<$PrismaModel> | $Enums.Tm30AccomRequestStatus
  }

  export type Tm30AccommodationRequestCountOrderByAggregateInput = {
    id?: SortOrder
    ownerSameAsRegistrant?: SortOrder
    ownerNationalType?: SortOrder
    ownerNationalId?: SortOrder
    ownerPassportNumber?: SortOrder
    ownerFirstName?: SortOrder
    ownerMiddleName?: SortOrder
    ownerLastName?: SortOrder
    ownerTelephone?: SortOrder
    ownerGender?: SortOrder
    entityType?: SortOrder
    houseIdNumber?: SortOrder
    accommodationType?: SortOrder
    accommodationName?: SortOrder
    position?: SortOrder
    positionOther?: SortOrder
    addressNumber?: SortOrder
    villageNumber?: SortOrder
    alley?: SortOrder
    road?: SortOrder
    province?: SortOrder
    district?: SortOrder
    subDistrict?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    houseRegistrationUrl?: SortOrder
    houseRegistrationPath?: SortOrder
    ocrProcessed?: SortOrder
    ocrProcessedAt?: SortOrder
    ocrRawData?: SortOrder
    ocrConfidence?: SortOrder
    status?: SortOrder
    tm30Id?: SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    rejectionReason?: SortOrder
    errorMessage?: SortOrder
    propertyId?: SortOrder
    propertyOwnerId?: SortOrder
    whatsappPhone?: SortOrder
    whatsappSessionId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Tm30AccommodationRequestAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    ocrConfidence?: SortOrder
  }

  export type Tm30AccommodationRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerSameAsRegistrant?: SortOrder
    ownerNationalType?: SortOrder
    ownerNationalId?: SortOrder
    ownerPassportNumber?: SortOrder
    ownerFirstName?: SortOrder
    ownerMiddleName?: SortOrder
    ownerLastName?: SortOrder
    ownerTelephone?: SortOrder
    ownerGender?: SortOrder
    entityType?: SortOrder
    houseIdNumber?: SortOrder
    accommodationType?: SortOrder
    accommodationName?: SortOrder
    position?: SortOrder
    positionOther?: SortOrder
    addressNumber?: SortOrder
    villageNumber?: SortOrder
    alley?: SortOrder
    road?: SortOrder
    province?: SortOrder
    district?: SortOrder
    subDistrict?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    houseRegistrationUrl?: SortOrder
    houseRegistrationPath?: SortOrder
    ocrProcessed?: SortOrder
    ocrProcessedAt?: SortOrder
    ocrConfidence?: SortOrder
    status?: SortOrder
    tm30Id?: SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    rejectionReason?: SortOrder
    errorMessage?: SortOrder
    propertyId?: SortOrder
    propertyOwnerId?: SortOrder
    whatsappPhone?: SortOrder
    whatsappSessionId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Tm30AccommodationRequestMinOrderByAggregateInput = {
    id?: SortOrder
    ownerSameAsRegistrant?: SortOrder
    ownerNationalType?: SortOrder
    ownerNationalId?: SortOrder
    ownerPassportNumber?: SortOrder
    ownerFirstName?: SortOrder
    ownerMiddleName?: SortOrder
    ownerLastName?: SortOrder
    ownerTelephone?: SortOrder
    ownerGender?: SortOrder
    entityType?: SortOrder
    houseIdNumber?: SortOrder
    accommodationType?: SortOrder
    accommodationName?: SortOrder
    position?: SortOrder
    positionOther?: SortOrder
    addressNumber?: SortOrder
    villageNumber?: SortOrder
    alley?: SortOrder
    road?: SortOrder
    province?: SortOrder
    district?: SortOrder
    subDistrict?: SortOrder
    postalCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    houseRegistrationUrl?: SortOrder
    houseRegistrationPath?: SortOrder
    ocrProcessed?: SortOrder
    ocrProcessedAt?: SortOrder
    ocrConfidence?: SortOrder
    status?: SortOrder
    tm30Id?: SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    rejectionReason?: SortOrder
    errorMessage?: SortOrder
    propertyId?: SortOrder
    propertyOwnerId?: SortOrder
    whatsappPhone?: SortOrder
    whatsappSessionId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Tm30AccommodationRequestSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    ocrConfidence?: SortOrder
  }

  export type EnumTm30AccomRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tm30AccomRequestStatus | EnumTm30AccomRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Tm30AccomRequestStatus[] | ListEnumTm30AccomRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Tm30AccomRequestStatus[] | ListEnumTm30AccomRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTm30AccomRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.Tm30AccomRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTm30AccomRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumTm30AccomRequestStatusFilter<$PrismaModel>
  }

  export type OwnerDocumentListRelationFilter = {
    every?: OwnerDocumentWhereInput
    some?: OwnerDocumentWhereInput
    none?: OwnerDocumentWhereInput
  }

  export type Tm30AccommodationRequestListRelationFilter = {
    every?: Tm30AccommodationRequestWhereInput
    some?: Tm30AccommodationRequestWhereInput
    none?: Tm30AccommodationRequestWhereInput
  }

  export type OwnerDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Tm30AccommodationRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyOwnerCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    thaiIdNumber?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    gender?: SortOrder
    idCardUrl?: SortOrder
    idCardPath?: SortOrder
    idCardOcrData?: SortOrder
    idCardVerified?: SortOrder
    idCardUploadedAt?: SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyOwnerMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    thaiIdNumber?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    gender?: SortOrder
    idCardUrl?: SortOrder
    idCardPath?: SortOrder
    idCardVerified?: SortOrder
    idCardUploadedAt?: SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyOwnerMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    thaiIdNumber?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    gender?: SortOrder
    idCardUrl?: SortOrder
    idCardPath?: SortOrder
    idCardVerified?: SortOrder
    idCardUploadedAt?: SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumOwnerDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OwnerDocumentType | EnumOwnerDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OwnerDocumentType[] | ListEnumOwnerDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OwnerDocumentType[] | ListEnumOwnerDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOwnerDocumentTypeFilter<$PrismaModel> | $Enums.OwnerDocumentType
  }

  export type PropertyOwnerScalarRelationFilter = {
    is?: PropertyOwnerWhereInput
    isNot?: PropertyOwnerWhereInput
  }

  export type OwnerDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    documentType?: SortOrder
    imageUrl?: SortOrder
    imagePath?: SortOrder
    fileName?: SortOrder
    ocrData?: SortOrder
    ocrProcessedAt?: SortOrder
    ocrConfidence?: SortOrder
    propertyId?: SortOrder
    houseId?: SortOrder
    extractedAddress?: SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OwnerDocumentAvgOrderByAggregateInput = {
    ocrConfidence?: SortOrder
  }

  export type OwnerDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    documentType?: SortOrder
    imageUrl?: SortOrder
    imagePath?: SortOrder
    fileName?: SortOrder
    ocrProcessedAt?: SortOrder
    ocrConfidence?: SortOrder
    propertyId?: SortOrder
    houseId?: SortOrder
    extractedAddress?: SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OwnerDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    documentType?: SortOrder
    imageUrl?: SortOrder
    imagePath?: SortOrder
    fileName?: SortOrder
    ocrProcessedAt?: SortOrder
    ocrConfidence?: SortOrder
    propertyId?: SortOrder
    houseId?: SortOrder
    extractedAddress?: SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OwnerDocumentSumOrderByAggregateInput = {
    ocrConfidence?: SortOrder
  }

  export type EnumOwnerDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OwnerDocumentType | EnumOwnerDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OwnerDocumentType[] | ListEnumOwnerDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OwnerDocumentType[] | ListEnumOwnerDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOwnerDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.OwnerDocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOwnerDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumOwnerDocumentTypeFilter<$PrismaModel>
  }

  export type WhatsappListingSessionCountOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    currentAction?: SortOrder
    ownerId?: SortOrder
    currentPropertyId?: SortOrder
    tm30RequestId?: SortOrder
    tm30OwnerFirstName?: SortOrder
    tm30OwnerLastName?: SortOrder
    tm30OwnerGender?: SortOrder
    tm30OwnerPhone?: SortOrder
    tm30ThaiIdNumber?: SortOrder
    tm30IdCardUrl?: SortOrder
    tm30BluebookUrl?: SortOrder
    tm30HouseId?: SortOrder
    tm30Province?: SortOrder
    tm30District?: SortOrder
    tm30SubDistrict?: SortOrder
    tm30AddressNumber?: SortOrder
    tm30PostalCode?: SortOrder
    tm30AccommodationName?: SortOrder
    pendingData?: SortOrder
    lastMessageAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsappListingSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    currentAction?: SortOrder
    ownerId?: SortOrder
    currentPropertyId?: SortOrder
    tm30RequestId?: SortOrder
    tm30OwnerFirstName?: SortOrder
    tm30OwnerLastName?: SortOrder
    tm30OwnerGender?: SortOrder
    tm30OwnerPhone?: SortOrder
    tm30ThaiIdNumber?: SortOrder
    tm30IdCardUrl?: SortOrder
    tm30BluebookUrl?: SortOrder
    tm30HouseId?: SortOrder
    tm30Province?: SortOrder
    tm30District?: SortOrder
    tm30SubDistrict?: SortOrder
    tm30AddressNumber?: SortOrder
    tm30PostalCode?: SortOrder
    tm30AccommodationName?: SortOrder
    lastMessageAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsappListingSessionMinOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    currentAction?: SortOrder
    ownerId?: SortOrder
    currentPropertyId?: SortOrder
    tm30RequestId?: SortOrder
    tm30OwnerFirstName?: SortOrder
    tm30OwnerLastName?: SortOrder
    tm30OwnerGender?: SortOrder
    tm30OwnerPhone?: SortOrder
    tm30ThaiIdNumber?: SortOrder
    tm30IdCardUrl?: SortOrder
    tm30BluebookUrl?: SortOrder
    tm30HouseId?: SortOrder
    tm30Province?: SortOrder
    tm30District?: SortOrder
    tm30SubDistrict?: SortOrder
    tm30AddressNumber?: SortOrder
    tm30PostalCode?: SortOrder
    tm30AccommodationName?: SortOrder
    lastMessageAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIAgentConfigCountOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    autonomousMode?: SortOrder
    minConfidenceThreshold?: SortOrder
    dailyDecisionLimit?: SortOrder
    dailyAutoExecuteLimit?: SortOrder
    notifyOnDecision?: SortOrder
    notifyOnAutoExecute?: SortOrder
    notifyEmail?: SortOrder
    allowedAutonomousTypes?: SortOrder
    forbiddenPatterns?: SortOrder
    learningEnabled?: SortOrder
    feedbackLoopDays?: SortOrder
    killSwitch?: SortOrder
    pausedUntil?: SortOrder
    pauseReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIAgentConfigAvgOrderByAggregateInput = {
    minConfidenceThreshold?: SortOrder
    dailyDecisionLimit?: SortOrder
    dailyAutoExecuteLimit?: SortOrder
    feedbackLoopDays?: SortOrder
  }

  export type AIAgentConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    autonomousMode?: SortOrder
    minConfidenceThreshold?: SortOrder
    dailyDecisionLimit?: SortOrder
    dailyAutoExecuteLimit?: SortOrder
    notifyOnDecision?: SortOrder
    notifyOnAutoExecute?: SortOrder
    notifyEmail?: SortOrder
    allowedAutonomousTypes?: SortOrder
    forbiddenPatterns?: SortOrder
    learningEnabled?: SortOrder
    feedbackLoopDays?: SortOrder
    killSwitch?: SortOrder
    pausedUntil?: SortOrder
    pauseReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIAgentConfigMinOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    autonomousMode?: SortOrder
    minConfidenceThreshold?: SortOrder
    dailyDecisionLimit?: SortOrder
    dailyAutoExecuteLimit?: SortOrder
    notifyOnDecision?: SortOrder
    notifyOnAutoExecute?: SortOrder
    notifyEmail?: SortOrder
    allowedAutonomousTypes?: SortOrder
    forbiddenPatterns?: SortOrder
    learningEnabled?: SortOrder
    feedbackLoopDays?: SortOrder
    killSwitch?: SortOrder
    pausedUntil?: SortOrder
    pauseReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIAgentConfigSumOrderByAggregateInput = {
    minConfidenceThreshold?: SortOrder
    dailyDecisionLimit?: SortOrder
    dailyAutoExecuteLimit?: SortOrder
    feedbackLoopDays?: SortOrder
  }

  export type EnumAIDecisionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AIDecisionStatus | EnumAIDecisionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AIDecisionStatus[] | ListEnumAIDecisionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIDecisionStatus[] | ListEnumAIDecisionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAIDecisionStatusFilter<$PrismaModel> | $Enums.AIDecisionStatus
  }

  export type AICodeChangeListRelationFilter = {
    every?: AICodeChangeWhereInput
    some?: AICodeChangeWhereInput
    none?: AICodeChangeWhereInput
  }

  export type AIAgentLogListRelationFilter = {
    every?: AIAgentLogWhereInput
    some?: AIAgentLogWhereInput
    none?: AIAgentLogWhereInput
  }

  export type AICodeChangeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIAgentLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIDecisionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    subType?: SortOrder
    priority?: SortOrder
    confidence?: SortOrder
    reasoning?: SortOrder
    dataSnapshot?: SortOrder
    actionType?: SortOrder
    actionPayload?: SortOrder
    estimatedImpact?: SortOrder
    rollbackPlan?: SortOrder
    requiresApproval?: SortOrder
    autoApproved?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedByName?: SortOrder
    approvedAt?: SortOrder
    rejectedBy?: SortOrder
    rejectedByName?: SortOrder
    rejectedAt?: SortOrder
    rejectionReason?: SortOrder
    executedAt?: SortOrder
    executionResult?: SortOrder
    executionError?: SortOrder
    executionDuration?: SortOrder
    rolledBackAt?: SortOrder
    rolledBackBy?: SortOrder
    rollbackReason?: SortOrder
    feedbackDueAt?: SortOrder
    actualImpact?: SortOrder
    wasSuccessful?: SortOrder
    successScore?: SortOrder
    feedbackNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIDecisionAvgOrderByAggregateInput = {
    confidence?: SortOrder
    executionDuration?: SortOrder
    successScore?: SortOrder
  }

  export type AIDecisionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    subType?: SortOrder
    priority?: SortOrder
    confidence?: SortOrder
    reasoning?: SortOrder
    actionType?: SortOrder
    estimatedImpact?: SortOrder
    rollbackPlan?: SortOrder
    requiresApproval?: SortOrder
    autoApproved?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedByName?: SortOrder
    approvedAt?: SortOrder
    rejectedBy?: SortOrder
    rejectedByName?: SortOrder
    rejectedAt?: SortOrder
    rejectionReason?: SortOrder
    executedAt?: SortOrder
    executionError?: SortOrder
    executionDuration?: SortOrder
    rolledBackAt?: SortOrder
    rolledBackBy?: SortOrder
    rollbackReason?: SortOrder
    feedbackDueAt?: SortOrder
    wasSuccessful?: SortOrder
    successScore?: SortOrder
    feedbackNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIDecisionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    subType?: SortOrder
    priority?: SortOrder
    confidence?: SortOrder
    reasoning?: SortOrder
    actionType?: SortOrder
    estimatedImpact?: SortOrder
    rollbackPlan?: SortOrder
    requiresApproval?: SortOrder
    autoApproved?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedByName?: SortOrder
    approvedAt?: SortOrder
    rejectedBy?: SortOrder
    rejectedByName?: SortOrder
    rejectedAt?: SortOrder
    rejectionReason?: SortOrder
    executedAt?: SortOrder
    executionError?: SortOrder
    executionDuration?: SortOrder
    rolledBackAt?: SortOrder
    rolledBackBy?: SortOrder
    rollbackReason?: SortOrder
    feedbackDueAt?: SortOrder
    wasSuccessful?: SortOrder
    successScore?: SortOrder
    feedbackNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIDecisionSumOrderByAggregateInput = {
    confidence?: SortOrder
    executionDuration?: SortOrder
    successScore?: SortOrder
  }

  export type EnumAIDecisionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIDecisionStatus | EnumAIDecisionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AIDecisionStatus[] | ListEnumAIDecisionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIDecisionStatus[] | ListEnumAIDecisionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAIDecisionStatusWithAggregatesFilter<$PrismaModel> | $Enums.AIDecisionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIDecisionStatusFilter<$PrismaModel>
    _max?: NestedEnumAIDecisionStatusFilter<$PrismaModel>
  }

  export type EnumAICodeActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AICodeAction | EnumAICodeActionFieldRefInput<$PrismaModel>
    in?: $Enums.AICodeAction[] | ListEnumAICodeActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AICodeAction[] | ListEnumAICodeActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAICodeActionFilter<$PrismaModel> | $Enums.AICodeAction
  }

  export type AIDecisionScalarRelationFilter = {
    is?: AIDecisionWhereInput
    isNot?: AIDecisionWhereInput
  }

  export type AICodeChangeCountOrderByAggregateInput = {
    id?: SortOrder
    decisionId?: SortOrder
    filePath?: SortOrder
    action?: SortOrder
    originalContent?: SortOrder
    newContent?: SortOrder
    diff?: SortOrder
    syntaxValid?: SortOrder
    typesValid?: SortOrder
    lintPassed?: SortOrder
    testsPassed?: SortOrder
    appliedAt?: SortOrder
    rolledBackAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AICodeChangeMaxOrderByAggregateInput = {
    id?: SortOrder
    decisionId?: SortOrder
    filePath?: SortOrder
    action?: SortOrder
    originalContent?: SortOrder
    newContent?: SortOrder
    diff?: SortOrder
    syntaxValid?: SortOrder
    typesValid?: SortOrder
    lintPassed?: SortOrder
    testsPassed?: SortOrder
    appliedAt?: SortOrder
    rolledBackAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AICodeChangeMinOrderByAggregateInput = {
    id?: SortOrder
    decisionId?: SortOrder
    filePath?: SortOrder
    action?: SortOrder
    originalContent?: SortOrder
    newContent?: SortOrder
    diff?: SortOrder
    syntaxValid?: SortOrder
    typesValid?: SortOrder
    lintPassed?: SortOrder
    testsPassed?: SortOrder
    appliedAt?: SortOrder
    rolledBackAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAICodeActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AICodeAction | EnumAICodeActionFieldRefInput<$PrismaModel>
    in?: $Enums.AICodeAction[] | ListEnumAICodeActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AICodeAction[] | ListEnumAICodeActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAICodeActionWithAggregatesFilter<$PrismaModel> | $Enums.AICodeAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAICodeActionFilter<$PrismaModel>
    _max?: NestedEnumAICodeActionFilter<$PrismaModel>
  }

  export type EnumAILogLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AILogLevel | EnumAILogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AILogLevel[] | ListEnumAILogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AILogLevel[] | ListEnumAILogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAILogLevelFilter<$PrismaModel> | $Enums.AILogLevel
  }

  export type AIDecisionNullableScalarRelationFilter = {
    is?: AIDecisionWhereInput | null
    isNot?: AIDecisionWhereInput | null
  }

  export type AIAgentLogCountOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    category?: SortOrder
    message?: SortOrder
    data?: SortOrder
    decisionId?: SortOrder
    errorCode?: SortOrder
    errorStack?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
  }

  export type AIAgentLogAvgOrderByAggregateInput = {
    durationMs?: SortOrder
  }

  export type AIAgentLogMaxOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    category?: SortOrder
    message?: SortOrder
    decisionId?: SortOrder
    errorCode?: SortOrder
    errorStack?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
  }

  export type AIAgentLogMinOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    category?: SortOrder
    message?: SortOrder
    decisionId?: SortOrder
    errorCode?: SortOrder
    errorStack?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
  }

  export type AIAgentLogSumOrderByAggregateInput = {
    durationMs?: SortOrder
  }

  export type EnumAILogLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AILogLevel | EnumAILogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AILogLevel[] | ListEnumAILogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AILogLevel[] | ListEnumAILogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAILogLevelWithAggregatesFilter<$PrismaModel> | $Enums.AILogLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAILogLevelFilter<$PrismaModel>
    _max?: NestedEnumAILogLevelFilter<$PrismaModel>
  }

  export type AIDataSnapshotCountOrderByAggregateInput = {
    id?: SortOrder
    snapshotType?: SortOrder
    totalViews?: SortOrder
    uniqueVisitors?: SortOrder
    bounceRate?: SortOrder
    avgSessionDuration?: SortOrder
    totalInquiries?: SortOrder
    viewingRequests?: SortOrder
    investorLeads?: SortOrder
    rentalLeads?: SortOrder
    conversionRate?: SortOrder
    totalProperties?: SortOrder
    activeListings?: SortOrder
    newListings?: SortOrder
    avgPropertyViews?: SortOrder
    totalBlogs?: SortOrder
    publishedBlogs?: SortOrder
    avgBlogViews?: SortOrder
    organicTraffic?: SortOrder
    topKeywords?: SortOrder
    avgPosition?: SortOrder
    estimatedLeadValue?: SortOrder
    errorCount?: SortOrder
    slowPages?: SortOrder
    brokenLinks?: SortOrder
    rawData?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
  }

  export type AIDataSnapshotAvgOrderByAggregateInput = {
    totalViews?: SortOrder
    uniqueVisitors?: SortOrder
    bounceRate?: SortOrder
    avgSessionDuration?: SortOrder
    totalInquiries?: SortOrder
    viewingRequests?: SortOrder
    investorLeads?: SortOrder
    rentalLeads?: SortOrder
    conversionRate?: SortOrder
    totalProperties?: SortOrder
    activeListings?: SortOrder
    newListings?: SortOrder
    avgPropertyViews?: SortOrder
    totalBlogs?: SortOrder
    publishedBlogs?: SortOrder
    avgBlogViews?: SortOrder
    organicTraffic?: SortOrder
    avgPosition?: SortOrder
    estimatedLeadValue?: SortOrder
    errorCount?: SortOrder
    brokenLinks?: SortOrder
  }

  export type AIDataSnapshotMaxOrderByAggregateInput = {
    id?: SortOrder
    snapshotType?: SortOrder
    totalViews?: SortOrder
    uniqueVisitors?: SortOrder
    bounceRate?: SortOrder
    avgSessionDuration?: SortOrder
    totalInquiries?: SortOrder
    viewingRequests?: SortOrder
    investorLeads?: SortOrder
    rentalLeads?: SortOrder
    conversionRate?: SortOrder
    totalProperties?: SortOrder
    activeListings?: SortOrder
    newListings?: SortOrder
    avgPropertyViews?: SortOrder
    totalBlogs?: SortOrder
    publishedBlogs?: SortOrder
    avgBlogViews?: SortOrder
    organicTraffic?: SortOrder
    avgPosition?: SortOrder
    estimatedLeadValue?: SortOrder
    errorCount?: SortOrder
    brokenLinks?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
  }

  export type AIDataSnapshotMinOrderByAggregateInput = {
    id?: SortOrder
    snapshotType?: SortOrder
    totalViews?: SortOrder
    uniqueVisitors?: SortOrder
    bounceRate?: SortOrder
    avgSessionDuration?: SortOrder
    totalInquiries?: SortOrder
    viewingRequests?: SortOrder
    investorLeads?: SortOrder
    rentalLeads?: SortOrder
    conversionRate?: SortOrder
    totalProperties?: SortOrder
    activeListings?: SortOrder
    newListings?: SortOrder
    avgPropertyViews?: SortOrder
    totalBlogs?: SortOrder
    publishedBlogs?: SortOrder
    avgBlogViews?: SortOrder
    organicTraffic?: SortOrder
    avgPosition?: SortOrder
    estimatedLeadValue?: SortOrder
    errorCount?: SortOrder
    brokenLinks?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
  }

  export type AIDataSnapshotSumOrderByAggregateInput = {
    totalViews?: SortOrder
    uniqueVisitors?: SortOrder
    bounceRate?: SortOrder
    avgSessionDuration?: SortOrder
    totalInquiries?: SortOrder
    viewingRequests?: SortOrder
    investorLeads?: SortOrder
    rentalLeads?: SortOrder
    conversionRate?: SortOrder
    totalProperties?: SortOrder
    activeListings?: SortOrder
    newListings?: SortOrder
    avgPropertyViews?: SortOrder
    totalBlogs?: SortOrder
    publishedBlogs?: SortOrder
    avgBlogViews?: SortOrder
    organicTraffic?: SortOrder
    avgPosition?: SortOrder
    estimatedLeadValue?: SortOrder
    errorCount?: SortOrder
    brokenLinks?: SortOrder
  }

  export type EnumAIOpportunityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AIOpportunityStatus | EnumAIOpportunityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AIOpportunityStatus[] | ListEnumAIOpportunityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIOpportunityStatus[] | ListEnumAIOpportunityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAIOpportunityStatusFilter<$PrismaModel> | $Enums.AIOpportunityStatus
  }

  export type AIOpportunityCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    subType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    trigger?: SortOrder
    priority?: SortOrder
    estimatedEffort?: SortOrder
    estimatedImpact?: SortOrder
    potentialRevenue?: SortOrder
    potentialLeads?: SortOrder
    status?: SortOrder
    decisionId?: SortOrder
    identifiedAt?: SortOrder
    addressedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIOpportunityAvgOrderByAggregateInput = {
    priority?: SortOrder
    potentialRevenue?: SortOrder
    potentialLeads?: SortOrder
  }

  export type AIOpportunityMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    subType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    trigger?: SortOrder
    priority?: SortOrder
    estimatedEffort?: SortOrder
    estimatedImpact?: SortOrder
    potentialRevenue?: SortOrder
    potentialLeads?: SortOrder
    status?: SortOrder
    decisionId?: SortOrder
    identifiedAt?: SortOrder
    addressedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIOpportunityMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    subType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    trigger?: SortOrder
    priority?: SortOrder
    estimatedEffort?: SortOrder
    estimatedImpact?: SortOrder
    potentialRevenue?: SortOrder
    potentialLeads?: SortOrder
    status?: SortOrder
    decisionId?: SortOrder
    identifiedAt?: SortOrder
    addressedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIOpportunitySumOrderByAggregateInput = {
    priority?: SortOrder
    potentialRevenue?: SortOrder
    potentialLeads?: SortOrder
  }

  export type EnumAIOpportunityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIOpportunityStatus | EnumAIOpportunityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AIOpportunityStatus[] | ListEnumAIOpportunityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIOpportunityStatus[] | ListEnumAIOpportunityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAIOpportunityStatusWithAggregatesFilter<$PrismaModel> | $Enums.AIOpportunityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIOpportunityStatusFilter<$PrismaModel>
    _max?: NestedEnumAIOpportunityStatusFilter<$PrismaModel>
  }

  export type AILearningCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    insight?: SortOrder
    sourceDecisionId?: SortOrder
    confidence?: SortOrder
    impactArea?: SortOrder
    adjustment?: SortOrder
    validatedBy?: SortOrder
    validatedAt?: SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
  }

  export type AILearningAvgOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type AILearningMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    insight?: SortOrder
    sourceDecisionId?: SortOrder
    confidence?: SortOrder
    impactArea?: SortOrder
    adjustment?: SortOrder
    validatedBy?: SortOrder
    validatedAt?: SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
  }

  export type AILearningMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    insight?: SortOrder
    sourceDecisionId?: SortOrder
    confidence?: SortOrder
    impactArea?: SortOrder
    adjustment?: SortOrder
    validatedBy?: SortOrder
    validatedAt?: SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
  }

  export type AILearningSumOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type PropertyCreateNestedManyWithoutUserInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type InvestorLeadCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<InvestorLeadCreateWithoutAssignedToInput, InvestorLeadUncheckedCreateWithoutAssignedToInput> | InvestorLeadCreateWithoutAssignedToInput[] | InvestorLeadUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: InvestorLeadCreateOrConnectWithoutAssignedToInput | InvestorLeadCreateOrConnectWithoutAssignedToInput[]
    createMany?: InvestorLeadCreateManyAssignedToInputEnvelope
    connect?: InvestorLeadWhereUniqueInput | InvestorLeadWhereUniqueInput[]
  }

  export type RentalLeadCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<RentalLeadCreateWithoutAssignedToInput, RentalLeadUncheckedCreateWithoutAssignedToInput> | RentalLeadCreateWithoutAssignedToInput[] | RentalLeadUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: RentalLeadCreateOrConnectWithoutAssignedToInput | RentalLeadCreateOrConnectWithoutAssignedToInput[]
    createMany?: RentalLeadCreateManyAssignedToInputEnvelope
    connect?: RentalLeadWhereUniqueInput | RentalLeadWhereUniqueInput[]
  }

  export type BlogCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogCreateWithoutAuthorInput, BlogUncheckedCreateWithoutAuthorInput> | BlogCreateWithoutAuthorInput[] | BlogUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutAuthorInput | BlogCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogCreateManyAuthorInputEnvelope
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
  }

  export type RentalBookingCreateNestedManyWithoutUserInput = {
    create?: XOR<RentalBookingCreateWithoutUserInput, RentalBookingUncheckedCreateWithoutUserInput> | RentalBookingCreateWithoutUserInput[] | RentalBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RentalBookingCreateOrConnectWithoutUserInput | RentalBookingCreateOrConnectWithoutUserInput[]
    createMany?: RentalBookingCreateManyUserInputEnvelope
    connect?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
  }

  export type RentalBookingCreateNestedManyWithoutAgentInput = {
    create?: XOR<RentalBookingCreateWithoutAgentInput, RentalBookingUncheckedCreateWithoutAgentInput> | RentalBookingCreateWithoutAgentInput[] | RentalBookingUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: RentalBookingCreateOrConnectWithoutAgentInput | RentalBookingCreateOrConnectWithoutAgentInput[]
    createMany?: RentalBookingCreateManyAgentInputEnvelope
    connect?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type InvestorLeadUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<InvestorLeadCreateWithoutAssignedToInput, InvestorLeadUncheckedCreateWithoutAssignedToInput> | InvestorLeadCreateWithoutAssignedToInput[] | InvestorLeadUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: InvestorLeadCreateOrConnectWithoutAssignedToInput | InvestorLeadCreateOrConnectWithoutAssignedToInput[]
    createMany?: InvestorLeadCreateManyAssignedToInputEnvelope
    connect?: InvestorLeadWhereUniqueInput | InvestorLeadWhereUniqueInput[]
  }

  export type RentalLeadUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<RentalLeadCreateWithoutAssignedToInput, RentalLeadUncheckedCreateWithoutAssignedToInput> | RentalLeadCreateWithoutAssignedToInput[] | RentalLeadUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: RentalLeadCreateOrConnectWithoutAssignedToInput | RentalLeadCreateOrConnectWithoutAssignedToInput[]
    createMany?: RentalLeadCreateManyAssignedToInputEnvelope
    connect?: RentalLeadWhereUniqueInput | RentalLeadWhereUniqueInput[]
  }

  export type BlogUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogCreateWithoutAuthorInput, BlogUncheckedCreateWithoutAuthorInput> | BlogCreateWithoutAuthorInput[] | BlogUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutAuthorInput | BlogCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogCreateManyAuthorInputEnvelope
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
  }

  export type RentalBookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RentalBookingCreateWithoutUserInput, RentalBookingUncheckedCreateWithoutUserInput> | RentalBookingCreateWithoutUserInput[] | RentalBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RentalBookingCreateOrConnectWithoutUserInput | RentalBookingCreateOrConnectWithoutUserInput[]
    createMany?: RentalBookingCreateManyUserInputEnvelope
    connect?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
  }

  export type RentalBookingUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<RentalBookingCreateWithoutAgentInput, RentalBookingUncheckedCreateWithoutAgentInput> | RentalBookingCreateWithoutAgentInput[] | RentalBookingUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: RentalBookingCreateOrConnectWithoutAgentInput | RentalBookingCreateOrConnectWithoutAgentInput[]
    createMany?: RentalBookingCreateManyAgentInputEnvelope
    connect?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type PropertyUpdateManyWithoutUserNestedInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutUserInput | PropertyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutUserInput | PropertyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutUserInput | PropertyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type InvestorLeadUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<InvestorLeadCreateWithoutAssignedToInput, InvestorLeadUncheckedCreateWithoutAssignedToInput> | InvestorLeadCreateWithoutAssignedToInput[] | InvestorLeadUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: InvestorLeadCreateOrConnectWithoutAssignedToInput | InvestorLeadCreateOrConnectWithoutAssignedToInput[]
    upsert?: InvestorLeadUpsertWithWhereUniqueWithoutAssignedToInput | InvestorLeadUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: InvestorLeadCreateManyAssignedToInputEnvelope
    set?: InvestorLeadWhereUniqueInput | InvestorLeadWhereUniqueInput[]
    disconnect?: InvestorLeadWhereUniqueInput | InvestorLeadWhereUniqueInput[]
    delete?: InvestorLeadWhereUniqueInput | InvestorLeadWhereUniqueInput[]
    connect?: InvestorLeadWhereUniqueInput | InvestorLeadWhereUniqueInput[]
    update?: InvestorLeadUpdateWithWhereUniqueWithoutAssignedToInput | InvestorLeadUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: InvestorLeadUpdateManyWithWhereWithoutAssignedToInput | InvestorLeadUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: InvestorLeadScalarWhereInput | InvestorLeadScalarWhereInput[]
  }

  export type RentalLeadUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<RentalLeadCreateWithoutAssignedToInput, RentalLeadUncheckedCreateWithoutAssignedToInput> | RentalLeadCreateWithoutAssignedToInput[] | RentalLeadUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: RentalLeadCreateOrConnectWithoutAssignedToInput | RentalLeadCreateOrConnectWithoutAssignedToInput[]
    upsert?: RentalLeadUpsertWithWhereUniqueWithoutAssignedToInput | RentalLeadUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: RentalLeadCreateManyAssignedToInputEnvelope
    set?: RentalLeadWhereUniqueInput | RentalLeadWhereUniqueInput[]
    disconnect?: RentalLeadWhereUniqueInput | RentalLeadWhereUniqueInput[]
    delete?: RentalLeadWhereUniqueInput | RentalLeadWhereUniqueInput[]
    connect?: RentalLeadWhereUniqueInput | RentalLeadWhereUniqueInput[]
    update?: RentalLeadUpdateWithWhereUniqueWithoutAssignedToInput | RentalLeadUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: RentalLeadUpdateManyWithWhereWithoutAssignedToInput | RentalLeadUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: RentalLeadScalarWhereInput | RentalLeadScalarWhereInput[]
  }

  export type BlogUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogCreateWithoutAuthorInput, BlogUncheckedCreateWithoutAuthorInput> | BlogCreateWithoutAuthorInput[] | BlogUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutAuthorInput | BlogCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogUpsertWithWhereUniqueWithoutAuthorInput | BlogUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogCreateManyAuthorInputEnvelope
    set?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    disconnect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    delete?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    update?: BlogUpdateWithWhereUniqueWithoutAuthorInput | BlogUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogUpdateManyWithWhereWithoutAuthorInput | BlogUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogScalarWhereInput | BlogScalarWhereInput[]
  }

  export type RentalBookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<RentalBookingCreateWithoutUserInput, RentalBookingUncheckedCreateWithoutUserInput> | RentalBookingCreateWithoutUserInput[] | RentalBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RentalBookingCreateOrConnectWithoutUserInput | RentalBookingCreateOrConnectWithoutUserInput[]
    upsert?: RentalBookingUpsertWithWhereUniqueWithoutUserInput | RentalBookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RentalBookingCreateManyUserInputEnvelope
    set?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    disconnect?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    delete?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    connect?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    update?: RentalBookingUpdateWithWhereUniqueWithoutUserInput | RentalBookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RentalBookingUpdateManyWithWhereWithoutUserInput | RentalBookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RentalBookingScalarWhereInput | RentalBookingScalarWhereInput[]
  }

  export type RentalBookingUpdateManyWithoutAgentNestedInput = {
    create?: XOR<RentalBookingCreateWithoutAgentInput, RentalBookingUncheckedCreateWithoutAgentInput> | RentalBookingCreateWithoutAgentInput[] | RentalBookingUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: RentalBookingCreateOrConnectWithoutAgentInput | RentalBookingCreateOrConnectWithoutAgentInput[]
    upsert?: RentalBookingUpsertWithWhereUniqueWithoutAgentInput | RentalBookingUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: RentalBookingCreateManyAgentInputEnvelope
    set?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    disconnect?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    delete?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    connect?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    update?: RentalBookingUpdateWithWhereUniqueWithoutAgentInput | RentalBookingUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: RentalBookingUpdateManyWithWhereWithoutAgentInput | RentalBookingUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: RentalBookingScalarWhereInput | RentalBookingScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutUserInput | PropertyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutUserInput | PropertyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutUserInput | PropertyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type InvestorLeadUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<InvestorLeadCreateWithoutAssignedToInput, InvestorLeadUncheckedCreateWithoutAssignedToInput> | InvestorLeadCreateWithoutAssignedToInput[] | InvestorLeadUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: InvestorLeadCreateOrConnectWithoutAssignedToInput | InvestorLeadCreateOrConnectWithoutAssignedToInput[]
    upsert?: InvestorLeadUpsertWithWhereUniqueWithoutAssignedToInput | InvestorLeadUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: InvestorLeadCreateManyAssignedToInputEnvelope
    set?: InvestorLeadWhereUniqueInput | InvestorLeadWhereUniqueInput[]
    disconnect?: InvestorLeadWhereUniqueInput | InvestorLeadWhereUniqueInput[]
    delete?: InvestorLeadWhereUniqueInput | InvestorLeadWhereUniqueInput[]
    connect?: InvestorLeadWhereUniqueInput | InvestorLeadWhereUniqueInput[]
    update?: InvestorLeadUpdateWithWhereUniqueWithoutAssignedToInput | InvestorLeadUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: InvestorLeadUpdateManyWithWhereWithoutAssignedToInput | InvestorLeadUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: InvestorLeadScalarWhereInput | InvestorLeadScalarWhereInput[]
  }

  export type RentalLeadUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<RentalLeadCreateWithoutAssignedToInput, RentalLeadUncheckedCreateWithoutAssignedToInput> | RentalLeadCreateWithoutAssignedToInput[] | RentalLeadUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: RentalLeadCreateOrConnectWithoutAssignedToInput | RentalLeadCreateOrConnectWithoutAssignedToInput[]
    upsert?: RentalLeadUpsertWithWhereUniqueWithoutAssignedToInput | RentalLeadUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: RentalLeadCreateManyAssignedToInputEnvelope
    set?: RentalLeadWhereUniqueInput | RentalLeadWhereUniqueInput[]
    disconnect?: RentalLeadWhereUniqueInput | RentalLeadWhereUniqueInput[]
    delete?: RentalLeadWhereUniqueInput | RentalLeadWhereUniqueInput[]
    connect?: RentalLeadWhereUniqueInput | RentalLeadWhereUniqueInput[]
    update?: RentalLeadUpdateWithWhereUniqueWithoutAssignedToInput | RentalLeadUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: RentalLeadUpdateManyWithWhereWithoutAssignedToInput | RentalLeadUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: RentalLeadScalarWhereInput | RentalLeadScalarWhereInput[]
  }

  export type BlogUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogCreateWithoutAuthorInput, BlogUncheckedCreateWithoutAuthorInput> | BlogCreateWithoutAuthorInput[] | BlogUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutAuthorInput | BlogCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogUpsertWithWhereUniqueWithoutAuthorInput | BlogUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogCreateManyAuthorInputEnvelope
    set?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    disconnect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    delete?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    update?: BlogUpdateWithWhereUniqueWithoutAuthorInput | BlogUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogUpdateManyWithWhereWithoutAuthorInput | BlogUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogScalarWhereInput | BlogScalarWhereInput[]
  }

  export type RentalBookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RentalBookingCreateWithoutUserInput, RentalBookingUncheckedCreateWithoutUserInput> | RentalBookingCreateWithoutUserInput[] | RentalBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RentalBookingCreateOrConnectWithoutUserInput | RentalBookingCreateOrConnectWithoutUserInput[]
    upsert?: RentalBookingUpsertWithWhereUniqueWithoutUserInput | RentalBookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RentalBookingCreateManyUserInputEnvelope
    set?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    disconnect?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    delete?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    connect?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    update?: RentalBookingUpdateWithWhereUniqueWithoutUserInput | RentalBookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RentalBookingUpdateManyWithWhereWithoutUserInput | RentalBookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RentalBookingScalarWhereInput | RentalBookingScalarWhereInput[]
  }

  export type RentalBookingUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<RentalBookingCreateWithoutAgentInput, RentalBookingUncheckedCreateWithoutAgentInput> | RentalBookingCreateWithoutAgentInput[] | RentalBookingUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: RentalBookingCreateOrConnectWithoutAgentInput | RentalBookingCreateOrConnectWithoutAgentInput[]
    upsert?: RentalBookingUpsertWithWhereUniqueWithoutAgentInput | RentalBookingUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: RentalBookingCreateManyAgentInputEnvelope
    set?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    disconnect?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    delete?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    connect?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    update?: RentalBookingUpdateWithWhereUniqueWithoutAgentInput | RentalBookingUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: RentalBookingUpdateManyWithWhereWithoutAgentInput | RentalBookingUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: RentalBookingScalarWhereInput | RentalBookingScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PropertyCreateamenitiesInput = {
    set: string[]
  }

  export type PropertyImageCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyImageCreateWithoutPropertyInput, PropertyImageUncheckedCreateWithoutPropertyInput> | PropertyImageCreateWithoutPropertyInput[] | PropertyImageUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyImageCreateOrConnectWithoutPropertyInput | PropertyImageCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyImageCreateManyPropertyInputEnvelope
    connect?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
  }

  export type PropertyViewCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput> | PropertyViewCreateWithoutPropertyInput[] | PropertyViewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutPropertyInput | PropertyViewCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyViewCreateManyPropertyInputEnvelope
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
  }

  export type PropertyOwnerCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<PropertyOwnerCreateWithoutPropertiesInput, PropertyOwnerUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PropertyOwnerCreateOrConnectWithoutPropertiesInput
    connect?: PropertyOwnerWhereUniqueInput
  }

  export type PropertyPoiDistanceCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyPoiDistanceCreateWithoutPropertyInput, PropertyPoiDistanceUncheckedCreateWithoutPropertyInput> | PropertyPoiDistanceCreateWithoutPropertyInput[] | PropertyPoiDistanceUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyPoiDistanceCreateOrConnectWithoutPropertyInput | PropertyPoiDistanceCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyPoiDistanceCreateManyPropertyInputEnvelope
    connect?: PropertyPoiDistanceWhereUniqueInput | PropertyPoiDistanceWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<UserCreateWithoutPropertiesInput, UserUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertiesInput
    connect?: UserWhereUniqueInput
  }

  export type ViewingRequestCreateNestedManyWithoutPropertyInput = {
    create?: XOR<ViewingRequestCreateWithoutPropertyInput, ViewingRequestUncheckedCreateWithoutPropertyInput> | ViewingRequestCreateWithoutPropertyInput[] | ViewingRequestUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ViewingRequestCreateOrConnectWithoutPropertyInput | ViewingRequestCreateOrConnectWithoutPropertyInput[]
    createMany?: ViewingRequestCreateManyPropertyInputEnvelope
    connect?: ViewingRequestWhereUniqueInput | ViewingRequestWhereUniqueInput[]
  }

  export type RentalBookingCreateNestedManyWithoutPropertyInput = {
    create?: XOR<RentalBookingCreateWithoutPropertyInput, RentalBookingUncheckedCreateWithoutPropertyInput> | RentalBookingCreateWithoutPropertyInput[] | RentalBookingUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: RentalBookingCreateOrConnectWithoutPropertyInput | RentalBookingCreateOrConnectWithoutPropertyInput[]
    createMany?: RentalBookingCreateManyPropertyInputEnvelope
    connect?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
  }

  export type PropertyBlockedDateCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyBlockedDateCreateWithoutPropertyInput, PropertyBlockedDateUncheckedCreateWithoutPropertyInput> | PropertyBlockedDateCreateWithoutPropertyInput[] | PropertyBlockedDateUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyBlockedDateCreateOrConnectWithoutPropertyInput | PropertyBlockedDateCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyBlockedDateCreateManyPropertyInputEnvelope
    connect?: PropertyBlockedDateWhereUniqueInput | PropertyBlockedDateWhereUniqueInput[]
  }

  export type Tm30AccommodationCreateNestedOneWithoutPropertyInput = {
    create?: XOR<Tm30AccommodationCreateWithoutPropertyInput, Tm30AccommodationUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: Tm30AccommodationCreateOrConnectWithoutPropertyInput
    connect?: Tm30AccommodationWhereUniqueInput
  }

  export type PropertyImageUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyImageCreateWithoutPropertyInput, PropertyImageUncheckedCreateWithoutPropertyInput> | PropertyImageCreateWithoutPropertyInput[] | PropertyImageUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyImageCreateOrConnectWithoutPropertyInput | PropertyImageCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyImageCreateManyPropertyInputEnvelope
    connect?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
  }

  export type PropertyViewUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput> | PropertyViewCreateWithoutPropertyInput[] | PropertyViewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutPropertyInput | PropertyViewCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyViewCreateManyPropertyInputEnvelope
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
  }

  export type PropertyPoiDistanceUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyPoiDistanceCreateWithoutPropertyInput, PropertyPoiDistanceUncheckedCreateWithoutPropertyInput> | PropertyPoiDistanceCreateWithoutPropertyInput[] | PropertyPoiDistanceUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyPoiDistanceCreateOrConnectWithoutPropertyInput | PropertyPoiDistanceCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyPoiDistanceCreateManyPropertyInputEnvelope
    connect?: PropertyPoiDistanceWhereUniqueInput | PropertyPoiDistanceWhereUniqueInput[]
  }

  export type ViewingRequestUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<ViewingRequestCreateWithoutPropertyInput, ViewingRequestUncheckedCreateWithoutPropertyInput> | ViewingRequestCreateWithoutPropertyInput[] | ViewingRequestUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ViewingRequestCreateOrConnectWithoutPropertyInput | ViewingRequestCreateOrConnectWithoutPropertyInput[]
    createMany?: ViewingRequestCreateManyPropertyInputEnvelope
    connect?: ViewingRequestWhereUniqueInput | ViewingRequestWhereUniqueInput[]
  }

  export type RentalBookingUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<RentalBookingCreateWithoutPropertyInput, RentalBookingUncheckedCreateWithoutPropertyInput> | RentalBookingCreateWithoutPropertyInput[] | RentalBookingUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: RentalBookingCreateOrConnectWithoutPropertyInput | RentalBookingCreateOrConnectWithoutPropertyInput[]
    createMany?: RentalBookingCreateManyPropertyInputEnvelope
    connect?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
  }

  export type PropertyBlockedDateUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyBlockedDateCreateWithoutPropertyInput, PropertyBlockedDateUncheckedCreateWithoutPropertyInput> | PropertyBlockedDateCreateWithoutPropertyInput[] | PropertyBlockedDateUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyBlockedDateCreateOrConnectWithoutPropertyInput | PropertyBlockedDateCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyBlockedDateCreateManyPropertyInputEnvelope
    connect?: PropertyBlockedDateWhereUniqueInput | PropertyBlockedDateWhereUniqueInput[]
  }

  export type Tm30AccommodationUncheckedCreateNestedOneWithoutPropertyInput = {
    create?: XOR<Tm30AccommodationCreateWithoutPropertyInput, Tm30AccommodationUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: Tm30AccommodationCreateOrConnectWithoutPropertyInput
    connect?: Tm30AccommodationWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumPropertyTypeFieldUpdateOperationsInput = {
    set?: $Enums.PropertyType
  }

  export type EnumPropertyCategoryFieldUpdateOperationsInput = {
    set?: $Enums.PropertyCategory
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type NullableEnumOwnershipTypeFieldUpdateOperationsInput = {
    set?: $Enums.OwnershipType | null
  }

  export type PropertyUpdateamenitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PropertyImageUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyImageCreateWithoutPropertyInput, PropertyImageUncheckedCreateWithoutPropertyInput> | PropertyImageCreateWithoutPropertyInput[] | PropertyImageUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyImageCreateOrConnectWithoutPropertyInput | PropertyImageCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyImageUpsertWithWhereUniqueWithoutPropertyInput | PropertyImageUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyImageCreateManyPropertyInputEnvelope
    set?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    disconnect?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    delete?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    connect?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    update?: PropertyImageUpdateWithWhereUniqueWithoutPropertyInput | PropertyImageUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyImageUpdateManyWithWhereWithoutPropertyInput | PropertyImageUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyImageScalarWhereInput | PropertyImageScalarWhereInput[]
  }

  export type PropertyViewUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput> | PropertyViewCreateWithoutPropertyInput[] | PropertyViewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutPropertyInput | PropertyViewCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyViewUpsertWithWhereUniqueWithoutPropertyInput | PropertyViewUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyViewCreateManyPropertyInputEnvelope
    set?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    disconnect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    delete?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    update?: PropertyViewUpdateWithWhereUniqueWithoutPropertyInput | PropertyViewUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyViewUpdateManyWithWhereWithoutPropertyInput | PropertyViewUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyViewScalarWhereInput | PropertyViewScalarWhereInput[]
  }

  export type PropertyOwnerUpdateOneWithoutPropertiesNestedInput = {
    create?: XOR<PropertyOwnerCreateWithoutPropertiesInput, PropertyOwnerUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PropertyOwnerCreateOrConnectWithoutPropertiesInput
    upsert?: PropertyOwnerUpsertWithoutPropertiesInput
    disconnect?: PropertyOwnerWhereInput | boolean
    delete?: PropertyOwnerWhereInput | boolean
    connect?: PropertyOwnerWhereUniqueInput
    update?: XOR<XOR<PropertyOwnerUpdateToOneWithWhereWithoutPropertiesInput, PropertyOwnerUpdateWithoutPropertiesInput>, PropertyOwnerUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertyPoiDistanceUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyPoiDistanceCreateWithoutPropertyInput, PropertyPoiDistanceUncheckedCreateWithoutPropertyInput> | PropertyPoiDistanceCreateWithoutPropertyInput[] | PropertyPoiDistanceUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyPoiDistanceCreateOrConnectWithoutPropertyInput | PropertyPoiDistanceCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyPoiDistanceUpsertWithWhereUniqueWithoutPropertyInput | PropertyPoiDistanceUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyPoiDistanceCreateManyPropertyInputEnvelope
    set?: PropertyPoiDistanceWhereUniqueInput | PropertyPoiDistanceWhereUniqueInput[]
    disconnect?: PropertyPoiDistanceWhereUniqueInput | PropertyPoiDistanceWhereUniqueInput[]
    delete?: PropertyPoiDistanceWhereUniqueInput | PropertyPoiDistanceWhereUniqueInput[]
    connect?: PropertyPoiDistanceWhereUniqueInput | PropertyPoiDistanceWhereUniqueInput[]
    update?: PropertyPoiDistanceUpdateWithWhereUniqueWithoutPropertyInput | PropertyPoiDistanceUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyPoiDistanceUpdateManyWithWhereWithoutPropertyInput | PropertyPoiDistanceUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyPoiDistanceScalarWhereInput | PropertyPoiDistanceScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutPropertiesNestedInput = {
    create?: XOR<UserCreateWithoutPropertiesInput, UserUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertiesInput
    upsert?: UserUpsertWithoutPropertiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPropertiesInput, UserUpdateWithoutPropertiesInput>, UserUncheckedUpdateWithoutPropertiesInput>
  }

  export type ViewingRequestUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<ViewingRequestCreateWithoutPropertyInput, ViewingRequestUncheckedCreateWithoutPropertyInput> | ViewingRequestCreateWithoutPropertyInput[] | ViewingRequestUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ViewingRequestCreateOrConnectWithoutPropertyInput | ViewingRequestCreateOrConnectWithoutPropertyInput[]
    upsert?: ViewingRequestUpsertWithWhereUniqueWithoutPropertyInput | ViewingRequestUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: ViewingRequestCreateManyPropertyInputEnvelope
    set?: ViewingRequestWhereUniqueInput | ViewingRequestWhereUniqueInput[]
    disconnect?: ViewingRequestWhereUniqueInput | ViewingRequestWhereUniqueInput[]
    delete?: ViewingRequestWhereUniqueInput | ViewingRequestWhereUniqueInput[]
    connect?: ViewingRequestWhereUniqueInput | ViewingRequestWhereUniqueInput[]
    update?: ViewingRequestUpdateWithWhereUniqueWithoutPropertyInput | ViewingRequestUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: ViewingRequestUpdateManyWithWhereWithoutPropertyInput | ViewingRequestUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: ViewingRequestScalarWhereInput | ViewingRequestScalarWhereInput[]
  }

  export type RentalBookingUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<RentalBookingCreateWithoutPropertyInput, RentalBookingUncheckedCreateWithoutPropertyInput> | RentalBookingCreateWithoutPropertyInput[] | RentalBookingUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: RentalBookingCreateOrConnectWithoutPropertyInput | RentalBookingCreateOrConnectWithoutPropertyInput[]
    upsert?: RentalBookingUpsertWithWhereUniqueWithoutPropertyInput | RentalBookingUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: RentalBookingCreateManyPropertyInputEnvelope
    set?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    disconnect?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    delete?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    connect?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    update?: RentalBookingUpdateWithWhereUniqueWithoutPropertyInput | RentalBookingUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: RentalBookingUpdateManyWithWhereWithoutPropertyInput | RentalBookingUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: RentalBookingScalarWhereInput | RentalBookingScalarWhereInput[]
  }

  export type PropertyBlockedDateUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyBlockedDateCreateWithoutPropertyInput, PropertyBlockedDateUncheckedCreateWithoutPropertyInput> | PropertyBlockedDateCreateWithoutPropertyInput[] | PropertyBlockedDateUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyBlockedDateCreateOrConnectWithoutPropertyInput | PropertyBlockedDateCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyBlockedDateUpsertWithWhereUniqueWithoutPropertyInput | PropertyBlockedDateUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyBlockedDateCreateManyPropertyInputEnvelope
    set?: PropertyBlockedDateWhereUniqueInput | PropertyBlockedDateWhereUniqueInput[]
    disconnect?: PropertyBlockedDateWhereUniqueInput | PropertyBlockedDateWhereUniqueInput[]
    delete?: PropertyBlockedDateWhereUniqueInput | PropertyBlockedDateWhereUniqueInput[]
    connect?: PropertyBlockedDateWhereUniqueInput | PropertyBlockedDateWhereUniqueInput[]
    update?: PropertyBlockedDateUpdateWithWhereUniqueWithoutPropertyInput | PropertyBlockedDateUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyBlockedDateUpdateManyWithWhereWithoutPropertyInput | PropertyBlockedDateUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyBlockedDateScalarWhereInput | PropertyBlockedDateScalarWhereInput[]
  }

  export type Tm30AccommodationUpdateOneWithoutPropertyNestedInput = {
    create?: XOR<Tm30AccommodationCreateWithoutPropertyInput, Tm30AccommodationUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: Tm30AccommodationCreateOrConnectWithoutPropertyInput
    upsert?: Tm30AccommodationUpsertWithoutPropertyInput
    disconnect?: Tm30AccommodationWhereInput | boolean
    delete?: Tm30AccommodationWhereInput | boolean
    connect?: Tm30AccommodationWhereUniqueInput
    update?: XOR<XOR<Tm30AccommodationUpdateToOneWithWhereWithoutPropertyInput, Tm30AccommodationUpdateWithoutPropertyInput>, Tm30AccommodationUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyImageCreateWithoutPropertyInput, PropertyImageUncheckedCreateWithoutPropertyInput> | PropertyImageCreateWithoutPropertyInput[] | PropertyImageUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyImageCreateOrConnectWithoutPropertyInput | PropertyImageCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyImageUpsertWithWhereUniqueWithoutPropertyInput | PropertyImageUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyImageCreateManyPropertyInputEnvelope
    set?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    disconnect?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    delete?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    connect?: PropertyImageWhereUniqueInput | PropertyImageWhereUniqueInput[]
    update?: PropertyImageUpdateWithWhereUniqueWithoutPropertyInput | PropertyImageUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyImageUpdateManyWithWhereWithoutPropertyInput | PropertyImageUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyImageScalarWhereInput | PropertyImageScalarWhereInput[]
  }

  export type PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput> | PropertyViewCreateWithoutPropertyInput[] | PropertyViewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutPropertyInput | PropertyViewCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyViewUpsertWithWhereUniqueWithoutPropertyInput | PropertyViewUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyViewCreateManyPropertyInputEnvelope
    set?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    disconnect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    delete?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    update?: PropertyViewUpdateWithWhereUniqueWithoutPropertyInput | PropertyViewUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyViewUpdateManyWithWhereWithoutPropertyInput | PropertyViewUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyViewScalarWhereInput | PropertyViewScalarWhereInput[]
  }

  export type PropertyPoiDistanceUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyPoiDistanceCreateWithoutPropertyInput, PropertyPoiDistanceUncheckedCreateWithoutPropertyInput> | PropertyPoiDistanceCreateWithoutPropertyInput[] | PropertyPoiDistanceUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyPoiDistanceCreateOrConnectWithoutPropertyInput | PropertyPoiDistanceCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyPoiDistanceUpsertWithWhereUniqueWithoutPropertyInput | PropertyPoiDistanceUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyPoiDistanceCreateManyPropertyInputEnvelope
    set?: PropertyPoiDistanceWhereUniqueInput | PropertyPoiDistanceWhereUniqueInput[]
    disconnect?: PropertyPoiDistanceWhereUniqueInput | PropertyPoiDistanceWhereUniqueInput[]
    delete?: PropertyPoiDistanceWhereUniqueInput | PropertyPoiDistanceWhereUniqueInput[]
    connect?: PropertyPoiDistanceWhereUniqueInput | PropertyPoiDistanceWhereUniqueInput[]
    update?: PropertyPoiDistanceUpdateWithWhereUniqueWithoutPropertyInput | PropertyPoiDistanceUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyPoiDistanceUpdateManyWithWhereWithoutPropertyInput | PropertyPoiDistanceUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyPoiDistanceScalarWhereInput | PropertyPoiDistanceScalarWhereInput[]
  }

  export type ViewingRequestUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<ViewingRequestCreateWithoutPropertyInput, ViewingRequestUncheckedCreateWithoutPropertyInput> | ViewingRequestCreateWithoutPropertyInput[] | ViewingRequestUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ViewingRequestCreateOrConnectWithoutPropertyInput | ViewingRequestCreateOrConnectWithoutPropertyInput[]
    upsert?: ViewingRequestUpsertWithWhereUniqueWithoutPropertyInput | ViewingRequestUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: ViewingRequestCreateManyPropertyInputEnvelope
    set?: ViewingRequestWhereUniqueInput | ViewingRequestWhereUniqueInput[]
    disconnect?: ViewingRequestWhereUniqueInput | ViewingRequestWhereUniqueInput[]
    delete?: ViewingRequestWhereUniqueInput | ViewingRequestWhereUniqueInput[]
    connect?: ViewingRequestWhereUniqueInput | ViewingRequestWhereUniqueInput[]
    update?: ViewingRequestUpdateWithWhereUniqueWithoutPropertyInput | ViewingRequestUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: ViewingRequestUpdateManyWithWhereWithoutPropertyInput | ViewingRequestUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: ViewingRequestScalarWhereInput | ViewingRequestScalarWhereInput[]
  }

  export type RentalBookingUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<RentalBookingCreateWithoutPropertyInput, RentalBookingUncheckedCreateWithoutPropertyInput> | RentalBookingCreateWithoutPropertyInput[] | RentalBookingUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: RentalBookingCreateOrConnectWithoutPropertyInput | RentalBookingCreateOrConnectWithoutPropertyInput[]
    upsert?: RentalBookingUpsertWithWhereUniqueWithoutPropertyInput | RentalBookingUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: RentalBookingCreateManyPropertyInputEnvelope
    set?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    disconnect?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    delete?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    connect?: RentalBookingWhereUniqueInput | RentalBookingWhereUniqueInput[]
    update?: RentalBookingUpdateWithWhereUniqueWithoutPropertyInput | RentalBookingUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: RentalBookingUpdateManyWithWhereWithoutPropertyInput | RentalBookingUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: RentalBookingScalarWhereInput | RentalBookingScalarWhereInput[]
  }

  export type PropertyBlockedDateUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyBlockedDateCreateWithoutPropertyInput, PropertyBlockedDateUncheckedCreateWithoutPropertyInput> | PropertyBlockedDateCreateWithoutPropertyInput[] | PropertyBlockedDateUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyBlockedDateCreateOrConnectWithoutPropertyInput | PropertyBlockedDateCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyBlockedDateUpsertWithWhereUniqueWithoutPropertyInput | PropertyBlockedDateUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyBlockedDateCreateManyPropertyInputEnvelope
    set?: PropertyBlockedDateWhereUniqueInput | PropertyBlockedDateWhereUniqueInput[]
    disconnect?: PropertyBlockedDateWhereUniqueInput | PropertyBlockedDateWhereUniqueInput[]
    delete?: PropertyBlockedDateWhereUniqueInput | PropertyBlockedDateWhereUniqueInput[]
    connect?: PropertyBlockedDateWhereUniqueInput | PropertyBlockedDateWhereUniqueInput[]
    update?: PropertyBlockedDateUpdateWithWhereUniqueWithoutPropertyInput | PropertyBlockedDateUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyBlockedDateUpdateManyWithWhereWithoutPropertyInput | PropertyBlockedDateUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyBlockedDateScalarWhereInput | PropertyBlockedDateScalarWhereInput[]
  }

  export type Tm30AccommodationUncheckedUpdateOneWithoutPropertyNestedInput = {
    create?: XOR<Tm30AccommodationCreateWithoutPropertyInput, Tm30AccommodationUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: Tm30AccommodationCreateOrConnectWithoutPropertyInput
    upsert?: Tm30AccommodationUpsertWithoutPropertyInput
    disconnect?: Tm30AccommodationWhereInput | boolean
    delete?: Tm30AccommodationWhereInput | boolean
    connect?: Tm30AccommodationWhereUniqueInput
    update?: XOR<XOR<Tm30AccommodationUpdateToOneWithWhereWithoutPropertyInput, Tm30AccommodationUpdateWithoutPropertyInput>, Tm30AccommodationUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyCreateNestedOneWithoutImagesInput = {
    create?: XOR<PropertyCreateWithoutImagesInput, PropertyUncheckedCreateWithoutImagesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutImagesInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<PropertyCreateWithoutImagesInput, PropertyUncheckedCreateWithoutImagesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutImagesInput
    upsert?: PropertyUpsertWithoutImagesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutImagesInput, PropertyUpdateWithoutImagesInput>, PropertyUncheckedUpdateWithoutImagesInput>
  }

  export type PropertyCreateNestedOneWithoutViewsInput = {
    create?: XOR<PropertyCreateWithoutViewsInput, PropertyUncheckedCreateWithoutViewsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutViewsInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutViewsNestedInput = {
    create?: XOR<PropertyCreateWithoutViewsInput, PropertyUncheckedCreateWithoutViewsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutViewsInput
    upsert?: PropertyUpsertWithoutViewsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutViewsInput, PropertyUpdateWithoutViewsInput>, PropertyUncheckedUpdateWithoutViewsInput>
  }

  export type PropertyCreateNestedOneWithoutViewingRequestsInput = {
    create?: XOR<PropertyCreateWithoutViewingRequestsInput, PropertyUncheckedCreateWithoutViewingRequestsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutViewingRequestsInput
    connect?: PropertyWhereUniqueInput
  }

  export type EnumRequestTypeFieldUpdateOperationsInput = {
    set?: $Enums.RequestType
  }

  export type EnumRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.RequestStatus
  }

  export type PropertyUpdateOneWithoutViewingRequestsNestedInput = {
    create?: XOR<PropertyCreateWithoutViewingRequestsInput, PropertyUncheckedCreateWithoutViewingRequestsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutViewingRequestsInput
    upsert?: PropertyUpsertWithoutViewingRequestsInput
    disconnect?: PropertyWhereInput | boolean
    delete?: PropertyWhereInput | boolean
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutViewingRequestsInput, PropertyUpdateWithoutViewingRequestsInput>, PropertyUncheckedUpdateWithoutViewingRequestsInput>
  }

  export type UserCreateNestedOneWithoutInvestorLeadsInput = {
    create?: XOR<UserCreateWithoutInvestorLeadsInput, UserUncheckedCreateWithoutInvestorLeadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvestorLeadsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumLeadStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeadStatus
  }

  export type UserUpdateOneWithoutInvestorLeadsNestedInput = {
    create?: XOR<UserCreateWithoutInvestorLeadsInput, UserUncheckedCreateWithoutInvestorLeadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvestorLeadsInput
    upsert?: UserUpsertWithoutInvestorLeadsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvestorLeadsInput, UserUpdateWithoutInvestorLeadsInput>, UserUncheckedUpdateWithoutInvestorLeadsInput>
  }

  export type UserCreateNestedOneWithoutRentalLeadsInput = {
    create?: XOR<UserCreateWithoutRentalLeadsInput, UserUncheckedCreateWithoutRentalLeadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRentalLeadsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumRentalLeadStatusFieldUpdateOperationsInput = {
    set?: $Enums.RentalLeadStatus
  }

  export type UserUpdateOneWithoutRentalLeadsNestedInput = {
    create?: XOR<UserCreateWithoutRentalLeadsInput, UserUncheckedCreateWithoutRentalLeadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRentalLeadsInput
    upsert?: UserUpsertWithoutRentalLeadsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRentalLeadsInput, UserUpdateWithoutRentalLeadsInput>, UserUncheckedUpdateWithoutRentalLeadsInput>
  }

  export type BlogCategoryCreateNestedOneWithoutBlogsInput = {
    create?: XOR<BlogCategoryCreateWithoutBlogsInput, BlogCategoryUncheckedCreateWithoutBlogsInput>
    connectOrCreate?: BlogCategoryCreateOrConnectWithoutBlogsInput
    connect?: BlogCategoryWhereUniqueInput
  }

  export type LinkUsageCreateNestedManyWithoutBlogInput = {
    create?: XOR<LinkUsageCreateWithoutBlogInput, LinkUsageUncheckedCreateWithoutBlogInput> | LinkUsageCreateWithoutBlogInput[] | LinkUsageUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: LinkUsageCreateOrConnectWithoutBlogInput | LinkUsageCreateOrConnectWithoutBlogInput[]
    createMany?: LinkUsageCreateManyBlogInputEnvelope
    connect?: LinkUsageWhereUniqueInput | LinkUsageWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutBlogsInput = {
    create?: XOR<UserCreateWithoutBlogsInput, UserUncheckedCreateWithoutBlogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogsInput
    connect?: UserWhereUniqueInput
  }

  export type LinkUsageUncheckedCreateNestedManyWithoutBlogInput = {
    create?: XOR<LinkUsageCreateWithoutBlogInput, LinkUsageUncheckedCreateWithoutBlogInput> | LinkUsageCreateWithoutBlogInput[] | LinkUsageUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: LinkUsageCreateOrConnectWithoutBlogInput | LinkUsageCreateOrConnectWithoutBlogInput[]
    createMany?: LinkUsageCreateManyBlogInputEnvelope
    connect?: LinkUsageWhereUniqueInput | LinkUsageWhereUniqueInput[]
  }

  export type BlogCategoryUpdateOneWithoutBlogsNestedInput = {
    create?: XOR<BlogCategoryCreateWithoutBlogsInput, BlogCategoryUncheckedCreateWithoutBlogsInput>
    connectOrCreate?: BlogCategoryCreateOrConnectWithoutBlogsInput
    upsert?: BlogCategoryUpsertWithoutBlogsInput
    disconnect?: BlogCategoryWhereInput | boolean
    delete?: BlogCategoryWhereInput | boolean
    connect?: BlogCategoryWhereUniqueInput
    update?: XOR<XOR<BlogCategoryUpdateToOneWithWhereWithoutBlogsInput, BlogCategoryUpdateWithoutBlogsInput>, BlogCategoryUncheckedUpdateWithoutBlogsInput>
  }

  export type LinkUsageUpdateManyWithoutBlogNestedInput = {
    create?: XOR<LinkUsageCreateWithoutBlogInput, LinkUsageUncheckedCreateWithoutBlogInput> | LinkUsageCreateWithoutBlogInput[] | LinkUsageUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: LinkUsageCreateOrConnectWithoutBlogInput | LinkUsageCreateOrConnectWithoutBlogInput[]
    upsert?: LinkUsageUpsertWithWhereUniqueWithoutBlogInput | LinkUsageUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: LinkUsageCreateManyBlogInputEnvelope
    set?: LinkUsageWhereUniqueInput | LinkUsageWhereUniqueInput[]
    disconnect?: LinkUsageWhereUniqueInput | LinkUsageWhereUniqueInput[]
    delete?: LinkUsageWhereUniqueInput | LinkUsageWhereUniqueInput[]
    connect?: LinkUsageWhereUniqueInput | LinkUsageWhereUniqueInput[]
    update?: LinkUsageUpdateWithWhereUniqueWithoutBlogInput | LinkUsageUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: LinkUsageUpdateManyWithWhereWithoutBlogInput | LinkUsageUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: LinkUsageScalarWhereInput | LinkUsageScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutBlogsNestedInput = {
    create?: XOR<UserCreateWithoutBlogsInput, UserUncheckedCreateWithoutBlogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogsInput
    upsert?: UserUpsertWithoutBlogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogsInput, UserUpdateWithoutBlogsInput>, UserUncheckedUpdateWithoutBlogsInput>
  }

  export type LinkUsageUncheckedUpdateManyWithoutBlogNestedInput = {
    create?: XOR<LinkUsageCreateWithoutBlogInput, LinkUsageUncheckedCreateWithoutBlogInput> | LinkUsageCreateWithoutBlogInput[] | LinkUsageUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: LinkUsageCreateOrConnectWithoutBlogInput | LinkUsageCreateOrConnectWithoutBlogInput[]
    upsert?: LinkUsageUpsertWithWhereUniqueWithoutBlogInput | LinkUsageUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: LinkUsageCreateManyBlogInputEnvelope
    set?: LinkUsageWhereUniqueInput | LinkUsageWhereUniqueInput[]
    disconnect?: LinkUsageWhereUniqueInput | LinkUsageWhereUniqueInput[]
    delete?: LinkUsageWhereUniqueInput | LinkUsageWhereUniqueInput[]
    connect?: LinkUsageWhereUniqueInput | LinkUsageWhereUniqueInput[]
    update?: LinkUsageUpdateWithWhereUniqueWithoutBlogInput | LinkUsageUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: LinkUsageUpdateManyWithWhereWithoutBlogInput | LinkUsageUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: LinkUsageScalarWhereInput | LinkUsageScalarWhereInput[]
  }

  export type BlogCategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<BlogCategoryCreateWithoutChildrenInput, BlogCategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: BlogCategoryCreateOrConnectWithoutChildrenInput
    connect?: BlogCategoryWhereUniqueInput
  }

  export type BlogCategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<BlogCategoryCreateWithoutParentInput, BlogCategoryUncheckedCreateWithoutParentInput> | BlogCategoryCreateWithoutParentInput[] | BlogCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: BlogCategoryCreateOrConnectWithoutParentInput | BlogCategoryCreateOrConnectWithoutParentInput[]
    createMany?: BlogCategoryCreateManyParentInputEnvelope
    connect?: BlogCategoryWhereUniqueInput | BlogCategoryWhereUniqueInput[]
  }

  export type BlogCreateNestedManyWithoutCategoryInput = {
    create?: XOR<BlogCreateWithoutCategoryInput, BlogUncheckedCreateWithoutCategoryInput> | BlogCreateWithoutCategoryInput[] | BlogUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutCategoryInput | BlogCreateOrConnectWithoutCategoryInput[]
    createMany?: BlogCreateManyCategoryInputEnvelope
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
  }

  export type BlogCategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<BlogCategoryCreateWithoutParentInput, BlogCategoryUncheckedCreateWithoutParentInput> | BlogCategoryCreateWithoutParentInput[] | BlogCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: BlogCategoryCreateOrConnectWithoutParentInput | BlogCategoryCreateOrConnectWithoutParentInput[]
    createMany?: BlogCategoryCreateManyParentInputEnvelope
    connect?: BlogCategoryWhereUniqueInput | BlogCategoryWhereUniqueInput[]
  }

  export type BlogUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<BlogCreateWithoutCategoryInput, BlogUncheckedCreateWithoutCategoryInput> | BlogCreateWithoutCategoryInput[] | BlogUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutCategoryInput | BlogCreateOrConnectWithoutCategoryInput[]
    createMany?: BlogCreateManyCategoryInputEnvelope
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
  }

  export type BlogCategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<BlogCategoryCreateWithoutChildrenInput, BlogCategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: BlogCategoryCreateOrConnectWithoutChildrenInput
    upsert?: BlogCategoryUpsertWithoutChildrenInput
    disconnect?: BlogCategoryWhereInput | boolean
    delete?: BlogCategoryWhereInput | boolean
    connect?: BlogCategoryWhereUniqueInput
    update?: XOR<XOR<BlogCategoryUpdateToOneWithWhereWithoutChildrenInput, BlogCategoryUpdateWithoutChildrenInput>, BlogCategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type BlogCategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<BlogCategoryCreateWithoutParentInput, BlogCategoryUncheckedCreateWithoutParentInput> | BlogCategoryCreateWithoutParentInput[] | BlogCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: BlogCategoryCreateOrConnectWithoutParentInput | BlogCategoryCreateOrConnectWithoutParentInput[]
    upsert?: BlogCategoryUpsertWithWhereUniqueWithoutParentInput | BlogCategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: BlogCategoryCreateManyParentInputEnvelope
    set?: BlogCategoryWhereUniqueInput | BlogCategoryWhereUniqueInput[]
    disconnect?: BlogCategoryWhereUniqueInput | BlogCategoryWhereUniqueInput[]
    delete?: BlogCategoryWhereUniqueInput | BlogCategoryWhereUniqueInput[]
    connect?: BlogCategoryWhereUniqueInput | BlogCategoryWhereUniqueInput[]
    update?: BlogCategoryUpdateWithWhereUniqueWithoutParentInput | BlogCategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: BlogCategoryUpdateManyWithWhereWithoutParentInput | BlogCategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: BlogCategoryScalarWhereInput | BlogCategoryScalarWhereInput[]
  }

  export type BlogUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<BlogCreateWithoutCategoryInput, BlogUncheckedCreateWithoutCategoryInput> | BlogCreateWithoutCategoryInput[] | BlogUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutCategoryInput | BlogCreateOrConnectWithoutCategoryInput[]
    upsert?: BlogUpsertWithWhereUniqueWithoutCategoryInput | BlogUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: BlogCreateManyCategoryInputEnvelope
    set?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    disconnect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    delete?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    update?: BlogUpdateWithWhereUniqueWithoutCategoryInput | BlogUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: BlogUpdateManyWithWhereWithoutCategoryInput | BlogUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: BlogScalarWhereInput | BlogScalarWhereInput[]
  }

  export type BlogCategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<BlogCategoryCreateWithoutParentInput, BlogCategoryUncheckedCreateWithoutParentInput> | BlogCategoryCreateWithoutParentInput[] | BlogCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: BlogCategoryCreateOrConnectWithoutParentInput | BlogCategoryCreateOrConnectWithoutParentInput[]
    upsert?: BlogCategoryUpsertWithWhereUniqueWithoutParentInput | BlogCategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: BlogCategoryCreateManyParentInputEnvelope
    set?: BlogCategoryWhereUniqueInput | BlogCategoryWhereUniqueInput[]
    disconnect?: BlogCategoryWhereUniqueInput | BlogCategoryWhereUniqueInput[]
    delete?: BlogCategoryWhereUniqueInput | BlogCategoryWhereUniqueInput[]
    connect?: BlogCategoryWhereUniqueInput | BlogCategoryWhereUniqueInput[]
    update?: BlogCategoryUpdateWithWhereUniqueWithoutParentInput | BlogCategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: BlogCategoryUpdateManyWithWhereWithoutParentInput | BlogCategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: BlogCategoryScalarWhereInput | BlogCategoryScalarWhereInput[]
  }

  export type BlogUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<BlogCreateWithoutCategoryInput, BlogUncheckedCreateWithoutCategoryInput> | BlogCreateWithoutCategoryInput[] | BlogUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutCategoryInput | BlogCreateOrConnectWithoutCategoryInput[]
    upsert?: BlogUpsertWithWhereUniqueWithoutCategoryInput | BlogUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: BlogCreateManyCategoryInputEnvelope
    set?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    disconnect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    delete?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    update?: BlogUpdateWithWhereUniqueWithoutCategoryInput | BlogUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: BlogUpdateManyWithWhereWithoutCategoryInput | BlogUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: BlogScalarWhereInput | BlogScalarWhereInput[]
  }

  export type PropertySubmissionCreateimagesInput = {
    set: string[]
  }

  export type PropertySubmissionUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumSubmissionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubmissionStatus
  }

  export type LinkUsageCreateNestedManyWithoutLinkInput = {
    create?: XOR<LinkUsageCreateWithoutLinkInput, LinkUsageUncheckedCreateWithoutLinkInput> | LinkUsageCreateWithoutLinkInput[] | LinkUsageUncheckedCreateWithoutLinkInput[]
    connectOrCreate?: LinkUsageCreateOrConnectWithoutLinkInput | LinkUsageCreateOrConnectWithoutLinkInput[]
    createMany?: LinkUsageCreateManyLinkInputEnvelope
    connect?: LinkUsageWhereUniqueInput | LinkUsageWhereUniqueInput[]
  }

  export type LinkUsageUncheckedCreateNestedManyWithoutLinkInput = {
    create?: XOR<LinkUsageCreateWithoutLinkInput, LinkUsageUncheckedCreateWithoutLinkInput> | LinkUsageCreateWithoutLinkInput[] | LinkUsageUncheckedCreateWithoutLinkInput[]
    connectOrCreate?: LinkUsageCreateOrConnectWithoutLinkInput | LinkUsageCreateOrConnectWithoutLinkInput[]
    createMany?: LinkUsageCreateManyLinkInputEnvelope
    connect?: LinkUsageWhereUniqueInput | LinkUsageWhereUniqueInput[]
  }

  export type LinkUsageUpdateManyWithoutLinkNestedInput = {
    create?: XOR<LinkUsageCreateWithoutLinkInput, LinkUsageUncheckedCreateWithoutLinkInput> | LinkUsageCreateWithoutLinkInput[] | LinkUsageUncheckedCreateWithoutLinkInput[]
    connectOrCreate?: LinkUsageCreateOrConnectWithoutLinkInput | LinkUsageCreateOrConnectWithoutLinkInput[]
    upsert?: LinkUsageUpsertWithWhereUniqueWithoutLinkInput | LinkUsageUpsertWithWhereUniqueWithoutLinkInput[]
    createMany?: LinkUsageCreateManyLinkInputEnvelope
    set?: LinkUsageWhereUniqueInput | LinkUsageWhereUniqueInput[]
    disconnect?: LinkUsageWhereUniqueInput | LinkUsageWhereUniqueInput[]
    delete?: LinkUsageWhereUniqueInput | LinkUsageWhereUniqueInput[]
    connect?: LinkUsageWhereUniqueInput | LinkUsageWhereUniqueInput[]
    update?: LinkUsageUpdateWithWhereUniqueWithoutLinkInput | LinkUsageUpdateWithWhereUniqueWithoutLinkInput[]
    updateMany?: LinkUsageUpdateManyWithWhereWithoutLinkInput | LinkUsageUpdateManyWithWhereWithoutLinkInput[]
    deleteMany?: LinkUsageScalarWhereInput | LinkUsageScalarWhereInput[]
  }

  export type LinkUsageUncheckedUpdateManyWithoutLinkNestedInput = {
    create?: XOR<LinkUsageCreateWithoutLinkInput, LinkUsageUncheckedCreateWithoutLinkInput> | LinkUsageCreateWithoutLinkInput[] | LinkUsageUncheckedCreateWithoutLinkInput[]
    connectOrCreate?: LinkUsageCreateOrConnectWithoutLinkInput | LinkUsageCreateOrConnectWithoutLinkInput[]
    upsert?: LinkUsageUpsertWithWhereUniqueWithoutLinkInput | LinkUsageUpsertWithWhereUniqueWithoutLinkInput[]
    createMany?: LinkUsageCreateManyLinkInputEnvelope
    set?: LinkUsageWhereUniqueInput | LinkUsageWhereUniqueInput[]
    disconnect?: LinkUsageWhereUniqueInput | LinkUsageWhereUniqueInput[]
    delete?: LinkUsageWhereUniqueInput | LinkUsageWhereUniqueInput[]
    connect?: LinkUsageWhereUniqueInput | LinkUsageWhereUniqueInput[]
    update?: LinkUsageUpdateWithWhereUniqueWithoutLinkInput | LinkUsageUpdateWithWhereUniqueWithoutLinkInput[]
    updateMany?: LinkUsageUpdateManyWithWhereWithoutLinkInput | LinkUsageUpdateManyWithWhereWithoutLinkInput[]
    deleteMany?: LinkUsageScalarWhereInput | LinkUsageScalarWhereInput[]
  }

  export type InternalLinkCreateNestedOneWithoutUsagesInput = {
    create?: XOR<InternalLinkCreateWithoutUsagesInput, InternalLinkUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: InternalLinkCreateOrConnectWithoutUsagesInput
    connect?: InternalLinkWhereUniqueInput
  }

  export type BlogCreateNestedOneWithoutLinkUsagesInput = {
    create?: XOR<BlogCreateWithoutLinkUsagesInput, BlogUncheckedCreateWithoutLinkUsagesInput>
    connectOrCreate?: BlogCreateOrConnectWithoutLinkUsagesInput
    connect?: BlogWhereUniqueInput
  }

  export type InternalLinkUpdateOneRequiredWithoutUsagesNestedInput = {
    create?: XOR<InternalLinkCreateWithoutUsagesInput, InternalLinkUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: InternalLinkCreateOrConnectWithoutUsagesInput
    upsert?: InternalLinkUpsertWithoutUsagesInput
    connect?: InternalLinkWhereUniqueInput
    update?: XOR<XOR<InternalLinkUpdateToOneWithWhereWithoutUsagesInput, InternalLinkUpdateWithoutUsagesInput>, InternalLinkUncheckedUpdateWithoutUsagesInput>
  }

  export type BlogUpdateOneRequiredWithoutLinkUsagesNestedInput = {
    create?: XOR<BlogCreateWithoutLinkUsagesInput, BlogUncheckedCreateWithoutLinkUsagesInput>
    connectOrCreate?: BlogCreateOrConnectWithoutLinkUsagesInput
    upsert?: BlogUpsertWithoutLinkUsagesInput
    connect?: BlogWhereUniqueInput
    update?: XOR<XOR<BlogUpdateToOneWithWhereWithoutLinkUsagesInput, BlogUpdateWithoutLinkUsagesInput>, BlogUncheckedUpdateWithoutLinkUsagesInput>
  }

  export type EnumLandingPageStatusFieldUpdateOperationsInput = {
    set?: $Enums.LandingPageStatus
  }

  export type EnumTopicStatusFieldUpdateOperationsInput = {
    set?: $Enums.TopicStatus
  }

  export type EnumScheduledBlogStatusFieldUpdateOperationsInput = {
    set?: $Enums.ScheduledBlogStatus
  }

  export type EnumHeroDeviceTypeFieldUpdateOperationsInput = {
    set?: $Enums.HeroDeviceType
  }

  export type NullableEnumPropertyTypeFieldUpdateOperationsInput = {
    set?: $Enums.PropertyType | null
  }

  export type NullableEnumPropertyCategoryFieldUpdateOperationsInput = {
    set?: $Enums.PropertyCategory | null
  }

  export type PropertyPoiDistanceCreateNestedManyWithoutPoiInput = {
    create?: XOR<PropertyPoiDistanceCreateWithoutPoiInput, PropertyPoiDistanceUncheckedCreateWithoutPoiInput> | PropertyPoiDistanceCreateWithoutPoiInput[] | PropertyPoiDistanceUncheckedCreateWithoutPoiInput[]
    connectOrCreate?: PropertyPoiDistanceCreateOrConnectWithoutPoiInput | PropertyPoiDistanceCreateOrConnectWithoutPoiInput[]
    createMany?: PropertyPoiDistanceCreateManyPoiInputEnvelope
    connect?: PropertyPoiDistanceWhereUniqueInput | PropertyPoiDistanceWhereUniqueInput[]
  }

  export type PropertyPoiDistanceUncheckedCreateNestedManyWithoutPoiInput = {
    create?: XOR<PropertyPoiDistanceCreateWithoutPoiInput, PropertyPoiDistanceUncheckedCreateWithoutPoiInput> | PropertyPoiDistanceCreateWithoutPoiInput[] | PropertyPoiDistanceUncheckedCreateWithoutPoiInput[]
    connectOrCreate?: PropertyPoiDistanceCreateOrConnectWithoutPoiInput | PropertyPoiDistanceCreateOrConnectWithoutPoiInput[]
    createMany?: PropertyPoiDistanceCreateManyPoiInputEnvelope
    connect?: PropertyPoiDistanceWhereUniqueInput | PropertyPoiDistanceWhereUniqueInput[]
  }

  export type EnumPoiSourceFieldUpdateOperationsInput = {
    set?: $Enums.PoiSource
  }

  export type EnumPoiCategoryFieldUpdateOperationsInput = {
    set?: $Enums.PoiCategory
  }

  export type NullableEnumNoiseLevelFieldUpdateOperationsInput = {
    set?: $Enums.NoiseLevel | null
  }

  export type NullableEnumTrafficLevelFieldUpdateOperationsInput = {
    set?: $Enums.TrafficLevel | null
  }

  export type PropertyPoiDistanceUpdateManyWithoutPoiNestedInput = {
    create?: XOR<PropertyPoiDistanceCreateWithoutPoiInput, PropertyPoiDistanceUncheckedCreateWithoutPoiInput> | PropertyPoiDistanceCreateWithoutPoiInput[] | PropertyPoiDistanceUncheckedCreateWithoutPoiInput[]
    connectOrCreate?: PropertyPoiDistanceCreateOrConnectWithoutPoiInput | PropertyPoiDistanceCreateOrConnectWithoutPoiInput[]
    upsert?: PropertyPoiDistanceUpsertWithWhereUniqueWithoutPoiInput | PropertyPoiDistanceUpsertWithWhereUniqueWithoutPoiInput[]
    createMany?: PropertyPoiDistanceCreateManyPoiInputEnvelope
    set?: PropertyPoiDistanceWhereUniqueInput | PropertyPoiDistanceWhereUniqueInput[]
    disconnect?: PropertyPoiDistanceWhereUniqueInput | PropertyPoiDistanceWhereUniqueInput[]
    delete?: PropertyPoiDistanceWhereUniqueInput | PropertyPoiDistanceWhereUniqueInput[]
    connect?: PropertyPoiDistanceWhereUniqueInput | PropertyPoiDistanceWhereUniqueInput[]
    update?: PropertyPoiDistanceUpdateWithWhereUniqueWithoutPoiInput | PropertyPoiDistanceUpdateWithWhereUniqueWithoutPoiInput[]
    updateMany?: PropertyPoiDistanceUpdateManyWithWhereWithoutPoiInput | PropertyPoiDistanceUpdateManyWithWhereWithoutPoiInput[]
    deleteMany?: PropertyPoiDistanceScalarWhereInput | PropertyPoiDistanceScalarWhereInput[]
  }

  export type PropertyPoiDistanceUncheckedUpdateManyWithoutPoiNestedInput = {
    create?: XOR<PropertyPoiDistanceCreateWithoutPoiInput, PropertyPoiDistanceUncheckedCreateWithoutPoiInput> | PropertyPoiDistanceCreateWithoutPoiInput[] | PropertyPoiDistanceUncheckedCreateWithoutPoiInput[]
    connectOrCreate?: PropertyPoiDistanceCreateOrConnectWithoutPoiInput | PropertyPoiDistanceCreateOrConnectWithoutPoiInput[]
    upsert?: PropertyPoiDistanceUpsertWithWhereUniqueWithoutPoiInput | PropertyPoiDistanceUpsertWithWhereUniqueWithoutPoiInput[]
    createMany?: PropertyPoiDistanceCreateManyPoiInputEnvelope
    set?: PropertyPoiDistanceWhereUniqueInput | PropertyPoiDistanceWhereUniqueInput[]
    disconnect?: PropertyPoiDistanceWhereUniqueInput | PropertyPoiDistanceWhereUniqueInput[]
    delete?: PropertyPoiDistanceWhereUniqueInput | PropertyPoiDistanceWhereUniqueInput[]
    connect?: PropertyPoiDistanceWhereUniqueInput | PropertyPoiDistanceWhereUniqueInput[]
    update?: PropertyPoiDistanceUpdateWithWhereUniqueWithoutPoiInput | PropertyPoiDistanceUpdateWithWhereUniqueWithoutPoiInput[]
    updateMany?: PropertyPoiDistanceUpdateManyWithWhereWithoutPoiInput | PropertyPoiDistanceUpdateManyWithWhereWithoutPoiInput[]
    deleteMany?: PropertyPoiDistanceScalarWhereInput | PropertyPoiDistanceScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutPoiDistancesInput = {
    create?: XOR<PropertyCreateWithoutPoiDistancesInput, PropertyUncheckedCreateWithoutPoiDistancesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPoiDistancesInput
    connect?: PropertyWhereUniqueInput
  }

  export type PoiCreateNestedOneWithoutPropertyDistancesInput = {
    create?: XOR<PoiCreateWithoutPropertyDistancesInput, PoiUncheckedCreateWithoutPropertyDistancesInput>
    connectOrCreate?: PoiCreateOrConnectWithoutPropertyDistancesInput
    connect?: PoiWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutPoiDistancesNestedInput = {
    create?: XOR<PropertyCreateWithoutPoiDistancesInput, PropertyUncheckedCreateWithoutPoiDistancesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPoiDistancesInput
    upsert?: PropertyUpsertWithoutPoiDistancesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutPoiDistancesInput, PropertyUpdateWithoutPoiDistancesInput>, PropertyUncheckedUpdateWithoutPoiDistancesInput>
  }

  export type PoiUpdateOneRequiredWithoutPropertyDistancesNestedInput = {
    create?: XOR<PoiCreateWithoutPropertyDistancesInput, PoiUncheckedCreateWithoutPropertyDistancesInput>
    connectOrCreate?: PoiCreateOrConnectWithoutPropertyDistancesInput
    upsert?: PoiUpsertWithoutPropertyDistancesInput
    connect?: PoiWhereUniqueInput
    update?: XOR<XOR<PoiUpdateToOneWithWhereWithoutPropertyDistancesInput, PoiUpdateWithoutPropertyDistancesInput>, PoiUncheckedUpdateWithoutPropertyDistancesInput>
  }

  export type EnumPoiSyncJobTypeFieldUpdateOperationsInput = {
    set?: $Enums.PoiSyncJobType
  }

  export type EnumPoiSyncJobStatusFieldUpdateOperationsInput = {
    set?: $Enums.PoiSyncJobStatus
  }

  export type NullableEnumPoiCategoryFieldUpdateOperationsInput = {
    set?: $Enums.PoiCategory | null
  }

  export type RentalPricingConfigCreatepeakSeasonMonthsInput = {
    set: number[]
  }

  export type RentalPricingConfigUpdatepeakSeasonMonthsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type PropertyCreateNestedOneWithoutRentalBookingsInput = {
    create?: XOR<PropertyCreateWithoutRentalBookingsInput, PropertyUncheckedCreateWithoutRentalBookingsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutRentalBookingsInput
    connect?: PropertyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRentalBookingsInput = {
    create?: XOR<UserCreateWithoutRentalBookingsInput, UserUncheckedCreateWithoutRentalBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRentalBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBookingsAsAgentInput = {
    create?: XOR<UserCreateWithoutBookingsAsAgentInput, UserUncheckedCreateWithoutBookingsAsAgentInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsAsAgentInput
    connect?: UserWhereUniqueInput
  }

  export type BookingMessageCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingMessageCreateWithoutBookingInput, BookingMessageUncheckedCreateWithoutBookingInput> | BookingMessageCreateWithoutBookingInput[] | BookingMessageUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingMessageCreateOrConnectWithoutBookingInput | BookingMessageCreateOrConnectWithoutBookingInput[]
    createMany?: BookingMessageCreateManyBookingInputEnvelope
    connect?: BookingMessageWhereUniqueInput | BookingMessageWhereUniqueInput[]
  }

  export type BookingGuestCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingGuestCreateWithoutBookingInput, BookingGuestUncheckedCreateWithoutBookingInput> | BookingGuestCreateWithoutBookingInput[] | BookingGuestUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingGuestCreateOrConnectWithoutBookingInput | BookingGuestCreateOrConnectWithoutBookingInput[]
    createMany?: BookingGuestCreateManyBookingInputEnvelope
    connect?: BookingGuestWhereUniqueInput | BookingGuestWhereUniqueInput[]
  }

  export type BookingMessageUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingMessageCreateWithoutBookingInput, BookingMessageUncheckedCreateWithoutBookingInput> | BookingMessageCreateWithoutBookingInput[] | BookingMessageUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingMessageCreateOrConnectWithoutBookingInput | BookingMessageCreateOrConnectWithoutBookingInput[]
    createMany?: BookingMessageCreateManyBookingInputEnvelope
    connect?: BookingMessageWhereUniqueInput | BookingMessageWhereUniqueInput[]
  }

  export type BookingGuestUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingGuestCreateWithoutBookingInput, BookingGuestUncheckedCreateWithoutBookingInput> | BookingGuestCreateWithoutBookingInput[] | BookingGuestUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingGuestCreateOrConnectWithoutBookingInput | BookingGuestCreateOrConnectWithoutBookingInput[]
    createMany?: BookingGuestCreateManyBookingInputEnvelope
    connect?: BookingGuestWhereUniqueInput | BookingGuestWhereUniqueInput[]
  }

  export type EnumRentalBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.RentalBookingStatus
  }

  export type EnumTM30BookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.TM30BookingStatus
  }

  export type PropertyUpdateOneRequiredWithoutRentalBookingsNestedInput = {
    create?: XOR<PropertyCreateWithoutRentalBookingsInput, PropertyUncheckedCreateWithoutRentalBookingsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutRentalBookingsInput
    upsert?: PropertyUpsertWithoutRentalBookingsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutRentalBookingsInput, PropertyUpdateWithoutRentalBookingsInput>, PropertyUncheckedUpdateWithoutRentalBookingsInput>
  }

  export type UserUpdateOneRequiredWithoutRentalBookingsNestedInput = {
    create?: XOR<UserCreateWithoutRentalBookingsInput, UserUncheckedCreateWithoutRentalBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRentalBookingsInput
    upsert?: UserUpsertWithoutRentalBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRentalBookingsInput, UserUpdateWithoutRentalBookingsInput>, UserUncheckedUpdateWithoutRentalBookingsInput>
  }

  export type UserUpdateOneWithoutBookingsAsAgentNestedInput = {
    create?: XOR<UserCreateWithoutBookingsAsAgentInput, UserUncheckedCreateWithoutBookingsAsAgentInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsAsAgentInput
    upsert?: UserUpsertWithoutBookingsAsAgentInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsAsAgentInput, UserUpdateWithoutBookingsAsAgentInput>, UserUncheckedUpdateWithoutBookingsAsAgentInput>
  }

  export type BookingMessageUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingMessageCreateWithoutBookingInput, BookingMessageUncheckedCreateWithoutBookingInput> | BookingMessageCreateWithoutBookingInput[] | BookingMessageUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingMessageCreateOrConnectWithoutBookingInput | BookingMessageCreateOrConnectWithoutBookingInput[]
    upsert?: BookingMessageUpsertWithWhereUniqueWithoutBookingInput | BookingMessageUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingMessageCreateManyBookingInputEnvelope
    set?: BookingMessageWhereUniqueInput | BookingMessageWhereUniqueInput[]
    disconnect?: BookingMessageWhereUniqueInput | BookingMessageWhereUniqueInput[]
    delete?: BookingMessageWhereUniqueInput | BookingMessageWhereUniqueInput[]
    connect?: BookingMessageWhereUniqueInput | BookingMessageWhereUniqueInput[]
    update?: BookingMessageUpdateWithWhereUniqueWithoutBookingInput | BookingMessageUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingMessageUpdateManyWithWhereWithoutBookingInput | BookingMessageUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingMessageScalarWhereInput | BookingMessageScalarWhereInput[]
  }

  export type BookingGuestUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingGuestCreateWithoutBookingInput, BookingGuestUncheckedCreateWithoutBookingInput> | BookingGuestCreateWithoutBookingInput[] | BookingGuestUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingGuestCreateOrConnectWithoutBookingInput | BookingGuestCreateOrConnectWithoutBookingInput[]
    upsert?: BookingGuestUpsertWithWhereUniqueWithoutBookingInput | BookingGuestUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingGuestCreateManyBookingInputEnvelope
    set?: BookingGuestWhereUniqueInput | BookingGuestWhereUniqueInput[]
    disconnect?: BookingGuestWhereUniqueInput | BookingGuestWhereUniqueInput[]
    delete?: BookingGuestWhereUniqueInput | BookingGuestWhereUniqueInput[]
    connect?: BookingGuestWhereUniqueInput | BookingGuestWhereUniqueInput[]
    update?: BookingGuestUpdateWithWhereUniqueWithoutBookingInput | BookingGuestUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingGuestUpdateManyWithWhereWithoutBookingInput | BookingGuestUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingGuestScalarWhereInput | BookingGuestScalarWhereInput[]
  }

  export type BookingMessageUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingMessageCreateWithoutBookingInput, BookingMessageUncheckedCreateWithoutBookingInput> | BookingMessageCreateWithoutBookingInput[] | BookingMessageUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingMessageCreateOrConnectWithoutBookingInput | BookingMessageCreateOrConnectWithoutBookingInput[]
    upsert?: BookingMessageUpsertWithWhereUniqueWithoutBookingInput | BookingMessageUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingMessageCreateManyBookingInputEnvelope
    set?: BookingMessageWhereUniqueInput | BookingMessageWhereUniqueInput[]
    disconnect?: BookingMessageWhereUniqueInput | BookingMessageWhereUniqueInput[]
    delete?: BookingMessageWhereUniqueInput | BookingMessageWhereUniqueInput[]
    connect?: BookingMessageWhereUniqueInput | BookingMessageWhereUniqueInput[]
    update?: BookingMessageUpdateWithWhereUniqueWithoutBookingInput | BookingMessageUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingMessageUpdateManyWithWhereWithoutBookingInput | BookingMessageUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingMessageScalarWhereInput | BookingMessageScalarWhereInput[]
  }

  export type BookingGuestUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingGuestCreateWithoutBookingInput, BookingGuestUncheckedCreateWithoutBookingInput> | BookingGuestCreateWithoutBookingInput[] | BookingGuestUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingGuestCreateOrConnectWithoutBookingInput | BookingGuestCreateOrConnectWithoutBookingInput[]
    upsert?: BookingGuestUpsertWithWhereUniqueWithoutBookingInput | BookingGuestUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingGuestCreateManyBookingInputEnvelope
    set?: BookingGuestWhereUniqueInput | BookingGuestWhereUniqueInput[]
    disconnect?: BookingGuestWhereUniqueInput | BookingGuestWhereUniqueInput[]
    delete?: BookingGuestWhereUniqueInput | BookingGuestWhereUniqueInput[]
    connect?: BookingGuestWhereUniqueInput | BookingGuestWhereUniqueInput[]
    update?: BookingGuestUpdateWithWhereUniqueWithoutBookingInput | BookingGuestUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingGuestUpdateManyWithWhereWithoutBookingInput | BookingGuestUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingGuestScalarWhereInput | BookingGuestScalarWhereInput[]
  }

  export type RentalBookingCreateNestedOneWithoutMessagesInput = {
    create?: XOR<RentalBookingCreateWithoutMessagesInput, RentalBookingUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: RentalBookingCreateOrConnectWithoutMessagesInput
    connect?: RentalBookingWhereUniqueInput
  }

  export type RentalBookingUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<RentalBookingCreateWithoutMessagesInput, RentalBookingUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: RentalBookingCreateOrConnectWithoutMessagesInput
    upsert?: RentalBookingUpsertWithoutMessagesInput
    connect?: RentalBookingWhereUniqueInput
    update?: XOR<XOR<RentalBookingUpdateToOneWithWhereWithoutMessagesInput, RentalBookingUpdateWithoutMessagesInput>, RentalBookingUncheckedUpdateWithoutMessagesInput>
  }

  export type RentalBookingCreateNestedOneWithoutGuestsInput = {
    create?: XOR<RentalBookingCreateWithoutGuestsInput, RentalBookingUncheckedCreateWithoutGuestsInput>
    connectOrCreate?: RentalBookingCreateOrConnectWithoutGuestsInput
    connect?: RentalBookingWhereUniqueInput
  }

  export type EnumTM30GuestStatusFieldUpdateOperationsInput = {
    set?: $Enums.TM30GuestStatus
  }

  export type RentalBookingUpdateOneRequiredWithoutGuestsNestedInput = {
    create?: XOR<RentalBookingCreateWithoutGuestsInput, RentalBookingUncheckedCreateWithoutGuestsInput>
    connectOrCreate?: RentalBookingCreateOrConnectWithoutGuestsInput
    upsert?: RentalBookingUpsertWithoutGuestsInput
    connect?: RentalBookingWhereUniqueInput
    update?: XOR<XOR<RentalBookingUpdateToOneWithWhereWithoutGuestsInput, RentalBookingUpdateWithoutGuestsInput>, RentalBookingUncheckedUpdateWithoutGuestsInput>
  }

  export type PropertyCreateNestedOneWithoutBlockedDatesInput = {
    create?: XOR<PropertyCreateWithoutBlockedDatesInput, PropertyUncheckedCreateWithoutBlockedDatesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutBlockedDatesInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutBlockedDatesNestedInput = {
    create?: XOR<PropertyCreateWithoutBlockedDatesInput, PropertyUncheckedCreateWithoutBlockedDatesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutBlockedDatesInput
    upsert?: PropertyUpsertWithoutBlockedDatesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutBlockedDatesInput, PropertyUpdateWithoutBlockedDatesInput>, PropertyUncheckedUpdateWithoutBlockedDatesInput>
  }

  export type PropertyCreateNestedOneWithoutTm30AccommodationInput = {
    create?: XOR<PropertyCreateWithoutTm30AccommodationInput, PropertyUncheckedCreateWithoutTm30AccommodationInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutTm30AccommodationInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneWithoutTm30AccommodationNestedInput = {
    create?: XOR<PropertyCreateWithoutTm30AccommodationInput, PropertyUncheckedCreateWithoutTm30AccommodationInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutTm30AccommodationInput
    upsert?: PropertyUpsertWithoutTm30AccommodationInput
    disconnect?: PropertyWhereInput | boolean
    delete?: PropertyWhereInput | boolean
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutTm30AccommodationInput, PropertyUpdateWithoutTm30AccommodationInput>, PropertyUncheckedUpdateWithoutTm30AccommodationInput>
  }

  export type PropertyOwnerCreateNestedOneWithoutTm30RequestsInput = {
    create?: XOR<PropertyOwnerCreateWithoutTm30RequestsInput, PropertyOwnerUncheckedCreateWithoutTm30RequestsInput>
    connectOrCreate?: PropertyOwnerCreateOrConnectWithoutTm30RequestsInput
    connect?: PropertyOwnerWhereUniqueInput
  }

  export type EnumTm30AccomRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.Tm30AccomRequestStatus
  }

  export type PropertyOwnerUpdateOneWithoutTm30RequestsNestedInput = {
    create?: XOR<PropertyOwnerCreateWithoutTm30RequestsInput, PropertyOwnerUncheckedCreateWithoutTm30RequestsInput>
    connectOrCreate?: PropertyOwnerCreateOrConnectWithoutTm30RequestsInput
    upsert?: PropertyOwnerUpsertWithoutTm30RequestsInput
    disconnect?: PropertyOwnerWhereInput | boolean
    delete?: PropertyOwnerWhereInput | boolean
    connect?: PropertyOwnerWhereUniqueInput
    update?: XOR<XOR<PropertyOwnerUpdateToOneWithWhereWithoutTm30RequestsInput, PropertyOwnerUpdateWithoutTm30RequestsInput>, PropertyOwnerUncheckedUpdateWithoutTm30RequestsInput>
  }

  export type OwnerDocumentCreateNestedManyWithoutOwnerInput = {
    create?: XOR<OwnerDocumentCreateWithoutOwnerInput, OwnerDocumentUncheckedCreateWithoutOwnerInput> | OwnerDocumentCreateWithoutOwnerInput[] | OwnerDocumentUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OwnerDocumentCreateOrConnectWithoutOwnerInput | OwnerDocumentCreateOrConnectWithoutOwnerInput[]
    createMany?: OwnerDocumentCreateManyOwnerInputEnvelope
    connect?: OwnerDocumentWhereUniqueInput | OwnerDocumentWhereUniqueInput[]
  }

  export type PropertyCreateNestedManyWithoutPropertyOwnerInput = {
    create?: XOR<PropertyCreateWithoutPropertyOwnerInput, PropertyUncheckedCreateWithoutPropertyOwnerInput> | PropertyCreateWithoutPropertyOwnerInput[] | PropertyUncheckedCreateWithoutPropertyOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyOwnerInput | PropertyCreateOrConnectWithoutPropertyOwnerInput[]
    createMany?: PropertyCreateManyPropertyOwnerInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type Tm30AccommodationRequestCreateNestedManyWithoutPropertyOwnerInput = {
    create?: XOR<Tm30AccommodationRequestCreateWithoutPropertyOwnerInput, Tm30AccommodationRequestUncheckedCreateWithoutPropertyOwnerInput> | Tm30AccommodationRequestCreateWithoutPropertyOwnerInput[] | Tm30AccommodationRequestUncheckedCreateWithoutPropertyOwnerInput[]
    connectOrCreate?: Tm30AccommodationRequestCreateOrConnectWithoutPropertyOwnerInput | Tm30AccommodationRequestCreateOrConnectWithoutPropertyOwnerInput[]
    createMany?: Tm30AccommodationRequestCreateManyPropertyOwnerInputEnvelope
    connect?: Tm30AccommodationRequestWhereUniqueInput | Tm30AccommodationRequestWhereUniqueInput[]
  }

  export type OwnerDocumentUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<OwnerDocumentCreateWithoutOwnerInput, OwnerDocumentUncheckedCreateWithoutOwnerInput> | OwnerDocumentCreateWithoutOwnerInput[] | OwnerDocumentUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OwnerDocumentCreateOrConnectWithoutOwnerInput | OwnerDocumentCreateOrConnectWithoutOwnerInput[]
    createMany?: OwnerDocumentCreateManyOwnerInputEnvelope
    connect?: OwnerDocumentWhereUniqueInput | OwnerDocumentWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutPropertyOwnerInput = {
    create?: XOR<PropertyCreateWithoutPropertyOwnerInput, PropertyUncheckedCreateWithoutPropertyOwnerInput> | PropertyCreateWithoutPropertyOwnerInput[] | PropertyUncheckedCreateWithoutPropertyOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyOwnerInput | PropertyCreateOrConnectWithoutPropertyOwnerInput[]
    createMany?: PropertyCreateManyPropertyOwnerInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type Tm30AccommodationRequestUncheckedCreateNestedManyWithoutPropertyOwnerInput = {
    create?: XOR<Tm30AccommodationRequestCreateWithoutPropertyOwnerInput, Tm30AccommodationRequestUncheckedCreateWithoutPropertyOwnerInput> | Tm30AccommodationRequestCreateWithoutPropertyOwnerInput[] | Tm30AccommodationRequestUncheckedCreateWithoutPropertyOwnerInput[]
    connectOrCreate?: Tm30AccommodationRequestCreateOrConnectWithoutPropertyOwnerInput | Tm30AccommodationRequestCreateOrConnectWithoutPropertyOwnerInput[]
    createMany?: Tm30AccommodationRequestCreateManyPropertyOwnerInputEnvelope
    connect?: Tm30AccommodationRequestWhereUniqueInput | Tm30AccommodationRequestWhereUniqueInput[]
  }

  export type OwnerDocumentUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<OwnerDocumentCreateWithoutOwnerInput, OwnerDocumentUncheckedCreateWithoutOwnerInput> | OwnerDocumentCreateWithoutOwnerInput[] | OwnerDocumentUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OwnerDocumentCreateOrConnectWithoutOwnerInput | OwnerDocumentCreateOrConnectWithoutOwnerInput[]
    upsert?: OwnerDocumentUpsertWithWhereUniqueWithoutOwnerInput | OwnerDocumentUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: OwnerDocumentCreateManyOwnerInputEnvelope
    set?: OwnerDocumentWhereUniqueInput | OwnerDocumentWhereUniqueInput[]
    disconnect?: OwnerDocumentWhereUniqueInput | OwnerDocumentWhereUniqueInput[]
    delete?: OwnerDocumentWhereUniqueInput | OwnerDocumentWhereUniqueInput[]
    connect?: OwnerDocumentWhereUniqueInput | OwnerDocumentWhereUniqueInput[]
    update?: OwnerDocumentUpdateWithWhereUniqueWithoutOwnerInput | OwnerDocumentUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: OwnerDocumentUpdateManyWithWhereWithoutOwnerInput | OwnerDocumentUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: OwnerDocumentScalarWhereInput | OwnerDocumentScalarWhereInput[]
  }

  export type PropertyUpdateManyWithoutPropertyOwnerNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyOwnerInput, PropertyUncheckedCreateWithoutPropertyOwnerInput> | PropertyCreateWithoutPropertyOwnerInput[] | PropertyUncheckedCreateWithoutPropertyOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyOwnerInput | PropertyCreateOrConnectWithoutPropertyOwnerInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutPropertyOwnerInput | PropertyUpsertWithWhereUniqueWithoutPropertyOwnerInput[]
    createMany?: PropertyCreateManyPropertyOwnerInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutPropertyOwnerInput | PropertyUpdateWithWhereUniqueWithoutPropertyOwnerInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutPropertyOwnerInput | PropertyUpdateManyWithWhereWithoutPropertyOwnerInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type Tm30AccommodationRequestUpdateManyWithoutPropertyOwnerNestedInput = {
    create?: XOR<Tm30AccommodationRequestCreateWithoutPropertyOwnerInput, Tm30AccommodationRequestUncheckedCreateWithoutPropertyOwnerInput> | Tm30AccommodationRequestCreateWithoutPropertyOwnerInput[] | Tm30AccommodationRequestUncheckedCreateWithoutPropertyOwnerInput[]
    connectOrCreate?: Tm30AccommodationRequestCreateOrConnectWithoutPropertyOwnerInput | Tm30AccommodationRequestCreateOrConnectWithoutPropertyOwnerInput[]
    upsert?: Tm30AccommodationRequestUpsertWithWhereUniqueWithoutPropertyOwnerInput | Tm30AccommodationRequestUpsertWithWhereUniqueWithoutPropertyOwnerInput[]
    createMany?: Tm30AccommodationRequestCreateManyPropertyOwnerInputEnvelope
    set?: Tm30AccommodationRequestWhereUniqueInput | Tm30AccommodationRequestWhereUniqueInput[]
    disconnect?: Tm30AccommodationRequestWhereUniqueInput | Tm30AccommodationRequestWhereUniqueInput[]
    delete?: Tm30AccommodationRequestWhereUniqueInput | Tm30AccommodationRequestWhereUniqueInput[]
    connect?: Tm30AccommodationRequestWhereUniqueInput | Tm30AccommodationRequestWhereUniqueInput[]
    update?: Tm30AccommodationRequestUpdateWithWhereUniqueWithoutPropertyOwnerInput | Tm30AccommodationRequestUpdateWithWhereUniqueWithoutPropertyOwnerInput[]
    updateMany?: Tm30AccommodationRequestUpdateManyWithWhereWithoutPropertyOwnerInput | Tm30AccommodationRequestUpdateManyWithWhereWithoutPropertyOwnerInput[]
    deleteMany?: Tm30AccommodationRequestScalarWhereInput | Tm30AccommodationRequestScalarWhereInput[]
  }

  export type OwnerDocumentUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<OwnerDocumentCreateWithoutOwnerInput, OwnerDocumentUncheckedCreateWithoutOwnerInput> | OwnerDocumentCreateWithoutOwnerInput[] | OwnerDocumentUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OwnerDocumentCreateOrConnectWithoutOwnerInput | OwnerDocumentCreateOrConnectWithoutOwnerInput[]
    upsert?: OwnerDocumentUpsertWithWhereUniqueWithoutOwnerInput | OwnerDocumentUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: OwnerDocumentCreateManyOwnerInputEnvelope
    set?: OwnerDocumentWhereUniqueInput | OwnerDocumentWhereUniqueInput[]
    disconnect?: OwnerDocumentWhereUniqueInput | OwnerDocumentWhereUniqueInput[]
    delete?: OwnerDocumentWhereUniqueInput | OwnerDocumentWhereUniqueInput[]
    connect?: OwnerDocumentWhereUniqueInput | OwnerDocumentWhereUniqueInput[]
    update?: OwnerDocumentUpdateWithWhereUniqueWithoutOwnerInput | OwnerDocumentUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: OwnerDocumentUpdateManyWithWhereWithoutOwnerInput | OwnerDocumentUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: OwnerDocumentScalarWhereInput | OwnerDocumentScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutPropertyOwnerNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyOwnerInput, PropertyUncheckedCreateWithoutPropertyOwnerInput> | PropertyCreateWithoutPropertyOwnerInput[] | PropertyUncheckedCreateWithoutPropertyOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyOwnerInput | PropertyCreateOrConnectWithoutPropertyOwnerInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutPropertyOwnerInput | PropertyUpsertWithWhereUniqueWithoutPropertyOwnerInput[]
    createMany?: PropertyCreateManyPropertyOwnerInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutPropertyOwnerInput | PropertyUpdateWithWhereUniqueWithoutPropertyOwnerInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutPropertyOwnerInput | PropertyUpdateManyWithWhereWithoutPropertyOwnerInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type Tm30AccommodationRequestUncheckedUpdateManyWithoutPropertyOwnerNestedInput = {
    create?: XOR<Tm30AccommodationRequestCreateWithoutPropertyOwnerInput, Tm30AccommodationRequestUncheckedCreateWithoutPropertyOwnerInput> | Tm30AccommodationRequestCreateWithoutPropertyOwnerInput[] | Tm30AccommodationRequestUncheckedCreateWithoutPropertyOwnerInput[]
    connectOrCreate?: Tm30AccommodationRequestCreateOrConnectWithoutPropertyOwnerInput | Tm30AccommodationRequestCreateOrConnectWithoutPropertyOwnerInput[]
    upsert?: Tm30AccommodationRequestUpsertWithWhereUniqueWithoutPropertyOwnerInput | Tm30AccommodationRequestUpsertWithWhereUniqueWithoutPropertyOwnerInput[]
    createMany?: Tm30AccommodationRequestCreateManyPropertyOwnerInputEnvelope
    set?: Tm30AccommodationRequestWhereUniqueInput | Tm30AccommodationRequestWhereUniqueInput[]
    disconnect?: Tm30AccommodationRequestWhereUniqueInput | Tm30AccommodationRequestWhereUniqueInput[]
    delete?: Tm30AccommodationRequestWhereUniqueInput | Tm30AccommodationRequestWhereUniqueInput[]
    connect?: Tm30AccommodationRequestWhereUniqueInput | Tm30AccommodationRequestWhereUniqueInput[]
    update?: Tm30AccommodationRequestUpdateWithWhereUniqueWithoutPropertyOwnerInput | Tm30AccommodationRequestUpdateWithWhereUniqueWithoutPropertyOwnerInput[]
    updateMany?: Tm30AccommodationRequestUpdateManyWithWhereWithoutPropertyOwnerInput | Tm30AccommodationRequestUpdateManyWithWhereWithoutPropertyOwnerInput[]
    deleteMany?: Tm30AccommodationRequestScalarWhereInput | Tm30AccommodationRequestScalarWhereInput[]
  }

  export type PropertyOwnerCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<PropertyOwnerCreateWithoutDocumentsInput, PropertyOwnerUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PropertyOwnerCreateOrConnectWithoutDocumentsInput
    connect?: PropertyOwnerWhereUniqueInput
  }

  export type EnumOwnerDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.OwnerDocumentType
  }

  export type PropertyOwnerUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<PropertyOwnerCreateWithoutDocumentsInput, PropertyOwnerUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PropertyOwnerCreateOrConnectWithoutDocumentsInput
    upsert?: PropertyOwnerUpsertWithoutDocumentsInput
    connect?: PropertyOwnerWhereUniqueInput
    update?: XOR<XOR<PropertyOwnerUpdateToOneWithWhereWithoutDocumentsInput, PropertyOwnerUpdateWithoutDocumentsInput>, PropertyOwnerUncheckedUpdateWithoutDocumentsInput>
  }

  export type AICodeChangeCreateNestedManyWithoutDecisionInput = {
    create?: XOR<AICodeChangeCreateWithoutDecisionInput, AICodeChangeUncheckedCreateWithoutDecisionInput> | AICodeChangeCreateWithoutDecisionInput[] | AICodeChangeUncheckedCreateWithoutDecisionInput[]
    connectOrCreate?: AICodeChangeCreateOrConnectWithoutDecisionInput | AICodeChangeCreateOrConnectWithoutDecisionInput[]
    createMany?: AICodeChangeCreateManyDecisionInputEnvelope
    connect?: AICodeChangeWhereUniqueInput | AICodeChangeWhereUniqueInput[]
  }

  export type AIAgentLogCreateNestedManyWithoutDecisionInput = {
    create?: XOR<AIAgentLogCreateWithoutDecisionInput, AIAgentLogUncheckedCreateWithoutDecisionInput> | AIAgentLogCreateWithoutDecisionInput[] | AIAgentLogUncheckedCreateWithoutDecisionInput[]
    connectOrCreate?: AIAgentLogCreateOrConnectWithoutDecisionInput | AIAgentLogCreateOrConnectWithoutDecisionInput[]
    createMany?: AIAgentLogCreateManyDecisionInputEnvelope
    connect?: AIAgentLogWhereUniqueInput | AIAgentLogWhereUniqueInput[]
  }

  export type AICodeChangeUncheckedCreateNestedManyWithoutDecisionInput = {
    create?: XOR<AICodeChangeCreateWithoutDecisionInput, AICodeChangeUncheckedCreateWithoutDecisionInput> | AICodeChangeCreateWithoutDecisionInput[] | AICodeChangeUncheckedCreateWithoutDecisionInput[]
    connectOrCreate?: AICodeChangeCreateOrConnectWithoutDecisionInput | AICodeChangeCreateOrConnectWithoutDecisionInput[]
    createMany?: AICodeChangeCreateManyDecisionInputEnvelope
    connect?: AICodeChangeWhereUniqueInput | AICodeChangeWhereUniqueInput[]
  }

  export type AIAgentLogUncheckedCreateNestedManyWithoutDecisionInput = {
    create?: XOR<AIAgentLogCreateWithoutDecisionInput, AIAgentLogUncheckedCreateWithoutDecisionInput> | AIAgentLogCreateWithoutDecisionInput[] | AIAgentLogUncheckedCreateWithoutDecisionInput[]
    connectOrCreate?: AIAgentLogCreateOrConnectWithoutDecisionInput | AIAgentLogCreateOrConnectWithoutDecisionInput[]
    createMany?: AIAgentLogCreateManyDecisionInputEnvelope
    connect?: AIAgentLogWhereUniqueInput | AIAgentLogWhereUniqueInput[]
  }

  export type EnumAIDecisionStatusFieldUpdateOperationsInput = {
    set?: $Enums.AIDecisionStatus
  }

  export type AICodeChangeUpdateManyWithoutDecisionNestedInput = {
    create?: XOR<AICodeChangeCreateWithoutDecisionInput, AICodeChangeUncheckedCreateWithoutDecisionInput> | AICodeChangeCreateWithoutDecisionInput[] | AICodeChangeUncheckedCreateWithoutDecisionInput[]
    connectOrCreate?: AICodeChangeCreateOrConnectWithoutDecisionInput | AICodeChangeCreateOrConnectWithoutDecisionInput[]
    upsert?: AICodeChangeUpsertWithWhereUniqueWithoutDecisionInput | AICodeChangeUpsertWithWhereUniqueWithoutDecisionInput[]
    createMany?: AICodeChangeCreateManyDecisionInputEnvelope
    set?: AICodeChangeWhereUniqueInput | AICodeChangeWhereUniqueInput[]
    disconnect?: AICodeChangeWhereUniqueInput | AICodeChangeWhereUniqueInput[]
    delete?: AICodeChangeWhereUniqueInput | AICodeChangeWhereUniqueInput[]
    connect?: AICodeChangeWhereUniqueInput | AICodeChangeWhereUniqueInput[]
    update?: AICodeChangeUpdateWithWhereUniqueWithoutDecisionInput | AICodeChangeUpdateWithWhereUniqueWithoutDecisionInput[]
    updateMany?: AICodeChangeUpdateManyWithWhereWithoutDecisionInput | AICodeChangeUpdateManyWithWhereWithoutDecisionInput[]
    deleteMany?: AICodeChangeScalarWhereInput | AICodeChangeScalarWhereInput[]
  }

  export type AIAgentLogUpdateManyWithoutDecisionNestedInput = {
    create?: XOR<AIAgentLogCreateWithoutDecisionInput, AIAgentLogUncheckedCreateWithoutDecisionInput> | AIAgentLogCreateWithoutDecisionInput[] | AIAgentLogUncheckedCreateWithoutDecisionInput[]
    connectOrCreate?: AIAgentLogCreateOrConnectWithoutDecisionInput | AIAgentLogCreateOrConnectWithoutDecisionInput[]
    upsert?: AIAgentLogUpsertWithWhereUniqueWithoutDecisionInput | AIAgentLogUpsertWithWhereUniqueWithoutDecisionInput[]
    createMany?: AIAgentLogCreateManyDecisionInputEnvelope
    set?: AIAgentLogWhereUniqueInput | AIAgentLogWhereUniqueInput[]
    disconnect?: AIAgentLogWhereUniqueInput | AIAgentLogWhereUniqueInput[]
    delete?: AIAgentLogWhereUniqueInput | AIAgentLogWhereUniqueInput[]
    connect?: AIAgentLogWhereUniqueInput | AIAgentLogWhereUniqueInput[]
    update?: AIAgentLogUpdateWithWhereUniqueWithoutDecisionInput | AIAgentLogUpdateWithWhereUniqueWithoutDecisionInput[]
    updateMany?: AIAgentLogUpdateManyWithWhereWithoutDecisionInput | AIAgentLogUpdateManyWithWhereWithoutDecisionInput[]
    deleteMany?: AIAgentLogScalarWhereInput | AIAgentLogScalarWhereInput[]
  }

  export type AICodeChangeUncheckedUpdateManyWithoutDecisionNestedInput = {
    create?: XOR<AICodeChangeCreateWithoutDecisionInput, AICodeChangeUncheckedCreateWithoutDecisionInput> | AICodeChangeCreateWithoutDecisionInput[] | AICodeChangeUncheckedCreateWithoutDecisionInput[]
    connectOrCreate?: AICodeChangeCreateOrConnectWithoutDecisionInput | AICodeChangeCreateOrConnectWithoutDecisionInput[]
    upsert?: AICodeChangeUpsertWithWhereUniqueWithoutDecisionInput | AICodeChangeUpsertWithWhereUniqueWithoutDecisionInput[]
    createMany?: AICodeChangeCreateManyDecisionInputEnvelope
    set?: AICodeChangeWhereUniqueInput | AICodeChangeWhereUniqueInput[]
    disconnect?: AICodeChangeWhereUniqueInput | AICodeChangeWhereUniqueInput[]
    delete?: AICodeChangeWhereUniqueInput | AICodeChangeWhereUniqueInput[]
    connect?: AICodeChangeWhereUniqueInput | AICodeChangeWhereUniqueInput[]
    update?: AICodeChangeUpdateWithWhereUniqueWithoutDecisionInput | AICodeChangeUpdateWithWhereUniqueWithoutDecisionInput[]
    updateMany?: AICodeChangeUpdateManyWithWhereWithoutDecisionInput | AICodeChangeUpdateManyWithWhereWithoutDecisionInput[]
    deleteMany?: AICodeChangeScalarWhereInput | AICodeChangeScalarWhereInput[]
  }

  export type AIAgentLogUncheckedUpdateManyWithoutDecisionNestedInput = {
    create?: XOR<AIAgentLogCreateWithoutDecisionInput, AIAgentLogUncheckedCreateWithoutDecisionInput> | AIAgentLogCreateWithoutDecisionInput[] | AIAgentLogUncheckedCreateWithoutDecisionInput[]
    connectOrCreate?: AIAgentLogCreateOrConnectWithoutDecisionInput | AIAgentLogCreateOrConnectWithoutDecisionInput[]
    upsert?: AIAgentLogUpsertWithWhereUniqueWithoutDecisionInput | AIAgentLogUpsertWithWhereUniqueWithoutDecisionInput[]
    createMany?: AIAgentLogCreateManyDecisionInputEnvelope
    set?: AIAgentLogWhereUniqueInput | AIAgentLogWhereUniqueInput[]
    disconnect?: AIAgentLogWhereUniqueInput | AIAgentLogWhereUniqueInput[]
    delete?: AIAgentLogWhereUniqueInput | AIAgentLogWhereUniqueInput[]
    connect?: AIAgentLogWhereUniqueInput | AIAgentLogWhereUniqueInput[]
    update?: AIAgentLogUpdateWithWhereUniqueWithoutDecisionInput | AIAgentLogUpdateWithWhereUniqueWithoutDecisionInput[]
    updateMany?: AIAgentLogUpdateManyWithWhereWithoutDecisionInput | AIAgentLogUpdateManyWithWhereWithoutDecisionInput[]
    deleteMany?: AIAgentLogScalarWhereInput | AIAgentLogScalarWhereInput[]
  }

  export type AIDecisionCreateNestedOneWithoutCodeChangesInput = {
    create?: XOR<AIDecisionCreateWithoutCodeChangesInput, AIDecisionUncheckedCreateWithoutCodeChangesInput>
    connectOrCreate?: AIDecisionCreateOrConnectWithoutCodeChangesInput
    connect?: AIDecisionWhereUniqueInput
  }

  export type EnumAICodeActionFieldUpdateOperationsInput = {
    set?: $Enums.AICodeAction
  }

  export type AIDecisionUpdateOneRequiredWithoutCodeChangesNestedInput = {
    create?: XOR<AIDecisionCreateWithoutCodeChangesInput, AIDecisionUncheckedCreateWithoutCodeChangesInput>
    connectOrCreate?: AIDecisionCreateOrConnectWithoutCodeChangesInput
    upsert?: AIDecisionUpsertWithoutCodeChangesInput
    connect?: AIDecisionWhereUniqueInput
    update?: XOR<XOR<AIDecisionUpdateToOneWithWhereWithoutCodeChangesInput, AIDecisionUpdateWithoutCodeChangesInput>, AIDecisionUncheckedUpdateWithoutCodeChangesInput>
  }

  export type AIDecisionCreateNestedOneWithoutLogsInput = {
    create?: XOR<AIDecisionCreateWithoutLogsInput, AIDecisionUncheckedCreateWithoutLogsInput>
    connectOrCreate?: AIDecisionCreateOrConnectWithoutLogsInput
    connect?: AIDecisionWhereUniqueInput
  }

  export type EnumAILogLevelFieldUpdateOperationsInput = {
    set?: $Enums.AILogLevel
  }

  export type AIDecisionUpdateOneWithoutLogsNestedInput = {
    create?: XOR<AIDecisionCreateWithoutLogsInput, AIDecisionUncheckedCreateWithoutLogsInput>
    connectOrCreate?: AIDecisionCreateOrConnectWithoutLogsInput
    upsert?: AIDecisionUpsertWithoutLogsInput
    disconnect?: AIDecisionWhereInput | boolean
    delete?: AIDecisionWhereInput | boolean
    connect?: AIDecisionWhereUniqueInput
    update?: XOR<XOR<AIDecisionUpdateToOneWithWhereWithoutLogsInput, AIDecisionUpdateWithoutLogsInput>, AIDecisionUncheckedUpdateWithoutLogsInput>
  }

  export type EnumAIOpportunityStatusFieldUpdateOperationsInput = {
    set?: $Enums.AIOpportunityStatus
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumPropertyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeFilter<$PrismaModel> | $Enums.PropertyType
  }

  export type NestedEnumPropertyCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyCategory | EnumPropertyCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyCategoryFilter<$PrismaModel> | $Enums.PropertyCategory
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedEnumOwnershipTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OwnershipType | EnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOwnershipTypeNullableFilter<$PrismaModel> | $Enums.OwnershipType | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeFilter<$PrismaModel>
  }

  export type NestedEnumPropertyCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyCategory | EnumPropertyCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PropertyCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyCategoryFilter<$PrismaModel>
    _max?: NestedEnumPropertyCategoryFilter<$PrismaModel>
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedEnumOwnershipTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OwnershipType | EnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOwnershipTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.OwnershipType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOwnershipTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumOwnershipTypeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumRequestTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestType | EnumRequestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestTypeFilter<$PrismaModel> | $Enums.RequestType
  }

  export type NestedEnumRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusFilter<$PrismaModel> | $Enums.RequestStatus
  }

  export type NestedEnumRequestTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestType | EnumRequestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestTypeWithAggregatesFilter<$PrismaModel> | $Enums.RequestType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestTypeFilter<$PrismaModel>
    _max?: NestedEnumRequestTypeFilter<$PrismaModel>
  }

  export type NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type NestedEnumRentalLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RentalLeadStatus | EnumRentalLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RentalLeadStatus[] | ListEnumRentalLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RentalLeadStatus[] | ListEnumRentalLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRentalLeadStatusFilter<$PrismaModel> | $Enums.RentalLeadStatus
  }

  export type NestedEnumRentalLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RentalLeadStatus | EnumRentalLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RentalLeadStatus[] | ListEnumRentalLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RentalLeadStatus[] | ListEnumRentalLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRentalLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.RentalLeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRentalLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumRentalLeadStatusFilter<$PrismaModel>
  }

  export type NestedEnumSubmissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionStatusFilter<$PrismaModel> | $Enums.SubmissionStatus
  }

  export type NestedEnumSubmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubmissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubmissionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubmissionStatusFilter<$PrismaModel>
  }

  export type NestedEnumLandingPageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LandingPageStatus | EnumLandingPageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LandingPageStatus[] | ListEnumLandingPageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LandingPageStatus[] | ListEnumLandingPageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLandingPageStatusFilter<$PrismaModel> | $Enums.LandingPageStatus
  }

  export type NestedEnumLandingPageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LandingPageStatus | EnumLandingPageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LandingPageStatus[] | ListEnumLandingPageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LandingPageStatus[] | ListEnumLandingPageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLandingPageStatusWithAggregatesFilter<$PrismaModel> | $Enums.LandingPageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLandingPageStatusFilter<$PrismaModel>
    _max?: NestedEnumLandingPageStatusFilter<$PrismaModel>
  }

  export type NestedEnumTopicStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TopicStatus | EnumTopicStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTopicStatusFilter<$PrismaModel> | $Enums.TopicStatus
  }

  export type NestedEnumTopicStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TopicStatus | EnumTopicStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TopicStatus[] | ListEnumTopicStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTopicStatusWithAggregatesFilter<$PrismaModel> | $Enums.TopicStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTopicStatusFilter<$PrismaModel>
    _max?: NestedEnumTopicStatusFilter<$PrismaModel>
  }

  export type NestedEnumScheduledBlogStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduledBlogStatus | EnumScheduledBlogStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduledBlogStatus[] | ListEnumScheduledBlogStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduledBlogStatus[] | ListEnumScheduledBlogStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduledBlogStatusFilter<$PrismaModel> | $Enums.ScheduledBlogStatus
  }

  export type NestedEnumScheduledBlogStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduledBlogStatus | EnumScheduledBlogStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduledBlogStatus[] | ListEnumScheduledBlogStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduledBlogStatus[] | ListEnumScheduledBlogStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduledBlogStatusWithAggregatesFilter<$PrismaModel> | $Enums.ScheduledBlogStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduledBlogStatusFilter<$PrismaModel>
    _max?: NestedEnumScheduledBlogStatusFilter<$PrismaModel>
  }

  export type NestedEnumHeroDeviceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.HeroDeviceType | EnumHeroDeviceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HeroDeviceType[] | ListEnumHeroDeviceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HeroDeviceType[] | ListEnumHeroDeviceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHeroDeviceTypeFilter<$PrismaModel> | $Enums.HeroDeviceType
  }

  export type NestedEnumHeroDeviceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HeroDeviceType | EnumHeroDeviceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HeroDeviceType[] | ListEnumHeroDeviceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HeroDeviceType[] | ListEnumHeroDeviceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHeroDeviceTypeWithAggregatesFilter<$PrismaModel> | $Enums.HeroDeviceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHeroDeviceTypeFilter<$PrismaModel>
    _max?: NestedEnumHeroDeviceTypeFilter<$PrismaModel>
  }

  export type NestedEnumPropertyTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyTypeNullableFilter<$PrismaModel> | $Enums.PropertyType | null
  }

  export type NestedEnumPropertyCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyCategory | EnumPropertyCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyCategoryNullableFilter<$PrismaModel> | $Enums.PropertyCategory | null
  }

  export type NestedEnumPropertyTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPropertyCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyCategory | EnumPropertyCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPropertyCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.PropertyCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPropertyCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumPropertyCategoryNullableFilter<$PrismaModel>
  }

  export type NestedEnumPoiSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.PoiSource | EnumPoiSourceFieldRefInput<$PrismaModel>
    in?: $Enums.PoiSource[] | ListEnumPoiSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoiSource[] | ListEnumPoiSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumPoiSourceFilter<$PrismaModel> | $Enums.PoiSource
  }

  export type NestedEnumPoiCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PoiCategory | EnumPoiCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PoiCategory[] | ListEnumPoiCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoiCategory[] | ListEnumPoiCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPoiCategoryFilter<$PrismaModel> | $Enums.PoiCategory
  }

  export type NestedEnumNoiseLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.NoiseLevel | EnumNoiseLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.NoiseLevel[] | ListEnumNoiseLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NoiseLevel[] | ListEnumNoiseLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNoiseLevelNullableFilter<$PrismaModel> | $Enums.NoiseLevel | null
  }

  export type NestedEnumTrafficLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TrafficLevel | EnumTrafficLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.TrafficLevel[] | ListEnumTrafficLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TrafficLevel[] | ListEnumTrafficLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTrafficLevelNullableFilter<$PrismaModel> | $Enums.TrafficLevel | null
  }

  export type NestedEnumPoiSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoiSource | EnumPoiSourceFieldRefInput<$PrismaModel>
    in?: $Enums.PoiSource[] | ListEnumPoiSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoiSource[] | ListEnumPoiSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumPoiSourceWithAggregatesFilter<$PrismaModel> | $Enums.PoiSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPoiSourceFilter<$PrismaModel>
    _max?: NestedEnumPoiSourceFilter<$PrismaModel>
  }

  export type NestedEnumPoiCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoiCategory | EnumPoiCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PoiCategory[] | ListEnumPoiCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoiCategory[] | ListEnumPoiCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPoiCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PoiCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPoiCategoryFilter<$PrismaModel>
    _max?: NestedEnumPoiCategoryFilter<$PrismaModel>
  }

  export type NestedEnumNoiseLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NoiseLevel | EnumNoiseLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.NoiseLevel[] | ListEnumNoiseLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NoiseLevel[] | ListEnumNoiseLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNoiseLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.NoiseLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumNoiseLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumNoiseLevelNullableFilter<$PrismaModel>
  }

  export type NestedEnumTrafficLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrafficLevel | EnumTrafficLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.TrafficLevel[] | ListEnumTrafficLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TrafficLevel[] | ListEnumTrafficLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTrafficLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.TrafficLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTrafficLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumTrafficLevelNullableFilter<$PrismaModel>
  }

  export type NestedEnumPoiSyncJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PoiSyncJobType | EnumPoiSyncJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PoiSyncJobType[] | ListEnumPoiSyncJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoiSyncJobType[] | ListEnumPoiSyncJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPoiSyncJobTypeFilter<$PrismaModel> | $Enums.PoiSyncJobType
  }

  export type NestedEnumPoiSyncJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PoiSyncJobStatus | EnumPoiSyncJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PoiSyncJobStatus[] | ListEnumPoiSyncJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoiSyncJobStatus[] | ListEnumPoiSyncJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPoiSyncJobStatusFilter<$PrismaModel> | $Enums.PoiSyncJobStatus
  }

  export type NestedEnumPoiCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PoiCategory | EnumPoiCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.PoiCategory[] | ListEnumPoiCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PoiCategory[] | ListEnumPoiCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPoiCategoryNullableFilter<$PrismaModel> | $Enums.PoiCategory | null
  }

  export type NestedEnumPoiSyncJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoiSyncJobType | EnumPoiSyncJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PoiSyncJobType[] | ListEnumPoiSyncJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoiSyncJobType[] | ListEnumPoiSyncJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPoiSyncJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.PoiSyncJobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPoiSyncJobTypeFilter<$PrismaModel>
    _max?: NestedEnumPoiSyncJobTypeFilter<$PrismaModel>
  }

  export type NestedEnumPoiSyncJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoiSyncJobStatus | EnumPoiSyncJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PoiSyncJobStatus[] | ListEnumPoiSyncJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PoiSyncJobStatus[] | ListEnumPoiSyncJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPoiSyncJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.PoiSyncJobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPoiSyncJobStatusFilter<$PrismaModel>
    _max?: NestedEnumPoiSyncJobStatusFilter<$PrismaModel>
  }

  export type NestedEnumPoiCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PoiCategory | EnumPoiCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.PoiCategory[] | ListEnumPoiCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PoiCategory[] | ListEnumPoiCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPoiCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.PoiCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPoiCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumPoiCategoryNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumRentalBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RentalBookingStatus | EnumRentalBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RentalBookingStatus[] | ListEnumRentalBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RentalBookingStatus[] | ListEnumRentalBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRentalBookingStatusFilter<$PrismaModel> | $Enums.RentalBookingStatus
  }

  export type NestedEnumTM30BookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TM30BookingStatus | EnumTM30BookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TM30BookingStatus[] | ListEnumTM30BookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TM30BookingStatus[] | ListEnumTM30BookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTM30BookingStatusFilter<$PrismaModel> | $Enums.TM30BookingStatus
  }

  export type NestedEnumRentalBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RentalBookingStatus | EnumRentalBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RentalBookingStatus[] | ListEnumRentalBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RentalBookingStatus[] | ListEnumRentalBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRentalBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.RentalBookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRentalBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumRentalBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumTM30BookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TM30BookingStatus | EnumTM30BookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TM30BookingStatus[] | ListEnumTM30BookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TM30BookingStatus[] | ListEnumTM30BookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTM30BookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.TM30BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTM30BookingStatusFilter<$PrismaModel>
    _max?: NestedEnumTM30BookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumTM30GuestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TM30GuestStatus | EnumTM30GuestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TM30GuestStatus[] | ListEnumTM30GuestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TM30GuestStatus[] | ListEnumTM30GuestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTM30GuestStatusFilter<$PrismaModel> | $Enums.TM30GuestStatus
  }

  export type NestedEnumTM30GuestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TM30GuestStatus | EnumTM30GuestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TM30GuestStatus[] | ListEnumTM30GuestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TM30GuestStatus[] | ListEnumTM30GuestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTM30GuestStatusWithAggregatesFilter<$PrismaModel> | $Enums.TM30GuestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTM30GuestStatusFilter<$PrismaModel>
    _max?: NestedEnumTM30GuestStatusFilter<$PrismaModel>
  }

  export type NestedEnumTm30AccomRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Tm30AccomRequestStatus | EnumTm30AccomRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Tm30AccomRequestStatus[] | ListEnumTm30AccomRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Tm30AccomRequestStatus[] | ListEnumTm30AccomRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTm30AccomRequestStatusFilter<$PrismaModel> | $Enums.Tm30AccomRequestStatus
  }

  export type NestedEnumTm30AccomRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tm30AccomRequestStatus | EnumTm30AccomRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Tm30AccomRequestStatus[] | ListEnumTm30AccomRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Tm30AccomRequestStatus[] | ListEnumTm30AccomRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTm30AccomRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.Tm30AccomRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTm30AccomRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumTm30AccomRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumOwnerDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OwnerDocumentType | EnumOwnerDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OwnerDocumentType[] | ListEnumOwnerDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OwnerDocumentType[] | ListEnumOwnerDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOwnerDocumentTypeFilter<$PrismaModel> | $Enums.OwnerDocumentType
  }

  export type NestedEnumOwnerDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OwnerDocumentType | EnumOwnerDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OwnerDocumentType[] | ListEnumOwnerDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OwnerDocumentType[] | ListEnumOwnerDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOwnerDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.OwnerDocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOwnerDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumOwnerDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumAIDecisionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AIDecisionStatus | EnumAIDecisionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AIDecisionStatus[] | ListEnumAIDecisionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIDecisionStatus[] | ListEnumAIDecisionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAIDecisionStatusFilter<$PrismaModel> | $Enums.AIDecisionStatus
  }

  export type NestedEnumAIDecisionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIDecisionStatus | EnumAIDecisionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AIDecisionStatus[] | ListEnumAIDecisionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIDecisionStatus[] | ListEnumAIDecisionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAIDecisionStatusWithAggregatesFilter<$PrismaModel> | $Enums.AIDecisionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIDecisionStatusFilter<$PrismaModel>
    _max?: NestedEnumAIDecisionStatusFilter<$PrismaModel>
  }

  export type NestedEnumAICodeActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AICodeAction | EnumAICodeActionFieldRefInput<$PrismaModel>
    in?: $Enums.AICodeAction[] | ListEnumAICodeActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AICodeAction[] | ListEnumAICodeActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAICodeActionFilter<$PrismaModel> | $Enums.AICodeAction
  }

  export type NestedEnumAICodeActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AICodeAction | EnumAICodeActionFieldRefInput<$PrismaModel>
    in?: $Enums.AICodeAction[] | ListEnumAICodeActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AICodeAction[] | ListEnumAICodeActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAICodeActionWithAggregatesFilter<$PrismaModel> | $Enums.AICodeAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAICodeActionFilter<$PrismaModel>
    _max?: NestedEnumAICodeActionFilter<$PrismaModel>
  }

  export type NestedEnumAILogLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AILogLevel | EnumAILogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AILogLevel[] | ListEnumAILogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AILogLevel[] | ListEnumAILogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAILogLevelFilter<$PrismaModel> | $Enums.AILogLevel
  }

  export type NestedEnumAILogLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AILogLevel | EnumAILogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AILogLevel[] | ListEnumAILogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AILogLevel[] | ListEnumAILogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAILogLevelWithAggregatesFilter<$PrismaModel> | $Enums.AILogLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAILogLevelFilter<$PrismaModel>
    _max?: NestedEnumAILogLevelFilter<$PrismaModel>
  }

  export type NestedEnumAIOpportunityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AIOpportunityStatus | EnumAIOpportunityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AIOpportunityStatus[] | ListEnumAIOpportunityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIOpportunityStatus[] | ListEnumAIOpportunityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAIOpportunityStatusFilter<$PrismaModel> | $Enums.AIOpportunityStatus
  }

  export type NestedEnumAIOpportunityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIOpportunityStatus | EnumAIOpportunityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AIOpportunityStatus[] | ListEnumAIOpportunityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIOpportunityStatus[] | ListEnumAIOpportunityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAIOpportunityStatusWithAggregatesFilter<$PrismaModel> | $Enums.AIOpportunityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIOpportunityStatusFilter<$PrismaModel>
    _max?: NestedEnumAIOpportunityStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutAccountsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    investorLeads?: InvestorLeadCreateNestedManyWithoutAssignedToInput
    rentalLeads?: RentalLeadCreateNestedManyWithoutAssignedToInput
    blogs?: BlogCreateNestedManyWithoutAuthorInput
    rentalBookings?: RentalBookingCreateNestedManyWithoutUserInput
    bookingsAsAgent?: RentalBookingCreateNestedManyWithoutAgentInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    investorLeads?: InvestorLeadUncheckedCreateNestedManyWithoutAssignedToInput
    rentalLeads?: RentalLeadUncheckedCreateNestedManyWithoutAssignedToInput
    blogs?: BlogUncheckedCreateNestedManyWithoutAuthorInput
    rentalBookings?: RentalBookingUncheckedCreateNestedManyWithoutUserInput
    bookingsAsAgent?: RentalBookingUncheckedCreateNestedManyWithoutAgentInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    investorLeads?: InvestorLeadUpdateManyWithoutAssignedToNestedInput
    rentalLeads?: RentalLeadUpdateManyWithoutAssignedToNestedInput
    blogs?: BlogUpdateManyWithoutAuthorNestedInput
    rentalBookings?: RentalBookingUpdateManyWithoutUserNestedInput
    bookingsAsAgent?: RentalBookingUpdateManyWithoutAgentNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    investorLeads?: InvestorLeadUncheckedUpdateManyWithoutAssignedToNestedInput
    rentalLeads?: RentalLeadUncheckedUpdateManyWithoutAssignedToNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutAuthorNestedInput
    rentalBookings?: RentalBookingUncheckedUpdateManyWithoutUserNestedInput
    bookingsAsAgent?: RentalBookingUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    investorLeads?: InvestorLeadCreateNestedManyWithoutAssignedToInput
    rentalLeads?: RentalLeadCreateNestedManyWithoutAssignedToInput
    blogs?: BlogCreateNestedManyWithoutAuthorInput
    rentalBookings?: RentalBookingCreateNestedManyWithoutUserInput
    bookingsAsAgent?: RentalBookingCreateNestedManyWithoutAgentInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    investorLeads?: InvestorLeadUncheckedCreateNestedManyWithoutAssignedToInput
    rentalLeads?: RentalLeadUncheckedCreateNestedManyWithoutAssignedToInput
    blogs?: BlogUncheckedCreateNestedManyWithoutAuthorInput
    rentalBookings?: RentalBookingUncheckedCreateNestedManyWithoutUserInput
    bookingsAsAgent?: RentalBookingUncheckedCreateNestedManyWithoutAgentInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    investorLeads?: InvestorLeadUpdateManyWithoutAssignedToNestedInput
    rentalLeads?: RentalLeadUpdateManyWithoutAssignedToNestedInput
    blogs?: BlogUpdateManyWithoutAuthorNestedInput
    rentalBookings?: RentalBookingUpdateManyWithoutUserNestedInput
    bookingsAsAgent?: RentalBookingUpdateManyWithoutAgentNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    investorLeads?: InvestorLeadUncheckedUpdateManyWithoutAssignedToNestedInput
    rentalLeads?: RentalLeadUncheckedUpdateManyWithoutAssignedToNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutAuthorNestedInput
    rentalBookings?: RentalBookingUncheckedUpdateManyWithoutUserNestedInput
    bookingsAsAgent?: RentalBookingUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type SessionCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PropertyCreateWithoutUserInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    views?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyOwner?: PropertyOwnerCreateNestedOneWithoutPropertiesInput
    poiDistances?: PropertyPoiDistanceCreateNestedManyWithoutPropertyInput
    viewingRequests?: ViewingRequestCreateNestedManyWithoutPropertyInput
    rentalBookings?: RentalBookingCreateNestedManyWithoutPropertyInput
    blockedDates?: PropertyBlockedDateCreateNestedManyWithoutPropertyInput
    tm30Accommodation?: Tm30AccommodationCreateNestedOneWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutUserInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    propertyOwnerId?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    views?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    poiDistances?: PropertyPoiDistanceUncheckedCreateNestedManyWithoutPropertyInput
    viewingRequests?: ViewingRequestUncheckedCreateNestedManyWithoutPropertyInput
    rentalBookings?: RentalBookingUncheckedCreateNestedManyWithoutPropertyInput
    blockedDates?: PropertyBlockedDateUncheckedCreateNestedManyWithoutPropertyInput
    tm30Accommodation?: Tm30AccommodationUncheckedCreateNestedOneWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutUserInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput>
  }

  export type PropertyCreateManyUserInputEnvelope = {
    data: PropertyCreateManyUserInput | PropertyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InvestorLeadCreateWithoutAssignedToInput = {
    id?: string
    name: string
    email: string
    phone: string
    countryCode?: string
    currency?: string
    investmentBudget: string
    investmentGoal: string
    timeline: string
    preferredAreas?: string | null
    propertyType?: string | null
    experience?: string | null
    financing?: string | null
    message?: string | null
    newsletter?: boolean
    status?: $Enums.LeadStatus
    ipAddress?: string | null
    userAgent?: string | null
    source?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorLeadUncheckedCreateWithoutAssignedToInput = {
    id?: string
    name: string
    email: string
    phone: string
    countryCode?: string
    currency?: string
    investmentBudget: string
    investmentGoal: string
    timeline: string
    preferredAreas?: string | null
    propertyType?: string | null
    experience?: string | null
    financing?: string | null
    message?: string | null
    newsletter?: boolean
    status?: $Enums.LeadStatus
    ipAddress?: string | null
    userAgent?: string | null
    source?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorLeadCreateOrConnectWithoutAssignedToInput = {
    where: InvestorLeadWhereUniqueInput
    create: XOR<InvestorLeadCreateWithoutAssignedToInput, InvestorLeadUncheckedCreateWithoutAssignedToInput>
  }

  export type InvestorLeadCreateManyAssignedToInputEnvelope = {
    data: InvestorLeadCreateManyAssignedToInput | InvestorLeadCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type RentalLeadCreateWithoutAssignedToInput = {
    id?: string
    name: string
    email: string
    phone: string
    countryCode?: string
    propertyType: string
    bedrooms: string
    budget: string
    rentalDuration: string
    preferredAreas?: string | null
    moveInDate?: string | null
    furnished?: string | null
    pets?: string | null
    message?: string | null
    newsletter?: boolean
    status?: $Enums.RentalLeadStatus
    ipAddress?: string | null
    userAgent?: string | null
    source?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RentalLeadUncheckedCreateWithoutAssignedToInput = {
    id?: string
    name: string
    email: string
    phone: string
    countryCode?: string
    propertyType: string
    bedrooms: string
    budget: string
    rentalDuration: string
    preferredAreas?: string | null
    moveInDate?: string | null
    furnished?: string | null
    pets?: string | null
    message?: string | null
    newsletter?: boolean
    status?: $Enums.RentalLeadStatus
    ipAddress?: string | null
    userAgent?: string | null
    source?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RentalLeadCreateOrConnectWithoutAssignedToInput = {
    where: RentalLeadWhereUniqueInput
    create: XOR<RentalLeadCreateWithoutAssignedToInput, RentalLeadUncheckedCreateWithoutAssignedToInput>
  }

  export type RentalLeadCreateManyAssignedToInputEnvelope = {
    data: RentalLeadCreateManyAssignedToInput | RentalLeadCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type BlogCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    coverImage?: string | null
    coverImageAlt?: string | null
    tag?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    published?: boolean
    publishedAt?: Date | string | null
    originalContent?: string | null
    linkOptimizedAt?: Date | string | null
    internalLinkCount?: number
    hasDynamicProperties?: boolean
    poiQueryParams?: string | null
    poiTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: BlogCategoryCreateNestedOneWithoutBlogsInput
    linkUsages?: LinkUsageCreateNestedManyWithoutBlogInput
  }

  export type BlogUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    coverImage?: string | null
    coverImageAlt?: string | null
    tag?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    categoryId?: string | null
    published?: boolean
    publishedAt?: Date | string | null
    originalContent?: string | null
    linkOptimizedAt?: Date | string | null
    internalLinkCount?: number
    hasDynamicProperties?: boolean
    poiQueryParams?: string | null
    poiTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    linkUsages?: LinkUsageUncheckedCreateNestedManyWithoutBlogInput
  }

  export type BlogCreateOrConnectWithoutAuthorInput = {
    where: BlogWhereUniqueInput
    create: XOR<BlogCreateWithoutAuthorInput, BlogUncheckedCreateWithoutAuthorInput>
  }

  export type BlogCreateManyAuthorInputEnvelope = {
    data: BlogCreateManyAuthorInput | BlogCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type RentalBookingCreateWithoutUserInput = {
    id?: string
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    adults?: number
    children?: number
    babies?: number
    pets?: number
    basePrice: number
    season: string
    discountPercent: number
    totalPrice: number
    guestName: string
    guestEmail: string
    guestPhone: string
    guestCountryCode?: string
    guestMessage?: string | null
    status?: $Enums.RentalBookingStatus
    paymentStatus?: string | null
    cancellationPolicy?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    internalNotes?: string | null
    checkInTime?: string | null
    checkOutTime?: string | null
    propertyAddress?: string | null
    propertyInstructions?: string | null
    wifiName?: string | null
    wifiPassword?: string | null
    accessCode?: string | null
    emergencyContact?: string | null
    houseRules?: string | null
    confirmedAt?: Date | string | null
    tm30Status?: $Enums.TM30BookingStatus
    tm30SubmittedAt?: Date | string | null
    tm30Reference?: string | null
    tm30Error?: string | null
    passportsRequired?: number
    passportsReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutRentalBookingsInput
    agent?: UserCreateNestedOneWithoutBookingsAsAgentInput
    messages?: BookingMessageCreateNestedManyWithoutBookingInput
    guests?: BookingGuestCreateNestedManyWithoutBookingInput
  }

  export type RentalBookingUncheckedCreateWithoutUserInput = {
    id?: string
    propertyId: string
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    adults?: number
    children?: number
    babies?: number
    pets?: number
    basePrice: number
    season: string
    discountPercent: number
    totalPrice: number
    guestName: string
    guestEmail: string
    guestPhone: string
    guestCountryCode?: string
    guestMessage?: string | null
    status?: $Enums.RentalBookingStatus
    paymentStatus?: string | null
    cancellationPolicy?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    internalNotes?: string | null
    checkInTime?: string | null
    checkOutTime?: string | null
    propertyAddress?: string | null
    propertyInstructions?: string | null
    wifiName?: string | null
    wifiPassword?: string | null
    accessCode?: string | null
    emergencyContact?: string | null
    houseRules?: string | null
    confirmedAt?: Date | string | null
    agentId?: string | null
    tm30Status?: $Enums.TM30BookingStatus
    tm30SubmittedAt?: Date | string | null
    tm30Reference?: string | null
    tm30Error?: string | null
    passportsRequired?: number
    passportsReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: BookingMessageUncheckedCreateNestedManyWithoutBookingInput
    guests?: BookingGuestUncheckedCreateNestedManyWithoutBookingInput
  }

  export type RentalBookingCreateOrConnectWithoutUserInput = {
    where: RentalBookingWhereUniqueInput
    create: XOR<RentalBookingCreateWithoutUserInput, RentalBookingUncheckedCreateWithoutUserInput>
  }

  export type RentalBookingCreateManyUserInputEnvelope = {
    data: RentalBookingCreateManyUserInput | RentalBookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RentalBookingCreateWithoutAgentInput = {
    id?: string
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    adults?: number
    children?: number
    babies?: number
    pets?: number
    basePrice: number
    season: string
    discountPercent: number
    totalPrice: number
    guestName: string
    guestEmail: string
    guestPhone: string
    guestCountryCode?: string
    guestMessage?: string | null
    status?: $Enums.RentalBookingStatus
    paymentStatus?: string | null
    cancellationPolicy?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    internalNotes?: string | null
    checkInTime?: string | null
    checkOutTime?: string | null
    propertyAddress?: string | null
    propertyInstructions?: string | null
    wifiName?: string | null
    wifiPassword?: string | null
    accessCode?: string | null
    emergencyContact?: string | null
    houseRules?: string | null
    confirmedAt?: Date | string | null
    tm30Status?: $Enums.TM30BookingStatus
    tm30SubmittedAt?: Date | string | null
    tm30Reference?: string | null
    tm30Error?: string | null
    passportsRequired?: number
    passportsReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutRentalBookingsInput
    user: UserCreateNestedOneWithoutRentalBookingsInput
    messages?: BookingMessageCreateNestedManyWithoutBookingInput
    guests?: BookingGuestCreateNestedManyWithoutBookingInput
  }

  export type RentalBookingUncheckedCreateWithoutAgentInput = {
    id?: string
    propertyId: string
    userId: string
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    adults?: number
    children?: number
    babies?: number
    pets?: number
    basePrice: number
    season: string
    discountPercent: number
    totalPrice: number
    guestName: string
    guestEmail: string
    guestPhone: string
    guestCountryCode?: string
    guestMessage?: string | null
    status?: $Enums.RentalBookingStatus
    paymentStatus?: string | null
    cancellationPolicy?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    internalNotes?: string | null
    checkInTime?: string | null
    checkOutTime?: string | null
    propertyAddress?: string | null
    propertyInstructions?: string | null
    wifiName?: string | null
    wifiPassword?: string | null
    accessCode?: string | null
    emergencyContact?: string | null
    houseRules?: string | null
    confirmedAt?: Date | string | null
    tm30Status?: $Enums.TM30BookingStatus
    tm30SubmittedAt?: Date | string | null
    tm30Reference?: string | null
    tm30Error?: string | null
    passportsRequired?: number
    passportsReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: BookingMessageUncheckedCreateNestedManyWithoutBookingInput
    guests?: BookingGuestUncheckedCreateNestedManyWithoutBookingInput
  }

  export type RentalBookingCreateOrConnectWithoutAgentInput = {
    where: RentalBookingWhereUniqueInput
    create: XOR<RentalBookingCreateWithoutAgentInput, RentalBookingUncheckedCreateWithoutAgentInput>
  }

  export type RentalBookingCreateManyAgentInputEnvelope = {
    data: RentalBookingCreateManyAgentInput | RentalBookingCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    impersonatedBy?: StringNullableFilter<"Session"> | string | null
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type PropertyUpsertWithWhereUniqueWithoutUserInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutUserInput, PropertyUncheckedUpdateWithoutUserInput>
    create: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutUserInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutUserInput, PropertyUncheckedUpdateWithoutUserInput>
  }

  export type PropertyUpdateManyWithWhereWithoutUserInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutUserInput>
  }

  export type PropertyScalarWhereInput = {
    AND?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    OR?: PropertyScalarWhereInput[]
    NOT?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    id?: StringFilter<"Property"> | string
    listingNumber?: StringNullableFilter<"Property"> | string | null
    title?: StringFilter<"Property"> | string
    slug?: StringFilter<"Property"> | string
    location?: StringFilter<"Property"> | string
    price?: StringFilter<"Property"> | string
    beds?: IntFilter<"Property"> | number
    baths?: FloatFilter<"Property"> | number
    sqft?: IntFilter<"Property"> | number
    plotSize?: IntNullableFilter<"Property"> | number | null
    type?: EnumPropertyTypeFilter<"Property"> | $Enums.PropertyType
    category?: EnumPropertyCategoryFilter<"Property"> | $Enums.PropertyCategory
    tag?: StringNullableFilter<"Property"> | string | null
    status?: EnumStatusFilter<"Property"> | $Enums.Status
    isHighlighted?: BoolFilter<"Property"> | boolean
    ownershipType?: EnumOwnershipTypeNullableFilter<"Property"> | $Enums.OwnershipType | null
    isResale?: BoolNullableFilter<"Property"> | boolean | null
    image?: StringFilter<"Property"> | string
    shortDescription?: StringNullableFilter<"Property"> | string | null
    descriptionParagraphs?: JsonNullableFilter<"Property">
    propertyFeatures?: JsonNullableFilter<"Property">
    amenities?: StringNullableListFilter<"Property">
    amenitiesWithIcons?: JsonNullableFilter<"Property">
    content?: StringFilter<"Property"> | string
    yearBuilt?: IntNullableFilter<"Property"> | number | null
    mapUrl?: StringNullableFilter<"Property"> | string | null
    monthlyRentalPrice?: FloatNullableFilter<"Property"> | number | null
    allowPets?: BoolFilter<"Property"> | boolean
    enableDailyRental?: BoolFilter<"Property"> | boolean
    maxGuests?: IntNullableFilter<"Property"> | number | null
    provinceSlug?: StringNullableFilter<"Property"> | string | null
    areaSlug?: StringNullableFilter<"Property"> | string | null
    ownerName?: StringNullableFilter<"Property"> | string | null
    ownerEmail?: StringNullableFilter<"Property"> | string | null
    ownerPhone?: StringNullableFilter<"Property"> | string | null
    ownerCountryCode?: StringNullableFilter<"Property"> | string | null
    ownerCompany?: StringNullableFilter<"Property"> | string | null
    ownerNotes?: StringNullableFilter<"Property"> | string | null
    propertyOwnerId?: StringNullableFilter<"Property"> | string | null
    bluebookUrl?: StringNullableFilter<"Property"> | string | null
    bluebookHouseId?: StringNullableFilter<"Property"> | string | null
    commissionRate?: FloatNullableFilter<"Property"> | number | null
    tm30AccommodationId?: StringNullableFilter<"Property"> | string | null
    tm30AccommodationName?: StringNullableFilter<"Property"> | string | null
    defaultCheckInTime?: StringNullableFilter<"Property"> | string | null
    defaultCheckOutTime?: StringNullableFilter<"Property"> | string | null
    defaultPropertyAddress?: StringNullableFilter<"Property"> | string | null
    defaultWifiName?: StringNullableFilter<"Property"> | string | null
    defaultWifiPassword?: StringNullableFilter<"Property"> | string | null
    defaultAccessCode?: StringNullableFilter<"Property"> | string | null
    defaultEmergencyContact?: StringNullableFilter<"Property"> | string | null
    defaultPropertyInstructions?: StringNullableFilter<"Property"> | string | null
    defaultHouseRules?: StringNullableFilter<"Property"> | string | null
    latitude?: FloatNullableFilter<"Property"> | number | null
    longitude?: FloatNullableFilter<"Property"> | number | null
    beachScore?: IntNullableFilter<"Property"> | number | null
    familyScore?: IntNullableFilter<"Property"> | number | null
    convenienceScore?: IntNullableFilter<"Property"> | number | null
    quietnessScore?: IntNullableFilter<"Property"> | number | null
    hasSeaView?: BoolFilter<"Property"> | boolean
    seaViewDirection?: StringNullableFilter<"Property"> | string | null
    seaDistance?: IntNullableFilter<"Property"> | number | null
    district?: StringNullableFilter<"Property"> | string | null
    poisLastCalculatedAt?: DateTimeNullableFilter<"Property"> | Date | string | null
    userId?: StringFilter<"Property"> | string
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
  }

  export type InvestorLeadUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: InvestorLeadWhereUniqueInput
    update: XOR<InvestorLeadUpdateWithoutAssignedToInput, InvestorLeadUncheckedUpdateWithoutAssignedToInput>
    create: XOR<InvestorLeadCreateWithoutAssignedToInput, InvestorLeadUncheckedCreateWithoutAssignedToInput>
  }

  export type InvestorLeadUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: InvestorLeadWhereUniqueInput
    data: XOR<InvestorLeadUpdateWithoutAssignedToInput, InvestorLeadUncheckedUpdateWithoutAssignedToInput>
  }

  export type InvestorLeadUpdateManyWithWhereWithoutAssignedToInput = {
    where: InvestorLeadScalarWhereInput
    data: XOR<InvestorLeadUpdateManyMutationInput, InvestorLeadUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type InvestorLeadScalarWhereInput = {
    AND?: InvestorLeadScalarWhereInput | InvestorLeadScalarWhereInput[]
    OR?: InvestorLeadScalarWhereInput[]
    NOT?: InvestorLeadScalarWhereInput | InvestorLeadScalarWhereInput[]
    id?: StringFilter<"InvestorLead"> | string
    name?: StringFilter<"InvestorLead"> | string
    email?: StringFilter<"InvestorLead"> | string
    phone?: StringFilter<"InvestorLead"> | string
    countryCode?: StringFilter<"InvestorLead"> | string
    currency?: StringFilter<"InvestorLead"> | string
    investmentBudget?: StringFilter<"InvestorLead"> | string
    investmentGoal?: StringFilter<"InvestorLead"> | string
    timeline?: StringFilter<"InvestorLead"> | string
    preferredAreas?: StringNullableFilter<"InvestorLead"> | string | null
    propertyType?: StringNullableFilter<"InvestorLead"> | string | null
    experience?: StringNullableFilter<"InvestorLead"> | string | null
    financing?: StringNullableFilter<"InvestorLead"> | string | null
    message?: StringNullableFilter<"InvestorLead"> | string | null
    newsletter?: BoolFilter<"InvestorLead"> | boolean
    status?: EnumLeadStatusFilter<"InvestorLead"> | $Enums.LeadStatus
    assignedToId?: StringNullableFilter<"InvestorLead"> | string | null
    ipAddress?: StringNullableFilter<"InvestorLead"> | string | null
    userAgent?: StringNullableFilter<"InvestorLead"> | string | null
    source?: StringNullableFilter<"InvestorLead"> | string | null
    createdAt?: DateTimeFilter<"InvestorLead"> | Date | string
    updatedAt?: DateTimeFilter<"InvestorLead"> | Date | string
  }

  export type RentalLeadUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: RentalLeadWhereUniqueInput
    update: XOR<RentalLeadUpdateWithoutAssignedToInput, RentalLeadUncheckedUpdateWithoutAssignedToInput>
    create: XOR<RentalLeadCreateWithoutAssignedToInput, RentalLeadUncheckedCreateWithoutAssignedToInput>
  }

  export type RentalLeadUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: RentalLeadWhereUniqueInput
    data: XOR<RentalLeadUpdateWithoutAssignedToInput, RentalLeadUncheckedUpdateWithoutAssignedToInput>
  }

  export type RentalLeadUpdateManyWithWhereWithoutAssignedToInput = {
    where: RentalLeadScalarWhereInput
    data: XOR<RentalLeadUpdateManyMutationInput, RentalLeadUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type RentalLeadScalarWhereInput = {
    AND?: RentalLeadScalarWhereInput | RentalLeadScalarWhereInput[]
    OR?: RentalLeadScalarWhereInput[]
    NOT?: RentalLeadScalarWhereInput | RentalLeadScalarWhereInput[]
    id?: StringFilter<"RentalLead"> | string
    name?: StringFilter<"RentalLead"> | string
    email?: StringFilter<"RentalLead"> | string
    phone?: StringFilter<"RentalLead"> | string
    countryCode?: StringFilter<"RentalLead"> | string
    propertyType?: StringFilter<"RentalLead"> | string
    bedrooms?: StringFilter<"RentalLead"> | string
    budget?: StringFilter<"RentalLead"> | string
    rentalDuration?: StringFilter<"RentalLead"> | string
    preferredAreas?: StringNullableFilter<"RentalLead"> | string | null
    moveInDate?: StringNullableFilter<"RentalLead"> | string | null
    furnished?: StringNullableFilter<"RentalLead"> | string | null
    pets?: StringNullableFilter<"RentalLead"> | string | null
    message?: StringNullableFilter<"RentalLead"> | string | null
    newsletter?: BoolFilter<"RentalLead"> | boolean
    status?: EnumRentalLeadStatusFilter<"RentalLead"> | $Enums.RentalLeadStatus
    assignedToId?: StringNullableFilter<"RentalLead"> | string | null
    ipAddress?: StringNullableFilter<"RentalLead"> | string | null
    userAgent?: StringNullableFilter<"RentalLead"> | string | null
    source?: StringNullableFilter<"RentalLead"> | string | null
    createdAt?: DateTimeFilter<"RentalLead"> | Date | string
    updatedAt?: DateTimeFilter<"RentalLead"> | Date | string
  }

  export type BlogUpsertWithWhereUniqueWithoutAuthorInput = {
    where: BlogWhereUniqueInput
    update: XOR<BlogUpdateWithoutAuthorInput, BlogUncheckedUpdateWithoutAuthorInput>
    create: XOR<BlogCreateWithoutAuthorInput, BlogUncheckedCreateWithoutAuthorInput>
  }

  export type BlogUpdateWithWhereUniqueWithoutAuthorInput = {
    where: BlogWhereUniqueInput
    data: XOR<BlogUpdateWithoutAuthorInput, BlogUncheckedUpdateWithoutAuthorInput>
  }

  export type BlogUpdateManyWithWhereWithoutAuthorInput = {
    where: BlogScalarWhereInput
    data: XOR<BlogUpdateManyMutationInput, BlogUncheckedUpdateManyWithoutAuthorInput>
  }

  export type BlogScalarWhereInput = {
    AND?: BlogScalarWhereInput | BlogScalarWhereInput[]
    OR?: BlogScalarWhereInput[]
    NOT?: BlogScalarWhereInput | BlogScalarWhereInput[]
    id?: StringFilter<"Blog"> | string
    title?: StringFilter<"Blog"> | string
    slug?: StringFilter<"Blog"> | string
    excerpt?: StringFilter<"Blog"> | string
    content?: StringFilter<"Blog"> | string
    coverImage?: StringNullableFilter<"Blog"> | string | null
    coverImageAlt?: StringNullableFilter<"Blog"> | string | null
    tag?: StringNullableFilter<"Blog"> | string | null
    metaTitle?: StringNullableFilter<"Blog"> | string | null
    metaDescription?: StringNullableFilter<"Blog"> | string | null
    categoryId?: StringNullableFilter<"Blog"> | string | null
    published?: BoolFilter<"Blog"> | boolean
    publishedAt?: DateTimeNullableFilter<"Blog"> | Date | string | null
    originalContent?: StringNullableFilter<"Blog"> | string | null
    linkOptimizedAt?: DateTimeNullableFilter<"Blog"> | Date | string | null
    internalLinkCount?: IntFilter<"Blog"> | number
    hasDynamicProperties?: BoolFilter<"Blog"> | boolean
    poiQueryParams?: StringNullableFilter<"Blog"> | string | null
    poiTemplateId?: StringNullableFilter<"Blog"> | string | null
    authorId?: StringFilter<"Blog"> | string
    createdAt?: DateTimeFilter<"Blog"> | Date | string
    updatedAt?: DateTimeFilter<"Blog"> | Date | string
  }

  export type RentalBookingUpsertWithWhereUniqueWithoutUserInput = {
    where: RentalBookingWhereUniqueInput
    update: XOR<RentalBookingUpdateWithoutUserInput, RentalBookingUncheckedUpdateWithoutUserInput>
    create: XOR<RentalBookingCreateWithoutUserInput, RentalBookingUncheckedCreateWithoutUserInput>
  }

  export type RentalBookingUpdateWithWhereUniqueWithoutUserInput = {
    where: RentalBookingWhereUniqueInput
    data: XOR<RentalBookingUpdateWithoutUserInput, RentalBookingUncheckedUpdateWithoutUserInput>
  }

  export type RentalBookingUpdateManyWithWhereWithoutUserInput = {
    where: RentalBookingScalarWhereInput
    data: XOR<RentalBookingUpdateManyMutationInput, RentalBookingUncheckedUpdateManyWithoutUserInput>
  }

  export type RentalBookingScalarWhereInput = {
    AND?: RentalBookingScalarWhereInput | RentalBookingScalarWhereInput[]
    OR?: RentalBookingScalarWhereInput[]
    NOT?: RentalBookingScalarWhereInput | RentalBookingScalarWhereInput[]
    id?: StringFilter<"RentalBooking"> | string
    propertyId?: StringFilter<"RentalBooking"> | string
    userId?: StringFilter<"RentalBooking"> | string
    checkIn?: DateTimeFilter<"RentalBooking"> | Date | string
    checkOut?: DateTimeFilter<"RentalBooking"> | Date | string
    nights?: IntFilter<"RentalBooking"> | number
    adults?: IntFilter<"RentalBooking"> | number
    children?: IntFilter<"RentalBooking"> | number
    babies?: IntFilter<"RentalBooking"> | number
    pets?: IntFilter<"RentalBooking"> | number
    basePrice?: FloatFilter<"RentalBooking"> | number
    season?: StringFilter<"RentalBooking"> | string
    discountPercent?: FloatFilter<"RentalBooking"> | number
    totalPrice?: FloatFilter<"RentalBooking"> | number
    guestName?: StringFilter<"RentalBooking"> | string
    guestEmail?: StringFilter<"RentalBooking"> | string
    guestPhone?: StringFilter<"RentalBooking"> | string
    guestCountryCode?: StringFilter<"RentalBooking"> | string
    guestMessage?: StringNullableFilter<"RentalBooking"> | string | null
    status?: EnumRentalBookingStatusFilter<"RentalBooking"> | $Enums.RentalBookingStatus
    paymentStatus?: StringNullableFilter<"RentalBooking"> | string | null
    cancellationPolicy?: StringNullableFilter<"RentalBooking"> | string | null
    cancelledAt?: DateTimeNullableFilter<"RentalBooking"> | Date | string | null
    cancellationReason?: StringNullableFilter<"RentalBooking"> | string | null
    internalNotes?: StringNullableFilter<"RentalBooking"> | string | null
    checkInTime?: StringNullableFilter<"RentalBooking"> | string | null
    checkOutTime?: StringNullableFilter<"RentalBooking"> | string | null
    propertyAddress?: StringNullableFilter<"RentalBooking"> | string | null
    propertyInstructions?: StringNullableFilter<"RentalBooking"> | string | null
    wifiName?: StringNullableFilter<"RentalBooking"> | string | null
    wifiPassword?: StringNullableFilter<"RentalBooking"> | string | null
    accessCode?: StringNullableFilter<"RentalBooking"> | string | null
    emergencyContact?: StringNullableFilter<"RentalBooking"> | string | null
    houseRules?: StringNullableFilter<"RentalBooking"> | string | null
    confirmedAt?: DateTimeNullableFilter<"RentalBooking"> | Date | string | null
    agentId?: StringNullableFilter<"RentalBooking"> | string | null
    tm30Status?: EnumTM30BookingStatusFilter<"RentalBooking"> | $Enums.TM30BookingStatus
    tm30SubmittedAt?: DateTimeNullableFilter<"RentalBooking"> | Date | string | null
    tm30Reference?: StringNullableFilter<"RentalBooking"> | string | null
    tm30Error?: StringNullableFilter<"RentalBooking"> | string | null
    passportsRequired?: IntFilter<"RentalBooking"> | number
    passportsReceived?: IntFilter<"RentalBooking"> | number
    createdAt?: DateTimeFilter<"RentalBooking"> | Date | string
    updatedAt?: DateTimeFilter<"RentalBooking"> | Date | string
  }

  export type RentalBookingUpsertWithWhereUniqueWithoutAgentInput = {
    where: RentalBookingWhereUniqueInput
    update: XOR<RentalBookingUpdateWithoutAgentInput, RentalBookingUncheckedUpdateWithoutAgentInput>
    create: XOR<RentalBookingCreateWithoutAgentInput, RentalBookingUncheckedCreateWithoutAgentInput>
  }

  export type RentalBookingUpdateWithWhereUniqueWithoutAgentInput = {
    where: RentalBookingWhereUniqueInput
    data: XOR<RentalBookingUpdateWithoutAgentInput, RentalBookingUncheckedUpdateWithoutAgentInput>
  }

  export type RentalBookingUpdateManyWithWhereWithoutAgentInput = {
    where: RentalBookingScalarWhereInput
    data: XOR<RentalBookingUpdateManyMutationInput, RentalBookingUncheckedUpdateManyWithoutAgentInput>
  }

  export type PropertyImageCreateWithoutPropertyInput = {
    id?: string
    url?: string | null
    position: number
    alt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyImageUncheckedCreateWithoutPropertyInput = {
    id?: string
    url?: string | null
    position: number
    alt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyImageCreateOrConnectWithoutPropertyInput = {
    where: PropertyImageWhereUniqueInput
    create: XOR<PropertyImageCreateWithoutPropertyInput, PropertyImageUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyImageCreateManyPropertyInputEnvelope = {
    data: PropertyImageCreateManyPropertyInput | PropertyImageCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PropertyViewCreateWithoutPropertyInput = {
    id?: string
    viewedAt?: Date | string
    country?: string | null
    city?: string | null
    ipHash?: string | null
    userAgent?: string | null
    referrer?: string | null
    sessionId?: string | null
  }

  export type PropertyViewUncheckedCreateWithoutPropertyInput = {
    id?: string
    viewedAt?: Date | string
    country?: string | null
    city?: string | null
    ipHash?: string | null
    userAgent?: string | null
    referrer?: string | null
    sessionId?: string | null
  }

  export type PropertyViewCreateOrConnectWithoutPropertyInput = {
    where: PropertyViewWhereUniqueInput
    create: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyViewCreateManyPropertyInputEnvelope = {
    data: PropertyViewCreateManyPropertyInput | PropertyViewCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PropertyOwnerCreateWithoutPropertiesInput = {
    id?: string
    firstName: string
    lastName: string
    thaiIdNumber?: string | null
    phone: string
    email?: string | null
    gender?: string | null
    idCardUrl?: string | null
    idCardPath?: string | null
    idCardOcrData?: NullableJsonNullValueInput | InputJsonValue
    idCardVerified?: boolean
    idCardUploadedAt?: Date | string | null
    isActive?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: OwnerDocumentCreateNestedManyWithoutOwnerInput
    tm30Requests?: Tm30AccommodationRequestCreateNestedManyWithoutPropertyOwnerInput
  }

  export type PropertyOwnerUncheckedCreateWithoutPropertiesInput = {
    id?: string
    firstName: string
    lastName: string
    thaiIdNumber?: string | null
    phone: string
    email?: string | null
    gender?: string | null
    idCardUrl?: string | null
    idCardPath?: string | null
    idCardOcrData?: NullableJsonNullValueInput | InputJsonValue
    idCardVerified?: boolean
    idCardUploadedAt?: Date | string | null
    isActive?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: OwnerDocumentUncheckedCreateNestedManyWithoutOwnerInput
    tm30Requests?: Tm30AccommodationRequestUncheckedCreateNestedManyWithoutPropertyOwnerInput
  }

  export type PropertyOwnerCreateOrConnectWithoutPropertiesInput = {
    where: PropertyOwnerWhereUniqueInput
    create: XOR<PropertyOwnerCreateWithoutPropertiesInput, PropertyOwnerUncheckedCreateWithoutPropertiesInput>
  }

  export type PropertyPoiDistanceCreateWithoutPropertyInput = {
    id?: string
    distanceMeters: number
    walkingMinutes?: number | null
    drivingMinutes?: number | null
    isHighlight?: boolean
    calculatedAt?: Date | string
    poi: PoiCreateNestedOneWithoutPropertyDistancesInput
  }

  export type PropertyPoiDistanceUncheckedCreateWithoutPropertyInput = {
    id?: string
    poiId: string
    distanceMeters: number
    walkingMinutes?: number | null
    drivingMinutes?: number | null
    isHighlight?: boolean
    calculatedAt?: Date | string
  }

  export type PropertyPoiDistanceCreateOrConnectWithoutPropertyInput = {
    where: PropertyPoiDistanceWhereUniqueInput
    create: XOR<PropertyPoiDistanceCreateWithoutPropertyInput, PropertyPoiDistanceUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyPoiDistanceCreateManyPropertyInputEnvelope = {
    data: PropertyPoiDistanceCreateManyPropertyInput | PropertyPoiDistanceCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutPropertiesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    investorLeads?: InvestorLeadCreateNestedManyWithoutAssignedToInput
    rentalLeads?: RentalLeadCreateNestedManyWithoutAssignedToInput
    blogs?: BlogCreateNestedManyWithoutAuthorInput
    rentalBookings?: RentalBookingCreateNestedManyWithoutUserInput
    bookingsAsAgent?: RentalBookingCreateNestedManyWithoutAgentInput
  }

  export type UserUncheckedCreateWithoutPropertiesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    investorLeads?: InvestorLeadUncheckedCreateNestedManyWithoutAssignedToInput
    rentalLeads?: RentalLeadUncheckedCreateNestedManyWithoutAssignedToInput
    blogs?: BlogUncheckedCreateNestedManyWithoutAuthorInput
    rentalBookings?: RentalBookingUncheckedCreateNestedManyWithoutUserInput
    bookingsAsAgent?: RentalBookingUncheckedCreateNestedManyWithoutAgentInput
  }

  export type UserCreateOrConnectWithoutPropertiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPropertiesInput, UserUncheckedCreateWithoutPropertiesInput>
  }

  export type ViewingRequestCreateWithoutPropertyInput = {
    id?: string
    requestType: $Enums.RequestType
    viewingDate?: Date | string | null
    name: string
    email: string
    phone: string
    countryCode?: string
    language?: string | null
    message?: string | null
    offerAmount?: string | null
    offerCurrency?: string | null
    status?: $Enums.RequestStatus
    confirmedBy?: string | null
    confirmedByName?: string | null
    confirmedAt?: Date | string | null
    completedBy?: string | null
    completedByName?: string | null
    completedAt?: Date | string | null
    cancelledBy?: string | null
    cancelledByName?: string | null
    cancelledAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViewingRequestUncheckedCreateWithoutPropertyInput = {
    id?: string
    requestType: $Enums.RequestType
    viewingDate?: Date | string | null
    name: string
    email: string
    phone: string
    countryCode?: string
    language?: string | null
    message?: string | null
    offerAmount?: string | null
    offerCurrency?: string | null
    status?: $Enums.RequestStatus
    confirmedBy?: string | null
    confirmedByName?: string | null
    confirmedAt?: Date | string | null
    completedBy?: string | null
    completedByName?: string | null
    completedAt?: Date | string | null
    cancelledBy?: string | null
    cancelledByName?: string | null
    cancelledAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ViewingRequestCreateOrConnectWithoutPropertyInput = {
    where: ViewingRequestWhereUniqueInput
    create: XOR<ViewingRequestCreateWithoutPropertyInput, ViewingRequestUncheckedCreateWithoutPropertyInput>
  }

  export type ViewingRequestCreateManyPropertyInputEnvelope = {
    data: ViewingRequestCreateManyPropertyInput | ViewingRequestCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type RentalBookingCreateWithoutPropertyInput = {
    id?: string
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    adults?: number
    children?: number
    babies?: number
    pets?: number
    basePrice: number
    season: string
    discountPercent: number
    totalPrice: number
    guestName: string
    guestEmail: string
    guestPhone: string
    guestCountryCode?: string
    guestMessage?: string | null
    status?: $Enums.RentalBookingStatus
    paymentStatus?: string | null
    cancellationPolicy?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    internalNotes?: string | null
    checkInTime?: string | null
    checkOutTime?: string | null
    propertyAddress?: string | null
    propertyInstructions?: string | null
    wifiName?: string | null
    wifiPassword?: string | null
    accessCode?: string | null
    emergencyContact?: string | null
    houseRules?: string | null
    confirmedAt?: Date | string | null
    tm30Status?: $Enums.TM30BookingStatus
    tm30SubmittedAt?: Date | string | null
    tm30Reference?: string | null
    tm30Error?: string | null
    passportsRequired?: number
    passportsReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRentalBookingsInput
    agent?: UserCreateNestedOneWithoutBookingsAsAgentInput
    messages?: BookingMessageCreateNestedManyWithoutBookingInput
    guests?: BookingGuestCreateNestedManyWithoutBookingInput
  }

  export type RentalBookingUncheckedCreateWithoutPropertyInput = {
    id?: string
    userId: string
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    adults?: number
    children?: number
    babies?: number
    pets?: number
    basePrice: number
    season: string
    discountPercent: number
    totalPrice: number
    guestName: string
    guestEmail: string
    guestPhone: string
    guestCountryCode?: string
    guestMessage?: string | null
    status?: $Enums.RentalBookingStatus
    paymentStatus?: string | null
    cancellationPolicy?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    internalNotes?: string | null
    checkInTime?: string | null
    checkOutTime?: string | null
    propertyAddress?: string | null
    propertyInstructions?: string | null
    wifiName?: string | null
    wifiPassword?: string | null
    accessCode?: string | null
    emergencyContact?: string | null
    houseRules?: string | null
    confirmedAt?: Date | string | null
    agentId?: string | null
    tm30Status?: $Enums.TM30BookingStatus
    tm30SubmittedAt?: Date | string | null
    tm30Reference?: string | null
    tm30Error?: string | null
    passportsRequired?: number
    passportsReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: BookingMessageUncheckedCreateNestedManyWithoutBookingInput
    guests?: BookingGuestUncheckedCreateNestedManyWithoutBookingInput
  }

  export type RentalBookingCreateOrConnectWithoutPropertyInput = {
    where: RentalBookingWhereUniqueInput
    create: XOR<RentalBookingCreateWithoutPropertyInput, RentalBookingUncheckedCreateWithoutPropertyInput>
  }

  export type RentalBookingCreateManyPropertyInputEnvelope = {
    data: RentalBookingCreateManyPropertyInput | RentalBookingCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PropertyBlockedDateCreateWithoutPropertyInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    blockedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyBlockedDateUncheckedCreateWithoutPropertyInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    blockedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyBlockedDateCreateOrConnectWithoutPropertyInput = {
    where: PropertyBlockedDateWhereUniqueInput
    create: XOR<PropertyBlockedDateCreateWithoutPropertyInput, PropertyBlockedDateUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyBlockedDateCreateManyPropertyInputEnvelope = {
    data: PropertyBlockedDateCreateManyPropertyInput | PropertyBlockedDateCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type Tm30AccommodationCreateWithoutPropertyInput = {
    id?: string
    tm30Id: string
    name: string
    address: string
    status?: string | null
    matchScore?: number | null
    matchedBy?: string | null
    matchedAt?: Date | string | null
    lastSyncedAt?: Date | string | null
    syncSource?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type Tm30AccommodationUncheckedCreateWithoutPropertyInput = {
    id?: string
    tm30Id: string
    name: string
    address: string
    status?: string | null
    matchScore?: number | null
    matchedBy?: string | null
    matchedAt?: Date | string | null
    lastSyncedAt?: Date | string | null
    syncSource?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type Tm30AccommodationCreateOrConnectWithoutPropertyInput = {
    where: Tm30AccommodationWhereUniqueInput
    create: XOR<Tm30AccommodationCreateWithoutPropertyInput, Tm30AccommodationUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyImageUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyImageWhereUniqueInput
    update: XOR<PropertyImageUpdateWithoutPropertyInput, PropertyImageUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyImageCreateWithoutPropertyInput, PropertyImageUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyImageUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyImageWhereUniqueInput
    data: XOR<PropertyImageUpdateWithoutPropertyInput, PropertyImageUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyImageUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyImageScalarWhereInput
    data: XOR<PropertyImageUpdateManyMutationInput, PropertyImageUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyImageScalarWhereInput = {
    AND?: PropertyImageScalarWhereInput | PropertyImageScalarWhereInput[]
    OR?: PropertyImageScalarWhereInput[]
    NOT?: PropertyImageScalarWhereInput | PropertyImageScalarWhereInput[]
    id?: StringFilter<"PropertyImage"> | string
    propertyId?: StringFilter<"PropertyImage"> | string
    url?: StringNullableFilter<"PropertyImage"> | string | null
    position?: IntFilter<"PropertyImage"> | number
    alt?: StringNullableFilter<"PropertyImage"> | string | null
    createdAt?: DateTimeFilter<"PropertyImage"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyImage"> | Date | string
  }

  export type PropertyViewUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyViewWhereUniqueInput
    update: XOR<PropertyViewUpdateWithoutPropertyInput, PropertyViewUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyViewUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyViewWhereUniqueInput
    data: XOR<PropertyViewUpdateWithoutPropertyInput, PropertyViewUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyViewUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyViewScalarWhereInput
    data: XOR<PropertyViewUpdateManyMutationInput, PropertyViewUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyViewScalarWhereInput = {
    AND?: PropertyViewScalarWhereInput | PropertyViewScalarWhereInput[]
    OR?: PropertyViewScalarWhereInput[]
    NOT?: PropertyViewScalarWhereInput | PropertyViewScalarWhereInput[]
    id?: StringFilter<"PropertyView"> | string
    propertyId?: StringFilter<"PropertyView"> | string
    viewedAt?: DateTimeFilter<"PropertyView"> | Date | string
    country?: StringNullableFilter<"PropertyView"> | string | null
    city?: StringNullableFilter<"PropertyView"> | string | null
    ipHash?: StringNullableFilter<"PropertyView"> | string | null
    userAgent?: StringNullableFilter<"PropertyView"> | string | null
    referrer?: StringNullableFilter<"PropertyView"> | string | null
    sessionId?: StringNullableFilter<"PropertyView"> | string | null
  }

  export type PropertyOwnerUpsertWithoutPropertiesInput = {
    update: XOR<PropertyOwnerUpdateWithoutPropertiesInput, PropertyOwnerUncheckedUpdateWithoutPropertiesInput>
    create: XOR<PropertyOwnerCreateWithoutPropertiesInput, PropertyOwnerUncheckedCreateWithoutPropertiesInput>
    where?: PropertyOwnerWhereInput
  }

  export type PropertyOwnerUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: PropertyOwnerWhereInput
    data: XOR<PropertyOwnerUpdateWithoutPropertiesInput, PropertyOwnerUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertyOwnerUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    idCardUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idCardPath?: NullableStringFieldUpdateOperationsInput | string | null
    idCardOcrData?: NullableJsonNullValueInput | InputJsonValue
    idCardVerified?: BoolFieldUpdateOperationsInput | boolean
    idCardUploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: OwnerDocumentUpdateManyWithoutOwnerNestedInput
    tm30Requests?: Tm30AccommodationRequestUpdateManyWithoutPropertyOwnerNestedInput
  }

  export type PropertyOwnerUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    idCardUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idCardPath?: NullableStringFieldUpdateOperationsInput | string | null
    idCardOcrData?: NullableJsonNullValueInput | InputJsonValue
    idCardVerified?: BoolFieldUpdateOperationsInput | boolean
    idCardUploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: OwnerDocumentUncheckedUpdateManyWithoutOwnerNestedInput
    tm30Requests?: Tm30AccommodationRequestUncheckedUpdateManyWithoutPropertyOwnerNestedInput
  }

  export type PropertyPoiDistanceUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyPoiDistanceWhereUniqueInput
    update: XOR<PropertyPoiDistanceUpdateWithoutPropertyInput, PropertyPoiDistanceUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyPoiDistanceCreateWithoutPropertyInput, PropertyPoiDistanceUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyPoiDistanceUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyPoiDistanceWhereUniqueInput
    data: XOR<PropertyPoiDistanceUpdateWithoutPropertyInput, PropertyPoiDistanceUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyPoiDistanceUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyPoiDistanceScalarWhereInput
    data: XOR<PropertyPoiDistanceUpdateManyMutationInput, PropertyPoiDistanceUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyPoiDistanceScalarWhereInput = {
    AND?: PropertyPoiDistanceScalarWhereInput | PropertyPoiDistanceScalarWhereInput[]
    OR?: PropertyPoiDistanceScalarWhereInput[]
    NOT?: PropertyPoiDistanceScalarWhereInput | PropertyPoiDistanceScalarWhereInput[]
    id?: StringFilter<"PropertyPoiDistance"> | string
    propertyId?: StringFilter<"PropertyPoiDistance"> | string
    poiId?: StringFilter<"PropertyPoiDistance"> | string
    distanceMeters?: IntFilter<"PropertyPoiDistance"> | number
    walkingMinutes?: IntNullableFilter<"PropertyPoiDistance"> | number | null
    drivingMinutes?: IntNullableFilter<"PropertyPoiDistance"> | number | null
    isHighlight?: BoolFilter<"PropertyPoiDistance"> | boolean
    calculatedAt?: DateTimeFilter<"PropertyPoiDistance"> | Date | string
  }

  export type UserUpsertWithoutPropertiesInput = {
    update: XOR<UserUpdateWithoutPropertiesInput, UserUncheckedUpdateWithoutPropertiesInput>
    create: XOR<UserCreateWithoutPropertiesInput, UserUncheckedCreateWithoutPropertiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPropertiesInput, UserUncheckedUpdateWithoutPropertiesInput>
  }

  export type UserUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    investorLeads?: InvestorLeadUpdateManyWithoutAssignedToNestedInput
    rentalLeads?: RentalLeadUpdateManyWithoutAssignedToNestedInput
    blogs?: BlogUpdateManyWithoutAuthorNestedInput
    rentalBookings?: RentalBookingUpdateManyWithoutUserNestedInput
    bookingsAsAgent?: RentalBookingUpdateManyWithoutAgentNestedInput
  }

  export type UserUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    investorLeads?: InvestorLeadUncheckedUpdateManyWithoutAssignedToNestedInput
    rentalLeads?: RentalLeadUncheckedUpdateManyWithoutAssignedToNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutAuthorNestedInput
    rentalBookings?: RentalBookingUncheckedUpdateManyWithoutUserNestedInput
    bookingsAsAgent?: RentalBookingUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type ViewingRequestUpsertWithWhereUniqueWithoutPropertyInput = {
    where: ViewingRequestWhereUniqueInput
    update: XOR<ViewingRequestUpdateWithoutPropertyInput, ViewingRequestUncheckedUpdateWithoutPropertyInput>
    create: XOR<ViewingRequestCreateWithoutPropertyInput, ViewingRequestUncheckedCreateWithoutPropertyInput>
  }

  export type ViewingRequestUpdateWithWhereUniqueWithoutPropertyInput = {
    where: ViewingRequestWhereUniqueInput
    data: XOR<ViewingRequestUpdateWithoutPropertyInput, ViewingRequestUncheckedUpdateWithoutPropertyInput>
  }

  export type ViewingRequestUpdateManyWithWhereWithoutPropertyInput = {
    where: ViewingRequestScalarWhereInput
    data: XOR<ViewingRequestUpdateManyMutationInput, ViewingRequestUncheckedUpdateManyWithoutPropertyInput>
  }

  export type ViewingRequestScalarWhereInput = {
    AND?: ViewingRequestScalarWhereInput | ViewingRequestScalarWhereInput[]
    OR?: ViewingRequestScalarWhereInput[]
    NOT?: ViewingRequestScalarWhereInput | ViewingRequestScalarWhereInput[]
    id?: StringFilter<"ViewingRequest"> | string
    propertyId?: StringNullableFilter<"ViewingRequest"> | string | null
    requestType?: EnumRequestTypeFilter<"ViewingRequest"> | $Enums.RequestType
    viewingDate?: DateTimeNullableFilter<"ViewingRequest"> | Date | string | null
    name?: StringFilter<"ViewingRequest"> | string
    email?: StringFilter<"ViewingRequest"> | string
    phone?: StringFilter<"ViewingRequest"> | string
    countryCode?: StringFilter<"ViewingRequest"> | string
    language?: StringNullableFilter<"ViewingRequest"> | string | null
    message?: StringNullableFilter<"ViewingRequest"> | string | null
    offerAmount?: StringNullableFilter<"ViewingRequest"> | string | null
    offerCurrency?: StringNullableFilter<"ViewingRequest"> | string | null
    status?: EnumRequestStatusFilter<"ViewingRequest"> | $Enums.RequestStatus
    confirmedBy?: StringNullableFilter<"ViewingRequest"> | string | null
    confirmedByName?: StringNullableFilter<"ViewingRequest"> | string | null
    confirmedAt?: DateTimeNullableFilter<"ViewingRequest"> | Date | string | null
    completedBy?: StringNullableFilter<"ViewingRequest"> | string | null
    completedByName?: StringNullableFilter<"ViewingRequest"> | string | null
    completedAt?: DateTimeNullableFilter<"ViewingRequest"> | Date | string | null
    cancelledBy?: StringNullableFilter<"ViewingRequest"> | string | null
    cancelledByName?: StringNullableFilter<"ViewingRequest"> | string | null
    cancelledAt?: DateTimeNullableFilter<"ViewingRequest"> | Date | string | null
    ipAddress?: StringNullableFilter<"ViewingRequest"> | string | null
    userAgent?: StringNullableFilter<"ViewingRequest"> | string | null
    createdAt?: DateTimeFilter<"ViewingRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ViewingRequest"> | Date | string
  }

  export type RentalBookingUpsertWithWhereUniqueWithoutPropertyInput = {
    where: RentalBookingWhereUniqueInput
    update: XOR<RentalBookingUpdateWithoutPropertyInput, RentalBookingUncheckedUpdateWithoutPropertyInput>
    create: XOR<RentalBookingCreateWithoutPropertyInput, RentalBookingUncheckedCreateWithoutPropertyInput>
  }

  export type RentalBookingUpdateWithWhereUniqueWithoutPropertyInput = {
    where: RentalBookingWhereUniqueInput
    data: XOR<RentalBookingUpdateWithoutPropertyInput, RentalBookingUncheckedUpdateWithoutPropertyInput>
  }

  export type RentalBookingUpdateManyWithWhereWithoutPropertyInput = {
    where: RentalBookingScalarWhereInput
    data: XOR<RentalBookingUpdateManyMutationInput, RentalBookingUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyBlockedDateUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyBlockedDateWhereUniqueInput
    update: XOR<PropertyBlockedDateUpdateWithoutPropertyInput, PropertyBlockedDateUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyBlockedDateCreateWithoutPropertyInput, PropertyBlockedDateUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyBlockedDateUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyBlockedDateWhereUniqueInput
    data: XOR<PropertyBlockedDateUpdateWithoutPropertyInput, PropertyBlockedDateUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyBlockedDateUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyBlockedDateScalarWhereInput
    data: XOR<PropertyBlockedDateUpdateManyMutationInput, PropertyBlockedDateUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyBlockedDateScalarWhereInput = {
    AND?: PropertyBlockedDateScalarWhereInput | PropertyBlockedDateScalarWhereInput[]
    OR?: PropertyBlockedDateScalarWhereInput[]
    NOT?: PropertyBlockedDateScalarWhereInput | PropertyBlockedDateScalarWhereInput[]
    id?: StringFilter<"PropertyBlockedDate"> | string
    propertyId?: StringFilter<"PropertyBlockedDate"> | string
    startDate?: DateTimeFilter<"PropertyBlockedDate"> | Date | string
    endDate?: DateTimeFilter<"PropertyBlockedDate"> | Date | string
    reason?: StringNullableFilter<"PropertyBlockedDate"> | string | null
    blockedBy?: StringNullableFilter<"PropertyBlockedDate"> | string | null
    createdAt?: DateTimeFilter<"PropertyBlockedDate"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyBlockedDate"> | Date | string
  }

  export type Tm30AccommodationUpsertWithoutPropertyInput = {
    update: XOR<Tm30AccommodationUpdateWithoutPropertyInput, Tm30AccommodationUncheckedUpdateWithoutPropertyInput>
    create: XOR<Tm30AccommodationCreateWithoutPropertyInput, Tm30AccommodationUncheckedCreateWithoutPropertyInput>
    where?: Tm30AccommodationWhereInput
  }

  export type Tm30AccommodationUpdateToOneWithWhereWithoutPropertyInput = {
    where?: Tm30AccommodationWhereInput
    data: XOR<Tm30AccommodationUpdateWithoutPropertyInput, Tm30AccommodationUncheckedUpdateWithoutPropertyInput>
  }

  export type Tm30AccommodationUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tm30Id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    matchScore?: NullableFloatFieldUpdateOperationsInput | number | null
    matchedBy?: NullableStringFieldUpdateOperationsInput | string | null
    matchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Tm30AccommodationUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tm30Id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    matchScore?: NullableFloatFieldUpdateOperationsInput | number | null
    matchedBy?: NullableStringFieldUpdateOperationsInput | string | null
    matchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncSource?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PropertyCreateWithoutImagesInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    views?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyOwner?: PropertyOwnerCreateNestedOneWithoutPropertiesInput
    poiDistances?: PropertyPoiDistanceCreateNestedManyWithoutPropertyInput
    user: UserCreateNestedOneWithoutPropertiesInput
    viewingRequests?: ViewingRequestCreateNestedManyWithoutPropertyInput
    rentalBookings?: RentalBookingCreateNestedManyWithoutPropertyInput
    blockedDates?: PropertyBlockedDateCreateNestedManyWithoutPropertyInput
    tm30Accommodation?: Tm30AccommodationCreateNestedOneWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutImagesInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    propertyOwnerId?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    views?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    poiDistances?: PropertyPoiDistanceUncheckedCreateNestedManyWithoutPropertyInput
    viewingRequests?: ViewingRequestUncheckedCreateNestedManyWithoutPropertyInput
    rentalBookings?: RentalBookingUncheckedCreateNestedManyWithoutPropertyInput
    blockedDates?: PropertyBlockedDateUncheckedCreateNestedManyWithoutPropertyInput
    tm30Accommodation?: Tm30AccommodationUncheckedCreateNestedOneWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutImagesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutImagesInput, PropertyUncheckedCreateWithoutImagesInput>
  }

  export type PropertyUpsertWithoutImagesInput = {
    update: XOR<PropertyUpdateWithoutImagesInput, PropertyUncheckedUpdateWithoutImagesInput>
    create: XOR<PropertyCreateWithoutImagesInput, PropertyUncheckedCreateWithoutImagesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutImagesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutImagesInput, PropertyUncheckedUpdateWithoutImagesInput>
  }

  export type PropertyUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    views?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyOwner?: PropertyOwnerUpdateOneWithoutPropertiesNestedInput
    poiDistances?: PropertyPoiDistanceUpdateManyWithoutPropertyNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    viewingRequests?: ViewingRequestUpdateManyWithoutPropertyNestedInput
    rentalBookings?: RentalBookingUpdateManyWithoutPropertyNestedInput
    blockedDates?: PropertyBlockedDateUpdateManyWithoutPropertyNestedInput
    tm30Accommodation?: Tm30AccommodationUpdateOneWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    propertyOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    views?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    poiDistances?: PropertyPoiDistanceUncheckedUpdateManyWithoutPropertyNestedInput
    viewingRequests?: ViewingRequestUncheckedUpdateManyWithoutPropertyNestedInput
    rentalBookings?: RentalBookingUncheckedUpdateManyWithoutPropertyNestedInput
    blockedDates?: PropertyBlockedDateUncheckedUpdateManyWithoutPropertyNestedInput
    tm30Accommodation?: Tm30AccommodationUncheckedUpdateOneWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutViewsInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    propertyOwner?: PropertyOwnerCreateNestedOneWithoutPropertiesInput
    poiDistances?: PropertyPoiDistanceCreateNestedManyWithoutPropertyInput
    user: UserCreateNestedOneWithoutPropertiesInput
    viewingRequests?: ViewingRequestCreateNestedManyWithoutPropertyInput
    rentalBookings?: RentalBookingCreateNestedManyWithoutPropertyInput
    blockedDates?: PropertyBlockedDateCreateNestedManyWithoutPropertyInput
    tm30Accommodation?: Tm30AccommodationCreateNestedOneWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutViewsInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    propertyOwnerId?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    poiDistances?: PropertyPoiDistanceUncheckedCreateNestedManyWithoutPropertyInput
    viewingRequests?: ViewingRequestUncheckedCreateNestedManyWithoutPropertyInput
    rentalBookings?: RentalBookingUncheckedCreateNestedManyWithoutPropertyInput
    blockedDates?: PropertyBlockedDateUncheckedCreateNestedManyWithoutPropertyInput
    tm30Accommodation?: Tm30AccommodationUncheckedCreateNestedOneWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutViewsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutViewsInput, PropertyUncheckedCreateWithoutViewsInput>
  }

  export type PropertyUpsertWithoutViewsInput = {
    update: XOR<PropertyUpdateWithoutViewsInput, PropertyUncheckedUpdateWithoutViewsInput>
    create: XOR<PropertyCreateWithoutViewsInput, PropertyUncheckedCreateWithoutViewsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutViewsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutViewsInput, PropertyUncheckedUpdateWithoutViewsInput>
  }

  export type PropertyUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    propertyOwner?: PropertyOwnerUpdateOneWithoutPropertiesNestedInput
    poiDistances?: PropertyPoiDistanceUpdateManyWithoutPropertyNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    viewingRequests?: ViewingRequestUpdateManyWithoutPropertyNestedInput
    rentalBookings?: RentalBookingUpdateManyWithoutPropertyNestedInput
    blockedDates?: PropertyBlockedDateUpdateManyWithoutPropertyNestedInput
    tm30Accommodation?: Tm30AccommodationUpdateOneWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutViewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    propertyOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    poiDistances?: PropertyPoiDistanceUncheckedUpdateManyWithoutPropertyNestedInput
    viewingRequests?: ViewingRequestUncheckedUpdateManyWithoutPropertyNestedInput
    rentalBookings?: RentalBookingUncheckedUpdateManyWithoutPropertyNestedInput
    blockedDates?: PropertyBlockedDateUncheckedUpdateManyWithoutPropertyNestedInput
    tm30Accommodation?: Tm30AccommodationUncheckedUpdateOneWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutViewingRequestsInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    views?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyOwner?: PropertyOwnerCreateNestedOneWithoutPropertiesInput
    poiDistances?: PropertyPoiDistanceCreateNestedManyWithoutPropertyInput
    user: UserCreateNestedOneWithoutPropertiesInput
    rentalBookings?: RentalBookingCreateNestedManyWithoutPropertyInput
    blockedDates?: PropertyBlockedDateCreateNestedManyWithoutPropertyInput
    tm30Accommodation?: Tm30AccommodationCreateNestedOneWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutViewingRequestsInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    propertyOwnerId?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    views?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    poiDistances?: PropertyPoiDistanceUncheckedCreateNestedManyWithoutPropertyInput
    rentalBookings?: RentalBookingUncheckedCreateNestedManyWithoutPropertyInput
    blockedDates?: PropertyBlockedDateUncheckedCreateNestedManyWithoutPropertyInput
    tm30Accommodation?: Tm30AccommodationUncheckedCreateNestedOneWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutViewingRequestsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutViewingRequestsInput, PropertyUncheckedCreateWithoutViewingRequestsInput>
  }

  export type PropertyUpsertWithoutViewingRequestsInput = {
    update: XOR<PropertyUpdateWithoutViewingRequestsInput, PropertyUncheckedUpdateWithoutViewingRequestsInput>
    create: XOR<PropertyCreateWithoutViewingRequestsInput, PropertyUncheckedCreateWithoutViewingRequestsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutViewingRequestsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutViewingRequestsInput, PropertyUncheckedUpdateWithoutViewingRequestsInput>
  }

  export type PropertyUpdateWithoutViewingRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    views?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyOwner?: PropertyOwnerUpdateOneWithoutPropertiesNestedInput
    poiDistances?: PropertyPoiDistanceUpdateManyWithoutPropertyNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    rentalBookings?: RentalBookingUpdateManyWithoutPropertyNestedInput
    blockedDates?: PropertyBlockedDateUpdateManyWithoutPropertyNestedInput
    tm30Accommodation?: Tm30AccommodationUpdateOneWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutViewingRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    propertyOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    views?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    poiDistances?: PropertyPoiDistanceUncheckedUpdateManyWithoutPropertyNestedInput
    rentalBookings?: RentalBookingUncheckedUpdateManyWithoutPropertyNestedInput
    blockedDates?: PropertyBlockedDateUncheckedUpdateManyWithoutPropertyNestedInput
    tm30Accommodation?: Tm30AccommodationUncheckedUpdateOneWithoutPropertyNestedInput
  }

  export type UserCreateWithoutInvestorLeadsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    rentalLeads?: RentalLeadCreateNestedManyWithoutAssignedToInput
    blogs?: BlogCreateNestedManyWithoutAuthorInput
    rentalBookings?: RentalBookingCreateNestedManyWithoutUserInput
    bookingsAsAgent?: RentalBookingCreateNestedManyWithoutAgentInput
  }

  export type UserUncheckedCreateWithoutInvestorLeadsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    rentalLeads?: RentalLeadUncheckedCreateNestedManyWithoutAssignedToInput
    blogs?: BlogUncheckedCreateNestedManyWithoutAuthorInput
    rentalBookings?: RentalBookingUncheckedCreateNestedManyWithoutUserInput
    bookingsAsAgent?: RentalBookingUncheckedCreateNestedManyWithoutAgentInput
  }

  export type UserCreateOrConnectWithoutInvestorLeadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvestorLeadsInput, UserUncheckedCreateWithoutInvestorLeadsInput>
  }

  export type UserUpsertWithoutInvestorLeadsInput = {
    update: XOR<UserUpdateWithoutInvestorLeadsInput, UserUncheckedUpdateWithoutInvestorLeadsInput>
    create: XOR<UserCreateWithoutInvestorLeadsInput, UserUncheckedCreateWithoutInvestorLeadsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvestorLeadsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvestorLeadsInput, UserUncheckedUpdateWithoutInvestorLeadsInput>
  }

  export type UserUpdateWithoutInvestorLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    rentalLeads?: RentalLeadUpdateManyWithoutAssignedToNestedInput
    blogs?: BlogUpdateManyWithoutAuthorNestedInput
    rentalBookings?: RentalBookingUpdateManyWithoutUserNestedInput
    bookingsAsAgent?: RentalBookingUpdateManyWithoutAgentNestedInput
  }

  export type UserUncheckedUpdateWithoutInvestorLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    rentalLeads?: RentalLeadUncheckedUpdateManyWithoutAssignedToNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutAuthorNestedInput
    rentalBookings?: RentalBookingUncheckedUpdateManyWithoutUserNestedInput
    bookingsAsAgent?: RentalBookingUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type UserCreateWithoutRentalLeadsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    investorLeads?: InvestorLeadCreateNestedManyWithoutAssignedToInput
    blogs?: BlogCreateNestedManyWithoutAuthorInput
    rentalBookings?: RentalBookingCreateNestedManyWithoutUserInput
    bookingsAsAgent?: RentalBookingCreateNestedManyWithoutAgentInput
  }

  export type UserUncheckedCreateWithoutRentalLeadsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    investorLeads?: InvestorLeadUncheckedCreateNestedManyWithoutAssignedToInput
    blogs?: BlogUncheckedCreateNestedManyWithoutAuthorInput
    rentalBookings?: RentalBookingUncheckedCreateNestedManyWithoutUserInput
    bookingsAsAgent?: RentalBookingUncheckedCreateNestedManyWithoutAgentInput
  }

  export type UserCreateOrConnectWithoutRentalLeadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRentalLeadsInput, UserUncheckedCreateWithoutRentalLeadsInput>
  }

  export type UserUpsertWithoutRentalLeadsInput = {
    update: XOR<UserUpdateWithoutRentalLeadsInput, UserUncheckedUpdateWithoutRentalLeadsInput>
    create: XOR<UserCreateWithoutRentalLeadsInput, UserUncheckedCreateWithoutRentalLeadsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRentalLeadsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRentalLeadsInput, UserUncheckedUpdateWithoutRentalLeadsInput>
  }

  export type UserUpdateWithoutRentalLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    investorLeads?: InvestorLeadUpdateManyWithoutAssignedToNestedInput
    blogs?: BlogUpdateManyWithoutAuthorNestedInput
    rentalBookings?: RentalBookingUpdateManyWithoutUserNestedInput
    bookingsAsAgent?: RentalBookingUpdateManyWithoutAgentNestedInput
  }

  export type UserUncheckedUpdateWithoutRentalLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    investorLeads?: InvestorLeadUncheckedUpdateManyWithoutAssignedToNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutAuthorNestedInput
    rentalBookings?: RentalBookingUncheckedUpdateManyWithoutUserNestedInput
    bookingsAsAgent?: RentalBookingUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type BlogCategoryCreateWithoutBlogsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    icon?: string | null
    color?: string | null
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: BlogCategoryCreateNestedOneWithoutChildrenInput
    children?: BlogCategoryCreateNestedManyWithoutParentInput
  }

  export type BlogCategoryUncheckedCreateWithoutBlogsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    icon?: string | null
    color?: string | null
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: BlogCategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type BlogCategoryCreateOrConnectWithoutBlogsInput = {
    where: BlogCategoryWhereUniqueInput
    create: XOR<BlogCategoryCreateWithoutBlogsInput, BlogCategoryUncheckedCreateWithoutBlogsInput>
  }

  export type LinkUsageCreateWithoutBlogInput = {
    id?: string
    anchorText: string
    context?: string | null
    position?: number | null
    wasAutoInserted?: boolean
    insertedAt?: Date | string
    createdAt?: Date | string
    link: InternalLinkCreateNestedOneWithoutUsagesInput
  }

  export type LinkUsageUncheckedCreateWithoutBlogInput = {
    id?: string
    linkId: string
    anchorText: string
    context?: string | null
    position?: number | null
    wasAutoInserted?: boolean
    insertedAt?: Date | string
    createdAt?: Date | string
  }

  export type LinkUsageCreateOrConnectWithoutBlogInput = {
    where: LinkUsageWhereUniqueInput
    create: XOR<LinkUsageCreateWithoutBlogInput, LinkUsageUncheckedCreateWithoutBlogInput>
  }

  export type LinkUsageCreateManyBlogInputEnvelope = {
    data: LinkUsageCreateManyBlogInput | LinkUsageCreateManyBlogInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutBlogsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    investorLeads?: InvestorLeadCreateNestedManyWithoutAssignedToInput
    rentalLeads?: RentalLeadCreateNestedManyWithoutAssignedToInput
    rentalBookings?: RentalBookingCreateNestedManyWithoutUserInput
    bookingsAsAgent?: RentalBookingCreateNestedManyWithoutAgentInput
  }

  export type UserUncheckedCreateWithoutBlogsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    investorLeads?: InvestorLeadUncheckedCreateNestedManyWithoutAssignedToInput
    rentalLeads?: RentalLeadUncheckedCreateNestedManyWithoutAssignedToInput
    rentalBookings?: RentalBookingUncheckedCreateNestedManyWithoutUserInput
    bookingsAsAgent?: RentalBookingUncheckedCreateNestedManyWithoutAgentInput
  }

  export type UserCreateOrConnectWithoutBlogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogsInput, UserUncheckedCreateWithoutBlogsInput>
  }

  export type BlogCategoryUpsertWithoutBlogsInput = {
    update: XOR<BlogCategoryUpdateWithoutBlogsInput, BlogCategoryUncheckedUpdateWithoutBlogsInput>
    create: XOR<BlogCategoryCreateWithoutBlogsInput, BlogCategoryUncheckedCreateWithoutBlogsInput>
    where?: BlogCategoryWhereInput
  }

  export type BlogCategoryUpdateToOneWithWhereWithoutBlogsInput = {
    where?: BlogCategoryWhereInput
    data: XOR<BlogCategoryUpdateWithoutBlogsInput, BlogCategoryUncheckedUpdateWithoutBlogsInput>
  }

  export type BlogCategoryUpdateWithoutBlogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: BlogCategoryUpdateOneWithoutChildrenNestedInput
    children?: BlogCategoryUpdateManyWithoutParentNestedInput
  }

  export type BlogCategoryUncheckedUpdateWithoutBlogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: BlogCategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type LinkUsageUpsertWithWhereUniqueWithoutBlogInput = {
    where: LinkUsageWhereUniqueInput
    update: XOR<LinkUsageUpdateWithoutBlogInput, LinkUsageUncheckedUpdateWithoutBlogInput>
    create: XOR<LinkUsageCreateWithoutBlogInput, LinkUsageUncheckedCreateWithoutBlogInput>
  }

  export type LinkUsageUpdateWithWhereUniqueWithoutBlogInput = {
    where: LinkUsageWhereUniqueInput
    data: XOR<LinkUsageUpdateWithoutBlogInput, LinkUsageUncheckedUpdateWithoutBlogInput>
  }

  export type LinkUsageUpdateManyWithWhereWithoutBlogInput = {
    where: LinkUsageScalarWhereInput
    data: XOR<LinkUsageUpdateManyMutationInput, LinkUsageUncheckedUpdateManyWithoutBlogInput>
  }

  export type LinkUsageScalarWhereInput = {
    AND?: LinkUsageScalarWhereInput | LinkUsageScalarWhereInput[]
    OR?: LinkUsageScalarWhereInput[]
    NOT?: LinkUsageScalarWhereInput | LinkUsageScalarWhereInput[]
    id?: StringFilter<"LinkUsage"> | string
    linkId?: StringFilter<"LinkUsage"> | string
    blogId?: StringFilter<"LinkUsage"> | string
    anchorText?: StringFilter<"LinkUsage"> | string
    context?: StringNullableFilter<"LinkUsage"> | string | null
    position?: IntNullableFilter<"LinkUsage"> | number | null
    wasAutoInserted?: BoolFilter<"LinkUsage"> | boolean
    insertedAt?: DateTimeFilter<"LinkUsage"> | Date | string
    createdAt?: DateTimeFilter<"LinkUsage"> | Date | string
  }

  export type UserUpsertWithoutBlogsInput = {
    update: XOR<UserUpdateWithoutBlogsInput, UserUncheckedUpdateWithoutBlogsInput>
    create: XOR<UserCreateWithoutBlogsInput, UserUncheckedCreateWithoutBlogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogsInput, UserUncheckedUpdateWithoutBlogsInput>
  }

  export type UserUpdateWithoutBlogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    investorLeads?: InvestorLeadUpdateManyWithoutAssignedToNestedInput
    rentalLeads?: RentalLeadUpdateManyWithoutAssignedToNestedInput
    rentalBookings?: RentalBookingUpdateManyWithoutUserNestedInput
    bookingsAsAgent?: RentalBookingUpdateManyWithoutAgentNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    investorLeads?: InvestorLeadUncheckedUpdateManyWithoutAssignedToNestedInput
    rentalLeads?: RentalLeadUncheckedUpdateManyWithoutAssignedToNestedInput
    rentalBookings?: RentalBookingUncheckedUpdateManyWithoutUserNestedInput
    bookingsAsAgent?: RentalBookingUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type BlogCategoryCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    icon?: string | null
    color?: string | null
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: BlogCategoryCreateNestedOneWithoutChildrenInput
    blogs?: BlogCreateNestedManyWithoutCategoryInput
  }

  export type BlogCategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    icon?: string | null
    color?: string | null
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    blogs?: BlogUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type BlogCategoryCreateOrConnectWithoutChildrenInput = {
    where: BlogCategoryWhereUniqueInput
    create: XOR<BlogCategoryCreateWithoutChildrenInput, BlogCategoryUncheckedCreateWithoutChildrenInput>
  }

  export type BlogCategoryCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    icon?: string | null
    color?: string | null
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: BlogCategoryCreateNestedManyWithoutParentInput
    blogs?: BlogCreateNestedManyWithoutCategoryInput
  }

  export type BlogCategoryUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    icon?: string | null
    color?: string | null
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: BlogCategoryUncheckedCreateNestedManyWithoutParentInput
    blogs?: BlogUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type BlogCategoryCreateOrConnectWithoutParentInput = {
    where: BlogCategoryWhereUniqueInput
    create: XOR<BlogCategoryCreateWithoutParentInput, BlogCategoryUncheckedCreateWithoutParentInput>
  }

  export type BlogCategoryCreateManyParentInputEnvelope = {
    data: BlogCategoryCreateManyParentInput | BlogCategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type BlogCreateWithoutCategoryInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    coverImage?: string | null
    coverImageAlt?: string | null
    tag?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    published?: boolean
    publishedAt?: Date | string | null
    originalContent?: string | null
    linkOptimizedAt?: Date | string | null
    internalLinkCount?: number
    hasDynamicProperties?: boolean
    poiQueryParams?: string | null
    poiTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    linkUsages?: LinkUsageCreateNestedManyWithoutBlogInput
    author: UserCreateNestedOneWithoutBlogsInput
  }

  export type BlogUncheckedCreateWithoutCategoryInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    coverImage?: string | null
    coverImageAlt?: string | null
    tag?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    published?: boolean
    publishedAt?: Date | string | null
    originalContent?: string | null
    linkOptimizedAt?: Date | string | null
    internalLinkCount?: number
    hasDynamicProperties?: boolean
    poiQueryParams?: string | null
    poiTemplateId?: string | null
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    linkUsages?: LinkUsageUncheckedCreateNestedManyWithoutBlogInput
  }

  export type BlogCreateOrConnectWithoutCategoryInput = {
    where: BlogWhereUniqueInput
    create: XOR<BlogCreateWithoutCategoryInput, BlogUncheckedCreateWithoutCategoryInput>
  }

  export type BlogCreateManyCategoryInputEnvelope = {
    data: BlogCreateManyCategoryInput | BlogCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type BlogCategoryUpsertWithoutChildrenInput = {
    update: XOR<BlogCategoryUpdateWithoutChildrenInput, BlogCategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<BlogCategoryCreateWithoutChildrenInput, BlogCategoryUncheckedCreateWithoutChildrenInput>
    where?: BlogCategoryWhereInput
  }

  export type BlogCategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: BlogCategoryWhereInput
    data: XOR<BlogCategoryUpdateWithoutChildrenInput, BlogCategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type BlogCategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: BlogCategoryUpdateOneWithoutChildrenNestedInput
    blogs?: BlogUpdateManyWithoutCategoryNestedInput
  }

  export type BlogCategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blogs?: BlogUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type BlogCategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: BlogCategoryWhereUniqueInput
    update: XOR<BlogCategoryUpdateWithoutParentInput, BlogCategoryUncheckedUpdateWithoutParentInput>
    create: XOR<BlogCategoryCreateWithoutParentInput, BlogCategoryUncheckedCreateWithoutParentInput>
  }

  export type BlogCategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: BlogCategoryWhereUniqueInput
    data: XOR<BlogCategoryUpdateWithoutParentInput, BlogCategoryUncheckedUpdateWithoutParentInput>
  }

  export type BlogCategoryUpdateManyWithWhereWithoutParentInput = {
    where: BlogCategoryScalarWhereInput
    data: XOR<BlogCategoryUpdateManyMutationInput, BlogCategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type BlogCategoryScalarWhereInput = {
    AND?: BlogCategoryScalarWhereInput | BlogCategoryScalarWhereInput[]
    OR?: BlogCategoryScalarWhereInput[]
    NOT?: BlogCategoryScalarWhereInput | BlogCategoryScalarWhereInput[]
    id?: StringFilter<"BlogCategory"> | string
    name?: StringFilter<"BlogCategory"> | string
    slug?: StringFilter<"BlogCategory"> | string
    description?: StringNullableFilter<"BlogCategory"> | string | null
    parentId?: StringNullableFilter<"BlogCategory"> | string | null
    metaTitle?: StringNullableFilter<"BlogCategory"> | string | null
    metaDescription?: StringNullableFilter<"BlogCategory"> | string | null
    icon?: StringNullableFilter<"BlogCategory"> | string | null
    color?: StringNullableFilter<"BlogCategory"> | string | null
    order?: IntFilter<"BlogCategory"> | number
    isActive?: BoolFilter<"BlogCategory"> | boolean
    createdAt?: DateTimeFilter<"BlogCategory"> | Date | string
    updatedAt?: DateTimeFilter<"BlogCategory"> | Date | string
  }

  export type BlogUpsertWithWhereUniqueWithoutCategoryInput = {
    where: BlogWhereUniqueInput
    update: XOR<BlogUpdateWithoutCategoryInput, BlogUncheckedUpdateWithoutCategoryInput>
    create: XOR<BlogCreateWithoutCategoryInput, BlogUncheckedCreateWithoutCategoryInput>
  }

  export type BlogUpdateWithWhereUniqueWithoutCategoryInput = {
    where: BlogWhereUniqueInput
    data: XOR<BlogUpdateWithoutCategoryInput, BlogUncheckedUpdateWithoutCategoryInput>
  }

  export type BlogUpdateManyWithWhereWithoutCategoryInput = {
    where: BlogScalarWhereInput
    data: XOR<BlogUpdateManyMutationInput, BlogUncheckedUpdateManyWithoutCategoryInput>
  }

  export type LinkUsageCreateWithoutLinkInput = {
    id?: string
    anchorText: string
    context?: string | null
    position?: number | null
    wasAutoInserted?: boolean
    insertedAt?: Date | string
    createdAt?: Date | string
    blog: BlogCreateNestedOneWithoutLinkUsagesInput
  }

  export type LinkUsageUncheckedCreateWithoutLinkInput = {
    id?: string
    blogId: string
    anchorText: string
    context?: string | null
    position?: number | null
    wasAutoInserted?: boolean
    insertedAt?: Date | string
    createdAt?: Date | string
  }

  export type LinkUsageCreateOrConnectWithoutLinkInput = {
    where: LinkUsageWhereUniqueInput
    create: XOR<LinkUsageCreateWithoutLinkInput, LinkUsageUncheckedCreateWithoutLinkInput>
  }

  export type LinkUsageCreateManyLinkInputEnvelope = {
    data: LinkUsageCreateManyLinkInput | LinkUsageCreateManyLinkInput[]
    skipDuplicates?: boolean
  }

  export type LinkUsageUpsertWithWhereUniqueWithoutLinkInput = {
    where: LinkUsageWhereUniqueInput
    update: XOR<LinkUsageUpdateWithoutLinkInput, LinkUsageUncheckedUpdateWithoutLinkInput>
    create: XOR<LinkUsageCreateWithoutLinkInput, LinkUsageUncheckedCreateWithoutLinkInput>
  }

  export type LinkUsageUpdateWithWhereUniqueWithoutLinkInput = {
    where: LinkUsageWhereUniqueInput
    data: XOR<LinkUsageUpdateWithoutLinkInput, LinkUsageUncheckedUpdateWithoutLinkInput>
  }

  export type LinkUsageUpdateManyWithWhereWithoutLinkInput = {
    where: LinkUsageScalarWhereInput
    data: XOR<LinkUsageUpdateManyMutationInput, LinkUsageUncheckedUpdateManyWithoutLinkInput>
  }

  export type InternalLinkCreateWithoutUsagesInput = {
    id?: string
    url: string
    title: string
    description?: string | null
    category?: string | null
    subCategory?: string | null
    keywords?: string | null
    anchorTexts?: string | null
    priority?: number
    isActive?: boolean
    usageCount?: number
    pageExists?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InternalLinkUncheckedCreateWithoutUsagesInput = {
    id?: string
    url: string
    title: string
    description?: string | null
    category?: string | null
    subCategory?: string | null
    keywords?: string | null
    anchorTexts?: string | null
    priority?: number
    isActive?: boolean
    usageCount?: number
    pageExists?: boolean
    lastChecked?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InternalLinkCreateOrConnectWithoutUsagesInput = {
    where: InternalLinkWhereUniqueInput
    create: XOR<InternalLinkCreateWithoutUsagesInput, InternalLinkUncheckedCreateWithoutUsagesInput>
  }

  export type BlogCreateWithoutLinkUsagesInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    coverImage?: string | null
    coverImageAlt?: string | null
    tag?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    published?: boolean
    publishedAt?: Date | string | null
    originalContent?: string | null
    linkOptimizedAt?: Date | string | null
    internalLinkCount?: number
    hasDynamicProperties?: boolean
    poiQueryParams?: string | null
    poiTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: BlogCategoryCreateNestedOneWithoutBlogsInput
    author: UserCreateNestedOneWithoutBlogsInput
  }

  export type BlogUncheckedCreateWithoutLinkUsagesInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    coverImage?: string | null
    coverImageAlt?: string | null
    tag?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    categoryId?: string | null
    published?: boolean
    publishedAt?: Date | string | null
    originalContent?: string | null
    linkOptimizedAt?: Date | string | null
    internalLinkCount?: number
    hasDynamicProperties?: boolean
    poiQueryParams?: string | null
    poiTemplateId?: string | null
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogCreateOrConnectWithoutLinkUsagesInput = {
    where: BlogWhereUniqueInput
    create: XOR<BlogCreateWithoutLinkUsagesInput, BlogUncheckedCreateWithoutLinkUsagesInput>
  }

  export type InternalLinkUpsertWithoutUsagesInput = {
    update: XOR<InternalLinkUpdateWithoutUsagesInput, InternalLinkUncheckedUpdateWithoutUsagesInput>
    create: XOR<InternalLinkCreateWithoutUsagesInput, InternalLinkUncheckedCreateWithoutUsagesInput>
    where?: InternalLinkWhereInput
  }

  export type InternalLinkUpdateToOneWithWhereWithoutUsagesInput = {
    where?: InternalLinkWhereInput
    data: XOR<InternalLinkUpdateWithoutUsagesInput, InternalLinkUncheckedUpdateWithoutUsagesInput>
  }

  export type InternalLinkUpdateWithoutUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    anchorTexts?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    pageExists?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternalLinkUncheckedUpdateWithoutUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    anchorTexts?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    pageExists?: BoolFieldUpdateOperationsInput | boolean
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogUpsertWithoutLinkUsagesInput = {
    update: XOR<BlogUpdateWithoutLinkUsagesInput, BlogUncheckedUpdateWithoutLinkUsagesInput>
    create: XOR<BlogCreateWithoutLinkUsagesInput, BlogUncheckedCreateWithoutLinkUsagesInput>
    where?: BlogWhereInput
  }

  export type BlogUpdateToOneWithWhereWithoutLinkUsagesInput = {
    where?: BlogWhereInput
    data: XOR<BlogUpdateWithoutLinkUsagesInput, BlogUncheckedUpdateWithoutLinkUsagesInput>
  }

  export type BlogUpdateWithoutLinkUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    linkOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalLinkCount?: IntFieldUpdateOperationsInput | number
    hasDynamicProperties?: BoolFieldUpdateOperationsInput | boolean
    poiQueryParams?: NullableStringFieldUpdateOperationsInput | string | null
    poiTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: BlogCategoryUpdateOneWithoutBlogsNestedInput
    author?: UserUpdateOneRequiredWithoutBlogsNestedInput
  }

  export type BlogUncheckedUpdateWithoutLinkUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    linkOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalLinkCount?: IntFieldUpdateOperationsInput | number
    hasDynamicProperties?: BoolFieldUpdateOperationsInput | boolean
    poiQueryParams?: NullableStringFieldUpdateOperationsInput | string | null
    poiTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPoiDistanceCreateWithoutPoiInput = {
    id?: string
    distanceMeters: number
    walkingMinutes?: number | null
    drivingMinutes?: number | null
    isHighlight?: boolean
    calculatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutPoiDistancesInput
  }

  export type PropertyPoiDistanceUncheckedCreateWithoutPoiInput = {
    id?: string
    propertyId: string
    distanceMeters: number
    walkingMinutes?: number | null
    drivingMinutes?: number | null
    isHighlight?: boolean
    calculatedAt?: Date | string
  }

  export type PropertyPoiDistanceCreateOrConnectWithoutPoiInput = {
    where: PropertyPoiDistanceWhereUniqueInput
    create: XOR<PropertyPoiDistanceCreateWithoutPoiInput, PropertyPoiDistanceUncheckedCreateWithoutPoiInput>
  }

  export type PropertyPoiDistanceCreateManyPoiInputEnvelope = {
    data: PropertyPoiDistanceCreateManyPoiInput | PropertyPoiDistanceCreateManyPoiInput[]
    skipDuplicates?: boolean
  }

  export type PropertyPoiDistanceUpsertWithWhereUniqueWithoutPoiInput = {
    where: PropertyPoiDistanceWhereUniqueInput
    update: XOR<PropertyPoiDistanceUpdateWithoutPoiInput, PropertyPoiDistanceUncheckedUpdateWithoutPoiInput>
    create: XOR<PropertyPoiDistanceCreateWithoutPoiInput, PropertyPoiDistanceUncheckedCreateWithoutPoiInput>
  }

  export type PropertyPoiDistanceUpdateWithWhereUniqueWithoutPoiInput = {
    where: PropertyPoiDistanceWhereUniqueInput
    data: XOR<PropertyPoiDistanceUpdateWithoutPoiInput, PropertyPoiDistanceUncheckedUpdateWithoutPoiInput>
  }

  export type PropertyPoiDistanceUpdateManyWithWhereWithoutPoiInput = {
    where: PropertyPoiDistanceScalarWhereInput
    data: XOR<PropertyPoiDistanceUpdateManyMutationInput, PropertyPoiDistanceUncheckedUpdateManyWithoutPoiInput>
  }

  export type PropertyCreateWithoutPoiDistancesInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    views?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyOwner?: PropertyOwnerCreateNestedOneWithoutPropertiesInput
    user: UserCreateNestedOneWithoutPropertiesInput
    viewingRequests?: ViewingRequestCreateNestedManyWithoutPropertyInput
    rentalBookings?: RentalBookingCreateNestedManyWithoutPropertyInput
    blockedDates?: PropertyBlockedDateCreateNestedManyWithoutPropertyInput
    tm30Accommodation?: Tm30AccommodationCreateNestedOneWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutPoiDistancesInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    propertyOwnerId?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    views?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    viewingRequests?: ViewingRequestUncheckedCreateNestedManyWithoutPropertyInput
    rentalBookings?: RentalBookingUncheckedCreateNestedManyWithoutPropertyInput
    blockedDates?: PropertyBlockedDateUncheckedCreateNestedManyWithoutPropertyInput
    tm30Accommodation?: Tm30AccommodationUncheckedCreateNestedOneWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPoiDistancesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPoiDistancesInput, PropertyUncheckedCreateWithoutPoiDistancesInput>
  }

  export type PoiCreateWithoutPropertyDistancesInput = {
    id?: string
    externalId?: string | null
    source?: $Enums.PoiSource
    name: string
    nameTh?: string | null
    nameLocal?: string | null
    category: $Enums.PoiCategory
    subCategory?: string | null
    latitude: number
    longitude: number
    address?: string | null
    district?: string | null
    osmTags?: NullableJsonNullValueInput | InputJsonValue
    importance?: number
    isVerified?: boolean
    isActive?: boolean
    noiseLevel?: $Enums.NoiseLevel | null
    trafficLevel?: $Enums.TrafficLevel | null
    lastSyncedAt?: Date | string | null
    syncError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PoiUncheckedCreateWithoutPropertyDistancesInput = {
    id?: string
    externalId?: string | null
    source?: $Enums.PoiSource
    name: string
    nameTh?: string | null
    nameLocal?: string | null
    category: $Enums.PoiCategory
    subCategory?: string | null
    latitude: number
    longitude: number
    address?: string | null
    district?: string | null
    osmTags?: NullableJsonNullValueInput | InputJsonValue
    importance?: number
    isVerified?: boolean
    isActive?: boolean
    noiseLevel?: $Enums.NoiseLevel | null
    trafficLevel?: $Enums.TrafficLevel | null
    lastSyncedAt?: Date | string | null
    syncError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PoiCreateOrConnectWithoutPropertyDistancesInput = {
    where: PoiWhereUniqueInput
    create: XOR<PoiCreateWithoutPropertyDistancesInput, PoiUncheckedCreateWithoutPropertyDistancesInput>
  }

  export type PropertyUpsertWithoutPoiDistancesInput = {
    update: XOR<PropertyUpdateWithoutPoiDistancesInput, PropertyUncheckedUpdateWithoutPoiDistancesInput>
    create: XOR<PropertyCreateWithoutPoiDistancesInput, PropertyUncheckedCreateWithoutPoiDistancesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutPoiDistancesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutPoiDistancesInput, PropertyUncheckedUpdateWithoutPoiDistancesInput>
  }

  export type PropertyUpdateWithoutPoiDistancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    views?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyOwner?: PropertyOwnerUpdateOneWithoutPropertiesNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    viewingRequests?: ViewingRequestUpdateManyWithoutPropertyNestedInput
    rentalBookings?: RentalBookingUpdateManyWithoutPropertyNestedInput
    blockedDates?: PropertyBlockedDateUpdateManyWithoutPropertyNestedInput
    tm30Accommodation?: Tm30AccommodationUpdateOneWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPoiDistancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    propertyOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    views?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    viewingRequests?: ViewingRequestUncheckedUpdateManyWithoutPropertyNestedInput
    rentalBookings?: RentalBookingUncheckedUpdateManyWithoutPropertyNestedInput
    blockedDates?: PropertyBlockedDateUncheckedUpdateManyWithoutPropertyNestedInput
    tm30Accommodation?: Tm30AccommodationUncheckedUpdateOneWithoutPropertyNestedInput
  }

  export type PoiUpsertWithoutPropertyDistancesInput = {
    update: XOR<PoiUpdateWithoutPropertyDistancesInput, PoiUncheckedUpdateWithoutPropertyDistancesInput>
    create: XOR<PoiCreateWithoutPropertyDistancesInput, PoiUncheckedCreateWithoutPropertyDistancesInput>
    where?: PoiWhereInput
  }

  export type PoiUpdateToOneWithWhereWithoutPropertyDistancesInput = {
    where?: PoiWhereInput
    data: XOR<PoiUpdateWithoutPropertyDistancesInput, PoiUncheckedUpdateWithoutPropertyDistancesInput>
  }

  export type PoiUpdateWithoutPropertyDistancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumPoiSourceFieldUpdateOperationsInput | $Enums.PoiSource
    name?: StringFieldUpdateOperationsInput | string
    nameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nameLocal?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPoiCategoryFieldUpdateOperationsInput | $Enums.PoiCategory
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    osmTags?: NullableJsonNullValueInput | InputJsonValue
    importance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    noiseLevel?: NullableEnumNoiseLevelFieldUpdateOperationsInput | $Enums.NoiseLevel | null
    trafficLevel?: NullableEnumTrafficLevelFieldUpdateOperationsInput | $Enums.TrafficLevel | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PoiUncheckedUpdateWithoutPropertyDistancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumPoiSourceFieldUpdateOperationsInput | $Enums.PoiSource
    name?: StringFieldUpdateOperationsInput | string
    nameTh?: NullableStringFieldUpdateOperationsInput | string | null
    nameLocal?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPoiCategoryFieldUpdateOperationsInput | $Enums.PoiCategory
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    osmTags?: NullableJsonNullValueInput | InputJsonValue
    importance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    noiseLevel?: NullableEnumNoiseLevelFieldUpdateOperationsInput | $Enums.NoiseLevel | null
    trafficLevel?: NullableEnumTrafficLevelFieldUpdateOperationsInput | $Enums.TrafficLevel | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateWithoutRentalBookingsInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    views?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyOwner?: PropertyOwnerCreateNestedOneWithoutPropertiesInput
    poiDistances?: PropertyPoiDistanceCreateNestedManyWithoutPropertyInput
    user: UserCreateNestedOneWithoutPropertiesInput
    viewingRequests?: ViewingRequestCreateNestedManyWithoutPropertyInput
    blockedDates?: PropertyBlockedDateCreateNestedManyWithoutPropertyInput
    tm30Accommodation?: Tm30AccommodationCreateNestedOneWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutRentalBookingsInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    propertyOwnerId?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    views?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    poiDistances?: PropertyPoiDistanceUncheckedCreateNestedManyWithoutPropertyInput
    viewingRequests?: ViewingRequestUncheckedCreateNestedManyWithoutPropertyInput
    blockedDates?: PropertyBlockedDateUncheckedCreateNestedManyWithoutPropertyInput
    tm30Accommodation?: Tm30AccommodationUncheckedCreateNestedOneWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutRentalBookingsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutRentalBookingsInput, PropertyUncheckedCreateWithoutRentalBookingsInput>
  }

  export type UserCreateWithoutRentalBookingsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    investorLeads?: InvestorLeadCreateNestedManyWithoutAssignedToInput
    rentalLeads?: RentalLeadCreateNestedManyWithoutAssignedToInput
    blogs?: BlogCreateNestedManyWithoutAuthorInput
    bookingsAsAgent?: RentalBookingCreateNestedManyWithoutAgentInput
  }

  export type UserUncheckedCreateWithoutRentalBookingsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    investorLeads?: InvestorLeadUncheckedCreateNestedManyWithoutAssignedToInput
    rentalLeads?: RentalLeadUncheckedCreateNestedManyWithoutAssignedToInput
    blogs?: BlogUncheckedCreateNestedManyWithoutAuthorInput
    bookingsAsAgent?: RentalBookingUncheckedCreateNestedManyWithoutAgentInput
  }

  export type UserCreateOrConnectWithoutRentalBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRentalBookingsInput, UserUncheckedCreateWithoutRentalBookingsInput>
  }

  export type UserCreateWithoutBookingsAsAgentInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    investorLeads?: InvestorLeadCreateNestedManyWithoutAssignedToInput
    rentalLeads?: RentalLeadCreateNestedManyWithoutAssignedToInput
    blogs?: BlogCreateNestedManyWithoutAuthorInput
    rentalBookings?: RentalBookingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookingsAsAgentInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    investorLeads?: InvestorLeadUncheckedCreateNestedManyWithoutAssignedToInput
    rentalLeads?: RentalLeadUncheckedCreateNestedManyWithoutAssignedToInput
    blogs?: BlogUncheckedCreateNestedManyWithoutAuthorInput
    rentalBookings?: RentalBookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookingsAsAgentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsAsAgentInput, UserUncheckedCreateWithoutBookingsAsAgentInput>
  }

  export type BookingMessageCreateWithoutBookingInput = {
    id?: string
    senderId: string
    senderRole?: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingMessageUncheckedCreateWithoutBookingInput = {
    id?: string
    senderId: string
    senderRole?: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingMessageCreateOrConnectWithoutBookingInput = {
    where: BookingMessageWhereUniqueInput
    create: XOR<BookingMessageCreateWithoutBookingInput, BookingMessageUncheckedCreateWithoutBookingInput>
  }

  export type BookingMessageCreateManyBookingInputEnvelope = {
    data: BookingMessageCreateManyBookingInput | BookingMessageCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type BookingGuestCreateWithoutBookingInput = {
    id?: string
    guestType?: string
    guestNumber?: number
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    gender?: string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    passportIssueDate?: Date | string | null
    passportCountry?: string | null
    passportImageUrl?: string | null
    passportImagePath?: string | null
    ocrConfidence?: number | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: Date | string | null
    passportVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    tm30Status?: $Enums.TM30GuestStatus
    tm30SubmittedAt?: Date | string | null
    tm30Error?: string | null
    whatsappMessageId?: string | null
    whatsappReceivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingGuestUncheckedCreateWithoutBookingInput = {
    id?: string
    guestType?: string
    guestNumber?: number
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    gender?: string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    passportIssueDate?: Date | string | null
    passportCountry?: string | null
    passportImageUrl?: string | null
    passportImagePath?: string | null
    ocrConfidence?: number | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: Date | string | null
    passportVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    tm30Status?: $Enums.TM30GuestStatus
    tm30SubmittedAt?: Date | string | null
    tm30Error?: string | null
    whatsappMessageId?: string | null
    whatsappReceivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingGuestCreateOrConnectWithoutBookingInput = {
    where: BookingGuestWhereUniqueInput
    create: XOR<BookingGuestCreateWithoutBookingInput, BookingGuestUncheckedCreateWithoutBookingInput>
  }

  export type BookingGuestCreateManyBookingInputEnvelope = {
    data: BookingGuestCreateManyBookingInput | BookingGuestCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type PropertyUpsertWithoutRentalBookingsInput = {
    update: XOR<PropertyUpdateWithoutRentalBookingsInput, PropertyUncheckedUpdateWithoutRentalBookingsInput>
    create: XOR<PropertyCreateWithoutRentalBookingsInput, PropertyUncheckedCreateWithoutRentalBookingsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutRentalBookingsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutRentalBookingsInput, PropertyUncheckedUpdateWithoutRentalBookingsInput>
  }

  export type PropertyUpdateWithoutRentalBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    views?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyOwner?: PropertyOwnerUpdateOneWithoutPropertiesNestedInput
    poiDistances?: PropertyPoiDistanceUpdateManyWithoutPropertyNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    viewingRequests?: ViewingRequestUpdateManyWithoutPropertyNestedInput
    blockedDates?: PropertyBlockedDateUpdateManyWithoutPropertyNestedInput
    tm30Accommodation?: Tm30AccommodationUpdateOneWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutRentalBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    propertyOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    views?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    poiDistances?: PropertyPoiDistanceUncheckedUpdateManyWithoutPropertyNestedInput
    viewingRequests?: ViewingRequestUncheckedUpdateManyWithoutPropertyNestedInput
    blockedDates?: PropertyBlockedDateUncheckedUpdateManyWithoutPropertyNestedInput
    tm30Accommodation?: Tm30AccommodationUncheckedUpdateOneWithoutPropertyNestedInput
  }

  export type UserUpsertWithoutRentalBookingsInput = {
    update: XOR<UserUpdateWithoutRentalBookingsInput, UserUncheckedUpdateWithoutRentalBookingsInput>
    create: XOR<UserCreateWithoutRentalBookingsInput, UserUncheckedCreateWithoutRentalBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRentalBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRentalBookingsInput, UserUncheckedUpdateWithoutRentalBookingsInput>
  }

  export type UserUpdateWithoutRentalBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    investorLeads?: InvestorLeadUpdateManyWithoutAssignedToNestedInput
    rentalLeads?: RentalLeadUpdateManyWithoutAssignedToNestedInput
    blogs?: BlogUpdateManyWithoutAuthorNestedInput
    bookingsAsAgent?: RentalBookingUpdateManyWithoutAgentNestedInput
  }

  export type UserUncheckedUpdateWithoutRentalBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    investorLeads?: InvestorLeadUncheckedUpdateManyWithoutAssignedToNestedInput
    rentalLeads?: RentalLeadUncheckedUpdateManyWithoutAssignedToNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutAuthorNestedInput
    bookingsAsAgent?: RentalBookingUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type UserUpsertWithoutBookingsAsAgentInput = {
    update: XOR<UserUpdateWithoutBookingsAsAgentInput, UserUncheckedUpdateWithoutBookingsAsAgentInput>
    create: XOR<UserCreateWithoutBookingsAsAgentInput, UserUncheckedCreateWithoutBookingsAsAgentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsAsAgentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsAsAgentInput, UserUncheckedUpdateWithoutBookingsAsAgentInput>
  }

  export type UserUpdateWithoutBookingsAsAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    investorLeads?: InvestorLeadUpdateManyWithoutAssignedToNestedInput
    rentalLeads?: RentalLeadUpdateManyWithoutAssignedToNestedInput
    blogs?: BlogUpdateManyWithoutAuthorNestedInput
    rentalBookings?: RentalBookingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsAsAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    investorLeads?: InvestorLeadUncheckedUpdateManyWithoutAssignedToNestedInput
    rentalLeads?: RentalLeadUncheckedUpdateManyWithoutAssignedToNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutAuthorNestedInput
    rentalBookings?: RentalBookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookingMessageUpsertWithWhereUniqueWithoutBookingInput = {
    where: BookingMessageWhereUniqueInput
    update: XOR<BookingMessageUpdateWithoutBookingInput, BookingMessageUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingMessageCreateWithoutBookingInput, BookingMessageUncheckedCreateWithoutBookingInput>
  }

  export type BookingMessageUpdateWithWhereUniqueWithoutBookingInput = {
    where: BookingMessageWhereUniqueInput
    data: XOR<BookingMessageUpdateWithoutBookingInput, BookingMessageUncheckedUpdateWithoutBookingInput>
  }

  export type BookingMessageUpdateManyWithWhereWithoutBookingInput = {
    where: BookingMessageScalarWhereInput
    data: XOR<BookingMessageUpdateManyMutationInput, BookingMessageUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingMessageScalarWhereInput = {
    AND?: BookingMessageScalarWhereInput | BookingMessageScalarWhereInput[]
    OR?: BookingMessageScalarWhereInput[]
    NOT?: BookingMessageScalarWhereInput | BookingMessageScalarWhereInput[]
    id?: StringFilter<"BookingMessage"> | string
    bookingId?: StringFilter<"BookingMessage"> | string
    senderId?: StringFilter<"BookingMessage"> | string
    senderRole?: StringFilter<"BookingMessage"> | string
    message?: StringFilter<"BookingMessage"> | string
    isRead?: BoolFilter<"BookingMessage"> | boolean
    createdAt?: DateTimeFilter<"BookingMessage"> | Date | string
    updatedAt?: DateTimeFilter<"BookingMessage"> | Date | string
  }

  export type BookingGuestUpsertWithWhereUniqueWithoutBookingInput = {
    where: BookingGuestWhereUniqueInput
    update: XOR<BookingGuestUpdateWithoutBookingInput, BookingGuestUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingGuestCreateWithoutBookingInput, BookingGuestUncheckedCreateWithoutBookingInput>
  }

  export type BookingGuestUpdateWithWhereUniqueWithoutBookingInput = {
    where: BookingGuestWhereUniqueInput
    data: XOR<BookingGuestUpdateWithoutBookingInput, BookingGuestUncheckedUpdateWithoutBookingInput>
  }

  export type BookingGuestUpdateManyWithWhereWithoutBookingInput = {
    where: BookingGuestScalarWhereInput
    data: XOR<BookingGuestUpdateManyMutationInput, BookingGuestUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingGuestScalarWhereInput = {
    AND?: BookingGuestScalarWhereInput | BookingGuestScalarWhereInput[]
    OR?: BookingGuestScalarWhereInput[]
    NOT?: BookingGuestScalarWhereInput | BookingGuestScalarWhereInput[]
    id?: StringFilter<"BookingGuest"> | string
    bookingId?: StringFilter<"BookingGuest"> | string
    guestType?: StringFilter<"BookingGuest"> | string
    guestNumber?: IntFilter<"BookingGuest"> | number
    firstName?: StringNullableFilter<"BookingGuest"> | string | null
    lastName?: StringNullableFilter<"BookingGuest"> | string | null
    fullName?: StringNullableFilter<"BookingGuest"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"BookingGuest"> | Date | string | null
    nationality?: StringNullableFilter<"BookingGuest"> | string | null
    gender?: StringNullableFilter<"BookingGuest"> | string | null
    passportNumber?: StringNullableFilter<"BookingGuest"> | string | null
    passportExpiry?: DateTimeNullableFilter<"BookingGuest"> | Date | string | null
    passportIssueDate?: DateTimeNullableFilter<"BookingGuest"> | Date | string | null
    passportCountry?: StringNullableFilter<"BookingGuest"> | string | null
    passportImageUrl?: StringNullableFilter<"BookingGuest"> | string | null
    passportImagePath?: StringNullableFilter<"BookingGuest"> | string | null
    ocrConfidence?: FloatNullableFilter<"BookingGuest"> | number | null
    ocrRawData?: JsonNullableFilter<"BookingGuest">
    ocrProcessedAt?: DateTimeNullableFilter<"BookingGuest"> | Date | string | null
    passportVerified?: BoolFilter<"BookingGuest"> | boolean
    verifiedBy?: StringNullableFilter<"BookingGuest"> | string | null
    verifiedAt?: DateTimeNullableFilter<"BookingGuest"> | Date | string | null
    tm30Status?: EnumTM30GuestStatusFilter<"BookingGuest"> | $Enums.TM30GuestStatus
    tm30SubmittedAt?: DateTimeNullableFilter<"BookingGuest"> | Date | string | null
    tm30Error?: StringNullableFilter<"BookingGuest"> | string | null
    whatsappMessageId?: StringNullableFilter<"BookingGuest"> | string | null
    whatsappReceivedAt?: DateTimeNullableFilter<"BookingGuest"> | Date | string | null
    createdAt?: DateTimeFilter<"BookingGuest"> | Date | string
    updatedAt?: DateTimeFilter<"BookingGuest"> | Date | string
  }

  export type RentalBookingCreateWithoutMessagesInput = {
    id?: string
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    adults?: number
    children?: number
    babies?: number
    pets?: number
    basePrice: number
    season: string
    discountPercent: number
    totalPrice: number
    guestName: string
    guestEmail: string
    guestPhone: string
    guestCountryCode?: string
    guestMessage?: string | null
    status?: $Enums.RentalBookingStatus
    paymentStatus?: string | null
    cancellationPolicy?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    internalNotes?: string | null
    checkInTime?: string | null
    checkOutTime?: string | null
    propertyAddress?: string | null
    propertyInstructions?: string | null
    wifiName?: string | null
    wifiPassword?: string | null
    accessCode?: string | null
    emergencyContact?: string | null
    houseRules?: string | null
    confirmedAt?: Date | string | null
    tm30Status?: $Enums.TM30BookingStatus
    tm30SubmittedAt?: Date | string | null
    tm30Reference?: string | null
    tm30Error?: string | null
    passportsRequired?: number
    passportsReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutRentalBookingsInput
    user: UserCreateNestedOneWithoutRentalBookingsInput
    agent?: UserCreateNestedOneWithoutBookingsAsAgentInput
    guests?: BookingGuestCreateNestedManyWithoutBookingInput
  }

  export type RentalBookingUncheckedCreateWithoutMessagesInput = {
    id?: string
    propertyId: string
    userId: string
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    adults?: number
    children?: number
    babies?: number
    pets?: number
    basePrice: number
    season: string
    discountPercent: number
    totalPrice: number
    guestName: string
    guestEmail: string
    guestPhone: string
    guestCountryCode?: string
    guestMessage?: string | null
    status?: $Enums.RentalBookingStatus
    paymentStatus?: string | null
    cancellationPolicy?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    internalNotes?: string | null
    checkInTime?: string | null
    checkOutTime?: string | null
    propertyAddress?: string | null
    propertyInstructions?: string | null
    wifiName?: string | null
    wifiPassword?: string | null
    accessCode?: string | null
    emergencyContact?: string | null
    houseRules?: string | null
    confirmedAt?: Date | string | null
    agentId?: string | null
    tm30Status?: $Enums.TM30BookingStatus
    tm30SubmittedAt?: Date | string | null
    tm30Reference?: string | null
    tm30Error?: string | null
    passportsRequired?: number
    passportsReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    guests?: BookingGuestUncheckedCreateNestedManyWithoutBookingInput
  }

  export type RentalBookingCreateOrConnectWithoutMessagesInput = {
    where: RentalBookingWhereUniqueInput
    create: XOR<RentalBookingCreateWithoutMessagesInput, RentalBookingUncheckedCreateWithoutMessagesInput>
  }

  export type RentalBookingUpsertWithoutMessagesInput = {
    update: XOR<RentalBookingUpdateWithoutMessagesInput, RentalBookingUncheckedUpdateWithoutMessagesInput>
    create: XOR<RentalBookingCreateWithoutMessagesInput, RentalBookingUncheckedCreateWithoutMessagesInput>
    where?: RentalBookingWhereInput
  }

  export type RentalBookingUpdateToOneWithWhereWithoutMessagesInput = {
    where?: RentalBookingWhereInput
    data: XOR<RentalBookingUpdateWithoutMessagesInput, RentalBookingUncheckedUpdateWithoutMessagesInput>
  }

  export type RentalBookingUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    babies?: IntFieldUpdateOperationsInput | number
    pets?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    discountPercent?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: StringFieldUpdateOperationsInput | string
    guestCountryCode?: StringFieldUpdateOperationsInput | string
    guestMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRentalBookingStatusFieldUpdateOperationsInput | $Enums.RentalBookingStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    wifiName?: NullableStringFieldUpdateOperationsInput | string | null
    wifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Status?: EnumTM30BookingStatusFieldUpdateOperationsInput | $Enums.TM30BookingStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Reference?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    passportsRequired?: IntFieldUpdateOperationsInput | number
    passportsReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutRentalBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutRentalBookingsNestedInput
    agent?: UserUpdateOneWithoutBookingsAsAgentNestedInput
    guests?: BookingGuestUpdateManyWithoutBookingNestedInput
  }

  export type RentalBookingUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    babies?: IntFieldUpdateOperationsInput | number
    pets?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    discountPercent?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: StringFieldUpdateOperationsInput | string
    guestCountryCode?: StringFieldUpdateOperationsInput | string
    guestMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRentalBookingStatusFieldUpdateOperationsInput | $Enums.RentalBookingStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    wifiName?: NullableStringFieldUpdateOperationsInput | string | null
    wifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Status?: EnumTM30BookingStatusFieldUpdateOperationsInput | $Enums.TM30BookingStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Reference?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    passportsRequired?: IntFieldUpdateOperationsInput | number
    passportsReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guests?: BookingGuestUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type RentalBookingCreateWithoutGuestsInput = {
    id?: string
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    adults?: number
    children?: number
    babies?: number
    pets?: number
    basePrice: number
    season: string
    discountPercent: number
    totalPrice: number
    guestName: string
    guestEmail: string
    guestPhone: string
    guestCountryCode?: string
    guestMessage?: string | null
    status?: $Enums.RentalBookingStatus
    paymentStatus?: string | null
    cancellationPolicy?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    internalNotes?: string | null
    checkInTime?: string | null
    checkOutTime?: string | null
    propertyAddress?: string | null
    propertyInstructions?: string | null
    wifiName?: string | null
    wifiPassword?: string | null
    accessCode?: string | null
    emergencyContact?: string | null
    houseRules?: string | null
    confirmedAt?: Date | string | null
    tm30Status?: $Enums.TM30BookingStatus
    tm30SubmittedAt?: Date | string | null
    tm30Reference?: string | null
    tm30Error?: string | null
    passportsRequired?: number
    passportsReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutRentalBookingsInput
    user: UserCreateNestedOneWithoutRentalBookingsInput
    agent?: UserCreateNestedOneWithoutBookingsAsAgentInput
    messages?: BookingMessageCreateNestedManyWithoutBookingInput
  }

  export type RentalBookingUncheckedCreateWithoutGuestsInput = {
    id?: string
    propertyId: string
    userId: string
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    adults?: number
    children?: number
    babies?: number
    pets?: number
    basePrice: number
    season: string
    discountPercent: number
    totalPrice: number
    guestName: string
    guestEmail: string
    guestPhone: string
    guestCountryCode?: string
    guestMessage?: string | null
    status?: $Enums.RentalBookingStatus
    paymentStatus?: string | null
    cancellationPolicy?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    internalNotes?: string | null
    checkInTime?: string | null
    checkOutTime?: string | null
    propertyAddress?: string | null
    propertyInstructions?: string | null
    wifiName?: string | null
    wifiPassword?: string | null
    accessCode?: string | null
    emergencyContact?: string | null
    houseRules?: string | null
    confirmedAt?: Date | string | null
    agentId?: string | null
    tm30Status?: $Enums.TM30BookingStatus
    tm30SubmittedAt?: Date | string | null
    tm30Reference?: string | null
    tm30Error?: string | null
    passportsRequired?: number
    passportsReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: BookingMessageUncheckedCreateNestedManyWithoutBookingInput
  }

  export type RentalBookingCreateOrConnectWithoutGuestsInput = {
    where: RentalBookingWhereUniqueInput
    create: XOR<RentalBookingCreateWithoutGuestsInput, RentalBookingUncheckedCreateWithoutGuestsInput>
  }

  export type RentalBookingUpsertWithoutGuestsInput = {
    update: XOR<RentalBookingUpdateWithoutGuestsInput, RentalBookingUncheckedUpdateWithoutGuestsInput>
    create: XOR<RentalBookingCreateWithoutGuestsInput, RentalBookingUncheckedCreateWithoutGuestsInput>
    where?: RentalBookingWhereInput
  }

  export type RentalBookingUpdateToOneWithWhereWithoutGuestsInput = {
    where?: RentalBookingWhereInput
    data: XOR<RentalBookingUpdateWithoutGuestsInput, RentalBookingUncheckedUpdateWithoutGuestsInput>
  }

  export type RentalBookingUpdateWithoutGuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    babies?: IntFieldUpdateOperationsInput | number
    pets?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    discountPercent?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: StringFieldUpdateOperationsInput | string
    guestCountryCode?: StringFieldUpdateOperationsInput | string
    guestMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRentalBookingStatusFieldUpdateOperationsInput | $Enums.RentalBookingStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    wifiName?: NullableStringFieldUpdateOperationsInput | string | null
    wifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Status?: EnumTM30BookingStatusFieldUpdateOperationsInput | $Enums.TM30BookingStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Reference?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    passportsRequired?: IntFieldUpdateOperationsInput | number
    passportsReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutRentalBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutRentalBookingsNestedInput
    agent?: UserUpdateOneWithoutBookingsAsAgentNestedInput
    messages?: BookingMessageUpdateManyWithoutBookingNestedInput
  }

  export type RentalBookingUncheckedUpdateWithoutGuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    babies?: IntFieldUpdateOperationsInput | number
    pets?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    discountPercent?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: StringFieldUpdateOperationsInput | string
    guestCountryCode?: StringFieldUpdateOperationsInput | string
    guestMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRentalBookingStatusFieldUpdateOperationsInput | $Enums.RentalBookingStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    wifiName?: NullableStringFieldUpdateOperationsInput | string | null
    wifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Status?: EnumTM30BookingStatusFieldUpdateOperationsInput | $Enums.TM30BookingStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Reference?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    passportsRequired?: IntFieldUpdateOperationsInput | number
    passportsReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: BookingMessageUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type PropertyCreateWithoutBlockedDatesInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    views?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyOwner?: PropertyOwnerCreateNestedOneWithoutPropertiesInput
    poiDistances?: PropertyPoiDistanceCreateNestedManyWithoutPropertyInput
    user: UserCreateNestedOneWithoutPropertiesInput
    viewingRequests?: ViewingRequestCreateNestedManyWithoutPropertyInput
    rentalBookings?: RentalBookingCreateNestedManyWithoutPropertyInput
    tm30Accommodation?: Tm30AccommodationCreateNestedOneWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutBlockedDatesInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    propertyOwnerId?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    views?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    poiDistances?: PropertyPoiDistanceUncheckedCreateNestedManyWithoutPropertyInput
    viewingRequests?: ViewingRequestUncheckedCreateNestedManyWithoutPropertyInput
    rentalBookings?: RentalBookingUncheckedCreateNestedManyWithoutPropertyInput
    tm30Accommodation?: Tm30AccommodationUncheckedCreateNestedOneWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutBlockedDatesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutBlockedDatesInput, PropertyUncheckedCreateWithoutBlockedDatesInput>
  }

  export type PropertyUpsertWithoutBlockedDatesInput = {
    update: XOR<PropertyUpdateWithoutBlockedDatesInput, PropertyUncheckedUpdateWithoutBlockedDatesInput>
    create: XOR<PropertyCreateWithoutBlockedDatesInput, PropertyUncheckedCreateWithoutBlockedDatesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutBlockedDatesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutBlockedDatesInput, PropertyUncheckedUpdateWithoutBlockedDatesInput>
  }

  export type PropertyUpdateWithoutBlockedDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    views?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyOwner?: PropertyOwnerUpdateOneWithoutPropertiesNestedInput
    poiDistances?: PropertyPoiDistanceUpdateManyWithoutPropertyNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    viewingRequests?: ViewingRequestUpdateManyWithoutPropertyNestedInput
    rentalBookings?: RentalBookingUpdateManyWithoutPropertyNestedInput
    tm30Accommodation?: Tm30AccommodationUpdateOneWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutBlockedDatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    propertyOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    views?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    poiDistances?: PropertyPoiDistanceUncheckedUpdateManyWithoutPropertyNestedInput
    viewingRequests?: ViewingRequestUncheckedUpdateManyWithoutPropertyNestedInput
    rentalBookings?: RentalBookingUncheckedUpdateManyWithoutPropertyNestedInput
    tm30Accommodation?: Tm30AccommodationUncheckedUpdateOneWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutTm30AccommodationInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    views?: PropertyViewCreateNestedManyWithoutPropertyInput
    propertyOwner?: PropertyOwnerCreateNestedOneWithoutPropertiesInput
    poiDistances?: PropertyPoiDistanceCreateNestedManyWithoutPropertyInput
    user: UserCreateNestedOneWithoutPropertiesInput
    viewingRequests?: ViewingRequestCreateNestedManyWithoutPropertyInput
    rentalBookings?: RentalBookingCreateNestedManyWithoutPropertyInput
    blockedDates?: PropertyBlockedDateCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutTm30AccommodationInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    propertyOwnerId?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    views?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    poiDistances?: PropertyPoiDistanceUncheckedCreateNestedManyWithoutPropertyInput
    viewingRequests?: ViewingRequestUncheckedCreateNestedManyWithoutPropertyInput
    rentalBookings?: RentalBookingUncheckedCreateNestedManyWithoutPropertyInput
    blockedDates?: PropertyBlockedDateUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutTm30AccommodationInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutTm30AccommodationInput, PropertyUncheckedCreateWithoutTm30AccommodationInput>
  }

  export type PropertyUpsertWithoutTm30AccommodationInput = {
    update: XOR<PropertyUpdateWithoutTm30AccommodationInput, PropertyUncheckedUpdateWithoutTm30AccommodationInput>
    create: XOR<PropertyCreateWithoutTm30AccommodationInput, PropertyUncheckedCreateWithoutTm30AccommodationInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutTm30AccommodationInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutTm30AccommodationInput, PropertyUncheckedUpdateWithoutTm30AccommodationInput>
  }

  export type PropertyUpdateWithoutTm30AccommodationInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    views?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyOwner?: PropertyOwnerUpdateOneWithoutPropertiesNestedInput
    poiDistances?: PropertyPoiDistanceUpdateManyWithoutPropertyNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    viewingRequests?: ViewingRequestUpdateManyWithoutPropertyNestedInput
    rentalBookings?: RentalBookingUpdateManyWithoutPropertyNestedInput
    blockedDates?: PropertyBlockedDateUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutTm30AccommodationInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    propertyOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    views?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    poiDistances?: PropertyPoiDistanceUncheckedUpdateManyWithoutPropertyNestedInput
    viewingRequests?: ViewingRequestUncheckedUpdateManyWithoutPropertyNestedInput
    rentalBookings?: RentalBookingUncheckedUpdateManyWithoutPropertyNestedInput
    blockedDates?: PropertyBlockedDateUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyOwnerCreateWithoutTm30RequestsInput = {
    id?: string
    firstName: string
    lastName: string
    thaiIdNumber?: string | null
    phone: string
    email?: string | null
    gender?: string | null
    idCardUrl?: string | null
    idCardPath?: string | null
    idCardOcrData?: NullableJsonNullValueInput | InputJsonValue
    idCardVerified?: boolean
    idCardUploadedAt?: Date | string | null
    isActive?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: OwnerDocumentCreateNestedManyWithoutOwnerInput
    properties?: PropertyCreateNestedManyWithoutPropertyOwnerInput
  }

  export type PropertyOwnerUncheckedCreateWithoutTm30RequestsInput = {
    id?: string
    firstName: string
    lastName: string
    thaiIdNumber?: string | null
    phone: string
    email?: string | null
    gender?: string | null
    idCardUrl?: string | null
    idCardPath?: string | null
    idCardOcrData?: NullableJsonNullValueInput | InputJsonValue
    idCardVerified?: boolean
    idCardUploadedAt?: Date | string | null
    isActive?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: OwnerDocumentUncheckedCreateNestedManyWithoutOwnerInput
    properties?: PropertyUncheckedCreateNestedManyWithoutPropertyOwnerInput
  }

  export type PropertyOwnerCreateOrConnectWithoutTm30RequestsInput = {
    where: PropertyOwnerWhereUniqueInput
    create: XOR<PropertyOwnerCreateWithoutTm30RequestsInput, PropertyOwnerUncheckedCreateWithoutTm30RequestsInput>
  }

  export type PropertyOwnerUpsertWithoutTm30RequestsInput = {
    update: XOR<PropertyOwnerUpdateWithoutTm30RequestsInput, PropertyOwnerUncheckedUpdateWithoutTm30RequestsInput>
    create: XOR<PropertyOwnerCreateWithoutTm30RequestsInput, PropertyOwnerUncheckedCreateWithoutTm30RequestsInput>
    where?: PropertyOwnerWhereInput
  }

  export type PropertyOwnerUpdateToOneWithWhereWithoutTm30RequestsInput = {
    where?: PropertyOwnerWhereInput
    data: XOR<PropertyOwnerUpdateWithoutTm30RequestsInput, PropertyOwnerUncheckedUpdateWithoutTm30RequestsInput>
  }

  export type PropertyOwnerUpdateWithoutTm30RequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    idCardUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idCardPath?: NullableStringFieldUpdateOperationsInput | string | null
    idCardOcrData?: NullableJsonNullValueInput | InputJsonValue
    idCardVerified?: BoolFieldUpdateOperationsInput | boolean
    idCardUploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: OwnerDocumentUpdateManyWithoutOwnerNestedInput
    properties?: PropertyUpdateManyWithoutPropertyOwnerNestedInput
  }

  export type PropertyOwnerUncheckedUpdateWithoutTm30RequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    idCardUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idCardPath?: NullableStringFieldUpdateOperationsInput | string | null
    idCardOcrData?: NullableJsonNullValueInput | InputJsonValue
    idCardVerified?: BoolFieldUpdateOperationsInput | boolean
    idCardUploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: OwnerDocumentUncheckedUpdateManyWithoutOwnerNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutPropertyOwnerNestedInput
  }

  export type OwnerDocumentCreateWithoutOwnerInput = {
    id?: string
    documentType: $Enums.OwnerDocumentType
    imageUrl: string
    imagePath: string
    fileName?: string | null
    ocrData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: Date | string | null
    ocrConfidence?: number | null
    propertyId?: string | null
    houseId?: string | null
    extractedAddress?: string | null
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OwnerDocumentUncheckedCreateWithoutOwnerInput = {
    id?: string
    documentType: $Enums.OwnerDocumentType
    imageUrl: string
    imagePath: string
    fileName?: string | null
    ocrData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: Date | string | null
    ocrConfidence?: number | null
    propertyId?: string | null
    houseId?: string | null
    extractedAddress?: string | null
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OwnerDocumentCreateOrConnectWithoutOwnerInput = {
    where: OwnerDocumentWhereUniqueInput
    create: XOR<OwnerDocumentCreateWithoutOwnerInput, OwnerDocumentUncheckedCreateWithoutOwnerInput>
  }

  export type OwnerDocumentCreateManyOwnerInputEnvelope = {
    data: OwnerDocumentCreateManyOwnerInput | OwnerDocumentCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type PropertyCreateWithoutPropertyOwnerInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PropertyImageCreateNestedManyWithoutPropertyInput
    views?: PropertyViewCreateNestedManyWithoutPropertyInput
    poiDistances?: PropertyPoiDistanceCreateNestedManyWithoutPropertyInput
    user: UserCreateNestedOneWithoutPropertiesInput
    viewingRequests?: ViewingRequestCreateNestedManyWithoutPropertyInput
    rentalBookings?: RentalBookingCreateNestedManyWithoutPropertyInput
    blockedDates?: PropertyBlockedDateCreateNestedManyWithoutPropertyInput
    tm30Accommodation?: Tm30AccommodationCreateNestedOneWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutPropertyOwnerInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: PropertyImageUncheckedCreateNestedManyWithoutPropertyInput
    views?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    poiDistances?: PropertyPoiDistanceUncheckedCreateNestedManyWithoutPropertyInput
    viewingRequests?: ViewingRequestUncheckedCreateNestedManyWithoutPropertyInput
    rentalBookings?: RentalBookingUncheckedCreateNestedManyWithoutPropertyInput
    blockedDates?: PropertyBlockedDateUncheckedCreateNestedManyWithoutPropertyInput
    tm30Accommodation?: Tm30AccommodationUncheckedCreateNestedOneWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPropertyOwnerInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPropertyOwnerInput, PropertyUncheckedCreateWithoutPropertyOwnerInput>
  }

  export type PropertyCreateManyPropertyOwnerInputEnvelope = {
    data: PropertyCreateManyPropertyOwnerInput | PropertyCreateManyPropertyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type Tm30AccommodationRequestCreateWithoutPropertyOwnerInput = {
    id?: string
    ownerSameAsRegistrant?: boolean
    ownerNationalType?: string
    ownerNationalId?: string | null
    ownerPassportNumber?: string | null
    ownerFirstName: string
    ownerMiddleName?: string | null
    ownerLastName: string
    ownerTelephone: string
    ownerGender?: string | null
    entityType?: string
    houseIdNumber?: string | null
    accommodationType: string
    accommodationName: string
    position?: string | null
    positionOther?: string | null
    addressNumber: string
    villageNumber?: string | null
    alley?: string | null
    road?: string | null
    province: string
    district: string
    subDistrict: string
    postalCode: string
    latitude?: number | null
    longitude?: number | null
    houseRegistrationUrl?: string | null
    houseRegistrationPath?: string | null
    ocrProcessed?: boolean
    ocrProcessedAt?: Date | string | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrConfidence?: number | null
    status?: $Enums.Tm30AccomRequestStatus
    tm30Id?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    errorMessage?: string | null
    propertyId?: string | null
    whatsappPhone?: string | null
    whatsappSessionId?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Tm30AccommodationRequestUncheckedCreateWithoutPropertyOwnerInput = {
    id?: string
    ownerSameAsRegistrant?: boolean
    ownerNationalType?: string
    ownerNationalId?: string | null
    ownerPassportNumber?: string | null
    ownerFirstName: string
    ownerMiddleName?: string | null
    ownerLastName: string
    ownerTelephone: string
    ownerGender?: string | null
    entityType?: string
    houseIdNumber?: string | null
    accommodationType: string
    accommodationName: string
    position?: string | null
    positionOther?: string | null
    addressNumber: string
    villageNumber?: string | null
    alley?: string | null
    road?: string | null
    province: string
    district: string
    subDistrict: string
    postalCode: string
    latitude?: number | null
    longitude?: number | null
    houseRegistrationUrl?: string | null
    houseRegistrationPath?: string | null
    ocrProcessed?: boolean
    ocrProcessedAt?: Date | string | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrConfidence?: number | null
    status?: $Enums.Tm30AccomRequestStatus
    tm30Id?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    errorMessage?: string | null
    propertyId?: string | null
    whatsappPhone?: string | null
    whatsappSessionId?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Tm30AccommodationRequestCreateOrConnectWithoutPropertyOwnerInput = {
    where: Tm30AccommodationRequestWhereUniqueInput
    create: XOR<Tm30AccommodationRequestCreateWithoutPropertyOwnerInput, Tm30AccommodationRequestUncheckedCreateWithoutPropertyOwnerInput>
  }

  export type Tm30AccommodationRequestCreateManyPropertyOwnerInputEnvelope = {
    data: Tm30AccommodationRequestCreateManyPropertyOwnerInput | Tm30AccommodationRequestCreateManyPropertyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type OwnerDocumentUpsertWithWhereUniqueWithoutOwnerInput = {
    where: OwnerDocumentWhereUniqueInput
    update: XOR<OwnerDocumentUpdateWithoutOwnerInput, OwnerDocumentUncheckedUpdateWithoutOwnerInput>
    create: XOR<OwnerDocumentCreateWithoutOwnerInput, OwnerDocumentUncheckedCreateWithoutOwnerInput>
  }

  export type OwnerDocumentUpdateWithWhereUniqueWithoutOwnerInput = {
    where: OwnerDocumentWhereUniqueInput
    data: XOR<OwnerDocumentUpdateWithoutOwnerInput, OwnerDocumentUncheckedUpdateWithoutOwnerInput>
  }

  export type OwnerDocumentUpdateManyWithWhereWithoutOwnerInput = {
    where: OwnerDocumentScalarWhereInput
    data: XOR<OwnerDocumentUpdateManyMutationInput, OwnerDocumentUncheckedUpdateManyWithoutOwnerInput>
  }

  export type OwnerDocumentScalarWhereInput = {
    AND?: OwnerDocumentScalarWhereInput | OwnerDocumentScalarWhereInput[]
    OR?: OwnerDocumentScalarWhereInput[]
    NOT?: OwnerDocumentScalarWhereInput | OwnerDocumentScalarWhereInput[]
    id?: StringFilter<"OwnerDocument"> | string
    ownerId?: StringFilter<"OwnerDocument"> | string
    documentType?: EnumOwnerDocumentTypeFilter<"OwnerDocument"> | $Enums.OwnerDocumentType
    imageUrl?: StringFilter<"OwnerDocument"> | string
    imagePath?: StringFilter<"OwnerDocument"> | string
    fileName?: StringNullableFilter<"OwnerDocument"> | string | null
    ocrData?: JsonNullableFilter<"OwnerDocument">
    ocrProcessedAt?: DateTimeNullableFilter<"OwnerDocument"> | Date | string | null
    ocrConfidence?: FloatNullableFilter<"OwnerDocument"> | number | null
    propertyId?: StringNullableFilter<"OwnerDocument"> | string | null
    houseId?: StringNullableFilter<"OwnerDocument"> | string | null
    extractedAddress?: StringNullableFilter<"OwnerDocument"> | string | null
    isVerified?: BoolFilter<"OwnerDocument"> | boolean
    verifiedBy?: StringNullableFilter<"OwnerDocument"> | string | null
    verifiedAt?: DateTimeNullableFilter<"OwnerDocument"> | Date | string | null
    createdAt?: DateTimeFilter<"OwnerDocument"> | Date | string
    updatedAt?: DateTimeFilter<"OwnerDocument"> | Date | string
  }

  export type PropertyUpsertWithWhereUniqueWithoutPropertyOwnerInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutPropertyOwnerInput, PropertyUncheckedUpdateWithoutPropertyOwnerInput>
    create: XOR<PropertyCreateWithoutPropertyOwnerInput, PropertyUncheckedCreateWithoutPropertyOwnerInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutPropertyOwnerInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutPropertyOwnerInput, PropertyUncheckedUpdateWithoutPropertyOwnerInput>
  }

  export type PropertyUpdateManyWithWhereWithoutPropertyOwnerInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutPropertyOwnerInput>
  }

  export type Tm30AccommodationRequestUpsertWithWhereUniqueWithoutPropertyOwnerInput = {
    where: Tm30AccommodationRequestWhereUniqueInput
    update: XOR<Tm30AccommodationRequestUpdateWithoutPropertyOwnerInput, Tm30AccommodationRequestUncheckedUpdateWithoutPropertyOwnerInput>
    create: XOR<Tm30AccommodationRequestCreateWithoutPropertyOwnerInput, Tm30AccommodationRequestUncheckedCreateWithoutPropertyOwnerInput>
  }

  export type Tm30AccommodationRequestUpdateWithWhereUniqueWithoutPropertyOwnerInput = {
    where: Tm30AccommodationRequestWhereUniqueInput
    data: XOR<Tm30AccommodationRequestUpdateWithoutPropertyOwnerInput, Tm30AccommodationRequestUncheckedUpdateWithoutPropertyOwnerInput>
  }

  export type Tm30AccommodationRequestUpdateManyWithWhereWithoutPropertyOwnerInput = {
    where: Tm30AccommodationRequestScalarWhereInput
    data: XOR<Tm30AccommodationRequestUpdateManyMutationInput, Tm30AccommodationRequestUncheckedUpdateManyWithoutPropertyOwnerInput>
  }

  export type Tm30AccommodationRequestScalarWhereInput = {
    AND?: Tm30AccommodationRequestScalarWhereInput | Tm30AccommodationRequestScalarWhereInput[]
    OR?: Tm30AccommodationRequestScalarWhereInput[]
    NOT?: Tm30AccommodationRequestScalarWhereInput | Tm30AccommodationRequestScalarWhereInput[]
    id?: StringFilter<"Tm30AccommodationRequest"> | string
    ownerSameAsRegistrant?: BoolFilter<"Tm30AccommodationRequest"> | boolean
    ownerNationalType?: StringFilter<"Tm30AccommodationRequest"> | string
    ownerNationalId?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    ownerPassportNumber?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    ownerFirstName?: StringFilter<"Tm30AccommodationRequest"> | string
    ownerMiddleName?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    ownerLastName?: StringFilter<"Tm30AccommodationRequest"> | string
    ownerTelephone?: StringFilter<"Tm30AccommodationRequest"> | string
    ownerGender?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    entityType?: StringFilter<"Tm30AccommodationRequest"> | string
    houseIdNumber?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    accommodationType?: StringFilter<"Tm30AccommodationRequest"> | string
    accommodationName?: StringFilter<"Tm30AccommodationRequest"> | string
    position?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    positionOther?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    addressNumber?: StringFilter<"Tm30AccommodationRequest"> | string
    villageNumber?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    alley?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    road?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    province?: StringFilter<"Tm30AccommodationRequest"> | string
    district?: StringFilter<"Tm30AccommodationRequest"> | string
    subDistrict?: StringFilter<"Tm30AccommodationRequest"> | string
    postalCode?: StringFilter<"Tm30AccommodationRequest"> | string
    latitude?: FloatNullableFilter<"Tm30AccommodationRequest"> | number | null
    longitude?: FloatNullableFilter<"Tm30AccommodationRequest"> | number | null
    houseRegistrationUrl?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    houseRegistrationPath?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    ocrProcessed?: BoolFilter<"Tm30AccommodationRequest"> | boolean
    ocrProcessedAt?: DateTimeNullableFilter<"Tm30AccommodationRequest"> | Date | string | null
    ocrRawData?: JsonNullableFilter<"Tm30AccommodationRequest">
    ocrConfidence?: FloatNullableFilter<"Tm30AccommodationRequest"> | number | null
    status?: EnumTm30AccomRequestStatusFilter<"Tm30AccommodationRequest"> | $Enums.Tm30AccomRequestStatus
    tm30Id?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    submittedAt?: DateTimeNullableFilter<"Tm30AccommodationRequest"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"Tm30AccommodationRequest"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"Tm30AccommodationRequest"> | Date | string | null
    rejectionReason?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    errorMessage?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    propertyId?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    propertyOwnerId?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    whatsappPhone?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    whatsappSessionId?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    createdBy?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    updatedBy?: StringNullableFilter<"Tm30AccommodationRequest"> | string | null
    createdAt?: DateTimeFilter<"Tm30AccommodationRequest"> | Date | string
    updatedAt?: DateTimeFilter<"Tm30AccommodationRequest"> | Date | string
  }

  export type PropertyOwnerCreateWithoutDocumentsInput = {
    id?: string
    firstName: string
    lastName: string
    thaiIdNumber?: string | null
    phone: string
    email?: string | null
    gender?: string | null
    idCardUrl?: string | null
    idCardPath?: string | null
    idCardOcrData?: NullableJsonNullValueInput | InputJsonValue
    idCardVerified?: boolean
    idCardUploadedAt?: Date | string | null
    isActive?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutPropertyOwnerInput
    tm30Requests?: Tm30AccommodationRequestCreateNestedManyWithoutPropertyOwnerInput
  }

  export type PropertyOwnerUncheckedCreateWithoutDocumentsInput = {
    id?: string
    firstName: string
    lastName: string
    thaiIdNumber?: string | null
    phone: string
    email?: string | null
    gender?: string | null
    idCardUrl?: string | null
    idCardPath?: string | null
    idCardOcrData?: NullableJsonNullValueInput | InputJsonValue
    idCardVerified?: boolean
    idCardUploadedAt?: Date | string | null
    isActive?: boolean
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutPropertyOwnerInput
    tm30Requests?: Tm30AccommodationRequestUncheckedCreateNestedManyWithoutPropertyOwnerInput
  }

  export type PropertyOwnerCreateOrConnectWithoutDocumentsInput = {
    where: PropertyOwnerWhereUniqueInput
    create: XOR<PropertyOwnerCreateWithoutDocumentsInput, PropertyOwnerUncheckedCreateWithoutDocumentsInput>
  }

  export type PropertyOwnerUpsertWithoutDocumentsInput = {
    update: XOR<PropertyOwnerUpdateWithoutDocumentsInput, PropertyOwnerUncheckedUpdateWithoutDocumentsInput>
    create: XOR<PropertyOwnerCreateWithoutDocumentsInput, PropertyOwnerUncheckedCreateWithoutDocumentsInput>
    where?: PropertyOwnerWhereInput
  }

  export type PropertyOwnerUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: PropertyOwnerWhereInput
    data: XOR<PropertyOwnerUpdateWithoutDocumentsInput, PropertyOwnerUncheckedUpdateWithoutDocumentsInput>
  }

  export type PropertyOwnerUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    idCardUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idCardPath?: NullableStringFieldUpdateOperationsInput | string | null
    idCardOcrData?: NullableJsonNullValueInput | InputJsonValue
    idCardVerified?: BoolFieldUpdateOperationsInput | boolean
    idCardUploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutPropertyOwnerNestedInput
    tm30Requests?: Tm30AccommodationRequestUpdateManyWithoutPropertyOwnerNestedInput
  }

  export type PropertyOwnerUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    idCardUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idCardPath?: NullableStringFieldUpdateOperationsInput | string | null
    idCardOcrData?: NullableJsonNullValueInput | InputJsonValue
    idCardVerified?: BoolFieldUpdateOperationsInput | boolean
    idCardUploadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutPropertyOwnerNestedInput
    tm30Requests?: Tm30AccommodationRequestUncheckedUpdateManyWithoutPropertyOwnerNestedInput
  }

  export type AICodeChangeCreateWithoutDecisionInput = {
    id?: string
    filePath: string
    action: $Enums.AICodeAction
    originalContent?: string | null
    newContent?: string | null
    diff?: string | null
    syntaxValid?: boolean
    typesValid?: boolean
    lintPassed?: boolean
    testsPassed?: boolean | null
    appliedAt?: Date | string | null
    rolledBackAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AICodeChangeUncheckedCreateWithoutDecisionInput = {
    id?: string
    filePath: string
    action: $Enums.AICodeAction
    originalContent?: string | null
    newContent?: string | null
    diff?: string | null
    syntaxValid?: boolean
    typesValid?: boolean
    lintPassed?: boolean
    testsPassed?: boolean | null
    appliedAt?: Date | string | null
    rolledBackAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AICodeChangeCreateOrConnectWithoutDecisionInput = {
    where: AICodeChangeWhereUniqueInput
    create: XOR<AICodeChangeCreateWithoutDecisionInput, AICodeChangeUncheckedCreateWithoutDecisionInput>
  }

  export type AICodeChangeCreateManyDecisionInputEnvelope = {
    data: AICodeChangeCreateManyDecisionInput | AICodeChangeCreateManyDecisionInput[]
    skipDuplicates?: boolean
  }

  export type AIAgentLogCreateWithoutDecisionInput = {
    id?: string
    level?: $Enums.AILogLevel
    category: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    errorCode?: string | null
    errorStack?: string | null
    durationMs?: number | null
    createdAt?: Date | string
  }

  export type AIAgentLogUncheckedCreateWithoutDecisionInput = {
    id?: string
    level?: $Enums.AILogLevel
    category: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    errorCode?: string | null
    errorStack?: string | null
    durationMs?: number | null
    createdAt?: Date | string
  }

  export type AIAgentLogCreateOrConnectWithoutDecisionInput = {
    where: AIAgentLogWhereUniqueInput
    create: XOR<AIAgentLogCreateWithoutDecisionInput, AIAgentLogUncheckedCreateWithoutDecisionInput>
  }

  export type AIAgentLogCreateManyDecisionInputEnvelope = {
    data: AIAgentLogCreateManyDecisionInput | AIAgentLogCreateManyDecisionInput[]
    skipDuplicates?: boolean
  }

  export type AICodeChangeUpsertWithWhereUniqueWithoutDecisionInput = {
    where: AICodeChangeWhereUniqueInput
    update: XOR<AICodeChangeUpdateWithoutDecisionInput, AICodeChangeUncheckedUpdateWithoutDecisionInput>
    create: XOR<AICodeChangeCreateWithoutDecisionInput, AICodeChangeUncheckedCreateWithoutDecisionInput>
  }

  export type AICodeChangeUpdateWithWhereUniqueWithoutDecisionInput = {
    where: AICodeChangeWhereUniqueInput
    data: XOR<AICodeChangeUpdateWithoutDecisionInput, AICodeChangeUncheckedUpdateWithoutDecisionInput>
  }

  export type AICodeChangeUpdateManyWithWhereWithoutDecisionInput = {
    where: AICodeChangeScalarWhereInput
    data: XOR<AICodeChangeUpdateManyMutationInput, AICodeChangeUncheckedUpdateManyWithoutDecisionInput>
  }

  export type AICodeChangeScalarWhereInput = {
    AND?: AICodeChangeScalarWhereInput | AICodeChangeScalarWhereInput[]
    OR?: AICodeChangeScalarWhereInput[]
    NOT?: AICodeChangeScalarWhereInput | AICodeChangeScalarWhereInput[]
    id?: StringFilter<"AICodeChange"> | string
    decisionId?: StringFilter<"AICodeChange"> | string
    filePath?: StringFilter<"AICodeChange"> | string
    action?: EnumAICodeActionFilter<"AICodeChange"> | $Enums.AICodeAction
    originalContent?: StringNullableFilter<"AICodeChange"> | string | null
    newContent?: StringNullableFilter<"AICodeChange"> | string | null
    diff?: StringNullableFilter<"AICodeChange"> | string | null
    syntaxValid?: BoolFilter<"AICodeChange"> | boolean
    typesValid?: BoolFilter<"AICodeChange"> | boolean
    lintPassed?: BoolFilter<"AICodeChange"> | boolean
    testsPassed?: BoolNullableFilter<"AICodeChange"> | boolean | null
    appliedAt?: DateTimeNullableFilter<"AICodeChange"> | Date | string | null
    rolledBackAt?: DateTimeNullableFilter<"AICodeChange"> | Date | string | null
    createdAt?: DateTimeFilter<"AICodeChange"> | Date | string
  }

  export type AIAgentLogUpsertWithWhereUniqueWithoutDecisionInput = {
    where: AIAgentLogWhereUniqueInput
    update: XOR<AIAgentLogUpdateWithoutDecisionInput, AIAgentLogUncheckedUpdateWithoutDecisionInput>
    create: XOR<AIAgentLogCreateWithoutDecisionInput, AIAgentLogUncheckedCreateWithoutDecisionInput>
  }

  export type AIAgentLogUpdateWithWhereUniqueWithoutDecisionInput = {
    where: AIAgentLogWhereUniqueInput
    data: XOR<AIAgentLogUpdateWithoutDecisionInput, AIAgentLogUncheckedUpdateWithoutDecisionInput>
  }

  export type AIAgentLogUpdateManyWithWhereWithoutDecisionInput = {
    where: AIAgentLogScalarWhereInput
    data: XOR<AIAgentLogUpdateManyMutationInput, AIAgentLogUncheckedUpdateManyWithoutDecisionInput>
  }

  export type AIAgentLogScalarWhereInput = {
    AND?: AIAgentLogScalarWhereInput | AIAgentLogScalarWhereInput[]
    OR?: AIAgentLogScalarWhereInput[]
    NOT?: AIAgentLogScalarWhereInput | AIAgentLogScalarWhereInput[]
    id?: StringFilter<"AIAgentLog"> | string
    level?: EnumAILogLevelFilter<"AIAgentLog"> | $Enums.AILogLevel
    category?: StringFilter<"AIAgentLog"> | string
    message?: StringFilter<"AIAgentLog"> | string
    data?: JsonNullableFilter<"AIAgentLog">
    decisionId?: StringNullableFilter<"AIAgentLog"> | string | null
    errorCode?: StringNullableFilter<"AIAgentLog"> | string | null
    errorStack?: StringNullableFilter<"AIAgentLog"> | string | null
    durationMs?: IntNullableFilter<"AIAgentLog"> | number | null
    createdAt?: DateTimeFilter<"AIAgentLog"> | Date | string
  }

  export type AIDecisionCreateWithoutCodeChangesInput = {
    id?: string
    type: string
    subType?: string | null
    priority: string
    confidence: number
    reasoning: string
    dataSnapshot?: NullableJsonNullValueInput | InputJsonValue
    actionType: string
    actionPayload: JsonNullValueInput | InputJsonValue
    estimatedImpact?: string | null
    rollbackPlan?: string | null
    requiresApproval?: boolean
    autoApproved?: boolean
    status?: $Enums.AIDecisionStatus
    approvedBy?: string | null
    approvedByName?: string | null
    approvedAt?: Date | string | null
    rejectedBy?: string | null
    rejectedByName?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    executedAt?: Date | string | null
    executionResult?: NullableJsonNullValueInput | InputJsonValue
    executionError?: string | null
    executionDuration?: number | null
    rolledBackAt?: Date | string | null
    rolledBackBy?: string | null
    rollbackReason?: string | null
    feedbackDueAt?: Date | string | null
    actualImpact?: NullableJsonNullValueInput | InputJsonValue
    wasSuccessful?: boolean | null
    successScore?: number | null
    feedbackNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: AIAgentLogCreateNestedManyWithoutDecisionInput
  }

  export type AIDecisionUncheckedCreateWithoutCodeChangesInput = {
    id?: string
    type: string
    subType?: string | null
    priority: string
    confidence: number
    reasoning: string
    dataSnapshot?: NullableJsonNullValueInput | InputJsonValue
    actionType: string
    actionPayload: JsonNullValueInput | InputJsonValue
    estimatedImpact?: string | null
    rollbackPlan?: string | null
    requiresApproval?: boolean
    autoApproved?: boolean
    status?: $Enums.AIDecisionStatus
    approvedBy?: string | null
    approvedByName?: string | null
    approvedAt?: Date | string | null
    rejectedBy?: string | null
    rejectedByName?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    executedAt?: Date | string | null
    executionResult?: NullableJsonNullValueInput | InputJsonValue
    executionError?: string | null
    executionDuration?: number | null
    rolledBackAt?: Date | string | null
    rolledBackBy?: string | null
    rollbackReason?: string | null
    feedbackDueAt?: Date | string | null
    actualImpact?: NullableJsonNullValueInput | InputJsonValue
    wasSuccessful?: boolean | null
    successScore?: number | null
    feedbackNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: AIAgentLogUncheckedCreateNestedManyWithoutDecisionInput
  }

  export type AIDecisionCreateOrConnectWithoutCodeChangesInput = {
    where: AIDecisionWhereUniqueInput
    create: XOR<AIDecisionCreateWithoutCodeChangesInput, AIDecisionUncheckedCreateWithoutCodeChangesInput>
  }

  export type AIDecisionUpsertWithoutCodeChangesInput = {
    update: XOR<AIDecisionUpdateWithoutCodeChangesInput, AIDecisionUncheckedUpdateWithoutCodeChangesInput>
    create: XOR<AIDecisionCreateWithoutCodeChangesInput, AIDecisionUncheckedCreateWithoutCodeChangesInput>
    where?: AIDecisionWhereInput
  }

  export type AIDecisionUpdateToOneWithWhereWithoutCodeChangesInput = {
    where?: AIDecisionWhereInput
    data: XOR<AIDecisionUpdateWithoutCodeChangesInput, AIDecisionUncheckedUpdateWithoutCodeChangesInput>
  }

  export type AIDecisionUpdateWithoutCodeChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    reasoning?: StringFieldUpdateOperationsInput | string
    dataSnapshot?: NullableJsonNullValueInput | InputJsonValue
    actionType?: StringFieldUpdateOperationsInput | string
    actionPayload?: JsonNullValueInput | InputJsonValue
    estimatedImpact?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackPlan?: NullableStringFieldUpdateOperationsInput | string | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    autoApproved?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAIDecisionStatusFieldUpdateOperationsInput | $Enums.AIDecisionStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByName?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedByName?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionResult?: NullableJsonNullValueInput | InputJsonValue
    executionError?: NullableStringFieldUpdateOperationsInput | string | null
    executionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    rolledBackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rolledBackBy?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackReason?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpact?: NullableJsonNullValueInput | InputJsonValue
    wasSuccessful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    successScore?: NullableFloatFieldUpdateOperationsInput | number | null
    feedbackNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: AIAgentLogUpdateManyWithoutDecisionNestedInput
  }

  export type AIDecisionUncheckedUpdateWithoutCodeChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    reasoning?: StringFieldUpdateOperationsInput | string
    dataSnapshot?: NullableJsonNullValueInput | InputJsonValue
    actionType?: StringFieldUpdateOperationsInput | string
    actionPayload?: JsonNullValueInput | InputJsonValue
    estimatedImpact?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackPlan?: NullableStringFieldUpdateOperationsInput | string | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    autoApproved?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAIDecisionStatusFieldUpdateOperationsInput | $Enums.AIDecisionStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByName?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedByName?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionResult?: NullableJsonNullValueInput | InputJsonValue
    executionError?: NullableStringFieldUpdateOperationsInput | string | null
    executionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    rolledBackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rolledBackBy?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackReason?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpact?: NullableJsonNullValueInput | InputJsonValue
    wasSuccessful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    successScore?: NullableFloatFieldUpdateOperationsInput | number | null
    feedbackNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: AIAgentLogUncheckedUpdateManyWithoutDecisionNestedInput
  }

  export type AIDecisionCreateWithoutLogsInput = {
    id?: string
    type: string
    subType?: string | null
    priority: string
    confidence: number
    reasoning: string
    dataSnapshot?: NullableJsonNullValueInput | InputJsonValue
    actionType: string
    actionPayload: JsonNullValueInput | InputJsonValue
    estimatedImpact?: string | null
    rollbackPlan?: string | null
    requiresApproval?: boolean
    autoApproved?: boolean
    status?: $Enums.AIDecisionStatus
    approvedBy?: string | null
    approvedByName?: string | null
    approvedAt?: Date | string | null
    rejectedBy?: string | null
    rejectedByName?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    executedAt?: Date | string | null
    executionResult?: NullableJsonNullValueInput | InputJsonValue
    executionError?: string | null
    executionDuration?: number | null
    rolledBackAt?: Date | string | null
    rolledBackBy?: string | null
    rollbackReason?: string | null
    feedbackDueAt?: Date | string | null
    actualImpact?: NullableJsonNullValueInput | InputJsonValue
    wasSuccessful?: boolean | null
    successScore?: number | null
    feedbackNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    codeChanges?: AICodeChangeCreateNestedManyWithoutDecisionInput
  }

  export type AIDecisionUncheckedCreateWithoutLogsInput = {
    id?: string
    type: string
    subType?: string | null
    priority: string
    confidence: number
    reasoning: string
    dataSnapshot?: NullableJsonNullValueInput | InputJsonValue
    actionType: string
    actionPayload: JsonNullValueInput | InputJsonValue
    estimatedImpact?: string | null
    rollbackPlan?: string | null
    requiresApproval?: boolean
    autoApproved?: boolean
    status?: $Enums.AIDecisionStatus
    approvedBy?: string | null
    approvedByName?: string | null
    approvedAt?: Date | string | null
    rejectedBy?: string | null
    rejectedByName?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    executedAt?: Date | string | null
    executionResult?: NullableJsonNullValueInput | InputJsonValue
    executionError?: string | null
    executionDuration?: number | null
    rolledBackAt?: Date | string | null
    rolledBackBy?: string | null
    rollbackReason?: string | null
    feedbackDueAt?: Date | string | null
    actualImpact?: NullableJsonNullValueInput | InputJsonValue
    wasSuccessful?: boolean | null
    successScore?: number | null
    feedbackNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    codeChanges?: AICodeChangeUncheckedCreateNestedManyWithoutDecisionInput
  }

  export type AIDecisionCreateOrConnectWithoutLogsInput = {
    where: AIDecisionWhereUniqueInput
    create: XOR<AIDecisionCreateWithoutLogsInput, AIDecisionUncheckedCreateWithoutLogsInput>
  }

  export type AIDecisionUpsertWithoutLogsInput = {
    update: XOR<AIDecisionUpdateWithoutLogsInput, AIDecisionUncheckedUpdateWithoutLogsInput>
    create: XOR<AIDecisionCreateWithoutLogsInput, AIDecisionUncheckedCreateWithoutLogsInput>
    where?: AIDecisionWhereInput
  }

  export type AIDecisionUpdateToOneWithWhereWithoutLogsInput = {
    where?: AIDecisionWhereInput
    data: XOR<AIDecisionUpdateWithoutLogsInput, AIDecisionUncheckedUpdateWithoutLogsInput>
  }

  export type AIDecisionUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    reasoning?: StringFieldUpdateOperationsInput | string
    dataSnapshot?: NullableJsonNullValueInput | InputJsonValue
    actionType?: StringFieldUpdateOperationsInput | string
    actionPayload?: JsonNullValueInput | InputJsonValue
    estimatedImpact?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackPlan?: NullableStringFieldUpdateOperationsInput | string | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    autoApproved?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAIDecisionStatusFieldUpdateOperationsInput | $Enums.AIDecisionStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByName?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedByName?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionResult?: NullableJsonNullValueInput | InputJsonValue
    executionError?: NullableStringFieldUpdateOperationsInput | string | null
    executionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    rolledBackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rolledBackBy?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackReason?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpact?: NullableJsonNullValueInput | InputJsonValue
    wasSuccessful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    successScore?: NullableFloatFieldUpdateOperationsInput | number | null
    feedbackNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codeChanges?: AICodeChangeUpdateManyWithoutDecisionNestedInput
  }

  export type AIDecisionUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subType?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    reasoning?: StringFieldUpdateOperationsInput | string
    dataSnapshot?: NullableJsonNullValueInput | InputJsonValue
    actionType?: StringFieldUpdateOperationsInput | string
    actionPayload?: JsonNullValueInput | InputJsonValue
    estimatedImpact?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackPlan?: NullableStringFieldUpdateOperationsInput | string | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    autoApproved?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumAIDecisionStatusFieldUpdateOperationsInput | $Enums.AIDecisionStatus
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByName?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedByName?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionResult?: NullableJsonNullValueInput | InputJsonValue
    executionError?: NullableStringFieldUpdateOperationsInput | string | null
    executionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    rolledBackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rolledBackBy?: NullableStringFieldUpdateOperationsInput | string | null
    rollbackReason?: NullableStringFieldUpdateOperationsInput | string | null
    feedbackDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualImpact?: NullableJsonNullValueInput | InputJsonValue
    wasSuccessful?: NullableBoolFieldUpdateOperationsInput | boolean | null
    successScore?: NullableFloatFieldUpdateOperationsInput | number | null
    feedbackNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codeChanges?: AICodeChangeUncheckedUpdateManyWithoutDecisionNestedInput
  }

  export type SessionCreateManyUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
  }

  export type AccountCreateManyUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type PropertyCreateManyUserInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    propertyOwnerId?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorLeadCreateManyAssignedToInput = {
    id?: string
    name: string
    email: string
    phone: string
    countryCode?: string
    currency?: string
    investmentBudget: string
    investmentGoal: string
    timeline: string
    preferredAreas?: string | null
    propertyType?: string | null
    experience?: string | null
    financing?: string | null
    message?: string | null
    newsletter?: boolean
    status?: $Enums.LeadStatus
    ipAddress?: string | null
    userAgent?: string | null
    source?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RentalLeadCreateManyAssignedToInput = {
    id?: string
    name: string
    email: string
    phone: string
    countryCode?: string
    propertyType: string
    bedrooms: string
    budget: string
    rentalDuration: string
    preferredAreas?: string | null
    moveInDate?: string | null
    furnished?: string | null
    pets?: string | null
    message?: string | null
    newsletter?: boolean
    status?: $Enums.RentalLeadStatus
    ipAddress?: string | null
    userAgent?: string | null
    source?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogCreateManyAuthorInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    coverImage?: string | null
    coverImageAlt?: string | null
    tag?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    categoryId?: string | null
    published?: boolean
    publishedAt?: Date | string | null
    originalContent?: string | null
    linkOptimizedAt?: Date | string | null
    internalLinkCount?: number
    hasDynamicProperties?: boolean
    poiQueryParams?: string | null
    poiTemplateId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RentalBookingCreateManyUserInput = {
    id?: string
    propertyId: string
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    adults?: number
    children?: number
    babies?: number
    pets?: number
    basePrice: number
    season: string
    discountPercent: number
    totalPrice: number
    guestName: string
    guestEmail: string
    guestPhone: string
    guestCountryCode?: string
    guestMessage?: string | null
    status?: $Enums.RentalBookingStatus
    paymentStatus?: string | null
    cancellationPolicy?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    internalNotes?: string | null
    checkInTime?: string | null
    checkOutTime?: string | null
    propertyAddress?: string | null
    propertyInstructions?: string | null
    wifiName?: string | null
    wifiPassword?: string | null
    accessCode?: string | null
    emergencyContact?: string | null
    houseRules?: string | null
    confirmedAt?: Date | string | null
    agentId?: string | null
    tm30Status?: $Enums.TM30BookingStatus
    tm30SubmittedAt?: Date | string | null
    tm30Reference?: string | null
    tm30Error?: string | null
    passportsRequired?: number
    passportsReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RentalBookingCreateManyAgentInput = {
    id?: string
    propertyId: string
    userId: string
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    adults?: number
    children?: number
    babies?: number
    pets?: number
    basePrice: number
    season: string
    discountPercent: number
    totalPrice: number
    guestName: string
    guestEmail: string
    guestPhone: string
    guestCountryCode?: string
    guestMessage?: string | null
    status?: $Enums.RentalBookingStatus
    paymentStatus?: string | null
    cancellationPolicy?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    internalNotes?: string | null
    checkInTime?: string | null
    checkOutTime?: string | null
    propertyAddress?: string | null
    propertyInstructions?: string | null
    wifiName?: string | null
    wifiPassword?: string | null
    accessCode?: string | null
    emergencyContact?: string | null
    houseRules?: string | null
    confirmedAt?: Date | string | null
    tm30Status?: $Enums.TM30BookingStatus
    tm30SubmittedAt?: Date | string | null
    tm30Reference?: string | null
    tm30Error?: string | null
    passportsRequired?: number
    passportsReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    views?: PropertyViewUpdateManyWithoutPropertyNestedInput
    propertyOwner?: PropertyOwnerUpdateOneWithoutPropertiesNestedInput
    poiDistances?: PropertyPoiDistanceUpdateManyWithoutPropertyNestedInput
    viewingRequests?: ViewingRequestUpdateManyWithoutPropertyNestedInput
    rentalBookings?: RentalBookingUpdateManyWithoutPropertyNestedInput
    blockedDates?: PropertyBlockedDateUpdateManyWithoutPropertyNestedInput
    tm30Accommodation?: Tm30AccommodationUpdateOneWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    propertyOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    views?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    poiDistances?: PropertyPoiDistanceUncheckedUpdateManyWithoutPropertyNestedInput
    viewingRequests?: ViewingRequestUncheckedUpdateManyWithoutPropertyNestedInput
    rentalBookings?: RentalBookingUncheckedUpdateManyWithoutPropertyNestedInput
    blockedDates?: PropertyBlockedDateUncheckedUpdateManyWithoutPropertyNestedInput
    tm30Accommodation?: Tm30AccommodationUncheckedUpdateOneWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    propertyOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorLeadUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    investmentBudget?: StringFieldUpdateOperationsInput | string
    investmentGoal?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    preferredAreas?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    financing?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    newsletter?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorLeadUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    investmentBudget?: StringFieldUpdateOperationsInput | string
    investmentGoal?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    preferredAreas?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    financing?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    newsletter?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorLeadUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    investmentBudget?: StringFieldUpdateOperationsInput | string
    investmentGoal?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    preferredAreas?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    financing?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    newsletter?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalLeadUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    propertyType?: StringFieldUpdateOperationsInput | string
    bedrooms?: StringFieldUpdateOperationsInput | string
    budget?: StringFieldUpdateOperationsInput | string
    rentalDuration?: StringFieldUpdateOperationsInput | string
    preferredAreas?: NullableStringFieldUpdateOperationsInput | string | null
    moveInDate?: NullableStringFieldUpdateOperationsInput | string | null
    furnished?: NullableStringFieldUpdateOperationsInput | string | null
    pets?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    newsletter?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRentalLeadStatusFieldUpdateOperationsInput | $Enums.RentalLeadStatus
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalLeadUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    propertyType?: StringFieldUpdateOperationsInput | string
    bedrooms?: StringFieldUpdateOperationsInput | string
    budget?: StringFieldUpdateOperationsInput | string
    rentalDuration?: StringFieldUpdateOperationsInput | string
    preferredAreas?: NullableStringFieldUpdateOperationsInput | string | null
    moveInDate?: NullableStringFieldUpdateOperationsInput | string | null
    furnished?: NullableStringFieldUpdateOperationsInput | string | null
    pets?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    newsletter?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRentalLeadStatusFieldUpdateOperationsInput | $Enums.RentalLeadStatus
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalLeadUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    propertyType?: StringFieldUpdateOperationsInput | string
    bedrooms?: StringFieldUpdateOperationsInput | string
    budget?: StringFieldUpdateOperationsInput | string
    rentalDuration?: StringFieldUpdateOperationsInput | string
    preferredAreas?: NullableStringFieldUpdateOperationsInput | string | null
    moveInDate?: NullableStringFieldUpdateOperationsInput | string | null
    furnished?: NullableStringFieldUpdateOperationsInput | string | null
    pets?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    newsletter?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRentalLeadStatusFieldUpdateOperationsInput | $Enums.RentalLeadStatus
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    linkOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalLinkCount?: IntFieldUpdateOperationsInput | number
    hasDynamicProperties?: BoolFieldUpdateOperationsInput | boolean
    poiQueryParams?: NullableStringFieldUpdateOperationsInput | string | null
    poiTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: BlogCategoryUpdateOneWithoutBlogsNestedInput
    linkUsages?: LinkUsageUpdateManyWithoutBlogNestedInput
  }

  export type BlogUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    linkOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalLinkCount?: IntFieldUpdateOperationsInput | number
    hasDynamicProperties?: BoolFieldUpdateOperationsInput | boolean
    poiQueryParams?: NullableStringFieldUpdateOperationsInput | string | null
    poiTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkUsages?: LinkUsageUncheckedUpdateManyWithoutBlogNestedInput
  }

  export type BlogUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    linkOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalLinkCount?: IntFieldUpdateOperationsInput | number
    hasDynamicProperties?: BoolFieldUpdateOperationsInput | boolean
    poiQueryParams?: NullableStringFieldUpdateOperationsInput | string | null
    poiTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalBookingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    babies?: IntFieldUpdateOperationsInput | number
    pets?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    discountPercent?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: StringFieldUpdateOperationsInput | string
    guestCountryCode?: StringFieldUpdateOperationsInput | string
    guestMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRentalBookingStatusFieldUpdateOperationsInput | $Enums.RentalBookingStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    wifiName?: NullableStringFieldUpdateOperationsInput | string | null
    wifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Status?: EnumTM30BookingStatusFieldUpdateOperationsInput | $Enums.TM30BookingStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Reference?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    passportsRequired?: IntFieldUpdateOperationsInput | number
    passportsReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutRentalBookingsNestedInput
    agent?: UserUpdateOneWithoutBookingsAsAgentNestedInput
    messages?: BookingMessageUpdateManyWithoutBookingNestedInput
    guests?: BookingGuestUpdateManyWithoutBookingNestedInput
  }

  export type RentalBookingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    babies?: IntFieldUpdateOperationsInput | number
    pets?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    discountPercent?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: StringFieldUpdateOperationsInput | string
    guestCountryCode?: StringFieldUpdateOperationsInput | string
    guestMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRentalBookingStatusFieldUpdateOperationsInput | $Enums.RentalBookingStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    wifiName?: NullableStringFieldUpdateOperationsInput | string | null
    wifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Status?: EnumTM30BookingStatusFieldUpdateOperationsInput | $Enums.TM30BookingStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Reference?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    passportsRequired?: IntFieldUpdateOperationsInput | number
    passportsReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: BookingMessageUncheckedUpdateManyWithoutBookingNestedInput
    guests?: BookingGuestUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type RentalBookingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    babies?: IntFieldUpdateOperationsInput | number
    pets?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    discountPercent?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: StringFieldUpdateOperationsInput | string
    guestCountryCode?: StringFieldUpdateOperationsInput | string
    guestMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRentalBookingStatusFieldUpdateOperationsInput | $Enums.RentalBookingStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    wifiName?: NullableStringFieldUpdateOperationsInput | string | null
    wifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Status?: EnumTM30BookingStatusFieldUpdateOperationsInput | $Enums.TM30BookingStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Reference?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    passportsRequired?: IntFieldUpdateOperationsInput | number
    passportsReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalBookingUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    babies?: IntFieldUpdateOperationsInput | number
    pets?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    discountPercent?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: StringFieldUpdateOperationsInput | string
    guestCountryCode?: StringFieldUpdateOperationsInput | string
    guestMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRentalBookingStatusFieldUpdateOperationsInput | $Enums.RentalBookingStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    wifiName?: NullableStringFieldUpdateOperationsInput | string | null
    wifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Status?: EnumTM30BookingStatusFieldUpdateOperationsInput | $Enums.TM30BookingStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Reference?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    passportsRequired?: IntFieldUpdateOperationsInput | number
    passportsReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutRentalBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutRentalBookingsNestedInput
    messages?: BookingMessageUpdateManyWithoutBookingNestedInput
    guests?: BookingGuestUpdateManyWithoutBookingNestedInput
  }

  export type RentalBookingUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    babies?: IntFieldUpdateOperationsInput | number
    pets?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    discountPercent?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: StringFieldUpdateOperationsInput | string
    guestCountryCode?: StringFieldUpdateOperationsInput | string
    guestMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRentalBookingStatusFieldUpdateOperationsInput | $Enums.RentalBookingStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    wifiName?: NullableStringFieldUpdateOperationsInput | string | null
    wifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Status?: EnumTM30BookingStatusFieldUpdateOperationsInput | $Enums.TM30BookingStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Reference?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    passportsRequired?: IntFieldUpdateOperationsInput | number
    passportsReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: BookingMessageUncheckedUpdateManyWithoutBookingNestedInput
    guests?: BookingGuestUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type RentalBookingUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    babies?: IntFieldUpdateOperationsInput | number
    pets?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    discountPercent?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: StringFieldUpdateOperationsInput | string
    guestCountryCode?: StringFieldUpdateOperationsInput | string
    guestMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRentalBookingStatusFieldUpdateOperationsInput | $Enums.RentalBookingStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    wifiName?: NullableStringFieldUpdateOperationsInput | string | null
    wifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Status?: EnumTM30BookingStatusFieldUpdateOperationsInput | $Enums.TM30BookingStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Reference?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    passportsRequired?: IntFieldUpdateOperationsInput | number
    passportsReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyImageCreateManyPropertyInput = {
    id?: string
    url?: string | null
    position: number
    alt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyViewCreateManyPropertyInput = {
    id?: string
    viewedAt?: Date | string
    country?: string | null
    city?: string | null
    ipHash?: string | null
    userAgent?: string | null
    referrer?: string | null
    sessionId?: string | null
  }

  export type PropertyPoiDistanceCreateManyPropertyInput = {
    id?: string
    poiId: string
    distanceMeters: number
    walkingMinutes?: number | null
    drivingMinutes?: number | null
    isHighlight?: boolean
    calculatedAt?: Date | string
  }

  export type ViewingRequestCreateManyPropertyInput = {
    id?: string
    requestType: $Enums.RequestType
    viewingDate?: Date | string | null
    name: string
    email: string
    phone: string
    countryCode?: string
    language?: string | null
    message?: string | null
    offerAmount?: string | null
    offerCurrency?: string | null
    status?: $Enums.RequestStatus
    confirmedBy?: string | null
    confirmedByName?: string | null
    confirmedAt?: Date | string | null
    completedBy?: string | null
    completedByName?: string | null
    completedAt?: Date | string | null
    cancelledBy?: string | null
    cancelledByName?: string | null
    cancelledAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RentalBookingCreateManyPropertyInput = {
    id?: string
    userId: string
    checkIn: Date | string
    checkOut: Date | string
    nights: number
    adults?: number
    children?: number
    babies?: number
    pets?: number
    basePrice: number
    season: string
    discountPercent: number
    totalPrice: number
    guestName: string
    guestEmail: string
    guestPhone: string
    guestCountryCode?: string
    guestMessage?: string | null
    status?: $Enums.RentalBookingStatus
    paymentStatus?: string | null
    cancellationPolicy?: string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    internalNotes?: string | null
    checkInTime?: string | null
    checkOutTime?: string | null
    propertyAddress?: string | null
    propertyInstructions?: string | null
    wifiName?: string | null
    wifiPassword?: string | null
    accessCode?: string | null
    emergencyContact?: string | null
    houseRules?: string | null
    confirmedAt?: Date | string | null
    agentId?: string | null
    tm30Status?: $Enums.TM30BookingStatus
    tm30SubmittedAt?: Date | string | null
    tm30Reference?: string | null
    tm30Error?: string | null
    passportsRequired?: number
    passportsReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyBlockedDateCreateManyPropertyInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    reason?: string | null
    blockedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyImageUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyImageUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyImageUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyViewUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyViewUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyViewUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PropertyPoiDistanceUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    distanceMeters?: IntFieldUpdateOperationsInput | number
    walkingMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    drivingMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isHighlight?: BoolFieldUpdateOperationsInput | boolean
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poi?: PoiUpdateOneRequiredWithoutPropertyDistancesNestedInput
  }

  export type PropertyPoiDistanceUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    poiId?: StringFieldUpdateOperationsInput | string
    distanceMeters?: IntFieldUpdateOperationsInput | number
    walkingMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    drivingMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isHighlight?: BoolFieldUpdateOperationsInput | boolean
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPoiDistanceUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    poiId?: StringFieldUpdateOperationsInput | string
    distanceMeters?: IntFieldUpdateOperationsInput | number
    walkingMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    drivingMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isHighlight?: BoolFieldUpdateOperationsInput | boolean
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewingRequestUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    viewingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    offerAmount?: NullableStringFieldUpdateOperationsInput | string | null
    offerCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedByName?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByName?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewingRequestUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    viewingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    offerAmount?: NullableStringFieldUpdateOperationsInput | string | null
    offerCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedByName?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByName?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewingRequestUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    viewingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    language?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    offerAmount?: NullableStringFieldUpdateOperationsInput | string | null
    offerCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedByName?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByName?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalBookingUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    babies?: IntFieldUpdateOperationsInput | number
    pets?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    discountPercent?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: StringFieldUpdateOperationsInput | string
    guestCountryCode?: StringFieldUpdateOperationsInput | string
    guestMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRentalBookingStatusFieldUpdateOperationsInput | $Enums.RentalBookingStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    wifiName?: NullableStringFieldUpdateOperationsInput | string | null
    wifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Status?: EnumTM30BookingStatusFieldUpdateOperationsInput | $Enums.TM30BookingStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Reference?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    passportsRequired?: IntFieldUpdateOperationsInput | number
    passportsReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRentalBookingsNestedInput
    agent?: UserUpdateOneWithoutBookingsAsAgentNestedInput
    messages?: BookingMessageUpdateManyWithoutBookingNestedInput
    guests?: BookingGuestUpdateManyWithoutBookingNestedInput
  }

  export type RentalBookingUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    babies?: IntFieldUpdateOperationsInput | number
    pets?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    discountPercent?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: StringFieldUpdateOperationsInput | string
    guestCountryCode?: StringFieldUpdateOperationsInput | string
    guestMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRentalBookingStatusFieldUpdateOperationsInput | $Enums.RentalBookingStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    wifiName?: NullableStringFieldUpdateOperationsInput | string | null
    wifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Status?: EnumTM30BookingStatusFieldUpdateOperationsInput | $Enums.TM30BookingStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Reference?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    passportsRequired?: IntFieldUpdateOperationsInput | number
    passportsReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: BookingMessageUncheckedUpdateManyWithoutBookingNestedInput
    guests?: BookingGuestUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type RentalBookingUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    nights?: IntFieldUpdateOperationsInput | number
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    babies?: IntFieldUpdateOperationsInput | number
    pets?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    discountPercent?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: StringFieldUpdateOperationsInput | string
    guestCountryCode?: StringFieldUpdateOperationsInput | string
    guestMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRentalBookingStatusFieldUpdateOperationsInput | $Enums.RentalBookingStatus
    paymentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    wifiName?: NullableStringFieldUpdateOperationsInput | string | null
    wifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    accessCode?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agentId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Status?: EnumTM30BookingStatusFieldUpdateOperationsInput | $Enums.TM30BookingStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Reference?: NullableStringFieldUpdateOperationsInput | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    passportsRequired?: IntFieldUpdateOperationsInput | number
    passportsReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyBlockedDateUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    blockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyBlockedDateUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    blockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyBlockedDateUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    blockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkUsageCreateManyBlogInput = {
    id?: string
    linkId: string
    anchorText: string
    context?: string | null
    position?: number | null
    wasAutoInserted?: boolean
    insertedAt?: Date | string
    createdAt?: Date | string
  }

  export type LinkUsageUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    anchorText?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    wasAutoInserted?: BoolFieldUpdateOperationsInput | boolean
    insertedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: InternalLinkUpdateOneRequiredWithoutUsagesNestedInput
  }

  export type LinkUsageUncheckedUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkId?: StringFieldUpdateOperationsInput | string
    anchorText?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    wasAutoInserted?: BoolFieldUpdateOperationsInput | boolean
    insertedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkUsageUncheckedUpdateManyWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkId?: StringFieldUpdateOperationsInput | string
    anchorText?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    wasAutoInserted?: BoolFieldUpdateOperationsInput | boolean
    insertedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCategoryCreateManyParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    icon?: string | null
    color?: string | null
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogCreateManyCategoryInput = {
    id?: string
    title: string
    slug: string
    excerpt: string
    content: string
    coverImage?: string | null
    coverImageAlt?: string | null
    tag?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    published?: boolean
    publishedAt?: Date | string | null
    originalContent?: string | null
    linkOptimizedAt?: Date | string | null
    internalLinkCount?: number
    hasDynamicProperties?: boolean
    poiQueryParams?: string | null
    poiTemplateId?: string | null
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogCategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: BlogCategoryUpdateManyWithoutParentNestedInput
    blogs?: BlogUpdateManyWithoutCategoryNestedInput
  }

  export type BlogCategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: BlogCategoryUncheckedUpdateManyWithoutParentNestedInput
    blogs?: BlogUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type BlogCategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    linkOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalLinkCount?: IntFieldUpdateOperationsInput | number
    hasDynamicProperties?: BoolFieldUpdateOperationsInput | boolean
    poiQueryParams?: NullableStringFieldUpdateOperationsInput | string | null
    poiTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkUsages?: LinkUsageUpdateManyWithoutBlogNestedInput
    author?: UserUpdateOneRequiredWithoutBlogsNestedInput
  }

  export type BlogUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    linkOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalLinkCount?: IntFieldUpdateOperationsInput | number
    hasDynamicProperties?: BoolFieldUpdateOperationsInput | boolean
    poiQueryParams?: NullableStringFieldUpdateOperationsInput | string | null
    poiTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkUsages?: LinkUsageUncheckedUpdateManyWithoutBlogNestedInput
  }

  export type BlogUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    linkOptimizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalLinkCount?: IntFieldUpdateOperationsInput | number
    hasDynamicProperties?: BoolFieldUpdateOperationsInput | boolean
    poiQueryParams?: NullableStringFieldUpdateOperationsInput | string | null
    poiTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkUsageCreateManyLinkInput = {
    id?: string
    blogId: string
    anchorText: string
    context?: string | null
    position?: number | null
    wasAutoInserted?: boolean
    insertedAt?: Date | string
    createdAt?: Date | string
  }

  export type LinkUsageUpdateWithoutLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    anchorText?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    wasAutoInserted?: BoolFieldUpdateOperationsInput | boolean
    insertedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blog?: BlogUpdateOneRequiredWithoutLinkUsagesNestedInput
  }

  export type LinkUsageUncheckedUpdateWithoutLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    anchorText?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    wasAutoInserted?: BoolFieldUpdateOperationsInput | boolean
    insertedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkUsageUncheckedUpdateManyWithoutLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    anchorText?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    wasAutoInserted?: BoolFieldUpdateOperationsInput | boolean
    insertedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPoiDistanceCreateManyPoiInput = {
    id?: string
    propertyId: string
    distanceMeters: number
    walkingMinutes?: number | null
    drivingMinutes?: number | null
    isHighlight?: boolean
    calculatedAt?: Date | string
  }

  export type PropertyPoiDistanceUpdateWithoutPoiInput = {
    id?: StringFieldUpdateOperationsInput | string
    distanceMeters?: IntFieldUpdateOperationsInput | number
    walkingMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    drivingMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isHighlight?: BoolFieldUpdateOperationsInput | boolean
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutPoiDistancesNestedInput
  }

  export type PropertyPoiDistanceUncheckedUpdateWithoutPoiInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    distanceMeters?: IntFieldUpdateOperationsInput | number
    walkingMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    drivingMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isHighlight?: BoolFieldUpdateOperationsInput | boolean
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyPoiDistanceUncheckedUpdateManyWithoutPoiInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    distanceMeters?: IntFieldUpdateOperationsInput | number
    walkingMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    drivingMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isHighlight?: BoolFieldUpdateOperationsInput | boolean
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingMessageCreateManyBookingInput = {
    id?: string
    senderId: string
    senderRole?: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingGuestCreateManyBookingInput = {
    id?: string
    guestType?: string
    guestNumber?: number
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    dateOfBirth?: Date | string | null
    nationality?: string | null
    gender?: string | null
    passportNumber?: string | null
    passportExpiry?: Date | string | null
    passportIssueDate?: Date | string | null
    passportCountry?: string | null
    passportImageUrl?: string | null
    passportImagePath?: string | null
    ocrConfidence?: number | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: Date | string | null
    passportVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    tm30Status?: $Enums.TM30GuestStatus
    tm30SubmittedAt?: Date | string | null
    tm30Error?: string | null
    whatsappMessageId?: string | null
    whatsappReceivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingMessageUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderRole?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingMessageUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderRole?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingMessageUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderRole?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingGuestUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestType?: StringFieldUpdateOperationsInput | string
    guestNumber?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportIssueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportCountry?: NullableStringFieldUpdateOperationsInput | string | null
    passportImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passportImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    ocrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Status?: EnumTM30GuestStatusFieldUpdateOperationsInput | $Enums.TM30GuestStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingGuestUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestType?: StringFieldUpdateOperationsInput | string
    guestNumber?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportIssueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportCountry?: NullableStringFieldUpdateOperationsInput | string | null
    passportImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passportImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    ocrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Status?: EnumTM30GuestStatusFieldUpdateOperationsInput | $Enums.TM30GuestStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingGuestUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestType?: StringFieldUpdateOperationsInput | string
    guestNumber?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportIssueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportCountry?: NullableStringFieldUpdateOperationsInput | string | null
    passportImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    passportImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    ocrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Status?: EnumTM30GuestStatusFieldUpdateOperationsInput | $Enums.TM30GuestStatus
    tm30SubmittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tm30Error?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerDocumentCreateManyOwnerInput = {
    id?: string
    documentType: $Enums.OwnerDocumentType
    imageUrl: string
    imagePath: string
    fileName?: string | null
    ocrData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: Date | string | null
    ocrConfidence?: number | null
    propertyId?: string | null
    houseId?: string | null
    extractedAddress?: string | null
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyCreateManyPropertyOwnerInput = {
    id?: string
    listingNumber?: string | null
    title: string
    slug: string
    location: string
    price: string
    beds: number
    baths: number
    sqft: number
    plotSize?: number | null
    type: $Enums.PropertyType
    category?: $Enums.PropertyCategory
    tag?: string | null
    status?: $Enums.Status
    isHighlighted?: boolean
    ownershipType?: $Enums.OwnershipType | null
    isResale?: boolean | null
    image: string
    shortDescription?: string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyCreateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content: string
    yearBuilt?: number | null
    mapUrl?: string | null
    monthlyRentalPrice?: number | null
    allowPets?: boolean
    enableDailyRental?: boolean
    maxGuests?: number | null
    provinceSlug?: string | null
    areaSlug?: string | null
    ownerName?: string | null
    ownerEmail?: string | null
    ownerPhone?: string | null
    ownerCountryCode?: string | null
    ownerCompany?: string | null
    ownerNotes?: string | null
    bluebookUrl?: string | null
    bluebookHouseId?: string | null
    commissionRate?: number | null
    tm30AccommodationId?: string | null
    tm30AccommodationName?: string | null
    defaultCheckInTime?: string | null
    defaultCheckOutTime?: string | null
    defaultPropertyAddress?: string | null
    defaultWifiName?: string | null
    defaultWifiPassword?: string | null
    defaultAccessCode?: string | null
    defaultEmergencyContact?: string | null
    defaultPropertyInstructions?: string | null
    defaultHouseRules?: string | null
    latitude?: number | null
    longitude?: number | null
    beachScore?: number | null
    familyScore?: number | null
    convenienceScore?: number | null
    quietnessScore?: number | null
    hasSeaView?: boolean
    seaViewDirection?: string | null
    seaDistance?: number | null
    district?: string | null
    poisLastCalculatedAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Tm30AccommodationRequestCreateManyPropertyOwnerInput = {
    id?: string
    ownerSameAsRegistrant?: boolean
    ownerNationalType?: string
    ownerNationalId?: string | null
    ownerPassportNumber?: string | null
    ownerFirstName: string
    ownerMiddleName?: string | null
    ownerLastName: string
    ownerTelephone: string
    ownerGender?: string | null
    entityType?: string
    houseIdNumber?: string | null
    accommodationType: string
    accommodationName: string
    position?: string | null
    positionOther?: string | null
    addressNumber: string
    villageNumber?: string | null
    alley?: string | null
    road?: string | null
    province: string
    district: string
    subDistrict: string
    postalCode: string
    latitude?: number | null
    longitude?: number | null
    houseRegistrationUrl?: string | null
    houseRegistrationPath?: string | null
    ocrProcessed?: boolean
    ocrProcessedAt?: Date | string | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrConfidence?: number | null
    status?: $Enums.Tm30AccomRequestStatus
    tm30Id?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    errorMessage?: string | null
    propertyId?: string | null
    whatsappPhone?: string | null
    whatsappSessionId?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OwnerDocumentUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumOwnerDocumentTypeFieldUpdateOperationsInput | $Enums.OwnerDocumentType
    imageUrl?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    ocrData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ocrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    houseId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerDocumentUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumOwnerDocumentTypeFieldUpdateOperationsInput | $Enums.OwnerDocumentType
    imageUrl?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    ocrData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ocrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    houseId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerDocumentUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumOwnerDocumentTypeFieldUpdateOperationsInput | $Enums.OwnerDocumentType
    imageUrl?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    ocrData?: NullableJsonNullValueInput | InputJsonValue
    ocrProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ocrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    houseId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyUpdateWithoutPropertyOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PropertyImageUpdateManyWithoutPropertyNestedInput
    views?: PropertyViewUpdateManyWithoutPropertyNestedInput
    poiDistances?: PropertyPoiDistanceUpdateManyWithoutPropertyNestedInput
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    viewingRequests?: ViewingRequestUpdateManyWithoutPropertyNestedInput
    rentalBookings?: RentalBookingUpdateManyWithoutPropertyNestedInput
    blockedDates?: PropertyBlockedDateUpdateManyWithoutPropertyNestedInput
    tm30Accommodation?: Tm30AccommodationUpdateOneWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPropertyOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: PropertyImageUncheckedUpdateManyWithoutPropertyNestedInput
    views?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    poiDistances?: PropertyPoiDistanceUncheckedUpdateManyWithoutPropertyNestedInput
    viewingRequests?: ViewingRequestUncheckedUpdateManyWithoutPropertyNestedInput
    rentalBookings?: RentalBookingUncheckedUpdateManyWithoutPropertyNestedInput
    blockedDates?: PropertyBlockedDateUncheckedUpdateManyWithoutPropertyNestedInput
    tm30Accommodation?: Tm30AccommodationUncheckedUpdateOneWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutPropertyOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    beds?: IntFieldUpdateOperationsInput | number
    baths?: FloatFieldUpdateOperationsInput | number
    sqft?: IntFieldUpdateOperationsInput | number
    plotSize?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    category?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    isHighlighted?: BoolFieldUpdateOperationsInput | boolean
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    isResale?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionParagraphs?: NullableJsonNullValueInput | InputJsonValue
    propertyFeatures?: NullableJsonNullValueInput | InputJsonValue
    amenities?: PropertyUpdateamenitiesInput | string[]
    amenitiesWithIcons?: NullableJsonNullValueInput | InputJsonValue
    content?: StringFieldUpdateOperationsInput | string
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    mapUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyRentalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    allowPets?: BoolFieldUpdateOperationsInput | boolean
    enableDailyRental?: BoolFieldUpdateOperationsInput | boolean
    maxGuests?: NullableIntFieldUpdateOperationsInput | number | null
    provinceSlug?: NullableStringFieldUpdateOperationsInput | string | null
    areaSlug?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCountryCode?: NullableStringFieldUpdateOperationsInput | string | null
    ownerCompany?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bluebookHouseId?: NullableStringFieldUpdateOperationsInput | string | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    tm30AccommodationId?: NullableStringFieldUpdateOperationsInput | string | null
    tm30AccommodationName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckInTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCheckOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiName?: NullableStringFieldUpdateOperationsInput | string | null
    defaultWifiPassword?: NullableStringFieldUpdateOperationsInput | string | null
    defaultAccessCode?: NullableStringFieldUpdateOperationsInput | string | null
    defaultEmergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPropertyInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    defaultHouseRules?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    beachScore?: NullableIntFieldUpdateOperationsInput | number | null
    familyScore?: NullableIntFieldUpdateOperationsInput | number | null
    convenienceScore?: NullableIntFieldUpdateOperationsInput | number | null
    quietnessScore?: NullableIntFieldUpdateOperationsInput | number | null
    hasSeaView?: BoolFieldUpdateOperationsInput | boolean
    seaViewDirection?: NullableStringFieldUpdateOperationsInput | string | null
    seaDistance?: NullableIntFieldUpdateOperationsInput | number | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    poisLastCalculatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Tm30AccommodationRequestUpdateWithoutPropertyOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerSameAsRegistrant?: BoolFieldUpdateOperationsInput | boolean
    ownerNationalType?: StringFieldUpdateOperationsInput | string
    ownerNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPassportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ownerFirstName?: StringFieldUpdateOperationsInput | string
    ownerMiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerLastName?: StringFieldUpdateOperationsInput | string
    ownerTelephone?: StringFieldUpdateOperationsInput | string
    ownerGender?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    houseIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationType?: StringFieldUpdateOperationsInput | string
    accommodationName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    positionOther?: NullableStringFieldUpdateOperationsInput | string | null
    addressNumber?: StringFieldUpdateOperationsInput | string
    villageNumber?: NullableStringFieldUpdateOperationsInput | string | null
    alley?: NullableStringFieldUpdateOperationsInput | string | null
    road?: NullableStringFieldUpdateOperationsInput | string | null
    province?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    subDistrict?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    houseRegistrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    houseRegistrationPath?: NullableStringFieldUpdateOperationsInput | string | null
    ocrProcessed?: BoolFieldUpdateOperationsInput | boolean
    ocrProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumTm30AccomRequestStatusFieldUpdateOperationsInput | $Enums.Tm30AccomRequestStatus
    tm30Id?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Tm30AccommodationRequestUncheckedUpdateWithoutPropertyOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerSameAsRegistrant?: BoolFieldUpdateOperationsInput | boolean
    ownerNationalType?: StringFieldUpdateOperationsInput | string
    ownerNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPassportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ownerFirstName?: StringFieldUpdateOperationsInput | string
    ownerMiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerLastName?: StringFieldUpdateOperationsInput | string
    ownerTelephone?: StringFieldUpdateOperationsInput | string
    ownerGender?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    houseIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationType?: StringFieldUpdateOperationsInput | string
    accommodationName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    positionOther?: NullableStringFieldUpdateOperationsInput | string | null
    addressNumber?: StringFieldUpdateOperationsInput | string
    villageNumber?: NullableStringFieldUpdateOperationsInput | string | null
    alley?: NullableStringFieldUpdateOperationsInput | string | null
    road?: NullableStringFieldUpdateOperationsInput | string | null
    province?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    subDistrict?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    houseRegistrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    houseRegistrationPath?: NullableStringFieldUpdateOperationsInput | string | null
    ocrProcessed?: BoolFieldUpdateOperationsInput | boolean
    ocrProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumTm30AccomRequestStatusFieldUpdateOperationsInput | $Enums.Tm30AccomRequestStatus
    tm30Id?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Tm30AccommodationRequestUncheckedUpdateManyWithoutPropertyOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerSameAsRegistrant?: BoolFieldUpdateOperationsInput | boolean
    ownerNationalType?: StringFieldUpdateOperationsInput | string
    ownerNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPassportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ownerFirstName?: StringFieldUpdateOperationsInput | string
    ownerMiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerLastName?: StringFieldUpdateOperationsInput | string
    ownerTelephone?: StringFieldUpdateOperationsInput | string
    ownerGender?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    houseIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accommodationType?: StringFieldUpdateOperationsInput | string
    accommodationName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    positionOther?: NullableStringFieldUpdateOperationsInput | string | null
    addressNumber?: StringFieldUpdateOperationsInput | string
    villageNumber?: NullableStringFieldUpdateOperationsInput | string | null
    alley?: NullableStringFieldUpdateOperationsInput | string | null
    road?: NullableStringFieldUpdateOperationsInput | string | null
    province?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    subDistrict?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    houseRegistrationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    houseRegistrationPath?: NullableStringFieldUpdateOperationsInput | string | null
    ocrProcessed?: BoolFieldUpdateOperationsInput | boolean
    ocrProcessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ocrRawData?: NullableJsonNullValueInput | InputJsonValue
    ocrConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumTm30AccomRequestStatusFieldUpdateOperationsInput | $Enums.Tm30AccomRequestStatus
    tm30Id?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    propertyId?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappPhone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AICodeChangeCreateManyDecisionInput = {
    id?: string
    filePath: string
    action: $Enums.AICodeAction
    originalContent?: string | null
    newContent?: string | null
    diff?: string | null
    syntaxValid?: boolean
    typesValid?: boolean
    lintPassed?: boolean
    testsPassed?: boolean | null
    appliedAt?: Date | string | null
    rolledBackAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AIAgentLogCreateManyDecisionInput = {
    id?: string
    level?: $Enums.AILogLevel
    category: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    errorCode?: string | null
    errorStack?: string | null
    durationMs?: number | null
    createdAt?: Date | string
  }

  export type AICodeChangeUpdateWithoutDecisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    action?: EnumAICodeActionFieldUpdateOperationsInput | $Enums.AICodeAction
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    newContent?: NullableStringFieldUpdateOperationsInput | string | null
    diff?: NullableStringFieldUpdateOperationsInput | string | null
    syntaxValid?: BoolFieldUpdateOperationsInput | boolean
    typesValid?: BoolFieldUpdateOperationsInput | boolean
    lintPassed?: BoolFieldUpdateOperationsInput | boolean
    testsPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rolledBackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AICodeChangeUncheckedUpdateWithoutDecisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    action?: EnumAICodeActionFieldUpdateOperationsInput | $Enums.AICodeAction
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    newContent?: NullableStringFieldUpdateOperationsInput | string | null
    diff?: NullableStringFieldUpdateOperationsInput | string | null
    syntaxValid?: BoolFieldUpdateOperationsInput | boolean
    typesValid?: BoolFieldUpdateOperationsInput | boolean
    lintPassed?: BoolFieldUpdateOperationsInput | boolean
    testsPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rolledBackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AICodeChangeUncheckedUpdateManyWithoutDecisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    action?: EnumAICodeActionFieldUpdateOperationsInput | $Enums.AICodeAction
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    newContent?: NullableStringFieldUpdateOperationsInput | string | null
    diff?: NullableStringFieldUpdateOperationsInput | string | null
    syntaxValid?: BoolFieldUpdateOperationsInput | boolean
    typesValid?: BoolFieldUpdateOperationsInput | boolean
    lintPassed?: BoolFieldUpdateOperationsInput | boolean
    testsPassed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rolledBackAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAgentLogUpdateWithoutDecisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumAILogLevelFieldUpdateOperationsInput | $Enums.AILogLevel
    category?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAgentLogUncheckedUpdateWithoutDecisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumAILogLevelFieldUpdateOperationsInput | $Enums.AILogLevel
    category?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIAgentLogUncheckedUpdateManyWithoutDecisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumAILogLevelFieldUpdateOperationsInput | $Enums.AILogLevel
    category?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}